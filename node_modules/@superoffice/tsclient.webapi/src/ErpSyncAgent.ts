// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/ErpSyncAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Services for the ERP Integration Services feature
 * 
 * **Online Restricted:** This agent is not available in Online by default. Access must be requested specifically when app is registered. Intended for ERP integration apps.
 */
export interface IErpSyncAgent {
    CreateDefaultErpSyncConnectorEntity(): Promise< carriers.ErpSyncConnectorEntity >;
    SaveErpSyncConnectorEntity(entity: carriers.ErpSyncConnectorEntity) : Promise< carriers.ErpSyncConnectorEntity >;
    DeleteErpSyncConnectorEntity(ErpSyncConnectorEntityId: number) : Promise<void>;
    GetConnection(request: carriers.ErpSync_GetConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection >;
    GetConnection(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection >;
    SaveConnection(request: carriers.ErpSync_SaveConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection >;
    SaveConnection(connection: carriers.ErpConnection, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection >;
    DeleteConnection(request: carriers.ErpSync_DeleteConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteConnection(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetConfigurationFields(request: carriers.ErpSync_GetConfigurationFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] >;
    GetConfigurationFields(erpConnectorId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] >;
    GetErpConnectionConfigFields(request: carriers.ErpSync_GetErpConnectionConfigFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetErpConnectionConfigFields(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    ToggleErpConnectionActive(request: carriers.ErpSync_ToggleErpConnectionActiveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    ToggleErpConnectionActive(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    TestConnectionById(request: carriers.ErpSync_TestConnectionByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    TestConnectionById(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    TestConnectionByConfig(request: carriers.ErpSync_TestConnectionByConfigRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    TestConnectionByConfig(erpConnectionId: number, configFields: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SaveErpConnectionSyncPriorities(request: carriers.ErpSync_SaveErpConnectionSyncPrioritiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SaveErpConnectionSyncPriorities(erpConnectionIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    MoveErpFieldItem(request: carriers.ErpSync_MoveErpFieldItemRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveErpFieldItem(erpFieldId: number, direction: number, erpConnectionId: number, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SupportsAdvancedSearch(request: carriers.ErpSync_SupportsAdvancedSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SupportsAdvancedSearch(erpConnectionId: number, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetAllConnectors(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItem[] >;
    GetAllConnections(request: carriers.ErpSync_GetAllConnectionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection[] >;
    GetAllConnections(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection[] >;
    GetConnectionsAndDisplayFields(request: carriers.ErpSync_GetConnectionsAndDisplayFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionData[] >;
    GetConnectionsAndDisplayFields(crmActorType: enums.CrmActorType, entityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionData[] >;
    GetErpFieldValues(request: carriers.ErpSync_GetErpFieldValuesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetErpFieldValues(erpConnectionId: number, crmActorType: enums.CrmActorType, entityId: number, fieldKeys: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetFieldsForNewErpActor(request: carriers.ErpSync_GetFieldsForNewErpActorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] >;
    GetFieldsForNewErpActor(erpConnectionId: number, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] >;
    GetConnectionListMappings(request: carriers.ErpSync_GetConnectionListMappingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer >;
    GetConnectionListMappings(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer >;
    SaveConnectionListMappings(request: carriers.ErpSync_SaveConnectionListMappingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer >;
    SaveConnectionListMappings(listMapping: carriers.ErpConnectionListMappingContainer, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer >;
    ConnectActor(request: carriers.ErpSync_ConnectActorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ConnectActor(erpConnectionId: number, crmRecordId: number, crmActorType: enums.CrmActorType, erpKey: string, erpActorType: enums.ErpActorType, fieldValues: carriers.ErpSyncFieldValue[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    TryConnectActor(request: carriers.ErpSync_TryConnectActorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    TryConnectActor(erpConnectionId: number, crmRecordId: number, crmActorType: enums.CrmActorType, erpKey: string, erpActorType: enums.ErpActorType, fieldValues: carriers.ErpSyncFieldValue[], webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetFieldValuesFromCrm(request: carriers.ErpSync_GetFieldValuesFromCrmRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] >;
    GetFieldValuesFromCrm(recordId: number, actorTypeCrm: enums.CrmActorType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] >;
    GetFieldValuesFromErp(request: carriers.ErpSync_GetFieldValuesFromErpRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] >;
    GetFieldValuesFromErp(erpConnectionId: number, actorTypeErp: enums.ErpActorType, erpKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] >;
    GetActorTypeMapping(request: carriers.ErpSync_GetActorTypeMappingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping >;
    GetActorTypeMapping(erpConnectionId: number, actorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping >;
    CreateActorLink(request: carriers.ErpSync_CreateActorLinkRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CreateActorLink(erpConnectionId: number, crmRecordId: number, crmActorType: enums.CrmActorType, erpKey: string, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    BreakActorLink(request: carriers.ErpSync_BreakActorLinkRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    BreakActorLink(erpConnectionId: number, crmRecordId: number, crmActorType: enums.CrmActorType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CreateErpActorFromCrm(request: carriers.ErpSync_CreateErpActorFromCrmRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CreateErpActorFromCrm(connectionId: number, crmEntityId: number, erpActorType: enums.ErpActorType, crmActorType: enums.CrmActorType, erpFieldKeyValues: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SaveActorTypeMapping(request: carriers.ErpSync_SaveActorTypeMappingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping >;
    SaveActorTypeMapping(mapping: carriers.ErpSyncActorTypeMapping, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping >;
    ValidateArchiveColumnConfig(request: carriers.ErpSync_ValidateArchiveColumnConfigRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ValidateArchiveColumnConfig(listOwner: string, erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    UpdateConnectionFields(request: carriers.ErpSync_UpdateConnectionFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    UpdateConnectionFields(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetCrmActorType(request: carriers.ErpSync_GetCrmActorTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.CrmActorType >;
    GetCrmActorType(erpConnectionId: number, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< enums.CrmActorType >;
    GetErpSyncConnectionSummary(request: carriers.ErpSync_GetErpSyncConnectionSummaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncConnectionSummary >;
    GetErpSyncConnectionSummary(erpSyncConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncConnectionSummary >;
    GetErpSyncConnectorEntity(erpSyncConnectorEntityId: number) :  Promise< carriers.ErpSyncConnectorEntity >;
    CanDeleteErpSyncConnectorEntity(request: carriers.ErpSync_CanDeleteErpSyncConnectorEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode >;
    CanDeleteErpSyncConnectorEntity(erpSyncConnectorId: number, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode >;
    TestConnectorUrl(request: carriers.ErpSync_TestConnectorUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode >;
    TestConnectorUrl(url: string, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode >;
    SaveDefaultValueInfo(request: carriers.ErpSync_SaveDefaultValueInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue >;
    SaveDefaultValueInfo(erpSyncDefaultValue: carriers.ErpSyncDefaultValue, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue >;
    GetDefaultValueInfo(request: carriers.ErpSync_GetDefaultValueInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue >;
    GetDefaultValueInfo(erpFieldId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue >;
    SyncAll(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    ForceSyncAll(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    ForceResync(request: carriers.ErpSync_ForceResyncRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    ForceResync(erpConnectionId: number, internalKeyIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    ForceResyncNoBlankValues(request: carriers.ErpSync_ForceResyncNoBlankValuesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    ForceResyncNoBlankValues(erpConnectionId: number, internalKeyIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    ForceResyncBatchTask(request: carriers.ErpSync_ForceResyncBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ForceResyncBatchTask(erpConnectionId: number, internalKeyIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ForceResyncExternal(request: carriers.ErpSync_ForceResyncExternalRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    ForceResyncExternal(erpConnectionId: number, erpActorType: enums.ErpActorType, externalKeys: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    ForceResyncExternalNoBlankValues(request: carriers.ErpSync_ForceResyncExternalNoBlankValuesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    ForceResyncExternalNoBlankValues(erpConnectionId: number, erpActorType: enums.ErpActorType, externalKeys: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    GetEngineStatus(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncEngineStatus >;
    ChangeEngineStatus(request: carriers.ErpSync_ChangeEngineStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncEngineStatus >;
    ChangeEngineStatus(run: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncEngineStatus >;
    ChangeEngineInterval(request: carriers.ErpSync_ChangeEngineIntervalRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangeEngineInterval(interval: moment.Duration, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
} // interface IErpSyncAgent




/**
 * Services for the ERP Integration Services feature
 */
export class ErpSyncAgent extends base.WebApiBase implements IErpSyncAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/ErpSync/";
        super(options);
    }



    /**
     * Set default values into a new ErpSyncConnectorEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultErpSyncConnectorEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncConnectorEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncConnectorEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultErpSyncConnectorEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncConnectorEntity = converters.Create_ErpSyncConnectorEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ErpSyncConnectorEntity or creates a new ErpSyncConnectorEntity if the id parameter is empty
     * @param entity - The ErpSyncConnectorEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ErpSyncConnectorEntity
     */
    public async SaveErpSyncConnectorEntity(entity: carriers.ErpSyncConnectorEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncConnectorEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncConnectorEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveErpSyncConnectorEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncConnectorEntity = converters.Create_ErpSyncConnectorEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ErpSyncConnectorEntity
     * @param ErpSyncConnectorEntityId - The id of the ErpSyncConnectorEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteErpSyncConnectorEntity(ErpSyncConnectorEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteErpSyncConnectorEntity?ErpSyncConnectorEntityId=" + ErpSyncConnectorEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    private async _GetConnection(request: carriers.ErpSync_GetConnectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpConnection >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpConnection = converters.Create_ErpConnection_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the specified connection.
     * @param request - ErpConnectionId
     * @returns The connection
     */
    public async GetConnection(request: carriers.ErpSync_GetConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection >;

    /**
     * Returns the specified connection.
     * @param erpConnectionId - Primary key of the connection
     * @returns The connection
     */
    public async GetConnection(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection >;

    public async GetConnection(erpConnectionId:number|carriers.ErpSync_GetConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection > {
        let _request : carriers.ErpSync_GetConnectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_GetConnectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConnection( _request, _options );
    }


    private async _SaveConnection(request: carriers.ErpSync_SaveConnectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpConnection >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConnection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpConnection = converters.Create_ErpConnection_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a connection to the database.
     * @param request - Connection
     * @returns The resulting connection.
     */
    public async SaveConnection(request: carriers.ErpSync_SaveConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection >;

    /**
     * Saves a connection to the database.
     * @param connection - The connection to save.
     * @returns The resulting connection.
     */
    public async SaveConnection(connection: carriers.ErpConnection, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection >;

    public async SaveConnection(connection:carriers.ErpConnection|carriers.ErpSync_SaveConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection > {
        let _request : carriers.ErpSync_SaveConnectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connection;
        if( typeof( first ) === "object" && first && ( typeof(first.Connection)!='undefined' ) )
        {
            _request = connection as carriers.ErpSync_SaveConnectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Connection: connection as carriers.ErpConnection,
                       };   
            _options = webapi_options;
        }
        return this._SaveConnection( _request, _options );
    }


    private async _DeleteConnection(request: carriers.ErpSync_DeleteConnectionRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteConnection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes a connection from the database.
     * @param request - ErpConnectionId
     * @returns A void return
     */
    public async DeleteConnection(request: carriers.ErpSync_DeleteConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes a connection from the database.
     * @param erpConnectionId - Primary key of the connection
     * @returns A void return
     */
    public async DeleteConnection(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteConnection(erpConnectionId:number|carriers.ErpSync_DeleteConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.ErpSync_DeleteConnectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_DeleteConnectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteConnection( _request, _options );
    }


    private async _GetConfigurationFields(request: carriers.ErpSync_GetConfigurationFieldsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.FieldMetadata[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConfigurationFields", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.FieldMetadata[] = converters.Create_FieldMetadataArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all fields needed to connect to the given connector
     * @param request - ErpConnectorId
     * @returns The fields
     */
    public async GetConfigurationFields(request: carriers.ErpSync_GetConfigurationFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] >;

    /**
     * Returns all fields needed to connect to the given connector
     * @param erpConnectorId - The id of the erp connector
     * @returns The fields
     */
    public async GetConfigurationFields(erpConnectorId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] >;

    public async GetConfigurationFields(erpConnectorId:number|carriers.ErpSync_GetConfigurationFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] > {
        let _request : carriers.ErpSync_GetConfigurationFieldsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectorId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectorId)!='undefined' ) )
        {
            _request = erpConnectorId as carriers.ErpSync_GetConfigurationFieldsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectorId: erpConnectorId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConfigurationFields( _request, _options );
    }


    private async _GetErpConnectionConfigFields(request: carriers.ErpSync_GetErpConnectionConfigFieldsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetErpConnectionConfigFields", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the config fields for the connection.
     * @param request - ErpConnectionId
     * @returns Config Fields
     */
    public async GetErpConnectionConfigFields(request: carriers.ErpSync_GetErpConnectionConfigFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Returns the config fields for the connection.
     * @param erpConnectionId - Primary key of the erp connection
     * @returns Config Fields
     */
    public async GetErpConnectionConfigFields(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async GetErpConnectionConfigFields(erpConnectionId:number|carriers.ErpSync_GetErpConnectionConfigFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.ErpSync_GetErpConnectionConfigFieldsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_GetErpConnectionConfigFieldsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetErpConnectionConfigFields( _request, _options );
    }


    private async _ToggleErpConnectionActive(request: carriers.ErpSync_ToggleErpConnectionActiveRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleErpConnectionActive", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Toggles the Active state of the connection
     * @param request - ErpConnectionId
     * @returns Contains the reason for why the toggle failed. Empty if operation was successful
     */
    public async ToggleErpConnectionActive(request: carriers.ErpSync_ToggleErpConnectionActiveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Toggles the Active state of the connection
     * @param erpConnectionId - Primary key of the erp connection
     * @returns Contains the reason for why the toggle failed. Empty if operation was successful
     */
    public async ToggleErpConnectionActive(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async ToggleErpConnectionActive(erpConnectionId:number|carriers.ErpSync_ToggleErpConnectionActiveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.ErpSync_ToggleErpConnectionActiveRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_ToggleErpConnectionActiveRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._ToggleErpConnectionActive( _request, _options );
    }


    private async _TestConnectionById(request: carriers.ErpSync_TestConnectionByIdRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestConnectionById", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Tests to see if we can establish a connection with the given config fields
     * @param request - ErpConnectionId
     * @returns Returns true if success
     */
    public async TestConnectionById(request: carriers.ErpSync_TestConnectionByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Tests to see if we can establish a connection with the given config fields
     * @param erpConnectionId - The id of the connection
     * @returns Returns true if success
     */
    public async TestConnectionById(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async TestConnectionById(erpConnectionId:number|carriers.ErpSync_TestConnectionByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.ErpSync_TestConnectionByIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_TestConnectionByIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._TestConnectionById( _request, _options );
    }


    private async _TestConnectionByConfig(request: carriers.ErpSync_TestConnectionByConfigRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestConnectionByConfig", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Tests to see if the given connection has a valid connection to its connector
     * @param request - ErpConnectionId, ConfigFields
     * @returns Returns true if success
     */
    public async TestConnectionByConfig(request: carriers.ErpSync_TestConnectionByConfigRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Tests to see if the given connection has a valid connection to its connector
     * @param erpConnectionId - The id of the connector we try to connect to
     * @param configFields - The config fields used to test connection
     * @returns Returns true if success
     */
    public async TestConnectionByConfig(erpConnectionId: number, configFields: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async TestConnectionByConfig(erpConnectionId:number|carriers.ErpSync_TestConnectionByConfigRequest, configFields?:carriers.StringDictionary|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.ErpSync_TestConnectionByConfigRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.ConfigFields)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_TestConnectionByConfigRequest;
            _options = configFields as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       ConfigFields: configFields as carriers.StringDictionary,
                       };   
            _options = webapi_options;
        }
        return this._TestConnectionByConfig( _request, _options );
    }


    private async _SaveErpConnectionSyncPriorities(request: carriers.ErpSync_SaveErpConnectionSyncPrioritiesRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveErpConnectionSyncPriorities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Takes an array of the ErpConnection ids and saves these as ordered sync priorities
     * @param request - ErpConnectionIds
     * @returns Returns true if new sync priorities is saved
     */
    public async SaveErpConnectionSyncPriorities(request: carriers.ErpSync_SaveErpConnectionSyncPrioritiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Takes an array of the ErpConnection ids and saves these as ordered sync priorities
     * @param erpConnectionIds - The id put in array in the same order as the priorities
     * @returns Returns true if new sync priorities is saved
     */
    public async SaveErpConnectionSyncPriorities(erpConnectionIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async SaveErpConnectionSyncPriorities(erpConnectionIds:number[]|carriers.ErpSync_SaveErpConnectionSyncPrioritiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.ErpSync_SaveErpConnectionSyncPrioritiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionIds;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionIds)!='undefined' ) )
        {
            _request = erpConnectionIds as carriers.ErpSync_SaveErpConnectionSyncPrioritiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionIds: erpConnectionIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SaveErpConnectionSyncPriorities( _request, _options );
    }


    private async _MoveErpFieldItem(request: carriers.ErpSync_MoveErpFieldItemRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveErpFieldItem", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Moves the rank of the erp field up or down
     * @param request - ErpFieldId, Direction, ErpConnectionId, ErpActorType
     * @returns 
     */
    public async MoveErpFieldItem(request: carriers.ErpSync_MoveErpFieldItemRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Moves the rank of the erp field up or down
     * @param erpFieldId - The id of the erp field to move
     * @param direction - Positive value to increase rank, negative to decrease.
     * @param erpConnectionId - The id of the connection
     * @param erpActorType - The actor type for which we want to rank fields
     * @returns 
     */
    public async MoveErpFieldItem(erpFieldId: number, direction: number, erpConnectionId: number, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MoveErpFieldItem(erpFieldId:number|carriers.ErpSync_MoveErpFieldItemRequest, direction?:number|base.WebApiRequestOptions, erpConnectionId?:number, erpActorType?:enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.ErpSync_MoveErpFieldItemRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpFieldId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpFieldId)!='undefined' || typeof(first.Direction)!='undefined' || typeof(first.ErpConnectionId)!='undefined' || typeof(first.ErpActorType)!='undefined' ) )
        {
            _request = erpFieldId as carriers.ErpSync_MoveErpFieldItemRequest;
            _options = direction as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpFieldId: erpFieldId as number,
                       Direction: direction as number,
                       ErpConnectionId: erpConnectionId as number,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       };   
            _options = webapi_options;
        }
        return this._MoveErpFieldItem( _request, _options );
    }


    private async _SupportsAdvancedSearch(request: carriers.ErpSync_SupportsAdvancedSearchRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SupportsAdvancedSearch", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Indicates if the connection supports advanced search for the given erp actor
     * @param request - ErpConnectionId, ErpActorType
     * @returns True if advanced search is supported
     */
    public async SupportsAdvancedSearch(request: carriers.ErpSync_SupportsAdvancedSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Indicates if the connection supports advanced search for the given erp actor
     * @param erpConnectionId - Ths id of the connection
     * @param erpActorType - The erp actor type to check for
     * @returns True if advanced search is supported
     */
    public async SupportsAdvancedSearch(erpConnectionId: number, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async SupportsAdvancedSearch(erpConnectionId:number|carriers.ErpSync_SupportsAdvancedSearchRequest, erpActorType?:enums.ErpActorType|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.ErpSync_SupportsAdvancedSearchRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.ErpActorType)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_SupportsAdvancedSearchRequest;
            _options = erpActorType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       };   
            _options = webapi_options;
        }
        return this._SupportsAdvancedSearch( _request, _options );
    }


    private async _GetAllConnectors( options?:base.WebApiRequestOptions) : Promise< carriers.ListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllConnectors", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItem[] = converters.Create_ListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all ERP Sync connectors. Uses the `ErpConnector` archive.
     * @returns The connector id, name, url
     */
    public async GetAllConnectors(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItem[] >
    {
        return this._GetAllConnectors(webapi_options);
    }


    private async _GetAllConnections(request: carriers.ErpSync_GetAllConnectionsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpConnection[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllConnections", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpConnection[] = converters.Create_ErpConnectionArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all ERP Sync connections without config field data. Uses the `ErpConnection` archive.
     * @param request - IncludeDeleted
     * @returns The connection id, name, description
     */
    public async GetAllConnections(request: carriers.ErpSync_GetAllConnectionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection[] >;

    /**
     * Returns all ERP Sync connections without config field data. Uses the `ErpConnection` archive.
     * @param includeDeleted - Include deleted connections in the result?
     * @returns The connection id, name, description
     */
    public async GetAllConnections(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection[] >;

    public async GetAllConnections(includeDeleted:boolean|carriers.ErpSync_GetAllConnectionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnection[] > {
        let _request : carriers.ErpSync_GetAllConnectionsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.ErpSync_GetAllConnectionsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllConnections( _request, _options );
    }


    private async _GetConnectionsAndDisplayFields(request: carriers.ErpSync_GetConnectionsAndDisplayFieldsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionData[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpConnectionData[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionsAndDisplayFields", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpConnectionData[] = converters.Create_ErpConnectionDataArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all connection statuses and fields for a given entity
     * @param request - CrmActorType, EntityId
     * @returns An array of ErpConnectionData carriers
     */
    public async GetConnectionsAndDisplayFields(request: carriers.ErpSync_GetConnectionsAndDisplayFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionData[] >;

    /**
     * Get all connection statuses and fields for a given entity
     * @param crmActorType - The type of the CRM entity
     * @param entityId - The id of the entity
     * @returns An array of ErpConnectionData carriers
     */
    public async GetConnectionsAndDisplayFields(crmActorType: enums.CrmActorType, entityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionData[] >;

    public async GetConnectionsAndDisplayFields(crmActorType:enums.CrmActorType|carriers.ErpSync_GetConnectionsAndDisplayFieldsRequest, entityId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionData[] > {
        let _request : carriers.ErpSync_GetConnectionsAndDisplayFieldsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = crmActorType;
        if( typeof( first ) === "object" && first && ( typeof(first.CrmActorType)!='undefined' || typeof(first.EntityId)!='undefined' ) )
        {
            _request = crmActorType as carriers.ErpSync_GetConnectionsAndDisplayFieldsRequest;
            _options = entityId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       CrmActorType: crmActorType as enums.CrmActorType,
                       EntityId: entityId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConnectionsAndDisplayFields( _request, _options );
    }


    private async _GetErpFieldValues(request: carriers.ErpSync_GetErpFieldValuesRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetErpFieldValues", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the values for the specified fields from the ERP connection
     * @param request - ErpConnectionId, CrmActorType, EntityId, FieldKeys
     * @returns An array containing the values for the specified fields, in the same order
     */
    public async GetErpFieldValues(request: carriers.ErpSync_GetErpFieldValuesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Get the values for the specified fields from the ERP connection
     * @param erpConnectionId - The id of the connection
     * @param crmActorType - The type of the CRM entity
     * @param entityId - The id of the entity
     * @param fieldKeys - The fields for which you want to get the values
     * @returns An array containing the values for the specified fields, in the same order
     */
    public async GetErpFieldValues(erpConnectionId: number, crmActorType: enums.CrmActorType, entityId: number, fieldKeys: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetErpFieldValues(erpConnectionId:number|carriers.ErpSync_GetErpFieldValuesRequest, crmActorType?:enums.CrmActorType|base.WebApiRequestOptions, entityId?:number, fieldKeys?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.ErpSync_GetErpFieldValuesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.CrmActorType)!='undefined' || typeof(first.EntityId)!='undefined' || typeof(first.FieldKeys)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_GetErpFieldValuesRequest;
            _options = crmActorType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       CrmActorType: crmActorType as enums.CrmActorType,
                       EntityId: entityId as number,
                       FieldKeys: fieldKeys as string[],
                       };   
            _options = webapi_options;
        }
        return this._GetErpFieldValues( _request, _options );
    }


    private async _GetFieldsForNewErpActor(request: carriers.ErpSync_GetFieldsForNewErpActorRequest, options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.FieldMetadata[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFieldsForNewErpActor", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.FieldMetadata[] = converters.Create_FieldMetadataArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the fields that must be filled out when creating a new ERP actor
     * @param request - ErpConnectionId, ErpActorType
     * @returns The fields that are required for the new ERP actor
     */
    public async GetFieldsForNewErpActor(request: carriers.ErpSync_GetFieldsForNewErpActorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] >;

    /**
     * Get the fields that must be filled out when creating a new ERP actor
     * @param erpConnectionId - The id of the connection
     * @param erpActorType - The type of the ERP actor to create
     * @returns The fields that are required for the new ERP actor
     */
    public async GetFieldsForNewErpActor(erpConnectionId: number, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] >;

    public async GetFieldsForNewErpActor(erpConnectionId:number|carriers.ErpSync_GetFieldsForNewErpActorRequest, erpActorType?:enums.ErpActorType|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadata[] > {
        let _request : carriers.ErpSync_GetFieldsForNewErpActorRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.ErpActorType)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_GetFieldsForNewErpActorRequest;
            _options = erpActorType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       };   
            _options = webapi_options;
        }
        return this._GetFieldsForNewErpActor( _request, _options );
    }


    private async _GetConnectionListMappings(request: carriers.ErpSync_GetConnectionListMappingsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpConnectionListMappingContainer >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionListMappings", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpConnectionListMappingContainer = converters.Create_ErpConnectionListMappingContainer_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the listmappings for the specified connection.
     * @param request - ErpConnectionId
     * @returns The listmappings
     */
    public async GetConnectionListMappings(request: carriers.ErpSync_GetConnectionListMappingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer >;

    /**
     * Returns the listmappings for the specified connection.
     * @param erpConnectionId - Primary key of the connection
     * @returns The listmappings
     */
    public async GetConnectionListMappings(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer >;

    public async GetConnectionListMappings(erpConnectionId:number|carriers.ErpSync_GetConnectionListMappingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer > {
        let _request : carriers.ErpSync_GetConnectionListMappingsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_GetConnectionListMappingsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConnectionListMappings( _request, _options );
    }


    private async _SaveConnectionListMappings(request: carriers.ErpSync_SaveConnectionListMappingsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpConnectionListMappingContainer >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConnectionListMappings", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpConnectionListMappingContainer = converters.Create_ErpConnectionListMappingContainer_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a connection to the database.
     * @param request - ListMapping
     * @returns The saved list mappings.
     */
    public async SaveConnectionListMappings(request: carriers.ErpSync_SaveConnectionListMappingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer >;

    /**
     * Saves a connection to the database.
     * @param listMapping - The list item mappings to save.
     * @returns The saved list mappings.
     */
    public async SaveConnectionListMappings(listMapping: carriers.ErpConnectionListMappingContainer, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer >;

    public async SaveConnectionListMappings(listMapping:carriers.ErpConnectionListMappingContainer|carriers.ErpSync_SaveConnectionListMappingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpConnectionListMappingContainer > {
        let _request : carriers.ErpSync_SaveConnectionListMappingsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = listMapping;
        if( typeof( first ) === "object" && first && ( typeof(first.ListMapping)!='undefined' ) )
        {
            _request = listMapping as carriers.ErpSync_SaveConnectionListMappingsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ListMapping: listMapping as carriers.ErpConnectionListMappingContainer,
                       };   
            _options = webapi_options;
        }
        return this._SaveConnectionListMappings( _request, _options );
    }


    private async _ConnectActor(request: carriers.ErpSync_ConnectActorRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ConnectActor", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a link between Erp and Crm and set default values
     * @param request - ErpConnectionId, CrmRecordId, CrmActorType, ErpKey, ErpActorType, FieldValues
     * @returns 
     */
    public async ConnectActor(request: carriers.ErpSync_ConnectActorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Create a link between Erp and Crm and set default values
     * @param erpConnectionId - ErpConnectionId
     * @param crmRecordId - CrmRecordId
     * @param crmActorType - The Crm Actor type
     * @param erpKey - 
     * @param erpActorType - The Erp Actor type
     * @param fieldValues - The Crm Fields
     * @returns 
     */
    public async ConnectActor(erpConnectionId: number, crmRecordId: number, crmActorType: enums.CrmActorType, erpKey: string, erpActorType: enums.ErpActorType, fieldValues: carriers.ErpSyncFieldValue[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ConnectActor(erpConnectionId:number|carriers.ErpSync_ConnectActorRequest, crmRecordId?:number|base.WebApiRequestOptions, crmActorType?:enums.CrmActorType, erpKey?:string, erpActorType?:enums.ErpActorType, fieldValues?:carriers.ErpSyncFieldValue[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.ErpSync_ConnectActorRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.CrmRecordId)!='undefined' || typeof(first.CrmActorType)!='undefined' || typeof(first.ErpKey)!='undefined' || typeof(first.ErpActorType)!='undefined' || typeof(first.FieldValues)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_ConnectActorRequest;
            _options = crmRecordId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       CrmRecordId: crmRecordId as number,
                       CrmActorType: crmActorType as enums.CrmActorType,
                       ErpKey: erpKey as string,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       FieldValues: fieldValues as carriers.ErpSyncFieldValue[],
                       };   
            _options = webapi_options;
        }
        return this._ConnectActor( _request, _options );
    }


    private async _TryConnectActor(request: carriers.ErpSync_TryConnectActorRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TryConnectActor", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a link between Erp and Crm and set default values
     * @param request - ErpConnectionId, CrmRecordId, CrmActorType, ErpKey, ErpActorType, FieldValues
     * @returns 
     */
    public async TryConnectActor(request: carriers.ErpSync_TryConnectActorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Create a link between Erp and Crm and set default values
     * @param erpConnectionId - ErpConnectionId
     * @param crmRecordId - CrmRecordId
     * @param crmActorType - The Crm Actor type
     * @param erpKey - 
     * @param erpActorType - The Erp Actor type
     * @param fieldValues - The Crm Fields
     * @returns 
     */
    public async TryConnectActor(erpConnectionId: number, crmRecordId: number, crmActorType: enums.CrmActorType, erpKey: string, erpActorType: enums.ErpActorType, fieldValues: carriers.ErpSyncFieldValue[], webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async TryConnectActor(erpConnectionId:number|carriers.ErpSync_TryConnectActorRequest, crmRecordId?:number|base.WebApiRequestOptions, crmActorType?:enums.CrmActorType, erpKey?:string, erpActorType?:enums.ErpActorType, fieldValues?:carriers.ErpSyncFieldValue[], webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.ErpSync_TryConnectActorRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.CrmRecordId)!='undefined' || typeof(first.CrmActorType)!='undefined' || typeof(first.ErpKey)!='undefined' || typeof(first.ErpActorType)!='undefined' || typeof(first.FieldValues)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_TryConnectActorRequest;
            _options = crmRecordId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       CrmRecordId: crmRecordId as number,
                       CrmActorType: crmActorType as enums.CrmActorType,
                       ErpKey: erpKey as string,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       FieldValues: fieldValues as carriers.ErpSyncFieldValue[],
                       };   
            _options = webapi_options;
        }
        return this._TryConnectActor( _request, _options );
    }


    private async _GetFieldValuesFromCrm(request: carriers.ErpSync_GetFieldValuesFromCrmRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncFieldValue[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFieldValuesFromCrm", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncFieldValue[] = converters.Create_ErpSyncFieldValueArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get Crm Field values
     * @param request - RecordId, ActorTypeCrm
     * @returns The Crm Fields
     */
    public async GetFieldValuesFromCrm(request: carriers.ErpSync_GetFieldValuesFromCrmRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] >;

    /**
     * Get Crm Field values
     * @param recordId - The id of the CRM entity
     * @param actorTypeCrm - CRM Actor type
     * @returns The Crm Fields
     */
    public async GetFieldValuesFromCrm(recordId: number, actorTypeCrm: enums.CrmActorType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] >;

    public async GetFieldValuesFromCrm(recordId:number|carriers.ErpSync_GetFieldValuesFromCrmRequest, actorTypeCrm?:enums.CrmActorType|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] > {
        let _request : carriers.ErpSync_GetFieldValuesFromCrmRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = recordId;
        if( typeof( first ) === "object" && first && ( typeof(first.RecordId)!='undefined' || typeof(first.ActorTypeCrm)!='undefined' ) )
        {
            _request = recordId as carriers.ErpSync_GetFieldValuesFromCrmRequest;
            _options = actorTypeCrm as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RecordId: recordId as number,
                       ActorTypeCrm: actorTypeCrm as enums.CrmActorType,
                       };   
            _options = webapi_options;
        }
        return this._GetFieldValuesFromCrm( _request, _options );
    }


    private async _GetFieldValuesFromErp(request: carriers.ErpSync_GetFieldValuesFromErpRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncFieldValue[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFieldValuesFromErp", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncFieldValue[] = converters.Create_ErpSyncFieldValueArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get Erp Field values
     * @param request - ErpConnectionId, ActorTypeErp, ErpKey
     * @returns The Erp Fields
     */
    public async GetFieldValuesFromErp(request: carriers.ErpSync_GetFieldValuesFromErpRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] >;

    /**
     * Get Erp Field values
     * @param erpConnectionId - Erp connection id
     * @param actorTypeErp - ERP Actor type
     * @param erpKey - Primary key for the erp actor
     * @returns The Erp Fields
     */
    public async GetFieldValuesFromErp(erpConnectionId: number, actorTypeErp: enums.ErpActorType, erpKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] >;

    public async GetFieldValuesFromErp(erpConnectionId:number|carriers.ErpSync_GetFieldValuesFromErpRequest, actorTypeErp?:enums.ErpActorType|base.WebApiRequestOptions, erpKey?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncFieldValue[] > {
        let _request : carriers.ErpSync_GetFieldValuesFromErpRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.ActorTypeErp)!='undefined' || typeof(first.ErpKey)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_GetFieldValuesFromErpRequest;
            _options = actorTypeErp as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       ActorTypeErp: actorTypeErp as enums.ErpActorType,
                       ErpKey: erpKey as string,
                       };   
            _options = webapi_options;
        }
        return this._GetFieldValuesFromErp( _request, _options );
    }


    private async _GetActorTypeMapping(request: carriers.ErpSync_GetActorTypeMappingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncActorTypeMapping >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetActorTypeMapping", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncActorTypeMapping = converters.Create_ErpSyncActorTypeMapping_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the current mappings for one connection/actor; connection+actor type = unique key
     * @param request - ErpConnectionId, ActorType
     * @returns The current mapping from the database
     */
    public async GetActorTypeMapping(request: carriers.ErpSync_GetActorTypeMappingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping >;

    /**
     * Get the current mappings for one connection/actor; connection+actor type = unique key
     * @param erpConnectionId - The ERP connection ID
     * @param actorType - The actor type
     * @returns The current mapping from the database
     */
    public async GetActorTypeMapping(erpConnectionId: number, actorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping >;

    public async GetActorTypeMapping(erpConnectionId:number|carriers.ErpSync_GetActorTypeMappingRequest, actorType?:enums.ErpActorType|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping > {
        let _request : carriers.ErpSync_GetActorTypeMappingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.ActorType)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_GetActorTypeMappingRequest;
            _options = actorType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       ActorType: actorType as enums.ErpActorType,
                       };   
            _options = webapi_options;
        }
        return this._GetActorTypeMapping( _request, _options );
    }


    private async _CreateActorLink(request: carriers.ErpSync_CreateActorLinkRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateActorLink", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Link a crm entity to an erp entity
     * @param request - ErpConnectionId, CrmRecordId, CrmActorType, ErpKey, ErpActorType
     * @returns True if success
     */
    public async CreateActorLink(request: carriers.ErpSync_CreateActorLinkRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Link a crm entity to an erp entity
     * @param erpConnectionId - The ERP connection ID
     * @param crmRecordId - The ID of the CRM entity to connect to
     * @param crmActorType - Identifies the CRM actor type corresponding to this CRM entity
     * @param erpKey - The ERP entity identifier
     * @param erpActorType - The ERP actor type
     * @returns True if success
     */
    public async CreateActorLink(erpConnectionId: number, crmRecordId: number, crmActorType: enums.CrmActorType, erpKey: string, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async CreateActorLink(erpConnectionId:number|carriers.ErpSync_CreateActorLinkRequest, crmRecordId?:number|base.WebApiRequestOptions, crmActorType?:enums.CrmActorType, erpKey?:string, erpActorType?:enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.ErpSync_CreateActorLinkRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.CrmRecordId)!='undefined' || typeof(first.CrmActorType)!='undefined' || typeof(first.ErpKey)!='undefined' || typeof(first.ErpActorType)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_CreateActorLinkRequest;
            _options = crmRecordId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       CrmRecordId: crmRecordId as number,
                       CrmActorType: crmActorType as enums.CrmActorType,
                       ErpKey: erpKey as string,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       };   
            _options = webapi_options;
        }
        return this._CreateActorLink( _request, _options );
    }


    private async _BreakActorLink(request: carriers.ErpSync_BreakActorLinkRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("BreakActorLink", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove the link between a CRM entity and an ERP entity
     * @param request - ErpConnectionId, CrmRecordId, CrmActorType
     * @returns True if success
     */
    public async BreakActorLink(request: carriers.ErpSync_BreakActorLinkRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Remove the link between a CRM entity and an ERP entity
     * @param erpConnectionId - The ERP connection ID
     * @param crmRecordId - The ID of the CRM entity to connect to
     * @param crmActorType - Identifies the CRM actor type corresponding to this CRM entity
     * @returns True if success
     */
    public async BreakActorLink(erpConnectionId: number, crmRecordId: number, crmActorType: enums.CrmActorType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async BreakActorLink(erpConnectionId:number|carriers.ErpSync_BreakActorLinkRequest, crmRecordId?:number|base.WebApiRequestOptions, crmActorType?:enums.CrmActorType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.ErpSync_BreakActorLinkRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.CrmRecordId)!='undefined' || typeof(first.CrmActorType)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_BreakActorLinkRequest;
            _options = crmRecordId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       CrmRecordId: crmRecordId as number,
                       CrmActorType: crmActorType as enums.CrmActorType,
                       };   
            _options = webapi_options;
        }
        return this._BreakActorLink( _request, _options );
    }


    private async _CreateErpActorFromCrm(request: carriers.ErpSync_CreateErpActorFromCrmRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateErpActorFromCrm", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create ErpActor from crm entity
     * @param request - ConnectionId, CrmEntityId, ErpActorType, CrmActorType, ErpFieldKeyValues
     * @returns Created ERP actor with success
     */
    public async CreateErpActorFromCrm(request: carriers.ErpSync_CreateErpActorFromCrmRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Create ErpActor from crm entity
     * @param connectionId - The connection ID
     * @param crmEntityId - The ID of the CRM entity to create an ERP actor from
     * @param erpActorType - The ERP actor type
     * @param crmActorType - The CRM actor type
     * @param erpFieldKeyValues - A map of matching erp field keys and values to set for the new erp entity
     * @returns Created ERP actor with success
     */
    public async CreateErpActorFromCrm(connectionId: number, crmEntityId: number, erpActorType: enums.ErpActorType, crmActorType: enums.CrmActorType, erpFieldKeyValues: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async CreateErpActorFromCrm(connectionId:number|carriers.ErpSync_CreateErpActorFromCrmRequest, crmEntityId?:number|base.WebApiRequestOptions, erpActorType?:enums.ErpActorType, crmActorType?:enums.CrmActorType, erpFieldKeyValues?:carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.ErpSync_CreateErpActorFromCrmRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionId)!='undefined' || typeof(first.CrmEntityId)!='undefined' || typeof(first.ErpActorType)!='undefined' || typeof(first.CrmActorType)!='undefined' || typeof(first.ErpFieldKeyValues)!='undefined' ) )
        {
            _request = connectionId as carriers.ErpSync_CreateErpActorFromCrmRequest;
            _options = crmEntityId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionId: connectionId as number,
                       CrmEntityId: crmEntityId as number,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       CrmActorType: crmActorType as enums.CrmActorType,
                       ErpFieldKeyValues: erpFieldKeyValues as carriers.StringDictionary,
                       };   
            _options = webapi_options;
        }
        return this._CreateErpActorFromCrm( _request, _options );
    }


    private async _SaveActorTypeMapping(request: carriers.ErpSync_SaveActorTypeMappingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncActorTypeMapping >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveActorTypeMapping", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncActorTypeMapping = converters.Create_ErpSyncActorTypeMapping_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save mappings for a connection/actor
     * @param request - Mapping
     * @returns The current mapping from the database
     */
    public async SaveActorTypeMapping(request: carriers.ErpSync_SaveActorTypeMappingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping >;

    /**
     * Save mappings for a connection/actor
     * @param mapping - The mapping to be saved; new mapping rows will be created in the database if needed
     * @returns The current mapping from the database
     */
    public async SaveActorTypeMapping(mapping: carriers.ErpSyncActorTypeMapping, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping >;

    public async SaveActorTypeMapping(mapping:carriers.ErpSyncActorTypeMapping|carriers.ErpSync_SaveActorTypeMappingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncActorTypeMapping > {
        let _request : carriers.ErpSync_SaveActorTypeMappingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mapping;
        if( typeof( first ) === "object" && first && ( typeof(first.Mapping)!='undefined' ) )
        {
            _request = mapping as carriers.ErpSync_SaveActorTypeMappingRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Mapping: mapping as carriers.ErpSyncActorTypeMapping,
                       };   
            _options = webapi_options;
        }
        return this._SaveActorTypeMapping( _request, _options );
    }


    private async _ValidateArchiveColumnConfig(request: carriers.ErpSync_ValidateArchiveColumnConfigRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateArchiveColumnConfig", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Clear field info from table SUPERLISTCOLUMNSIZE if field mapping changed on given connection
     * @param request - ListOwner, ErpConnectionId
     * @returns Validated ArchiveColumnConfig
     */
    public async ValidateArchiveColumnConfig(request: carriers.ErpSync_ValidateArchiveColumnConfigRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Clear field info from table SUPERLISTCOLUMNSIZE if field mapping changed on given connection
     * @param listOwner - GUI name used in archive control config
     * @param erpConnectionId - The ERP connection ID
     * @returns Validated ArchiveColumnConfig
     */
    public async ValidateArchiveColumnConfig(listOwner: string, erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ValidateArchiveColumnConfig(listOwner:string|carriers.ErpSync_ValidateArchiveColumnConfigRequest, erpConnectionId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.ErpSync_ValidateArchiveColumnConfigRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = listOwner;
        if( typeof( first ) === "object" && first && ( typeof(first.ListOwner)!='undefined' || typeof(first.ErpConnectionId)!='undefined' ) )
        {
            _request = listOwner as carriers.ErpSync_ValidateArchiveColumnConfigRequest;
            _options = erpConnectionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ListOwner: listOwner as string,
                       ErpConnectionId: erpConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._ValidateArchiveColumnConfig( _request, _options );
    }


    private async _UpdateConnectionFields(request: carriers.ErpSync_UpdateConnectionFieldsRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateConnectionFields", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets all supported actor types, and all fields for each actor type, and save this state to the CRM database
     * @param request - ErpConnectionId
     * @returns Success or fail
     */
    public async UpdateConnectionFields(request: carriers.ErpSync_UpdateConnectionFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Gets all supported actor types, and all fields for each actor type, and save this state to the CRM database
     * @param erpConnectionId - The ERP connection ID
     * @returns Success or fail
     */
    public async UpdateConnectionFields(erpConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async UpdateConnectionFields(erpConnectionId:number|carriers.ErpSync_UpdateConnectionFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.ErpSync_UpdateConnectionFieldsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_UpdateConnectionFieldsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._UpdateConnectionFields( _request, _options );
    }


    private async _GetCrmActorType(request: carriers.ErpSync_GetCrmActorTypeRequest, options?:base.WebApiRequestOptions) : Promise< enums.CrmActorType > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< enums.CrmActorType >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCrmActorType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : enums.CrmActorType = response.data as enums.CrmActorType;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieves the CrmActorType that are mapped to a specific ErpActorType for this connection
     * @param request - ErpConnectionId, ErpActorType
     * @returns The CrmActorType
     */
    public async GetCrmActorType(request: carriers.ErpSync_GetCrmActorTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.CrmActorType >;

    /**
     * Retrieves the CrmActorType that are mapped to a specific ErpActorType for this connection
     * @param erpConnectionId - The ERP connection ID
     * @param erpActorType - The ERP actor type
     * @returns The CrmActorType
     */
    public async GetCrmActorType(erpConnectionId: number, erpActorType: enums.ErpActorType, webapi_options?:base.WebApiRequestOptions) : Promise< enums.CrmActorType >;

    public async GetCrmActorType(erpConnectionId:number|carriers.ErpSync_GetCrmActorTypeRequest, erpActorType?:enums.ErpActorType|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< enums.CrmActorType > {
        let _request : carriers.ErpSync_GetCrmActorTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.ErpActorType)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_GetCrmActorTypeRequest;
            _options = erpActorType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       };   
            _options = webapi_options;
        }
        return this._GetCrmActorType( _request, _options );
    }


    private async _GetErpSyncConnectionSummary(request: carriers.ErpSync_GetErpSyncConnectionSummaryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncConnectionSummary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncConnectionSummary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetErpSyncConnectionSummary", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncConnectionSummary = converters.Create_ErpSyncConnectionSummary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a summary of the current ErpSync configuration/setup
     * @param request - ErpSyncConnectionId
     * @returns Summary of connection information, and one summary element per configured actor type
     */
    public async GetErpSyncConnectionSummary(request: carriers.ErpSync_GetErpSyncConnectionSummaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncConnectionSummary >;

    /**
     * Get a summary of the current ErpSync configuration/setup
     * @param erpSyncConnectionId - The ID of the ErpSync connection for which information is sought
     * @returns Summary of connection information, and one summary element per configured actor type
     */
    public async GetErpSyncConnectionSummary(erpSyncConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncConnectionSummary >;

    public async GetErpSyncConnectionSummary(erpSyncConnectionId:number|carriers.ErpSync_GetErpSyncConnectionSummaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncConnectionSummary > {
        let _request : carriers.ErpSync_GetErpSyncConnectionSummaryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpSyncConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpSyncConnectionId)!='undefined' ) )
        {
            _request = erpSyncConnectionId as carriers.ErpSync_GetErpSyncConnectionSummaryRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpSyncConnectionId: erpSyncConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetErpSyncConnectionSummary( _request, _options );
    }

    /*
     * Gets a ErpSyncConnectorEntity object.
     * @param erpSyncConnectorEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ErpSyncConnectorEntity
     */
    public async GetErpSyncConnectorEntity(erpSyncConnectorEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncConnectorEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncConnectorEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetErpSyncConnectorEntity?erpSyncConnectorEntityId=" + erpSyncConnectorEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncConnectorEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _CanDeleteErpSyncConnectorEntity(request: carriers.ErpSync_CanDeleteErpSyncConnectorEntityRequest, options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< enums.ErpSyncResponseCode >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanDeleteErpSyncConnectorEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : enums.ErpSyncResponseCode = response.data as enums.ErpSyncResponseCode;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Can we delete the connector?
     * @param request - ErpSyncConnectorId
     * @returns Enum response says ok or what is wrong
     */
    public async CanDeleteErpSyncConnectorEntity(request: carriers.ErpSync_CanDeleteErpSyncConnectorEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode >;

    /**
     * Can we delete the connector?
     * @param erpSyncConnectorId - The ID of the ErpSync connector to check if can be deleted
     * @returns Enum response says ok or what is wrong
     */
    public async CanDeleteErpSyncConnectorEntity(erpSyncConnectorId: number, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode >;

    public async CanDeleteErpSyncConnectorEntity(erpSyncConnectorId:number|carriers.ErpSync_CanDeleteErpSyncConnectorEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode > {
        let _request : carriers.ErpSync_CanDeleteErpSyncConnectorEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpSyncConnectorId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpSyncConnectorId)!='undefined' ) )
        {
            _request = erpSyncConnectorId as carriers.ErpSync_CanDeleteErpSyncConnectorEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpSyncConnectorId: erpSyncConnectorId as number,
                       };   
            _options = webapi_options;
        }
        return this._CanDeleteErpSyncConnectorEntity( _request, _options );
    }


    private async _TestConnectorUrl(request: carriers.ErpSync_TestConnectorUrlRequest, options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< enums.ErpSyncResponseCode >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestConnectorUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : enums.ErpSyncResponseCode = response.data as enums.ErpSyncResponseCode;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Test if connector urls anwers
     * @param request - Url
     * @returns Enum response says ok or what is wrong
     */
    public async TestConnectorUrl(request: carriers.ErpSync_TestConnectorUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode >;

    /**
     * Test if connector urls anwers
     * @param url - The url to test connection on
     * @returns Enum response says ok or what is wrong
     */
    public async TestConnectorUrl(url: string, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode >;

    public async TestConnectorUrl(url:string|carriers.ErpSync_TestConnectorUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ErpSyncResponseCode > {
        let _request : carriers.ErpSync_TestConnectorUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = url;
        if( typeof( first ) === "object" && first && ( typeof(first.Url)!='undefined' ) )
        {
            _request = url as carriers.ErpSync_TestConnectorUrlRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Url: url as string,
                       };   
            _options = webapi_options;
        }
        return this._TestConnectorUrl( _request, _options );
    }


    private async _SaveDefaultValueInfo(request: carriers.ErpSync_SaveDefaultValueInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncDefaultValue >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDefaultValueInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncDefaultValue = converters.Create_ErpSyncDefaultValue_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save information about a default value for an ERP field
     * @param request - ErpSyncDefaultValue
     * @returns The newly saved ErpSyncDefaultValue
     */
    public async SaveDefaultValueInfo(request: carriers.ErpSync_SaveDefaultValueInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue >;

    /**
     * Save information about a default value for an ERP field
     * @param erpSyncDefaultValue - The id of the ERPfield to save
     * @returns The newly saved ErpSyncDefaultValue
     */
    public async SaveDefaultValueInfo(erpSyncDefaultValue: carriers.ErpSyncDefaultValue, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue >;

    public async SaveDefaultValueInfo(erpSyncDefaultValue:carriers.ErpSyncDefaultValue|carriers.ErpSync_SaveDefaultValueInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue > {
        let _request : carriers.ErpSync_SaveDefaultValueInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpSyncDefaultValue;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpSyncDefaultValue)!='undefined' ) )
        {
            _request = erpSyncDefaultValue as carriers.ErpSync_SaveDefaultValueInfoRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpSyncDefaultValue: erpSyncDefaultValue as carriers.ErpSyncDefaultValue,
                       };   
            _options = webapi_options;
        }
        return this._SaveDefaultValueInfo( _request, _options );
    }


    private async _GetDefaultValueInfo(request: carriers.ErpSync_GetDefaultValueInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncDefaultValue >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultValueInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncDefaultValue = converters.Create_ErpSyncDefaultValue_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get information about default value for an ERP field
     * @param request - ErpFieldId
     * @returns Object with information about default values
     */
    public async GetDefaultValueInfo(request: carriers.ErpSync_GetDefaultValueInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue >;

    /**
     * Get information about default value for an ERP field
     * @param erpFieldId - The id of the ERP field
     * @returns Object with information about default values
     */
    public async GetDefaultValueInfo(erpFieldId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue >;

    public async GetDefaultValueInfo(erpFieldId:number|carriers.ErpSync_GetDefaultValueInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncDefaultValue > {
        let _request : carriers.ErpSync_GetDefaultValueInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpFieldId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpFieldId)!='undefined' ) )
        {
            _request = erpFieldId as carriers.ErpSync_GetDefaultValueInfoRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpFieldId: erpFieldId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDefaultValueInfo( _request, _options );
    }


    private async _SyncAll( options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SyncAll", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Sync all active connections
     * @returns The response
     */
    public async SyncAll(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >
    {
        return this._SyncAll(webapi_options);
    }


    private async _ForceSyncAll( options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceSyncAll", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Sync all active connections even when automatic sync is off
     * @returns The response
     */
    public async ForceSyncAll(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >
    {
        return this._ForceSyncAll(webapi_options);
    }


    private async _ForceResync(request: carriers.ErpSync_ForceResyncRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResync", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Force resync from CRM or given Erp connection to all other connections
     * @param request - ErpConnectionId, InternalKeyIds
     * @returns The response
     */
    public async ForceResync(request: carriers.ErpSync_ForceResyncRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    /**
     * Force resync from CRM or given Erp connection to all other connections
     * @param erpConnectionId - If positive, resync from the given erp connection
     * @param internalKeyIds - The internal keys of the entities to resync, or empty to resync all
     * @returns The response
     */
    public async ForceResync(erpConnectionId: number, internalKeyIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    public async ForceResync(erpConnectionId:number|carriers.ErpSync_ForceResyncRequest, internalKeyIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        let _request : carriers.ErpSync_ForceResyncRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.InternalKeyIds)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_ForceResyncRequest;
            _options = internalKeyIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       InternalKeyIds: internalKeyIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._ForceResync( _request, _options );
    }


    private async _ForceResyncNoBlankValues(request: carriers.ErpSync_ForceResyncNoBlankValuesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResyncNoBlankValues", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Force resync from CRM or given Erp connection to all other connections and tell the sync that you don&apos;t want blank values to overwrite non-blank values. Useful on import.
     * @param request - ErpConnectionId, InternalKeyIds
     * @returns The response
     */
    public async ForceResyncNoBlankValues(request: carriers.ErpSync_ForceResyncNoBlankValuesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    /**
     * Force resync from CRM or given Erp connection to all other connections and tell the sync that you don&apos;t want blank values to overwrite non-blank values. Useful on import.
     * @param erpConnectionId - If positive, resync from the given erp connection
     * @param internalKeyIds - The internal keys of the entities to resync, or empty to resync all
     * @returns The response
     */
    public async ForceResyncNoBlankValues(erpConnectionId: number, internalKeyIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    public async ForceResyncNoBlankValues(erpConnectionId:number|carriers.ErpSync_ForceResyncNoBlankValuesRequest, internalKeyIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        let _request : carriers.ErpSync_ForceResyncNoBlankValuesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.InternalKeyIds)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_ForceResyncNoBlankValuesRequest;
            _options = internalKeyIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       InternalKeyIds: internalKeyIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._ForceResyncNoBlankValues( _request, _options );
    }


    private async _ForceResyncBatchTask(request: carriers.ErpSync_ForceResyncBatchTaskRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResyncBatchTask", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Start batch task to force resync from CRM or given Erp connection to all other connections
     * @param request - ErpConnectionId, InternalKeyIds
     * @returns 
     */
    public async ForceResyncBatchTask(request: carriers.ErpSync_ForceResyncBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Start batch task to force resync from CRM or given Erp connection to all other connections
     * @param erpConnectionId - If positive, resync from the given erp connection
     * @param internalKeyIds - The internal keys of the entities to resync, or empty to resync all
     * @returns 
     */
    public async ForceResyncBatchTask(erpConnectionId: number, internalKeyIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ForceResyncBatchTask(erpConnectionId:number|carriers.ErpSync_ForceResyncBatchTaskRequest, internalKeyIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.ErpSync_ForceResyncBatchTaskRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.InternalKeyIds)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_ForceResyncBatchTaskRequest;
            _options = internalKeyIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       InternalKeyIds: internalKeyIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._ForceResyncBatchTask( _request, _options );
    }


    private async _ForceResyncExternal(request: carriers.ErpSync_ForceResyncExternalRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResyncExternal", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Force resync from CRM or given Erp connection to all other connections, using external keys
     * @param request - ErpConnectionId, ErpActorType, ExternalKeys
     * @returns The response
     */
    public async ForceResyncExternal(request: carriers.ErpSync_ForceResyncExternalRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    /**
     * Force resync from CRM or given Erp connection to all other connections, using external keys
     * @param erpConnectionId - Resync from the given erp connection
     * @param erpActorType - Which actor type the external keys are associated with
     * @param externalKeys - The internal keys of the entities to resync, or empty to resync all
     * @returns The response
     */
    public async ForceResyncExternal(erpConnectionId: number, erpActorType: enums.ErpActorType, externalKeys: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    public async ForceResyncExternal(erpConnectionId:number|carriers.ErpSync_ForceResyncExternalRequest, erpActorType?:enums.ErpActorType|base.WebApiRequestOptions, externalKeys?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        let _request : carriers.ErpSync_ForceResyncExternalRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.ErpActorType)!='undefined' || typeof(first.ExternalKeys)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_ForceResyncExternalRequest;
            _options = erpActorType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       ExternalKeys: externalKeys as string[],
                       };   
            _options = webapi_options;
        }
        return this._ForceResyncExternal( _request, _options );
    }


    private async _ForceResyncExternalNoBlankValues(request: carriers.ErpSync_ForceResyncExternalNoBlankValuesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResyncExternalNoBlankValues", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Force resync from CRM or given Erp connection to all other connections, using external keys, and tell the sync that you don&apos;t want blank values to overwrite non-blank values. Useful on import.
     * @param request - ErpConnectionId, ErpActorType, ExternalKeys
     * @returns The response
     */
    public async ForceResyncExternalNoBlankValues(request: carriers.ErpSync_ForceResyncExternalNoBlankValuesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    /**
     * Force resync from CRM or given Erp connection to all other connections, using external keys, and tell the sync that you don&apos;t want blank values to overwrite non-blank values. Useful on import.
     * @param erpConnectionId - Resync from the given erp connection
     * @param erpActorType - Which actor type the external keys are associated with
     * @param externalKeys - The internal keys of the entities to resync, or empty to resync all
     * @returns The response
     */
    public async ForceResyncExternalNoBlankValues(erpConnectionId: number, erpActorType: enums.ErpActorType, externalKeys: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    public async ForceResyncExternalNoBlankValues(erpConnectionId:number|carriers.ErpSync_ForceResyncExternalNoBlankValuesRequest, erpActorType?:enums.ErpActorType|base.WebApiRequestOptions, externalKeys?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        let _request : carriers.ErpSync_ForceResyncExternalNoBlankValuesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = erpConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ErpConnectionId)!='undefined' || typeof(first.ErpActorType)!='undefined' || typeof(first.ExternalKeys)!='undefined' ) )
        {
            _request = erpConnectionId as carriers.ErpSync_ForceResyncExternalNoBlankValuesRequest;
            _options = erpActorType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ErpConnectionId: erpConnectionId as number,
                       ErpActorType: erpActorType as enums.ErpActorType,
                       ExternalKeys: externalKeys as string[],
                       };   
            _options = webapi_options;
        }
        return this._ForceResyncExternalNoBlankValues( _request, _options );
    }


    private async _GetEngineStatus( options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncEngineStatus > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncEngineStatus >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEngineStatus", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncEngineStatus = converters.Create_ErpSyncEngineStatus_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the current status of the Sync engine
     * @returns The current status of the engine
     */
    public async GetEngineStatus(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncEngineStatus >
    {
        return this._GetEngineStatus(webapi_options);
    }


    private async _ChangeEngineStatus(request: carriers.ErpSync_ChangeEngineStatusRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncEngineStatus > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ErpSyncEngineStatus >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeEngineStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ErpSyncEngineStatus = converters.Create_ErpSyncEngineStatus_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change the current running/stopped status of the Sync engine
     * @param request - Run
     * @returns The current status of the engine
     */
    public async ChangeEngineStatus(request: carriers.ErpSync_ChangeEngineStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncEngineStatus >;

    /**
     * Change the current running/stopped status of the Sync engine
     * @param run - If true, then start the engine; otherwise stop it (requests to the Batch system, may not be immediately reflected)
     * @returns The current status of the engine
     */
    public async ChangeEngineStatus(run: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncEngineStatus >;

    public async ChangeEngineStatus(run:boolean|carriers.ErpSync_ChangeEngineStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ErpSyncEngineStatus > {
        let _request : carriers.ErpSync_ChangeEngineStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = run;
        if( typeof( first ) === "object" && first && ( typeof(first.Run)!='undefined' ) )
        {
            _request = run as carriers.ErpSync_ChangeEngineStatusRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Run: run as boolean,
                       };   
            _options = webapi_options;
        }
        return this._ChangeEngineStatus( _request, _options );
    }


    private async _ChangeEngineInterval(request: carriers.ErpSync_ChangeEngineIntervalRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeEngineInterval", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change the interval for each run of the Sync Engine
     * @param request - Interval
     * @returns 
     */
    public async ChangeEngineInterval(request: carriers.ErpSync_ChangeEngineIntervalRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Change the interval for each run of the Sync Engine
     * @param interval - The run interval for the engine
     * @returns 
     */
    public async ChangeEngineInterval(interval: moment.Duration, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ChangeEngineInterval(interval:moment.Duration|carriers.ErpSync_ChangeEngineIntervalRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.ErpSync_ChangeEngineIntervalRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = interval;
        if( typeof( first ) === "object" && first && ( typeof(first.Interval)!='undefined' ) )
        {
            _request = interval as carriers.ErpSync_ChangeEngineIntervalRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Interval: interval as moment.Duration,
                       };   
            _options = webapi_options;
        }
        return this._ChangeEngineInterval( _request, _options );
    }

    } // class v1ErpSyncAgentController 



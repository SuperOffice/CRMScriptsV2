// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/DocumentMigrationAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Agent used to support migrating documents between different document-plugins, as single documents or batches.
 * 
 * **Online Restricted:** This agent is not available in Online by default. Access must be requested specifically when app is registered. Intended for SuperOffice-internal apps.
 */
export interface IDocumentMigrationAgent {
    CreateDefaultDocumentMigrationItemList(): Promise< carriers.DocumentMigrationItemList >;
    CreateDefaultDocumentTemplateMigrationList(): Promise< carriers.DocumentTemplateMigrationList >;
    GetForAllDocuments(request: carriers.DocumentMigration_GetForAllDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;
    GetForAllDocuments(documentPluginId: number, includeEmails: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;
    GetForDateRange(request: carriers.DocumentMigration_GetForDateRangeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;
    GetForDateRange(documentPluginId: number, minDate: Date, maxDate: Date, includeEmails: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;
    GetForSelection(request: carriers.DocumentMigration_GetForSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;
    GetForSelection(documentPluginId: number, selectionId: number, includeEmails: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;
    MigrateDocumentToNewDocPlugin(request: carriers.DocumentMigration_MigrateDocumentToNewDocPluginRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MigrateDocumentToNewDocPlugin(documentId: number, documentPluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    HasDocumentsToMigrate(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetForTemplates(request: carriers.DocumentMigration_GetForTemplatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateMigrationList >;
    GetForTemplates(targetDocumentPluginId: number, includeEmails: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateMigrationList >;
    MigrateTemplateToNewDocPlugin(request: carriers.DocumentMigration_MigrateTemplateToNewDocPluginRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MigrateTemplateToNewDocPlugin(documentTemplateId: number, targetDocumentPluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
} // interface IDocumentMigrationAgent




/**
 * Agent used to support migrating documents between different document-plugins, as single documents or batches.
 */
export class DocumentMigrationAgent extends base.WebApiBase implements IDocumentMigrationAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/DocumentMigration/";
        super(options);
    }



    /**
     * Set default values into a new DocumentMigrationItemList.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDocumentMigrationItemList(options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentMigrationItemList >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDocumentMigrationItemList", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentMigrationItemList = converters.Create_DocumentMigrationItemList_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new DocumentTemplateMigrationList.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDocumentTemplateMigrationList(options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateMigrationList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplateMigrationList >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDocumentTemplateMigrationList", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentTemplateMigrationList = converters.Create_DocumentTemplateMigrationList_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    private async _GetForAllDocuments(request: carriers.DocumentMigration_GetForAllDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentMigrationItemList >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetForAllDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentMigrationItemList = converters.Create_DocumentMigrationItemList_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a migration summary for all documents stored in CRM. Warning: Expensive!
     * @param request - DocumentPluginId, IncludeEmails
     * @returns Never null.
     */
    public async GetForAllDocuments(request: carriers.DocumentMigration_GetForAllDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;

    /**
     * Gets a migration summary for all documents stored in CRM. Warning: Expensive!
     * @param documentPluginId - The ID of the document-plugin to migrate to.
     * @param includeEmails - True if documents to migrate should include emails.
     * @returns Never null.
     */
    public async GetForAllDocuments(documentPluginId: number, includeEmails: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;

    public async GetForAllDocuments(documentPluginId:number|carriers.DocumentMigration_GetForAllDocumentsRequest, includeEmails?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList > {
        let _request : carriers.DocumentMigration_GetForAllDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentPluginId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentPluginId)!='undefined' || typeof(first.IncludeEmails)!='undefined' ) )
        {
            _request = documentPluginId as carriers.DocumentMigration_GetForAllDocumentsRequest;
            _options = includeEmails as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentPluginId: documentPluginId as number,
                       IncludeEmails: includeEmails as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetForAllDocuments( _request, _options );
    }


    private async _GetForDateRange(request: carriers.DocumentMigration_GetForDateRangeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentMigrationItemList >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetForDateRange", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentMigrationItemList = converters.Create_DocumentMigrationItemList_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a migration summary for documents in the provided date-rage
     * @param request - DocumentPluginId, MinDate, MaxDate, IncludeEmails
     * @returns Never null.
     */
    public async GetForDateRange(request: carriers.DocumentMigration_GetForDateRangeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;

    /**
     * Gets a migration summary for documents in the provided date-rage
     * @param documentPluginId - The ID of the document-plugin to migrate to.
     * @param minDate - Inclusive mininmum.
     * @param maxDate - Inclusive maximum.
     * @param includeEmails - True if documents to migrate should include emails.
     * @returns Never null.
     */
    public async GetForDateRange(documentPluginId: number, minDate: Date, maxDate: Date, includeEmails: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;

    public async GetForDateRange(documentPluginId:number|carriers.DocumentMigration_GetForDateRangeRequest, minDate?:Date|base.WebApiRequestOptions, maxDate?:Date, includeEmails?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList > {
        let _request : carriers.DocumentMigration_GetForDateRangeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentPluginId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentPluginId)!='undefined' || typeof(first.MinDate)!='undefined' || typeof(first.MaxDate)!='undefined' || typeof(first.IncludeEmails)!='undefined' ) )
        {
            _request = documentPluginId as carriers.DocumentMigration_GetForDateRangeRequest;
            _options = minDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentPluginId: documentPluginId as number,
                       MinDate: minDate as Date,
                       MaxDate: maxDate as Date,
                       IncludeEmails: includeEmails as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetForDateRange( _request, _options );
    }


    private async _GetForSelection(request: carriers.DocumentMigration_GetForSelectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentMigrationItemList >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetForSelection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentMigrationItemList = converters.Create_DocumentMigrationItemList_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a migration summary for documents in the provided selection
     * @param request - DocumentPluginId, SelectionId, IncludeEmails
     * @returns Never null.
     */
    public async GetForSelection(request: carriers.DocumentMigration_GetForSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;

    /**
     * Gets a migration summary for documents in the provided selection
     * @param documentPluginId - The ID of the document-plugin to migrate to.
     * @param selectionId - ID of the selection used to create the DocumentMigrationSummary instance.
     * @param includeEmails - True if documents to migrate should include emails.
     * @returns Never null.
     */
    public async GetForSelection(documentPluginId: number, selectionId: number, includeEmails: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList >;

    public async GetForSelection(documentPluginId:number|carriers.DocumentMigration_GetForSelectionRequest, selectionId?:number|base.WebApiRequestOptions, includeEmails?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentMigrationItemList > {
        let _request : carriers.DocumentMigration_GetForSelectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentPluginId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentPluginId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.IncludeEmails)!='undefined' ) )
        {
            _request = documentPluginId as carriers.DocumentMigration_GetForSelectionRequest;
            _options = selectionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentPluginId: documentPluginId as number,
                       SelectionId: selectionId as number,
                       IncludeEmails: includeEmails as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetForSelection( _request, _options );
    }


    private async _MigrateDocumentToNewDocPlugin(request: carriers.DocumentMigration_MigrateDocumentToNewDocPluginRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MigrateDocumentToNewDocPlugin", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Migrates the document with the provided id to the specified document-plugin.
     * @param request - DocumentId, DocumentPluginId
     * @returns This method has no return value
     */
    public async MigrateDocumentToNewDocPlugin(request: carriers.DocumentMigration_MigrateDocumentToNewDocPluginRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Migrates the document with the provided id to the specified document-plugin.
     * @param documentId - The ID of the document to migrate.
     * @param documentPluginId - The ID of the document-plugin to migrate to.
     * @returns This method has no return value
     */
    public async MigrateDocumentToNewDocPlugin(documentId: number, documentPluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MigrateDocumentToNewDocPlugin(documentId:number|carriers.DocumentMigration_MigrateDocumentToNewDocPluginRequest, documentPluginId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.DocumentMigration_MigrateDocumentToNewDocPluginRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.DocumentPluginId)!='undefined' ) )
        {
            _request = documentId as carriers.DocumentMigration_MigrateDocumentToNewDocPluginRequest;
            _options = documentPluginId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       DocumentPluginId: documentPluginId as number,
                       };   
            _options = webapi_options;
        }
        return this._MigrateDocumentToNewDocPlugin( _request, _options );
    }


    private async _HasDocumentsToMigrate( options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasDocumentsToMigrate", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Checks if there are any documents in the current database stored using a non-default document-plugin, and which can be migrated.
     * @returns True if there are documents available to migrate.
     */
    public async HasDocumentsToMigrate(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >
    {
        return this._HasDocumentsToMigrate(webapi_options);
    }


    private async _GetForTemplates(request: carriers.DocumentMigration_GetForTemplatesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateMigrationList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplateMigrationList >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetForTemplates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentTemplateMigrationList = converters.Create_DocumentTemplateMigrationList_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a migration summary for all templates stored in CRM.
     * @param request - TargetDocumentPluginId, IncludeEmails
     * @returns Never null.
     */
    public async GetForTemplates(request: carriers.DocumentMigration_GetForTemplatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateMigrationList >;

    /**
     * Gets a migration summary for all templates stored in CRM.
     * @param targetDocumentPluginId - The ID of the document-plugin to migrate to.
     * @param includeEmails - True if templates to migrate should include emails.
     * @returns Never null.
     */
    public async GetForTemplates(targetDocumentPluginId: number, includeEmails: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateMigrationList >;

    public async GetForTemplates(targetDocumentPluginId:number|carriers.DocumentMigration_GetForTemplatesRequest, includeEmails?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateMigrationList > {
        let _request : carriers.DocumentMigration_GetForTemplatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = targetDocumentPluginId;
        if( typeof( first ) === "object" && first && ( typeof(first.TargetDocumentPluginId)!='undefined' || typeof(first.IncludeEmails)!='undefined' ) )
        {
            _request = targetDocumentPluginId as carriers.DocumentMigration_GetForTemplatesRequest;
            _options = includeEmails as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TargetDocumentPluginId: targetDocumentPluginId as number,
                       IncludeEmails: includeEmails as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetForTemplates( _request, _options );
    }


    private async _MigrateTemplateToNewDocPlugin(request: carriers.DocumentMigration_MigrateTemplateToNewDocPluginRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MigrateTemplateToNewDocPlugin", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Migrates the template with the provided id to the specified document-plugin.
     * @param request - DocumentTemplateId, TargetDocumentPluginId
     * @returns This method has no return value
     */
    public async MigrateTemplateToNewDocPlugin(request: carriers.DocumentMigration_MigrateTemplateToNewDocPluginRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Migrates the template with the provided id to the specified document-plugin.
     * @param documentTemplateId - The ID of the document-template to migrate.
     * @param targetDocumentPluginId - The ID of the document-plugin to migrate to.
     * @returns This method has no return value
     */
    public async MigrateTemplateToNewDocPlugin(documentTemplateId: number, targetDocumentPluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MigrateTemplateToNewDocPlugin(documentTemplateId:number|carriers.DocumentMigration_MigrateTemplateToNewDocPluginRequest, targetDocumentPluginId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.DocumentMigration_MigrateTemplateToNewDocPluginRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' || typeof(first.TargetDocumentPluginId)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.DocumentMigration_MigrateTemplateToNewDocPluginRequest;
            _options = targetDocumentPluginId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       TargetDocumentPluginId: targetDocumentPluginId as number,
                       };   
            _options = webapi_options;
        }
        return this._MigrateTemplateToNewDocPlugin( _request, _options );
    }

    } // class v1DocumentMigrationAgentController 



// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/ArchiveAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * ArchiveList functions of all kinds
 */
export interface IArchiveAgent {
    CreateDefaultArchiveListResult(): Promise< carriers.ArchiveListResult >;
    GetActivityFilter(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ActivityFilter >;
    SetActivityFilter(request: carriers.Archive_SetActivityFilterRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetActivityFilter(activityFilter: carriers.ActivityFilter, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetGroupAssociateIds(request: carriers.Archive_GetGroupAssociateIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    GetGroupAssociateIds(groupIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    GetArchiveConfiguration(request: carriers.Archive_GetArchiveConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;
    GetArchiveConfiguration(guiName: string, providerName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;
    GetArchiveConfigurationWithContext(request: carriers.Archive_GetArchiveConfigurationWithContextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;
    GetArchiveConfigurationWithContext(guiName: string, providerName: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;
    SetColumnWidths(request: carriers.Archive_SetColumnWidthsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetColumnWidths(guiName: string, columnWidths: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetChosenEntities(request: carriers.Archive_SetChosenEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetChosenEntities(guiName: string, providerName: string, entities: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetChosenColumns(request: carriers.Archive_SetChosenColumnsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetChosenColumns(guiName: string, providerName: string, chosenColumns: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetArchiveConfigurationV2(request: carriers.Archive_GetArchiveConfigurationV2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;
    GetArchiveConfigurationV2(guiName: string, providerName: string, context: string, ownerKeys: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;
    SetColumnWidthsV2(request: carriers.Archive_SetColumnWidthsV2Request, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetColumnWidthsV2(guiName: string, providerName: string, context: string, ownerKeys: string, columnWidths: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetChosenEntitiesV2(request: carriers.Archive_SetChosenEntitiesV2Request, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetChosenEntitiesV2(guiName: string, providerName: string, context: string, ownerKeys: string, entities: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetChosenColumnsV2(request: carriers.Archive_SetChosenColumnsV2Request, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetChosenColumnsV2(guiName: string, providerName: string, context: string, ownerKeys: string, chosenColumns: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetArchiveListByColumns(request: carriers.Archive_GetArchiveListByColumnsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListByColumns(providerName: string, columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListByColumnsWithContext(request: carriers.Archive_GetArchiveListByColumnsWithContextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListByColumnsWithContext(providerName: string, columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveList(request: carriers.Archive_GetArchiveListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveList(guiName: string, providerName: string, sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListWithContext(request: carriers.Archive_GetArchiveListWithContextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListWithContext(guiName: string, providerName: string, sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListByColumnsWithHeader(request: carriers.Archive_GetArchiveListByColumnsWithHeaderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;
    GetArchiveListByColumnsWithHeader(providerName: string, columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, options: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;
    GetProviderNames(webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetArchiveListByColumnsWithHeaderWithContext(request: carriers.Archive_GetArchiveListByColumnsWithHeaderWithContextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;
    GetArchiveListByColumnsWithHeaderWithContext(providerName: string, columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, options: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;
    GetAvailableColumns(request: carriers.Archive_GetAvailableColumnsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveColumnInfo[] >;
    GetAvailableColumns(providerName: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveColumnInfo[] >;
    GetAvailableEntities(request: carriers.Archive_GetAvailableEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    GetAvailableEntities(providerName: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    GetArchiveListByColumns2(request: carriers.Archive_GetArchiveListByColumns2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListByColumns2(providerName: string, columns: string, sortOrder: string, restrictions: string, entities: string, page: number, pageSize: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListByColumnsWithContext2(request: carriers.Archive_GetArchiveListByColumnsWithContext2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListByColumnsWithContext2(providerName: string, columns: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveList2(request: carriers.Archive_GetArchiveList2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveList2(guiName: string, providerName: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListWithContext2(request: carriers.Archive_GetArchiveListWithContext2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListWithContext2(guiName: string, providerName: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetArchiveListByColumnsWithHeader2(request: carriers.Archive_GetArchiveListByColumnsWithHeader2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;
    GetArchiveListByColumnsWithHeader2(providerName: string, columns: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, options: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;
    GetArchiveListByColumnsWithHeaderWithContext2(request: carriers.Archive_GetArchiveListByColumnsWithHeaderWithContext2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;
    GetArchiveListByColumnsWithHeaderWithContext2(providerName: string, columns: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, options: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;
    ExportArchive(request: carriers.Archive_ExportArchiveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ExportArchiveResult >;
    ExportArchive(providerName: string, context: string, desiredEntities: string[], columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restrictions: carriers.ArchiveRestrictionInfo[], exportType: string, selectedRowIds: string[], estimatedRowCount: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ExportArchiveResult >;
    GetRelatedData(request: carriers.Archive_GetRelatedDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] >;
    GetRelatedData(table: string, recordId: number, fields: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] >;
    GetRelatedData2(request: carriers.Archive_GetRelatedData2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] >;
    GetRelatedData2(table: string, recordId: number, fields: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] >;
} // interface IArchiveAgent




/**
 * ArchiveList functions of all kinds
 */
export class ArchiveAgent extends base.WebApiBase implements IArchiveAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Archive/";
        super(options);
    }



    /**
     * Set default values into a new ArchiveListResult.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultArchiveListResult(options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListResult >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultArchiveListResult", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListResult = converters.Create_ArchiveListResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    private async _GetActivityFilter( options?:base.WebApiRequestOptions) : Promise< carriers.ActivityFilter > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ActivityFilter >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetActivityFilter", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ActivityFilter = converters.Create_ActivityFilter_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get activity filter for the specified list.
     * @returns The activity filter for the specified list
     */
    public async GetActivityFilter(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ActivityFilter >
    {
        return this._GetActivityFilter(webapi_options);
    }


    private async _SetActivityFilter(request: carriers.Archive_SetActivityFilterRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetActivityFilter", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set activity filter for the specified list.
     * @param request - ActivityFilter
     * @returns 
     */
    public async SetActivityFilter(request: carriers.Archive_SetActivityFilterRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set activity filter for the specified list.
     * @param activityFilter - New activity filter
     * @returns 
     */
    public async SetActivityFilter(activityFilter: carriers.ActivityFilter, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetActivityFilter(activityFilter:carriers.ActivityFilter|carriers.Archive_SetActivityFilterRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Archive_SetActivityFilterRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = activityFilter;
        if( typeof( first ) === "object" && first && ( typeof(first.ActivityFilter)!='undefined' ) )
        {
            _request = activityFilter as carriers.Archive_SetActivityFilterRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ActivityFilter: activityFilter as carriers.ActivityFilter,
                       };   
            _options = webapi_options;
        }
        return this._SetActivityFilter( _request, _options );
    }


    private async _GetGroupAssociateIds(request: carriers.Archive_GetGroupAssociateIdsRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetGroupAssociateIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the  associate ids that belongs to the given groups
     * @param request - GroupIds
     * @returns Array of associate ids
     */
    public async GetGroupAssociateIds(request: carriers.Archive_GetGroupAssociateIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * Returns the  associate ids that belongs to the given groups
     * @param groupIds - Array of group ids
     * @returns Array of associate ids
     */
    public async GetGroupAssociateIds(groupIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async GetGroupAssociateIds(groupIds:number[]|carriers.Archive_GetGroupAssociateIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.Archive_GetGroupAssociateIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = groupIds;
        if( typeof( first ) === "object" && first && ( typeof(first.GroupIds)!='undefined' ) )
        {
            _request = groupIds as carriers.Archive_GetGroupAssociateIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GroupIds: groupIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetGroupAssociateIds( _request, _options );
    }


    private async _GetArchiveConfiguration(request: carriers.Archive_GetArchiveConfigurationRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveConfiguration >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveConfiguration", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveConfiguration = converters.Create_ArchiveConfiguration_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the configuration for one archive. The configuration is keyed by a combination of archive provider name and gui name. The archive provider name must match an archive provider plugin; the gui name is an arbitrary string used to distinguish multiple occurrences of the same underlying provider in a gui.
     * @param request - GuiName, ProviderName
     * @returns Archive configuration consisting of column information, orderby information and entities
     */
    public async GetArchiveConfiguration(request: carriers.Archive_GetArchiveConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;

    /**
     * Get the configuration for one archive. The configuration is keyed by a combination of archive provider name and gui name. The archive provider name must match an archive provider plugin; the gui name is an arbitrary string used to distinguish multiple occurrences of the same underlying provider in a gui.
     * @param guiName - String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     * @param providerName - Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     * @returns Archive configuration consisting of column information, orderby information and entities
     */
    public async GetArchiveConfiguration(guiName: string, providerName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;

    public async GetArchiveConfiguration(guiName:string|carriers.Archive_GetArchiveConfigurationRequest, providerName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration > {
        let _request : carriers.Archive_GetArchiveConfigurationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_GetArchiveConfigurationRequest;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveConfiguration( _request, _options );
    }


    private async _GetArchiveConfigurationWithContext(request: carriers.Archive_GetArchiveConfigurationWithContextRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveConfiguration >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveConfigurationWithContext", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveConfiguration = converters.Create_ArchiveConfiguration_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the configuration for one archive, with context parameter. The configuration is keyed by a combination of archive provider name and gui name. The archive provider name must match an archive provider plugin; the gui name is an arbitrary string used to distinguish multiple occurrences of the same underlying provider in a gui.
     * @param request - GuiName, ProviderName, Context
     * @returns Archive configuration consisting of column information, orderby information and entities
     */
    public async GetArchiveConfigurationWithContext(request: carriers.Archive_GetArchiveConfigurationWithContextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;

    /**
     * Get the configuration for one archive, with context parameter. The configuration is keyed by a combination of archive provider name and gui name. The archive provider name must match an archive provider plugin; the gui name is an arbitrary string used to distinguish multiple occurrences of the same underlying provider in a gui.
     * @param guiName - String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     * @param providerName - Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @returns Archive configuration consisting of column information, orderby information and entities
     */
    public async GetArchiveConfigurationWithContext(guiName: string, providerName: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;

    public async GetArchiveConfigurationWithContext(guiName:string|carriers.Archive_GetArchiveConfigurationWithContextRequest, providerName?:string|base.WebApiRequestOptions, context?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration > {
        let _request : carriers.Archive_GetArchiveConfigurationWithContextRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.Context)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_GetArchiveConfigurationWithContextRequest;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       Context: context as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveConfigurationWithContext( _request, _options );
    }


    private async _SetColumnWidths(request: carriers.Archive_SetColumnWidthsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetColumnWidths", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the column widths for the given set of columns and GUI name. 
     * @param request - GuiName, ColumnWidths
     * @returns 
     */
    public async SetColumnWidths(request: carriers.Archive_SetColumnWidthsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the column widths for the given set of columns and GUI name. 
     * @param guiName - String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     * @param columnWidths - Array of column widths. A column width is specified either as a fixed number of character (10c) or as a percentage (10%). Percentages will be recalculated so that they add up to exactly 100 when the configuration is fetched again.
     * @returns 
     */
    public async SetColumnWidths(guiName: string, columnWidths: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetColumnWidths(guiName:string|carriers.Archive_SetColumnWidthsRequest, columnWidths?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Archive_SetColumnWidthsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ColumnWidths)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_SetColumnWidthsRequest;
            _options = columnWidths as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ColumnWidths: columnWidths as string[],
                       };   
            _options = webapi_options;
        }
        return this._SetColumnWidths( _request, _options );
    }


    private async _SetChosenEntities(request: carriers.Archive_SetChosenEntitiesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetChosenEntities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the currently chosen entities for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveEntities: plus the archive provider name and gui name as its additionalInfo.
     * @param request - GuiName, ProviderName, Entities
     * @returns 
     */
    public async SetChosenEntities(request: carriers.Archive_SetChosenEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the currently chosen entities for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveEntities: plus the archive provider name and gui name as its additionalInfo.
     * @param guiName - String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     * @param providerName - Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     * @param entities - Array of entity names
     * @returns 
     */
    public async SetChosenEntities(guiName: string, providerName: string, entities: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetChosenEntities(guiName:string|carriers.Archive_SetChosenEntitiesRequest, providerName?:string|base.WebApiRequestOptions, entities?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Archive_SetChosenEntitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.Entities)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_SetChosenEntitiesRequest;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       Entities: entities as string[],
                       };   
            _options = webapi_options;
        }
        return this._SetChosenEntities( _request, _options );
    }


    private async _SetChosenColumns(request: carriers.Archive_SetChosenColumnsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetChosenColumns", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the currently chosen columns for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveColumns: plus the archive provider name and gui name as its additionalInfo.
     * @param request - GuiName, ProviderName, ChosenColumns
     * @returns 
     */
    public async SetChosenColumns(request: carriers.Archive_SetChosenColumnsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the currently chosen columns for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveColumns: plus the archive provider name and gui name as its additionalInfo.
     * @param guiName - String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     * @param providerName - Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     * @param chosenColumns - Array of column names, where array order indicates left to right order in the archive.
     * @returns 
     */
    public async SetChosenColumns(guiName: string, providerName: string, chosenColumns: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetChosenColumns(guiName:string|carriers.Archive_SetChosenColumnsRequest, providerName?:string|base.WebApiRequestOptions, chosenColumns?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Archive_SetChosenColumnsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.ChosenColumns)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_SetChosenColumnsRequest;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       ChosenColumns: chosenColumns as string[],
                       };   
            _options = webapi_options;
        }
        return this._SetChosenColumns( _request, _options );
    }


    private async _GetArchiveConfigurationV2(request: carriers.Archive_GetArchiveConfigurationV2Request, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveConfiguration >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveConfigurationV2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveConfiguration = converters.Create_ArchiveConfiguration_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the configuration for one archive. The configuration is keyed by a combination of archive provider name (plus optional context), gui name, and optional table binding. The archive provider name must match an archive provider plugin; the gui name is an arbitrary string used to distinguish multiple occurrences of the same underlying provider in a gui.
     * @param request - GuiName, ProviderName, Context, OwnerKeys
     * @returns Archive configuration consisting of column information, orderby information and entities
     */
    public async GetArchiveConfigurationV2(request: carriers.Archive_GetArchiveConfigurationV2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;

    /**
     * Get the configuration for one archive. The configuration is keyed by a combination of archive provider name (plus optional context), gui name, and optional table binding. The archive provider name must match an archive provider plugin; the gui name is an arbitrary string used to distinguish multiple occurrences of the same underlying provider in a gui.
     * @param guiName - String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     * @param providerName - Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor. Optional, but required for archives that depend on a context - for instance Quote archives that need to know their QuoteConnectionId to be meaningful
     * @param ownerKeys - Name/value string containing ownership binding information. The first should resolve to a table/primarykey, such as selection=123. Future functionality may allow multiple/extended keys
     * @returns Archive configuration consisting of column information, orderby information and entities
     */
    public async GetArchiveConfigurationV2(guiName: string, providerName: string, context: string, ownerKeys: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration >;

    public async GetArchiveConfigurationV2(guiName:string|carriers.Archive_GetArchiveConfigurationV2Request, providerName?:string|base.WebApiRequestOptions, context?:string, ownerKeys?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveConfiguration > {
        let _request : carriers.Archive_GetArchiveConfigurationV2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.Context)!='undefined' || typeof(first.OwnerKeys)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_GetArchiveConfigurationV2Request;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       Context: context as string,
                       OwnerKeys: ownerKeys as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveConfigurationV2( _request, _options );
    }


    private async _SetColumnWidthsV2(request: carriers.Archive_SetColumnWidthsV2Request, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetColumnWidthsV2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the column widths for the given set of columns and GUI name. 
     * @param request - GuiName, ProviderName, Context, OwnerKeys, ColumnWidths
     * @returns 
     */
    public async SetColumnWidthsV2(request: carriers.Archive_SetColumnWidthsV2Request, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the column widths for the given set of columns and GUI name. 
     * @param guiName - String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     * @param providerName - Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor. Optional, but required for archives that depend on a context - for instance Quote archives that need to know their QuoteConnectionId to be meaningful
     * @param ownerKeys - Name/value string containing ownership binding information. The first should resolve to a table/primarykey, such as selection=123. Future functionality may allow multiple/extended keys
     * @param columnWidths - Array of column widths. A column width is specified either as a fixed number of character (10c) or as a percentage (10%). Percentages will be recalculated so that they add up to exactly 100 when the configuration is fetched again.
     * @returns 
     */
    public async SetColumnWidthsV2(guiName: string, providerName: string, context: string, ownerKeys: string, columnWidths: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetColumnWidthsV2(guiName:string|carriers.Archive_SetColumnWidthsV2Request, providerName?:string|base.WebApiRequestOptions, context?:string, ownerKeys?:string, columnWidths?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Archive_SetColumnWidthsV2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.Context)!='undefined' || typeof(first.OwnerKeys)!='undefined' || typeof(first.ColumnWidths)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_SetColumnWidthsV2Request;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       Context: context as string,
                       OwnerKeys: ownerKeys as string,
                       ColumnWidths: columnWidths as string[],
                       };   
            _options = webapi_options;
        }
        return this._SetColumnWidthsV2( _request, _options );
    }


    private async _SetChosenEntitiesV2(request: carriers.Archive_SetChosenEntitiesV2Request, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetChosenEntitiesV2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the currently chosen entities for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveEntities: plus the archive provider name and gui name as its additionalInfo.
     * @param request - GuiName, ProviderName, Context, OwnerKeys, Entities
     * @returns 
     */
    public async SetChosenEntitiesV2(request: carriers.Archive_SetChosenEntitiesV2Request, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the currently chosen entities for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveEntities: plus the archive provider name and gui name as its additionalInfo.
     * @param guiName - String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     * @param providerName - Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor. Optional, but required for archives that depend on a context - for instance Quote archives that need to know their QuoteConnectionId to be meaningful
     * @param ownerKeys - Name/value string containing ownership binding information. The first should resolve to a table/primarykey, such as selection=123. Future functionality may allow multiple/extended keys
     * @param entities - Array of entity names
     * @returns 
     */
    public async SetChosenEntitiesV2(guiName: string, providerName: string, context: string, ownerKeys: string, entities: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetChosenEntitiesV2(guiName:string|carriers.Archive_SetChosenEntitiesV2Request, providerName?:string|base.WebApiRequestOptions, context?:string, ownerKeys?:string, entities?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Archive_SetChosenEntitiesV2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.Context)!='undefined' || typeof(first.OwnerKeys)!='undefined' || typeof(first.Entities)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_SetChosenEntitiesV2Request;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       Context: context as string,
                       OwnerKeys: ownerKeys as string,
                       Entities: entities as string[],
                       };   
            _options = webapi_options;
        }
        return this._SetChosenEntitiesV2( _request, _options );
    }


    private async _SetChosenColumnsV2(request: carriers.Archive_SetChosenColumnsV2Request, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetChosenColumnsV2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the currently chosen columns for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveColumns: plus the archive provider name and gui name as its additionalInfo.
     * @param request - GuiName, ProviderName, Context, OwnerKeys, ChosenColumns
     * @returns 
     */
    public async SetChosenColumnsV2(request: carriers.Archive_SetChosenColumnsV2Request, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the currently chosen columns for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveColumns: plus the archive provider name and gui name as its additionalInfo.
     * @param guiName - String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     * @param providerName - Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor. Optional, but required for archives that depend on a context - for instance Quote archives that need to know their QuoteConnectionId to be meaningful
     * @param ownerKeys - Name/value string containing ownership binding information. The first should resolve to a table/primarykey, such as selection=123. Future functionality may allow multiple/extended keys
     * @param chosenColumns - Array of column names, where array order indicates left to right order in the archive.
     * @returns 
     */
    public async SetChosenColumnsV2(guiName: string, providerName: string, context: string, ownerKeys: string, chosenColumns: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetChosenColumnsV2(guiName:string|carriers.Archive_SetChosenColumnsV2Request, providerName?:string|base.WebApiRequestOptions, context?:string, ownerKeys?:string, chosenColumns?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Archive_SetChosenColumnsV2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.Context)!='undefined' || typeof(first.OwnerKeys)!='undefined' || typeof(first.ChosenColumns)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_SetChosenColumnsV2Request;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       Context: context as string,
                       OwnerKeys: ownerKeys as string,
                       ChosenColumns: chosenColumns as string[],
                       };   
            _options = webapi_options;
        }
        return this._SetChosenColumnsV2( _request, _options );
    }


    private async _GetArchiveListByColumns(request: carriers.Archive_GetArchiveListByColumnsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListByColumns", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of results for an archive list, explicitly specifying the restrictions, orderby and chosen columns.
     * @param request - ProviderName, Columns, SortOrder, Restriction, Entities, Page, PageSize
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumns(request: carriers.Archive_GetArchiveListByColumnsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get a page of results for an archive list, explicitly specifying the restrictions, orderby and chosen columns.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param columns - An array of the names of the columns wanted.
     * @param sortOrder - Sort order for the archive. Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Which entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumns(providerName: string, columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetArchiveListByColumns(providerName:string|carriers.Archive_GetArchiveListByColumnsRequest, columns?:string[]|base.WebApiRequestOptions, sortOrder?:carriers.ArchiveOrderByInfo[], restriction?:carriers.ArchiveRestrictionInfo[], entities?:string[], page?:number, pageSize?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Archive_GetArchiveListByColumnsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetArchiveListByColumnsRequest;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Columns: columns as string[],
                       SortOrder: sortOrder as carriers.ArchiveOrderByInfo[],
                       Restriction: restriction as carriers.ArchiveRestrictionInfo[],
                       Entities: entities as string[],
                       Page: page as number,
                       PageSize: pageSize as number,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListByColumns( _request, _options );
    }


    private async _GetArchiveListByColumnsWithContext(request: carriers.Archive_GetArchiveListByColumnsWithContextRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListByColumnsWithContext", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of results for an archive list with context parameter, explicitly specifying the restrictions, orderby and chosen columns.
     * @param request - ProviderName, Columns, SortOrder, Restriction, Entities, Page, PageSize, Context
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithContext(request: carriers.Archive_GetArchiveListByColumnsWithContextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get a page of results for an archive list with context parameter, explicitly specifying the restrictions, orderby and chosen columns.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param columns - An array of the names of the columns wanted.
     * @param sortOrder - Sort order for the archive. Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Which entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithContext(providerName: string, columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetArchiveListByColumnsWithContext(providerName:string|carriers.Archive_GetArchiveListByColumnsWithContextRequest, columns?:string[]|base.WebApiRequestOptions, sortOrder?:carriers.ArchiveOrderByInfo[], restriction?:carriers.ArchiveRestrictionInfo[], entities?:string[], page?:number, pageSize?:number, context?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Archive_GetArchiveListByColumnsWithContextRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' || typeof(first.Context)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetArchiveListByColumnsWithContextRequest;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Columns: columns as string[],
                       SortOrder: sortOrder as carriers.ArchiveOrderByInfo[],
                       Restriction: restriction as carriers.ArchiveRestrictionInfo[],
                       Entities: entities as string[],
                       Page: page as number,
                       PageSize: pageSize as number,
                       Context: context as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListByColumnsWithContext( _request, _options );
    }


    private async _GetArchiveList(request: carriers.Archive_GetArchiveListRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of data for an archive. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
     * @param request - GuiName, ProviderName, SortOrder, Restriction, Entities, Page, PageSize
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveList(request: carriers.Archive_GetArchiveListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get a page of data for an archive. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
     * @param guiName - The GUI name of the archive list, used to retrieve the currently configured set of columns (otherwise manipulated using the ArchiveConfiguration service)
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param sortOrder - Sort order for the archive. Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Which entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveList(guiName: string, providerName: string, sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetArchiveList(guiName:string|carriers.Archive_GetArchiveListRequest, providerName?:string|base.WebApiRequestOptions, sortOrder?:carriers.ArchiveOrderByInfo[], restriction?:carriers.ArchiveRestrictionInfo[], entities?:string[], page?:number, pageSize?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Archive_GetArchiveListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_GetArchiveListRequest;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       SortOrder: sortOrder as carriers.ArchiveOrderByInfo[],
                       Restriction: restriction as carriers.ArchiveRestrictionInfo[],
                       Entities: entities as string[],
                       Page: page as number,
                       PageSize: pageSize as number,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveList( _request, _options );
    }


    private async _GetArchiveListWithContext(request: carriers.Archive_GetArchiveListWithContextRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListWithContext", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of data for an archive, with context parameter. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
     * @param request - GuiName, ProviderName, SortOrder, Restriction, Entities, Page, PageSize, Context
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListWithContext(request: carriers.Archive_GetArchiveListWithContextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get a page of data for an archive, with context parameter. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
     * @param guiName - The GUI name of the archive list, used to retrieve the currently configured set of columns (otherwise manipulated using the ArchiveConfiguration service)
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param sortOrder - Sort order for the archive. Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Which entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListWithContext(guiName: string, providerName: string, sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetArchiveListWithContext(guiName:string|carriers.Archive_GetArchiveListWithContextRequest, providerName?:string|base.WebApiRequestOptions, sortOrder?:carriers.ArchiveOrderByInfo[], restriction?:carriers.ArchiveRestrictionInfo[], entities?:string[], page?:number, pageSize?:number, context?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Archive_GetArchiveListWithContextRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' || typeof(first.Context)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_GetArchiveListWithContextRequest;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       SortOrder: sortOrder as carriers.ArchiveOrderByInfo[],
                       Restriction: restriction as carriers.ArchiveRestrictionInfo[],
                       Entities: entities as string[],
                       Page: page as number,
                       PageSize: pageSize as number,
                       Context: context as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListWithContext( _request, _options );
    }


    private async _GetArchiveListByColumnsWithHeader(request: carriers.Archive_GetArchiveListByColumnsWithHeaderRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListByColumnsWithHeader", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListResult = converters.Create_ArchiveListResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of results for an archive list, explicitly specifying the restrictions, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
     * @param request - ProviderName, Columns, SortOrder, Restriction, Entities, Page, PageSize, Options
     * @returns Header with optional row count, plus array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithHeader(request: carriers.Archive_GetArchiveListByColumnsWithHeaderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;

    /**
     * Get a page of results for an archive list, explicitly specifying the restrictions, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param columns - An array of the names of the columns wanted.
     * @param sortOrder - Sort order for the archive. Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Which entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @param options - name=value&amp;... formatted set of options. "rowcount=true" will cause the rowcount to be calculated and populated.
     * @returns Header with optional row count, plus array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithHeader(providerName: string, columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, options: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;

    public async GetArchiveListByColumnsWithHeader(providerName:string|carriers.Archive_GetArchiveListByColumnsWithHeaderRequest, columns?:string[]|base.WebApiRequestOptions, sortOrder?:carriers.ArchiveOrderByInfo[], restriction?:carriers.ArchiveRestrictionInfo[], entities?:string[], page?:number, pageSize?:number, options?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult > {
        let _request : carriers.Archive_GetArchiveListByColumnsWithHeaderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' || typeof(first.Options)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetArchiveListByColumnsWithHeaderRequest;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Columns: columns as string[],
                       SortOrder: sortOrder as carriers.ArchiveOrderByInfo[],
                       Restriction: restriction as carriers.ArchiveRestrictionInfo[],
                       Entities: entities as string[],
                       Page: page as number,
                       PageSize: pageSize as number,
                       Options: options as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListByColumnsWithHeader( _request, _options );
    }


    private async _GetProviderNames( options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProviderNames", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Return list of all archive provider names
     * @returns Array of all archive provider names. 
     */
    public async GetProviderNames(webapi_options?:base.WebApiRequestOptions) : Promise< string[] >
    {
        return this._GetProviderNames(webapi_options);
    }


    private async _GetArchiveListByColumnsWithHeaderWithContext(request: carriers.Archive_GetArchiveListByColumnsWithHeaderWithContextRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListByColumnsWithHeaderWithContext", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListResult = converters.Create_ArchiveListResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of results for an archive list, with context parameter, explicitly specifying the restrictions, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
     * @param request - ProviderName, Columns, SortOrder, Restriction, Entities, Page, PageSize, Options, Context
     * @returns Header with optional row count, plus array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithHeaderWithContext(request: carriers.Archive_GetArchiveListByColumnsWithHeaderWithContextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;

    /**
     * Get a page of results for an archive list, with context parameter, explicitly specifying the restrictions, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param columns - An array of the names of the columns wanted.
     * @param sortOrder - Sort order for the archive. Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Which entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @param options - name=value&amp;... formatted set of options. "rowcount=true" will cause the rowcount to be calculated and populated.
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @returns Header with optional row count, plus array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithHeaderWithContext(providerName: string, columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restriction: carriers.ArchiveRestrictionInfo[], entities: string[], page: number, pageSize: number, options: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;

    public async GetArchiveListByColumnsWithHeaderWithContext(providerName:string|carriers.Archive_GetArchiveListByColumnsWithHeaderWithContextRequest, columns?:string[]|base.WebApiRequestOptions, sortOrder?:carriers.ArchiveOrderByInfo[], restriction?:carriers.ArchiveRestrictionInfo[], entities?:string[], page?:number, pageSize?:number, options?:string, context?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult > {
        let _request : carriers.Archive_GetArchiveListByColumnsWithHeaderWithContextRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' || typeof(first.Options)!='undefined' || typeof(first.Context)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetArchiveListByColumnsWithHeaderWithContextRequest;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Columns: columns as string[],
                       SortOrder: sortOrder as carriers.ArchiveOrderByInfo[],
                       Restriction: restriction as carriers.ArchiveRestrictionInfo[],
                       Entities: entities as string[],
                       Page: page as number,
                       PageSize: pageSize as number,
                       Options: options as string,
                       Context: context as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListByColumnsWithHeaderWithContext( _request, _options );
    }


    private async _GetAvailableColumns(request: carriers.Archive_GetAvailableColumnsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveColumnInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveColumnInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAvailableColumns", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveColumnInfo[] = converters.Create_ArchiveColumnInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Return list of all columns supported by an archive provider. See also GetArchiveConfiguration.
     * @param request - ProviderName, Context
     * @returns Array of all columns supported by the archive provider. 
     */
    public async GetAvailableColumns(request: carriers.Archive_GetAvailableColumnsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveColumnInfo[] >;

    /**
     * Return list of all columns supported by an archive provider. See also GetArchiveConfiguration.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param context - Optional context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @returns Array of all columns supported by the archive provider. 
     */
    public async GetAvailableColumns(providerName: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveColumnInfo[] >;

    public async GetAvailableColumns(providerName:string|carriers.Archive_GetAvailableColumnsRequest, context?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveColumnInfo[] > {
        let _request : carriers.Archive_GetAvailableColumnsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Context)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetAvailableColumnsRequest;
            _options = context as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Context: context as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAvailableColumns( _request, _options );
    }


    private async _GetAvailableEntities(request: carriers.Archive_GetAvailableEntitiesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAvailableEntities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MDOListItem[] = converters.Create_MDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Return list of all entities supported by an archive provider. See also GetArchiveConfiguration.
     * @param request - ProviderName, Context
     * @returns Array of all entity types supported by the archive provider. MDOListItem.Name = DisplayName, Tooltip = DisplayTooltip, Type = code name, StyleHint = optional/mandatory, IconHint=DefaultShow 
     */
    public async GetAvailableEntities(request: carriers.Archive_GetAvailableEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    /**
     * Return list of all entities supported by an archive provider. See also GetArchiveConfiguration.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param context - Optional context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @returns Array of all entity types supported by the archive provider. MDOListItem.Name = DisplayName, Tooltip = DisplayTooltip, Type = code name, StyleHint = optional/mandatory, IconHint=DefaultShow 
     */
    public async GetAvailableEntities(providerName: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    public async GetAvailableEntities(providerName:string|carriers.Archive_GetAvailableEntitiesRequest, context?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        let _request : carriers.Archive_GetAvailableEntitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Context)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetAvailableEntitiesRequest;
            _options = context as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Context: context as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAvailableEntities( _request, _options );
    }


    private async _GetArchiveListByColumns2(request: carriers.Archive_GetArchiveListByColumns2Request, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListByColumns2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of results for an archive list, explicitly specifying the restrictions as a string, orderby and chosen columns.
     * @param request - ProviderName, Columns, SortOrder, Restrictions, Entities, Page, PageSize
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumns2(request: carriers.Archive_GetArchiveListByColumns2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get a page of results for an archive list, explicitly specifying the restrictions as a string, orderby and chosen columns.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param columns - An array of the names of the columns wanted.
     * @param sortOrder - Sort order for the archive as string ('name asc, dept desc'). Can be null, which indicates 'no particular order'
     * @param restrictions - Archive restrictions as string ('category = 1 and business oneOf (1,2,3)'). Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumns2(providerName: string, columns: string, sortOrder: string, restrictions: string, entities: string, page: number, pageSize: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetArchiveListByColumns2(providerName:string|carriers.Archive_GetArchiveListByColumns2Request, columns?:string|base.WebApiRequestOptions, sortOrder?:string, restrictions?:string, entities?:string, page?:number, pageSize?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Archive_GetArchiveListByColumns2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restrictions)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetArchiveListByColumns2Request;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Columns: columns as string,
                       SortOrder: sortOrder as string,
                       Restrictions: restrictions as string,
                       Entities: entities as string,
                       Page: page as number,
                       PageSize: pageSize as number,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListByColumns2( _request, _options );
    }


    private async _GetArchiveListByColumnsWithContext2(request: carriers.Archive_GetArchiveListByColumnsWithContext2Request, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListByColumnsWithContext2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of results for an archive list with context parameter, explicitly specifying the restrictions as a string, orderby and chosen columns.
     * @param request - ProviderName, Columns, SortOrder, Restriction, Entities, Page, PageSize, Context
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithContext2(request: carriers.Archive_GetArchiveListByColumnsWithContext2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get a page of results for an archive list with context parameter, explicitly specifying the restrictions as a string, orderby and chosen columns.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param columns - Comma separated names of the columns wanted.
     * @param sortOrder - Comma separated list of columns to sort order for the archive. e.g.: "name asc, dept desc, registeredBy" Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions as string. e.g. "name startsWith 'foo' and (dept = 'bar' or dept = 'baz')" Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithContext2(providerName: string, columns: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetArchiveListByColumnsWithContext2(providerName:string|carriers.Archive_GetArchiveListByColumnsWithContext2Request, columns?:string|base.WebApiRequestOptions, sortOrder?:string, restriction?:string, entities?:string, page?:number, pageSize?:number, context?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Archive_GetArchiveListByColumnsWithContext2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' || typeof(first.Context)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetArchiveListByColumnsWithContext2Request;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Columns: columns as string,
                       SortOrder: sortOrder as string,
                       Restriction: restriction as string,
                       Entities: entities as string,
                       Page: page as number,
                       PageSize: pageSize as number,
                       Context: context as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListByColumnsWithContext2( _request, _options );
    }


    private async _GetArchiveList2(request: carriers.Archive_GetArchiveList2Request, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveList2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of data for an archive using a restriction string. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
     * @param request - GuiName, ProviderName, SortOrder, Restriction, Entities, Page, PageSize
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveList2(request: carriers.Archive_GetArchiveList2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get a page of data for an archive using a restriction string. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
     * @param guiName - The GUI name of the archive list, used to retrieve the currently configured set of columns (otherwise manipulated using the ArchiveConfiguration service)
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param sortOrder - Sort order for the archive. Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions as string. e.g. "name = 'baz' or category oneOf (1,2,3)". Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveList2(guiName: string, providerName: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetArchiveList2(guiName:string|carriers.Archive_GetArchiveList2Request, providerName?:string|base.WebApiRequestOptions, sortOrder?:string, restriction?:string, entities?:string, page?:number, pageSize?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Archive_GetArchiveList2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_GetArchiveList2Request;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       SortOrder: sortOrder as string,
                       Restriction: restriction as string,
                       Entities: entities as string,
                       Page: page as number,
                       PageSize: pageSize as number,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveList2( _request, _options );
    }


    private async _GetArchiveListWithContext2(request: carriers.Archive_GetArchiveListWithContext2Request, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListWithContext2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of data for an archive using restrictions as strings, with context parameter. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
     * @param request - GuiName, ProviderName, SortOrder, Restriction, Entities, Page, PageSize, Context
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListWithContext2(request: carriers.Archive_GetArchiveListWithContext2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get a page of data for an archive using restrictions as strings, with context parameter. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
     * @param guiName - The GUI name of the archive list, used to retrieve the currently configured set of columns (otherwise manipulated using the ArchiveConfiguration service)
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param sortOrder - Sort order for the archive. e.g. "name asc, dept desc" Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions as string. e.g. "name gt 'B' or dept = 'baz'" Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @returns Array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListWithContext2(guiName: string, providerName: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetArchiveListWithContext2(guiName:string|carriers.Archive_GetArchiveListWithContext2Request, providerName?:string|base.WebApiRequestOptions, sortOrder?:string, restriction?:string, entities?:string, page?:number, pageSize?:number, context?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Archive_GetArchiveListWithContext2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = guiName;
        if( typeof( first ) === "object" && first && ( typeof(first.GuiName)!='undefined' || typeof(first.ProviderName)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' || typeof(first.Context)!='undefined' ) )
        {
            _request = guiName as carriers.Archive_GetArchiveListWithContext2Request;
            _options = providerName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GuiName: guiName as string,
                       ProviderName: providerName as string,
                       SortOrder: sortOrder as string,
                       Restriction: restriction as string,
                       Entities: entities as string,
                       Page: page as number,
                       PageSize: pageSize as number,
                       Context: context as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListWithContext2( _request, _options );
    }


    private async _GetArchiveListByColumnsWithHeader2(request: carriers.Archive_GetArchiveListByColumnsWithHeader2Request, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListByColumnsWithHeader2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListResult = converters.Create_ArchiveListResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of results for an archive list, explicitly specifying the restrictions as strings, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
     * @param request - ProviderName, Columns, SortOrder, Restriction, Entities, Page, PageSize, Options
     * @returns Header with optional row count, plus array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithHeader2(request: carriers.Archive_GetArchiveListByColumnsWithHeader2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;

    /**
     * Get a page of results for an archive list, explicitly specifying the restrictions as strings, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param columns - Comma separated string of the names of the columns wanted.
     * @param sortOrder - Comma separated string of sort order for the archive. e.g. "name asc, dept desc" Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions. e.g. "category = 2 or business oneOf (2,3,4)" Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @param options - name=value&amp;... formatted set of options. "rowcount=true" will cause the rowcount to be calculated and populated.
     * @returns Header with optional row count, plus array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithHeader2(providerName: string, columns: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, options: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;

    public async GetArchiveListByColumnsWithHeader2(providerName:string|carriers.Archive_GetArchiveListByColumnsWithHeader2Request, columns?:string|base.WebApiRequestOptions, sortOrder?:string, restriction?:string, entities?:string, page?:number, pageSize?:number, options?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult > {
        let _request : carriers.Archive_GetArchiveListByColumnsWithHeader2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' || typeof(first.Options)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetArchiveListByColumnsWithHeader2Request;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Columns: columns as string,
                       SortOrder: sortOrder as string,
                       Restriction: restriction as string,
                       Entities: entities as string,
                       Page: page as number,
                       PageSize: pageSize as number,
                       Options: options as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListByColumnsWithHeader2( _request, _options );
    }


    private async _GetArchiveListByColumnsWithHeaderWithContext2(request: carriers.Archive_GetArchiveListByColumnsWithHeaderWithContext2Request, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetArchiveListByColumnsWithHeaderWithContext2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListResult = converters.Create_ArchiveListResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a page of results for an archive list, with context parameter, explicitly specifying the restrictions as strings, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
     * @param request - ProviderName, Columns, SortOrder, Restriction, Entities, Page, PageSize, Options, Context
     * @returns Header with optional row count, plus array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithHeaderWithContext2(request: carriers.Archive_GetArchiveListByColumnsWithHeaderWithContext2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;

    /**
     * Get a page of results for an archive list, with context parameter, explicitly specifying the restrictions as strings, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param columns - Comma separated list of the names of the columns wanted.
     * @param sortOrder - Sort order for the archive. "name asc, dept desc" Can be null, which indicates 'no particular order'
     * @param restriction - Archive restrictions as string. "updated > '2009.1.1' and registeredBy = 2" Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     * @param entities - Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     * @param page - Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     * @param pageSize - Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     * @param options - name=value&amp;... formatted set of options. "rowcount=true" will cause the rowcount to be calculated and populated.
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @returns Header with optional row count, plus array of archive list items, where each item represents one row of data (row level data + the requested columns)
     */
    public async GetArchiveListByColumnsWithHeaderWithContext2(providerName: string, columns: string, sortOrder: string, restriction: string, entities: string, page: number, pageSize: number, options: string, context: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult >;

    public async GetArchiveListByColumnsWithHeaderWithContext2(providerName:string|carriers.Archive_GetArchiveListByColumnsWithHeaderWithContext2Request, columns?:string|base.WebApiRequestOptions, sortOrder?:string, restriction?:string, entities?:string, page?:number, pageSize?:number, options?:string, context?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListResult > {
        let _request : carriers.Archive_GetArchiveListByColumnsWithHeaderWithContext2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restriction)!='undefined' || typeof(first.Entities)!='undefined' || typeof(first.Page)!='undefined' || typeof(first.PageSize)!='undefined' || typeof(first.Options)!='undefined' || typeof(first.Context)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_GetArchiveListByColumnsWithHeaderWithContext2Request;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Columns: columns as string,
                       SortOrder: sortOrder as string,
                       Restriction: restriction as string,
                       Entities: entities as string,
                       Page: page as number,
                       PageSize: pageSize as number,
                       Options: options as string,
                       Context: context as string,
                       };   
            _options = webapi_options;
        }
        return this._GetArchiveListByColumnsWithHeaderWithContext2( _request, _options );
    }


    private async _ExportArchive(request: carriers.Archive_ExportArchiveRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ExportArchiveResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ExportArchiveResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExportArchive", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ExportArchiveResult = converters.Create_ExportArchiveResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Exports the target archive to a downloadable format.
     * @param request - ProviderName, Context, DesiredEntities, Columns, SortOrder, Restrictions, ExportType, SelectedRowIds, EstimatedRowCount
     * @returns 
     */
    public async ExportArchive(request: carriers.Archive_ExportArchiveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ExportArchiveResult >;

    /**
     * Exports the target archive to a downloadable format.
     * @param providerName - The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     * @param context - Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     * @param desiredEntities - Comma separated list of the names of the desired entities.
     * @param columns - Comma separated list of the names of the columns wanted; supports display names
     * @param sortOrder - 
     * @param restrictions - 
     * @param exportType - To what format the archive should be exported; Excel, etc.
     * @param selectedRowIds - 
     * @param estimatedRowCount - The estimated amount of rows to be exported. Used to determine if the operation should be run as a batch task or immediately.
     * @returns 
     */
    public async ExportArchive(providerName: string, context: string, desiredEntities: string[], columns: string[], sortOrder: carriers.ArchiveOrderByInfo[], restrictions: carriers.ArchiveRestrictionInfo[], exportType: string, selectedRowIds: string[], estimatedRowCount: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ExportArchiveResult >;

    public async ExportArchive(providerName:string|carriers.Archive_ExportArchiveRequest, context?:string|base.WebApiRequestOptions, desiredEntities?:string[], columns?:string[], sortOrder?:carriers.ArchiveOrderByInfo[], restrictions?:carriers.ArchiveRestrictionInfo[], exportType?:string, selectedRowIds?:string[], estimatedRowCount?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ExportArchiveResult > {
        let _request : carriers.Archive_ExportArchiveRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Context)!='undefined' || typeof(first.DesiredEntities)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.SortOrder)!='undefined' || typeof(first.Restrictions)!='undefined' || typeof(first.ExportType)!='undefined' || typeof(first.SelectedRowIds)!='undefined' || typeof(first.EstimatedRowCount)!='undefined' ) )
        {
            _request = providerName as carriers.Archive_ExportArchiveRequest;
            _options = context as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Context: context as string,
                       DesiredEntities: desiredEntities as string[],
                       Columns: columns as string[],
                       SortOrder: sortOrder as carriers.ArchiveOrderByInfo[],
                       Restrictions: restrictions as carriers.ArchiveRestrictionInfo[],
                       ExportType: exportType as string,
                       SelectedRowIds: selectedRowIds as string[],
                       EstimatedRowCount: estimatedRowCount as number,
                       };   
            _options = webapi_options;
        }
        return this._ExportArchive( _request, _options );
    }


    private async _GetRelatedData(request: carriers.Archive_GetRelatedDataRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RelatedData[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRelatedData", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RelatedData[] = converters.Create_RelatedDataArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get data for fields related to a table record. While this method /can/ be used to fetch plain fields, that is not the intended usage and it does not replace the Entity.Get methods available for that purpose. Nor does it replace the generic DotSyntax/Dynamic archive provider.
     * @param request - Table, RecordId, Fields
     * @returns Array of field => ArchiveColumnData objects
     */
    public async GetRelatedData(request: carriers.Archive_GetRelatedDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] >;

    /**
     * Get data for fields related to a table record. While this method /can/ be used to fetch plain fields, that is not the intended usage and it does not replace the Entity.Get methods available for that purpose. Nor does it replace the generic DotSyntax/Dynamic archive provider.
     * @param table - The root table to get related data for, such as 'ticket' or 'y_car'
     * @param recordId - The primary key of the root table to get related data for
     * @param fields - Names of fields - these need to be valid in the DotSyntax for this table, and can be arbitrarily deep. Examples: 'title', 'created_by.associate_id.person.fullName', 'x_comment'. Do not start with the root table name.
     * @returns Array of field => ArchiveColumnData objects
     */
    public async GetRelatedData(table: string, recordId: number, fields: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] >;

    public async GetRelatedData(table:string|carriers.Archive_GetRelatedDataRequest, recordId?:number|base.WebApiRequestOptions, fields?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] > {
        let _request : carriers.Archive_GetRelatedDataRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = table;
        if( typeof( first ) === "object" && first && ( typeof(first.Table)!='undefined' || typeof(first.RecordId)!='undefined' || typeof(first.Fields)!='undefined' ) )
        {
            _request = table as carriers.Archive_GetRelatedDataRequest;
            _options = recordId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Table: table as string,
                       RecordId: recordId as number,
                       Fields: fields as string[],
                       };   
            _options = webapi_options;
        }
        return this._GetRelatedData( _request, _options );
    }


    private async _GetRelatedData2(request: carriers.Archive_GetRelatedData2Request, options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RelatedData[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRelatedData2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RelatedData[] = converters.Create_RelatedDataArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get data for fields related to a table record. While this method /can/ be used to fetch plain fields, that is not the intended usage and it does not replace the Entity.Get methods available for that purpose. Nor does it replace the generic DotSyntax/Dynamic archive provider.
     * @param request - Table, RecordId, Fields
     * @returns Array of field => ArchiveColumnData objects
     */
    public async GetRelatedData2(request: carriers.Archive_GetRelatedData2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] >;

    /**
     * Get data for fields related to a table record. While this method /can/ be used to fetch plain fields, that is not the intended usage and it does not replace the Entity.Get methods available for that purpose. Nor does it replace the generic DotSyntax/Dynamic archive provider.
     * @param table - The root table to get related data for, such as 'ticket' or 'y_car'
     * @param recordId - The primary key of the root table to get related data for
     * @param fields - Names of fields as a comma-separated list - these need to be valid in the DotSyntax for this table, and can be arbitrarily deep. Example: 'title,created_by.associate_id.person.fullName, x_comment'. Do not start with the root table name.
     * @returns Array of field => ArchiveColumnData objects
     */
    public async GetRelatedData2(table: string, recordId: number, fields: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] >;

    public async GetRelatedData2(table:string|carriers.Archive_GetRelatedData2Request, recordId?:number|base.WebApiRequestOptions, fields?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RelatedData[] > {
        let _request : carriers.Archive_GetRelatedData2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = table;
        if( typeof( first ) === "object" && first && ( typeof(first.Table)!='undefined' || typeof(first.RecordId)!='undefined' || typeof(first.Fields)!='undefined' ) )
        {
            _request = table as carriers.Archive_GetRelatedData2Request;
            _options = recordId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Table: table as string,
                       RecordId: recordId as number,
                       Fields: fields as string,
                       };   
            _options = webapi_options;
        }
        return this._GetRelatedData2( _request, _options );
    }

    } // class v1ArchiveAgentController 



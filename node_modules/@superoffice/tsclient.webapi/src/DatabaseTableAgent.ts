// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/DatabaseTableAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Agent used for CRUD operations on database tables. Read, add, update, delete rows in tables.
 */
export interface IDatabaseTableAgent {
    ReadRow(request: carriers.DatabaseTable_ReadRowRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRecord >;
    ReadRow(tableName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRecord >;
    InsertRow(request: carriers.DatabaseTable_InsertRowRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    InsertRow(tableName: string, values: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    UpdateRow(request: carriers.DatabaseTable_UpdateRowRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    UpdateRow(tableName: string, id: number, values: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteRow(request: carriers.DatabaseTable_DeleteRowRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteRow(tableName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Insert(request: carriers.DatabaseTable_InsertRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;
    Insert(tableName: string, columns: string[], data: string[][], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;
    Truncate(request: carriers.DatabaseTable_TruncateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;
    Truncate(tableName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;
    Upsert(request: carriers.DatabaseTable_UpsertRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;
    Upsert(tableName: string, columns: string[], keys: string[], data: string[][], nomatchAction: enums.UpsertNomatchAction, returnRowStatus: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;
    Delete(request: carriers.DatabaseTable_DeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;
    Delete(tableName: string, iDs: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;
} // interface IDatabaseTableAgent




/**
 * Agent used for CRUD operations on database tables. Read, add, update, delete rows in tables.
 */
export class DatabaseTableAgent extends base.WebApiBase implements IDatabaseTableAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/DatabaseTable/";
        super(options);
    }



    private async _ReadRow(request: carriers.DatabaseTable_ReadRowRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TableRecord > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TableRecord >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ReadRow", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TableRecord = converters.Create_TableRecord_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Read a row from a table
     * @param request - TableName, Id
     * @returns The row from the table
     */
    public async ReadRow(request: carriers.DatabaseTable_ReadRowRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRecord >;

    /**
     * Read a row from a table
     * @param tableName - The name of the table to fetch; in the current release this must be an 'extratable'. Use the database name, on the form y_aTable
     * @param id - The id of the row to fetch
     * @returns The row from the table
     */
    public async ReadRow(tableName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRecord >;

    public async ReadRow(tableName:string|carriers.DatabaseTable_ReadRowRequest, id?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRecord > {
        let _request : carriers.DatabaseTable_ReadRowRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.Id)!='undefined' ) )
        {
            _request = tableName as carriers.DatabaseTable_ReadRowRequest;
            _options = id as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._ReadRow( _request, _options );
    }


    private async _InsertRow(request: carriers.DatabaseTable_InsertRowRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("InsertRow", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Insert a row into a table
     * @param request - TableName, Values
     * @returns The id of the newly inserted row
     */
    public async InsertRow(request: carriers.DatabaseTable_InsertRowRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Insert a row into a table
     * @param tableName - The name of the table to insert into; in the current release this must be an 'extratable'. Use the database name, on the form y_aTable
     * @param values - A StringDictionary with the values to insert. You do not need to specify all the values in the table. The omitted ones will get default values
     * @returns The id of the newly inserted row
     */
    public async InsertRow(tableName: string, values: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async InsertRow(tableName:string|carriers.DatabaseTable_InsertRowRequest, values?:carriers.StringDictionary|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.DatabaseTable_InsertRowRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.Values)!='undefined' ) )
        {
            _request = tableName as carriers.DatabaseTable_InsertRowRequest;
            _options = values as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       Values: values as carriers.StringDictionary,
                       };   
            _options = webapi_options;
        }
        return this._InsertRow( _request, _options );
    }


    private async _UpdateRow(request: carriers.DatabaseTable_UpdateRowRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateRow", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update a row in a table
     * @param request - TableName, Id, Values
     * @returns 
     */
    public async UpdateRow(request: carriers.DatabaseTable_UpdateRowRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Update a row in a table
     * @param tableName - The name of the table to update; in the current release this must be an 'extratable'. Use the database name, on the form y_aTable
     * @param id - The id of the row to update
     * @param values - A StringDictionary with the values to update. You do not need to specify all the values in the table. The omitted ones will remain unchanged
     * @returns 
     */
    public async UpdateRow(tableName: string, id: number, values: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async UpdateRow(tableName:string|carriers.DatabaseTable_UpdateRowRequest, id?:number|base.WebApiRequestOptions, values?:carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.DatabaseTable_UpdateRowRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.Id)!='undefined' || typeof(first.Values)!='undefined' ) )
        {
            _request = tableName as carriers.DatabaseTable_UpdateRowRequest;
            _options = id as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       Id: id as number,
                       Values: values as carriers.StringDictionary,
                       };   
            _options = webapi_options;
        }
        return this._UpdateRow( _request, _options );
    }


    private async _DeleteRow(request: carriers.DatabaseTable_DeleteRowRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteRow", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a row from a table
     * @param request - TableName, Id
     * @returns 
     */
    public async DeleteRow(request: carriers.DatabaseTable_DeleteRowRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a row from a table
     * @param tableName - The name of the table to delete from; in the current release this must be an 'extratable'. Use the database name, on the form y_aTable
     * @param id - The id of the row to delete
     * @returns 
     */
    public async DeleteRow(tableName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteRow(tableName:string|carriers.DatabaseTable_DeleteRowRequest, id?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.DatabaseTable_DeleteRowRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.Id)!='undefined' ) )
        {
            _request = tableName as carriers.DatabaseTable_DeleteRowRequest;
            _options = id as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteRow( _request, _options );
    }


    private async _Insert(request: carriers.DatabaseTable_InsertRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MassOperationResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Insert", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MassOperationResult = converters.Create_MassOperationResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Mass-insert rows, with or without primary keys specified. Works on physical tables with no special processing for udef etc.; traveltransactionlog and WebHooks are supported
     * @param request - TableName, Columns, Data
     * @returns Summary of results
     */
    public async Insert(request: carriers.DatabaseTable_InsertRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;

    /**
     * Mass-insert rows, with or without primary keys specified. Works on physical tables with no special processing for udef etc.; traveltransactionlog and WebHooks are supported
     * @param tableName - The name of the table where rows should be inserted
     * @param columns - List of column names, in the same order as in the Data parameter
     * @param data - Outer array = rows, inner = columns in specified order; use CultureDataFormatter to format values that aren't string or int
     * @returns Summary of results
     */
    public async Insert(tableName: string, columns: string[], data: string[][], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;

    public async Insert(tableName:string|carriers.DatabaseTable_InsertRequest, columns?:string[]|base.WebApiRequestOptions, data?:string[][], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult > {
        let _request : carriers.DatabaseTable_InsertRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.Data)!='undefined' ) )
        {
            _request = tableName as carriers.DatabaseTable_InsertRequest;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       Columns: columns as string[],
                       Data: data as string[][],
                       };   
            _options = webapi_options;
        }
        return this._Insert( _request, _options );
    }


    private async _Truncate(request: carriers.DatabaseTable_TruncateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MassOperationResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Truncate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MassOperationResult = converters.Create_MassOperationResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Drop all rows in a table. This clearance is not individually logged in TravelTransactionlog or Webhook/script calls
     * @param request - TableName
     * @returns Summary of results
     */
    public async Truncate(request: carriers.DatabaseTable_TruncateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;

    /**
     * Drop all rows in a table. This clearance is not individually logged in TravelTransactionlog or Webhook/script calls
     * @param tableName - Name of table to be truncated
     * @returns Summary of results
     */
    public async Truncate(tableName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;

    public async Truncate(tableName:string|carriers.DatabaseTable_TruncateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult > {
        let _request : carriers.DatabaseTable_TruncateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' ) )
        {
            _request = tableName as carriers.DatabaseTable_TruncateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       };   
            _options = webapi_options;
        }
        return this._Truncate( _request, _options );
    }


    private async _Upsert(request: carriers.DatabaseTable_UpsertRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MassOperationResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Upsert", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MassOperationResult = converters.Create_MassOperationResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Insert or update rows, optionally deleting/zeroing &apos;leftover&apos; rows. Special support for UDEF, as well as optional extensive information return. Traveltransactionlog and WebHooks are supported
     * @param request - TableName, Columns, Keys, Data, NomatchAction, ReturnRowStatus
     * @returns Summary of results
     */
    public async Upsert(request: carriers.DatabaseTable_UpsertRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;

    /**
     * Insert or update rows, optionally deleting/zeroing &apos;leftover&apos; rows. Special support for UDEF, as well as optional extensive information return. Traveltransactionlog and WebHooks are supported
     * @param tableName - The name of the table where rows should be inserted or updated
     * @param columns - List of column names, in the same order as in the data
     * @param keys - List of columns that are to be used as keys, to match any existing rows
     * @param data - Outer array = row, inner = column in specified order; use CultureDataFormatter to format values
     * @param nomatchAction - Action to take on rows in the target table, that are not matched by any rows in the incoming data. Use the deletion options with care. NEVER use deletion if your Upsert is so large you need to divide it into multiple batches.
     * @param returnRowStatus - If true, then the 'RowStatus' member of the return carrier will be populated with a per-row status, for each incoming row
     * @returns Summary of results
     */
    public async Upsert(tableName: string, columns: string[], keys: string[], data: string[][], nomatchAction: enums.UpsertNomatchAction, returnRowStatus: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;

    public async Upsert(tableName:string|carriers.DatabaseTable_UpsertRequest, columns?:string[]|base.WebApiRequestOptions, keys?:string[], data?:string[][], nomatchAction?:enums.UpsertNomatchAction, returnRowStatus?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult > {
        let _request : carriers.DatabaseTable_UpsertRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.Columns)!='undefined' || typeof(first.Keys)!='undefined' || typeof(first.Data)!='undefined' || typeof(first.NomatchAction)!='undefined' || typeof(first.ReturnRowStatus)!='undefined' ) )
        {
            _request = tableName as carriers.DatabaseTable_UpsertRequest;
            _options = columns as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       Columns: columns as string[],
                       Keys: keys as string[],
                       Data: data as string[][],
                       NomatchAction: nomatchAction as enums.UpsertNomatchAction,
                       ReturnRowStatus: returnRowStatus as boolean,
                       };   
            _options = webapi_options;
        }
        return this._Upsert( _request, _options );
    }


    private async _Delete(request: carriers.DatabaseTable_DeleteRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MassOperationResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Delete", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MassOperationResult = converters.Create_MassOperationResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete rows, by primary key; traveltransactionlog and WebHooks are supported
     * @param request - TableName, IDs
     * @returns Summary of results
     */
    public async Delete(request: carriers.DatabaseTable_DeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;

    /**
     * Delete rows, by primary key; traveltransactionlog and WebHooks are supported
     * @param tableName - The name of the table where rows should be deleted
     * @param iDs - Primary keys of the rows to be deleted
     * @returns Summary of results
     */
    public async Delete(tableName: string, iDs: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult >;

    public async Delete(tableName:string|carriers.DatabaseTable_DeleteRequest, iDs?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MassOperationResult > {
        let _request : carriers.DatabaseTable_DeleteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.IDs)!='undefined' ) )
        {
            _request = tableName as carriers.DatabaseTable_DeleteRequest;
            _options = iDs as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       IDs: iDs as number[],
                       };   
            _options = webapi_options;
        }
        return this._Delete( _request, _options );
    }

    } // class v1DatabaseTableAgentController 



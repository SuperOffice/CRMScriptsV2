// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/AIAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * AI services, such as Translation, Statistics, Sentiment analysis, backed by calls to Public Cloud providers
 */
export interface IAIAgent {
    GetTrainingStatus(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CategorizationStatusResponse >;
    GuessCategory(request: carriers.AI_GuessCategoryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GuessCategory(ticketId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    TrainCategoryGuesser(request: carriers.AI_TrainCategoryGuesserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    TrainCategoryGuesser(selectionId: number, maxItems: number, maxTextLength: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    DetectLanguage(request: carriers.AI_DetectLanguageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    DetectLanguage(text: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    DetectSentiment(request: carriers.AI_DetectSentimentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sentiment >;
    DetectSentiment(text: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sentiment >;
    Translate(request: carriers.AI_TranslateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    Translate(text: string, targetLanguage: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    TranslateEntity(request: carriers.AI_TranslateEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    TranslateEntity(entityName: string, entityId: number, targetLanguage: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
} // interface IAIAgent




/**
 * AI services, such as Translation, Statistics, Sentiment analysis, backed by calls to Public Cloud providers
 */
export class AIAgent extends base.WebApiBase implements IAIAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/AI/";
        super(options);
    }



    private async _GetTrainingStatus( options?:base.WebApiRequestOptions) : Promise< carriers.CategorizationStatusResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CategorizationStatusResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTrainingStatus", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CategorizationStatusResponse = converters.Create_CategorizationStatusResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Calling the HugoAI endpoint to fetch the current training status.
     * @returns Carrier to describe the current status of HugoAI categorization
     */
    public async GetTrainingStatus(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CategorizationStatusResponse >
    {
        return this._GetTrainingStatus(webapi_options);
    }


    private async _GuessCategory(request: carriers.AI_GuessCategoryRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GuessCategory", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Given a ticket&apos;s id, guess the ticket category it should be placed in. Currently this is based on the first message in the ticket
     * @param request - TicketId
     * @returns Suggested ticket category ID
     */
    public async GuessCategory(request: carriers.AI_GuessCategoryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Given a ticket&apos;s id, guess the ticket category it should be placed in. Currently this is based on the first message in the ticket
     * @param ticketId - Id of ticket to guess category for
     * @returns Suggested ticket category ID
     */
    public async GuessCategory(ticketId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async GuessCategory(ticketId:number|carriers.AI_GuessCategoryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.AI_GuessCategoryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketId)!='undefined' ) )
        {
            _request = ticketId as carriers.AI_GuessCategoryRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketId: ticketId as number,
                       };   
            _options = webapi_options;
        }
        return this._GuessCategory( _request, _options );
    }


    private async _TrainCategoryGuesser(request: carriers.AI_TrainCategoryGuesserRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TrainCategoryGuesser", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * The category guesser training API will be called with an array of CategorizationTrainingItem during the (background, Batch) execution of this call
     * @param request - SelectionId, MaxItems, MaxTextLength
     * @returns Placeholder for result...  should this be a BatchTaskId?  maybe not useful?
     */
    public async TrainCategoryGuesser(request: carriers.AI_TrainCategoryGuesserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * The category guesser training API will be called with an array of CategorizationTrainingItem during the (background, Batch) execution of this call
     * @param selectionId - Id of selection of tickets, to retrieve training data from
     * @param maxItems - Maximum number of tickets to retrieve data from
     * @param maxTextLength - Maximum length of PlainTextBody or any other large text, truncated to nearest word boundary
     * @returns Placeholder for result...  should this be a BatchTaskId?  maybe not useful?
     */
    public async TrainCategoryGuesser(selectionId: number, maxItems: number, maxTextLength: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async TrainCategoryGuesser(selectionId:number|carriers.AI_TrainCategoryGuesserRequest, maxItems?:number|base.WebApiRequestOptions, maxTextLength?:number, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.AI_TrainCategoryGuesserRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.MaxItems)!='undefined' || typeof(first.MaxTextLength)!='undefined' ) )
        {
            _request = selectionId as carriers.AI_TrainCategoryGuesserRequest;
            _options = maxItems as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       MaxItems: maxItems as number,
                       MaxTextLength: maxTextLength as number,
                       };   
            _options = webapi_options;
        }
        return this._TrainCategoryGuesser( _request, _options );
    }


    private async _DetectLanguage(request: carriers.AI_DetectLanguageRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DetectLanguage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Given a (reasonably short) text, detect the language it is written in
     * @param request - Text
     * @returns ISO Language code, such as NO, US, ES, FR
     */
    public async DetectLanguage(request: carriers.AI_DetectLanguageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Given a (reasonably short) text, detect the language it is written in
     * @param text - Text to be analyzed; there may be a cost-per-character so do not send a book here
     * @returns ISO Language code, such as NO, US, ES, FR
     */
    public async DetectLanguage(text: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async DetectLanguage(text:string|carriers.AI_DetectLanguageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.AI_DetectLanguageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = text;
        if( typeof( first ) === "object" && first && ( typeof(first.Text)!='undefined' ) )
        {
            _request = text as carriers.AI_DetectLanguageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Text: text as string,
                       };   
            _options = webapi_options;
        }
        return this._DetectLanguage( _request, _options );
    }


    private async _DetectSentiment(request: carriers.AI_DetectSentimentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Sentiment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sentiment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DetectSentiment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Sentiment = converters.Create_Sentiment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Detect the sentiment of a (reasonably short) text. Sentiment analysis may cause a translation to be made, since sentiment analysis only supports a limited set of languages
     * @param request - Text
     * @returns The sentiment information: score (-100 to +100) and confidence
     */
    public async DetectSentiment(request: carriers.AI_DetectSentimentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sentiment >;

    /**
     * Detect the sentiment of a (reasonably short) text. Sentiment analysis may cause a translation to be made, since sentiment analysis only supports a limited set of languages
     * @param text - Text to be analyzed
     * @returns The sentiment information: score (-100 to +100) and confidence
     */
    public async DetectSentiment(text: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sentiment >;

    public async DetectSentiment(text:string|carriers.AI_DetectSentimentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sentiment > {
        let _request : carriers.AI_DetectSentimentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = text;
        if( typeof( first ) === "object" && first && ( typeof(first.Text)!='undefined' ) )
        {
            _request = text as carriers.AI_DetectSentimentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Text: text as string,
                       };   
            _options = webapi_options;
        }
        return this._DetectSentiment( _request, _options );
    }


    private async _Translate(request: carriers.AI_TranslateRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Translate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Translate a text from one language to another. Language of the text is automatically detected.
     * @param request - Text, TargetLanguage
     * @returns Translated text
     */
    public async Translate(request: carriers.AI_TranslateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Translate a text from one language to another. Language of the text is automatically detected.
     * @param text - Text to be translated. Language of the text is automatically detected.
     * @param targetLanguage - ISO Language code (such as FR) to translate the text into
     * @returns Translated text
     */
    public async Translate(text: string, targetLanguage: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async Translate(text:string|carriers.AI_TranslateRequest, targetLanguage?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.AI_TranslateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = text;
        if( typeof( first ) === "object" && first && ( typeof(first.Text)!='undefined' || typeof(first.TargetLanguage)!='undefined' ) )
        {
            _request = text as carriers.AI_TranslateRequest;
            _options = targetLanguage as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Text: text as string,
                       TargetLanguage: targetLanguage as string,
                       };   
            _options = webapi_options;
        }
        return this._Translate( _request, _options );
    }


    private async _TranslateEntity(request: carriers.AI_TranslateEntityRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TranslateEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve, format and translate text for an entity to a specified language
     * @param request - EntityName, EntityId, TargetLanguage
     * @returns Translated text
     */
    public async TranslateEntity(request: carriers.AI_TranslateEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Retrieve, format and translate text for an entity to a specified language
     * @param entityName - Name of entity to get the text to be translated; eg., 'ticketMessage'
     * @param entityId - Identifier for the entity to get text to be translated
     * @param targetLanguage - ISO Language code (such as FR) to translate the text into
     * @returns Translated text
     */
    public async TranslateEntity(entityName: string, entityId: number, targetLanguage: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async TranslateEntity(entityName:string|carriers.AI_TranslateEntityRequest, entityId?:number|base.WebApiRequestOptions, targetLanguage?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.AI_TranslateEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = entityName;
        if( typeof( first ) === "object" && first && ( typeof(first.EntityName)!='undefined' || typeof(first.EntityId)!='undefined' || typeof(first.TargetLanguage)!='undefined' ) )
        {
            _request = entityName as carriers.AI_TranslateEntityRequest;
            _options = entityId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EntityName: entityName as string,
                       EntityId: entityId as number,
                       TargetLanguage: targetLanguage as string,
                       };   
            _options = webapi_options;
        }
        return this._TranslateEntity( _request, _options );
    }

    } // class v1AIAgentController 



// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/ReportAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Run reports, set favourites, labels
 */
export interface IReportAgent {
    CreateDefaultReportEntity(): Promise< carriers.ReportEntity >;
    SaveReportEntity(entity: carriers.ReportEntity) : Promise< carriers.ReportEntity >;
    CreateDefaultReportLabelLayoutEntity(): Promise< carriers.ReportLabelLayoutEntity >;
    SaveReportLabelLayoutEntity(entity: carriers.ReportLabelLayoutEntity) : Promise< carriers.ReportLabelLayoutEntity >;
    DeleteReportLabelLayoutEntity(ReportLabelLayoutEntityId: number) : Promise<void>;
    GetReportEntity(reportEntityId: number) :  Promise< carriers.ReportEntity >;
    CreateFavorite(request: carriers.Report_CreateFavoriteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity >;
    CreateFavorite(sourceId: number, name: string, description: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity >;
    DeleteFavorite(request: carriers.Report_DeleteFavoriteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteFavorite(reportEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    UpdateFavorite(request: carriers.Report_UpdateFavoriteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity >;
    UpdateFavorite(reportEntity: carriers.ReportEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity >;
    GenerateReport(request: carriers.Report_GenerateReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GenerateReport(reportId: number, labelLayoutId: number, filename: string, language: string, fileType: string, restrictions: carriers.ArchiveRestrictionInfo[], webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    ImportReport(request: carriers.Report_ImportReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    ImportReport(report: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    DeleteReport(request: carriers.Report_DeleteReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    DeleteReport(reportId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetReportLabelLayoutEntity(reportLabelLayoutEntityId: number) :  Promise< carriers.ReportLabelLayoutEntity >;
} // interface IReportAgent




/**
 * Run reports, set favourites, labels
 */
export class ReportAgent extends base.WebApiBase implements IReportAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Report/";
        super(options);
    }



    /**
     * Set default values into a new ReportEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultReportEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReportEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultReportEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReportEntity = converters.Create_ReportEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ReportEntity or creates a new ReportEntity if the id parameter is empty
     * @param entity - The ReportEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ReportEntity
     */
    public async SaveReportEntity(entity: carriers.ReportEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReportEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveReportEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReportEntity = converters.Create_ReportEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ReportLabelLayoutEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultReportLabelLayoutEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ReportLabelLayoutEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReportLabelLayoutEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultReportLabelLayoutEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReportLabelLayoutEntity = converters.Create_ReportLabelLayoutEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ReportLabelLayoutEntity or creates a new ReportLabelLayoutEntity if the id parameter is empty
     * @param entity - The ReportLabelLayoutEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ReportLabelLayoutEntity
     */
    public async SaveReportLabelLayoutEntity(entity: carriers.ReportLabelLayoutEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ReportLabelLayoutEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReportLabelLayoutEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveReportLabelLayoutEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReportLabelLayoutEntity = converters.Create_ReportLabelLayoutEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ReportLabelLayoutEntity
     * @param ReportLabelLayoutEntityId - The id of the ReportLabelLayoutEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteReportLabelLayoutEntity(ReportLabelLayoutEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteReportLabelLayoutEntity?ReportLabelLayoutEntityId=" + ReportLabelLayoutEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ReportEntity object.
     * @param reportEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ReportEntity
     */
    public async GetReportEntity(reportEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReportEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReportEntity?reportEntityId=" + reportEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReportEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _CreateFavorite(request: carriers.Report_CreateFavoriteRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReportEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateFavorite", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReportEntity = converters.Create_ReportEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates the report as favorite. The sourceId is the key to the report that the favorite is based on.
     * @param request - SourceId, Name, Description
     * @returns The new favorite ReportEntity.
     */
    public async CreateFavorite(request: carriers.Report_CreateFavoriteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity >;

    /**
     * Creates the report as favorite. The sourceId is the key to the report that the favorite is based on.
     * @param sourceId - The primary key to the report to make the favorite from.
     * @param name - The name of the new favorite.
     * @param description - The description of the new favorite.
     * @returns The new favorite ReportEntity.
     */
    public async CreateFavorite(sourceId: number, name: string, description: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity >;

    public async CreateFavorite(sourceId:number|carriers.Report_CreateFavoriteRequest, name?:string|base.WebApiRequestOptions, description?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity > {
        let _request : carriers.Report_CreateFavoriteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceId;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceId)!='undefined' || typeof(first.Name)!='undefined' || typeof(first.Description)!='undefined' ) )
        {
            _request = sourceId as carriers.Report_CreateFavoriteRequest;
            _options = name as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceId: sourceId as number,
                       Name: name as string,
                       Description: description as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateFavorite( _request, _options );
    }


    private async _DeleteFavorite(request: carriers.Report_DeleteFavoriteRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteFavorite", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes the report favorite.
     * @param request - ReportEntityId
     * @returns 
     */
    public async DeleteFavorite(request: carriers.Report_DeleteFavoriteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes the report favorite.
     * @param reportEntityId - The id of the report favorite to delete.
     * @returns 
     */
    public async DeleteFavorite(reportEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteFavorite(reportEntityId:number|carriers.Report_DeleteFavoriteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Report_DeleteFavoriteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = reportEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.ReportEntityId)!='undefined' ) )
        {
            _request = reportEntityId as carriers.Report_DeleteFavoriteRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ReportEntityId: reportEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteFavorite( _request, _options );
    }


    private async _UpdateFavorite(request: carriers.Report_UpdateFavoriteRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReportEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateFavorite", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReportEntity = converters.Create_ReportEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Updates the favorite.
     * @param request - ReportEntity
     * @returns The updated ReportEntity carrier.
     */
    public async UpdateFavorite(request: carriers.Report_UpdateFavoriteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity >;

    /**
     * Updates the favorite.
     * @param reportEntity - ReportEntity carrier containg updated data.
     * @returns The updated ReportEntity carrier.
     */
    public async UpdateFavorite(reportEntity: carriers.ReportEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity >;

    public async UpdateFavorite(reportEntity:carriers.ReportEntity|carriers.Report_UpdateFavoriteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReportEntity > {
        let _request : carriers.Report_UpdateFavoriteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = reportEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.ReportEntity)!='undefined' ) )
        {
            _request = reportEntity as carriers.Report_UpdateFavoriteRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ReportEntity: reportEntity as carriers.ReportEntity,
                       };   
            _options = webapi_options;
        }
        return this._UpdateFavorite( _request, _options );
    }


    private async _GenerateReport(request: carriers.Report_GenerateReportRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateReport", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Generates the report in PDF format
     * @param request - ReportId, LabelLayoutId, Filename, Language, FileType, Restrictions
     * @returns Batch task id, as string. Used to be path to the generated report, but no more.
     */
    public async GenerateReport(request: carriers.Report_GenerateReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Generates the report in PDF format
     * @param reportId - The id of the report.
     * @param labelLayoutId - The id of the labellayout. Use 0 if the report isn't of type label.
     * @param filename - Filename of the report.
     * @param language - Language to use when generating the report.
     * @param fileType - 
     * @param restrictions - Use restrictions to provide additional restrictions when generating the report.
     * @returns Batch task id, as string. Used to be path to the generated report, but no more.
     */
    public async GenerateReport(reportId: number, labelLayoutId: number, filename: string, language: string, fileType: string, restrictions: carriers.ArchiveRestrictionInfo[], webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GenerateReport(reportId:number|carriers.Report_GenerateReportRequest, labelLayoutId?:number|base.WebApiRequestOptions, filename?:string, language?:string, fileType?:string, restrictions?:carriers.ArchiveRestrictionInfo[], webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Report_GenerateReportRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = reportId;
        if( typeof( first ) === "object" && first && ( typeof(first.ReportId)!='undefined' || typeof(first.LabelLayoutId)!='undefined' || typeof(first.Filename)!='undefined' || typeof(first.Language)!='undefined' || typeof(first.FileType)!='undefined' || typeof(first.Restrictions)!='undefined' ) )
        {
            _request = reportId as carriers.Report_GenerateReportRequest;
            _options = labelLayoutId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ReportId: reportId as number,
                       LabelLayoutId: labelLayoutId as number,
                       Filename: filename as string,
                       Language: language as string,
                       FileType: fileType as string,
                       Restrictions: restrictions as carriers.ArchiveRestrictionInfo[],
                       };   
            _options = webapi_options;
        }
        return this._GenerateReport( _request, _options );
    }


    private async _ImportReport(request: carriers.Report_ImportReportRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ImportReport", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Takes the input stream and create a report. This stream must be on a valid xml format
     * @param request - Report
     * @returns The id of the newly imported report
     */
    public async ImportReport(request: carriers.Report_ImportReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Takes the input stream and create a report. This stream must be on a valid xml format
     * @param report - The report to import in a correct xml format
     * @returns The id of the newly imported report
     */
    public async ImportReport(report: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async ImportReport(report:string|carriers.Report_ImportReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Report_ImportReportRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = report;
        if( typeof( first ) === "object" && first && ( typeof(first.Report)!='undefined' ) )
        {
            _request = report as carriers.Report_ImportReportRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Report: report as string,
                       };   
            _options = webapi_options;
        }
        return this._ImportReport( _request, _options );
    }


    private async _DeleteReport(request: carriers.Report_DeleteReportRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteReport", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete the report with the given id
     * @param request - ReportId
     * @returns Delete ok?
     */
    public async DeleteReport(request: carriers.Report_DeleteReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Delete the report with the given id
     * @param reportId - The id of the report to delete
     * @returns Delete ok?
     */
    public async DeleteReport(reportId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async DeleteReport(reportId:number|carriers.Report_DeleteReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Report_DeleteReportRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = reportId;
        if( typeof( first ) === "object" && first && ( typeof(first.ReportId)!='undefined' ) )
        {
            _request = reportId as carriers.Report_DeleteReportRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ReportId: reportId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteReport( _request, _options );
    }

    /*
     * Gets a ReportLabelLayoutEntity object.
     * @param reportLabelLayoutEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ReportLabelLayoutEntity
     */
    public async GetReportLabelLayoutEntity(reportLabelLayoutEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ReportLabelLayoutEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReportLabelLayoutEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReportLabelLayoutEntity?reportLabelLayoutEntityId=" + reportLabelLayoutEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReportLabelLayoutEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    } // class v1ReportAgentController 



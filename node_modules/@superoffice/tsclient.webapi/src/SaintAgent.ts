// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/SaintAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Administration and maintenance of SAINT counters and statuses
 */
export interface ISaintAgent {
    CreateDefaultSaintConfiguration(): Promise< carriers.SaintConfiguration >;
    SaveSaintConfiguration(entity: carriers.SaintConfiguration) : Promise< carriers.SaintConfiguration >;
    CreateDefaultStatusMonitor(): Promise< carriers.StatusMonitor >;
    SaveStatusMonitor(entity: carriers.StatusMonitor) : Promise< carriers.StatusMonitor >;
    CreateDefaultStatusMonitorPeriods(): Promise< carriers.StatusMonitorPeriods >;
    SaveStatusMonitorPeriods(entity: carriers.StatusMonitorPeriods) : Promise< carriers.StatusMonitorPeriods >;
    GetSaintConfigurations(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaintConfiguration[] >;
    GetStatusMonitors(request: carriers.Saint_GetStatusMonitorsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor[] >;
    GetStatusMonitors(id: number, type: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor[] >;
    GetStatusMonitor(request: carriers.Saint_GetStatusMonitorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor >;
    GetStatusMonitor(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor >;
    RegenerateStatusMonitors(request: carriers.Saint_RegenerateStatusMonitorsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    RegenerateStatusMonitors(runAsBatch: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    SetRankOnStatusMonitors(request: carriers.Saint_SetRankOnStatusMonitorsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnStatusMonitors(type: string, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RegenerateStatusMonitor(request: carriers.Saint_RegenerateStatusMonitorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RegenerateStatusMonitor(statusMonitorId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RegenerateCounters(request: carriers.Saint_RegenerateCountersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    RegenerateCounters(runAsBatch: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    GetStatusMonitorPeriods(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitorPeriods >;
} // interface ISaintAgent




/**
 * Administration and maintenance of SAINT counters and statuses
 */
export class SaintAgent extends base.WebApiBase implements ISaintAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Saint/";
        super(options);
    }



    /**
     * Set default values into a new SaintConfiguration.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSaintConfiguration(options?:base.WebApiRequestOptions) : Promise< carriers.SaintConfiguration > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaintConfiguration >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaintConfiguration", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaintConfiguration = converters.Create_SaintConfiguration_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SaintConfiguration or creates a new SaintConfiguration if the id parameter is empty
     * @param entity - The SaintConfiguration to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SaintConfiguration
     */
    public async SaveSaintConfiguration(entity: carriers.SaintConfiguration, options?:base.WebApiRequestOptions) : Promise< carriers.SaintConfiguration > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaintConfiguration >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSaintConfiguration", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaintConfiguration = converters.Create_SaintConfiguration_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new StatusMonitor.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultStatusMonitor(options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StatusMonitor >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultStatusMonitor", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StatusMonitor = converters.Create_StatusMonitor_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing StatusMonitor or creates a new StatusMonitor if the id parameter is empty
     * @param entity - The StatusMonitor to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated StatusMonitor
     */
    public async SaveStatusMonitor(entity: carriers.StatusMonitor, options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StatusMonitor >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveStatusMonitor", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StatusMonitor = converters.Create_StatusMonitor_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new StatusMonitorPeriods.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultStatusMonitorPeriods(options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitorPeriods > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StatusMonitorPeriods >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultStatusMonitorPeriods", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StatusMonitorPeriods = converters.Create_StatusMonitorPeriods_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing StatusMonitorPeriods or creates a new StatusMonitorPeriods if the id parameter is empty
     * @param entity - The StatusMonitorPeriods to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated StatusMonitorPeriods
     */
    public async SaveStatusMonitorPeriods(entity: carriers.StatusMonitorPeriods, options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitorPeriods > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StatusMonitorPeriods >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveStatusMonitorPeriods", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StatusMonitorPeriods = converters.Create_StatusMonitorPeriods_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    private async _GetSaintConfigurations( options?:base.WebApiRequestOptions) : Promise< carriers.SaintConfiguration[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaintConfiguration[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSaintConfigurations", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaintConfiguration[] = converters.Create_SaintConfigurationArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns the StatusMonitorPeriods entity.
     * @returns The SaintConfiguration for all entities
     */
    public async GetSaintConfigurations(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaintConfiguration[] >
    {
        return this._GetSaintConfigurations(webapi_options);
    }


    private async _GetStatusMonitors(request: carriers.Saint_GetStatusMonitorsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StatusMonitor[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetStatusMonitors", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StatusMonitor[] = converters.Create_StatusMonitorArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all active status monitors for a specified target
     * @param request - Id, Type
     * @returns Active status monitors
     */
    public async GetStatusMonitors(request: carriers.Saint_GetStatusMonitorsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor[] >;

    /**
     * Get all active status monitors for a specified target
     * @param id - Identity of target type(contact identity, project identity etc.)
     * @param type - Type to get status monitors for("contact", "project", etc.)
     * @returns Active status monitors
     */
    public async GetStatusMonitors(id: number, type: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor[] >;

    public async GetStatusMonitors(id:number|carriers.Saint_GetStatusMonitorsRequest, type?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor[] > {
        let _request : carriers.Saint_GetStatusMonitorsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.Type)!='undefined' ) )
        {
            _request = id as carriers.Saint_GetStatusMonitorsRequest;
            _options = type as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       Type: type as string,
                       };   
            _options = webapi_options;
        }
        return this._GetStatusMonitors( _request, _options );
    }


    private async _GetStatusMonitor(request: carriers.Saint_GetStatusMonitorRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StatusMonitor >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetStatusMonitor", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StatusMonitor = converters.Create_StatusMonitor_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a single status monitor based on its identity
     * @param request - Id
     * @returns The requested status monitor
     */
    public async GetStatusMonitor(request: carriers.Saint_GetStatusMonitorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor >;

    /**
     * Get a single status monitor based on its identity
     * @param id - Identity of status monitor
     * @returns The requested status monitor
     */
    public async GetStatusMonitor(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor >;

    public async GetStatusMonitor(id:number|carriers.Saint_GetStatusMonitorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitor > {
        let _request : carriers.Saint_GetStatusMonitorRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.Saint_GetStatusMonitorRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._GetStatusMonitor( _request, _options );
    }


    private async _RegenerateStatusMonitors(request: carriers.Saint_RegenerateStatusMonitorsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RegenerateStatusMonitors", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo = converters.Create_BatchTaskInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Regenerate status monitors
     * @param request - RunAsBatch
     * @returns Information about the batch task, if batch execution was requested. Otherwise null
     */
    public async RegenerateStatusMonitors(request: carriers.Saint_RegenerateStatusMonitorsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    /**
     * Regenerate status monitors
     * @param runAsBatch - If true, then execute the regeneration as a Batch Task; the service call will return immediately. Otherwise wait until the task completes, may cause a timeout if called as a Web Service
     * @returns Information about the batch task, if batch execution was requested. Otherwise null
     */
    public async RegenerateStatusMonitors(runAsBatch: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    public async RegenerateStatusMonitors(runAsBatch:boolean|carriers.Saint_RegenerateStatusMonitorsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        let _request : carriers.Saint_RegenerateStatusMonitorsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = runAsBatch;
        if( typeof( first ) === "object" && first && ( typeof(first.RunAsBatch)!='undefined' ) )
        {
            _request = runAsBatch as carriers.Saint_RegenerateStatusMonitorsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RunAsBatch: runAsBatch as boolean,
                       };   
            _options = webapi_options;
        }
        return this._RegenerateStatusMonitors( _request, _options );
    }


    private async _SetRankOnStatusMonitors(request: carriers.Saint_SetRankOnStatusMonitorsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnStatusMonitors", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set rank order on status monitors
     * @param request - Type, ItemsIds
     * @returns This method has no return value
     */
    public async SetRankOnStatusMonitors(request: carriers.Saint_SetRankOnStatusMonitorsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set rank order on status monitors
     * @param type - Type of status monitors to reorder ("contact", "project", etc.)
     * @param itemsIds - The ids of the items in the order you want
     * @returns This method has no return value
     */
    public async SetRankOnStatusMonitors(type: string, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetRankOnStatusMonitors(type:string|carriers.Saint_SetRankOnStatusMonitorsRequest, itemsIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Saint_SetRankOnStatusMonitorsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' || typeof(first.ItemsIds)!='undefined' ) )
        {
            _request = type as carriers.Saint_SetRankOnStatusMonitorsRequest;
            _options = itemsIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as string,
                       ItemsIds: itemsIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetRankOnStatusMonitors( _request, _options );
    }


    private async _RegenerateStatusMonitor(request: carriers.Saint_RegenerateStatusMonitorRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RegenerateStatusMonitor", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Regenerate the given status monitor
     * @param request - StatusMonitorId
     * @returns This method has no return value
     */
    public async RegenerateStatusMonitor(request: carriers.Saint_RegenerateStatusMonitorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Regenerate the given status monitor
     * @param statusMonitorId - The id of the statusmonitor to regenerate
     * @returns This method has no return value
     */
    public async RegenerateStatusMonitor(statusMonitorId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RegenerateStatusMonitor(statusMonitorId:number|carriers.Saint_RegenerateStatusMonitorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Saint_RegenerateStatusMonitorRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = statusMonitorId;
        if( typeof( first ) === "object" && first && ( typeof(first.StatusMonitorId)!='undefined' ) )
        {
            _request = statusMonitorId as carriers.Saint_RegenerateStatusMonitorRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StatusMonitorId: statusMonitorId as number,
                       };   
            _options = webapi_options;
        }
        return this._RegenerateStatusMonitor( _request, _options );
    }


    private async _RegenerateCounters(request: carriers.Saint_RegenerateCountersRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RegenerateCounters", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo = converters.Create_BatchTaskInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Regenerate the Saint counters - this can take several minutes
     * @param request - RunAsBatch
     * @returns Information about the batch task, if batch execution was requested. Otherwise null
     */
    public async RegenerateCounters(request: carriers.Saint_RegenerateCountersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    /**
     * Regenerate the Saint counters - this can take several minutes
     * @param runAsBatch - If true, then execute the regeneration as a Batch Task; the service call will return immediately. Otherwise wait until the task completes, may cause a timeout if called as a Web Service
     * @returns Information about the batch task, if batch execution was requested. Otherwise null
     */
    public async RegenerateCounters(runAsBatch: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    public async RegenerateCounters(runAsBatch:boolean|carriers.Saint_RegenerateCountersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        let _request : carriers.Saint_RegenerateCountersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = runAsBatch;
        if( typeof( first ) === "object" && first && ( typeof(first.RunAsBatch)!='undefined' ) )
        {
            _request = runAsBatch as carriers.Saint_RegenerateCountersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RunAsBatch: runAsBatch as boolean,
                       };   
            _options = webapi_options;
        }
        return this._RegenerateCounters( _request, _options );
    }


    private async _GetStatusMonitorPeriods( options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitorPeriods > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StatusMonitorPeriods >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetStatusMonitorPeriods", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StatusMonitorPeriods = converters.Create_StatusMonitorPeriods_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns the StatusMonitorPeriods entity.
     * @returns The StatusMonitorEntity
     */
    public async GetStatusMonitorPeriods(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatusMonitorPeriods >
    {
        return this._GetStatusMonitorPeriods(webapi_options);
    }

    } // class v1SaintAgentController 



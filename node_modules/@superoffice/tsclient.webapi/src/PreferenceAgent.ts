// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/PreferenceAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Preferences, user interface tab configuration
 */
export interface IPreferenceAgent {
    CreateDefaultPreference(): Promise< carriers.Preference >;
    CreateDefaultPreferenceDescription(): Promise< carriers.PreferenceDescription >;
    SavePreferenceDescription(entity: carriers.PreferenceDescription) : Promise< carriers.PreferenceDescription >;
    DeletePreferenceDescription(PreferenceDescriptionId: number) : Promise<void>;
    CreateDefaultPreferenceDescriptionLine(): Promise< carriers.PreferenceDescriptionLine >;
    SavePreferenceDescriptionLine(entity: carriers.PreferenceDescriptionLine) : Promise< carriers.PreferenceDescriptionLine >;
    DeletePreferenceDescriptionLine(PreferenceDescriptionLineId: number) : Promise<void>;
    SavePreference(request: carriers.Preference_SavePreferenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SavePreference(preference: carriers.Preference, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveTabOrder(request: carriers.Preference_SaveTabOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveTabOrder(tabOrder: carriers.TabOrder, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetTabOrder(request: carriers.Preference_GetTabOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TabOrder >;
    GetTabOrder(tabName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TabOrder >;
    GetPreference(request: carriers.Preference_GetPreferenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;
    GetPreference(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;
    SavePreferenceEntity(request: carriers.Preference_SavePreferenceEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;
    SavePreferenceEntity(preference: carriers.Preference, removeLowerLevels: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;
    DeletePreference(request: carriers.Preference_DeletePreferenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeletePreference(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeletePreferences(request: carriers.Preference_DeletePreferencesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeletePreferences(ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPreferenceByName(request: carriers.Preference_GetPreferenceByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;
    GetPreferenceByName(prefSection: string, prefKey: string, prefLevel: enums.PreferenceLevel, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;
    GetPreferenceByNameAndId(request: carriers.Preference_GetPreferenceByNameAndIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;
    GetPreferenceByNameAndId(prefSection: string, prefKey: string, prefLevel: enums.PreferenceLevel, ownerId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;
    GetNetServicesStatusUrl(webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    UpdateNetServicesStatus(request: carriers.Preference_UpdateNetServicesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    UpdateNetServicesStatus(xmlOrJson: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetXsrfPaths(request: carriers.Preference_GetXsrfPathsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetXsrfPaths(hostname: string, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    SetXsrfPaths(request: carriers.Preference_SetXsrfPathsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetXsrfPaths(hostname: string, paths: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPreferenceDescription(preferenceDescriptionId: number) :  Promise< carriers.PreferenceDescription >;
    GetFromSectionAndKey(request: carriers.Preference_GetFromSectionAndKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription >;
    GetFromSectionAndKey(section: string, key: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription >;
    GetAll(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription[] >;
    GetAllFromSection(request: carriers.Preference_GetAllFromSectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription[] >;
    GetAllFromSection(section: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription[] >;
    SaveFromSectionAndKey(request: carriers.Preference_SaveFromSectionAndKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription >;
    SaveFromSectionAndKey(section: string, key: string, preferenceDescription: carriers.PreferenceDescription, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription >;
    DeleteFromSectionAndKey(request: carriers.Preference_DeleteFromSectionAndKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteFromSectionAndKey(section: string, key: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPreferenceDescriptionLine(preferenceDescriptionLineId: number) :  Promise< carriers.PreferenceDescriptionLine >;
    GetPreferenceDescriptionLineFromIdAndValue(request: carriers.Preference_GetPreferenceDescriptionLineFromIdAndValueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine >;
    GetPreferenceDescriptionLineFromIdAndValue(prefDescId: number, prefValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine >;
    GetPreferenceDescriptionLinesByPrefDescId(request: carriers.Preference_GetPreferenceDescriptionLinesByPrefDescIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] >;
    GetPreferenceDescriptionLinesByPrefDescId(prefDescId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] >;
    SavePreferenceDescriptionLines(request: carriers.Preference_SavePreferenceDescriptionLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] >;
    SavePreferenceDescriptionLines(preferenceDescriptionLines: carriers.PreferenceDescriptionLine[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] >;
    DeletePreferenceDescriptionLines(request: carriers.Preference_DeletePreferenceDescriptionLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeletePreferenceDescriptionLines(prefDescLineIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeletePrefDescLinesByPrefDescId(request: carriers.Preference_DeletePrefDescLinesByPrefDescIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeletePrefDescLinesByPrefDescId(prefDescId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeletePrefDescLinesByPrefDescIds(request: carriers.Preference_DeletePrefDescLinesByPrefDescIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeletePrefDescLinesByPrefDescIds(prefDescIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPreferences(request: carriers.Preference_GetPreferencesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] >;
    GetPreferences(specifications: carriers.PreferenceSpec[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] >;
    SavePreferences(request: carriers.Preference_SavePreferencesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SavePreferences(preferences: carriers.Preference[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPreferencesWithDisplayValues(request: carriers.Preference_GetPreferencesWithDisplayValuesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] >;
    GetPreferencesWithDisplayValues(specifications: carriers.PreferenceSpec[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] >;
    GetTabOrders(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TabOrder[] >;
    SaveTabOrders(request: carriers.Preference_SaveTabOrdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveTabOrders(tabOrders: carriers.TabOrder[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SavePreferenceEntities(request: carriers.Preference_SavePreferenceEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SavePreferenceEntities(preferences: carriers.Preference[], removeLowerLevels: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
} // interface IPreferenceAgent




/**
 * Preferences, user interface tab configuration
 */
export class PreferenceAgent extends base.WebApiBase implements IPreferenceAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Preference/";
        super(options);
    }



    /**
     * Set default values into a new Preference.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultPreference(options?:base.WebApiRequestOptions) : Promise< carriers.Preference > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Preference >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreference", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Preference = converters.Create_Preference_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new PreferenceDescription.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultPreferenceDescription(options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescription >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreferenceDescription", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescription = converters.Create_PreferenceDescription_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing PreferenceDescription or creates a new PreferenceDescription if the id parameter is empty
     * @param entity - The PreferenceDescription to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated PreferenceDescription
     */
    public async SavePreferenceDescription(entity: carriers.PreferenceDescription, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescription >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SavePreferenceDescription", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescription = converters.Create_PreferenceDescription_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the PreferenceDescription
     * @param PreferenceDescriptionId - The id of the PreferenceDescription to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeletePreferenceDescription(PreferenceDescriptionId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeletePreferenceDescription?PreferenceDescriptionId=" + PreferenceDescriptionId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new PreferenceDescriptionLine.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultPreferenceDescriptionLine(options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescriptionLine >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreferenceDescriptionLine", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescriptionLine = converters.Create_PreferenceDescriptionLine_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing PreferenceDescriptionLine or creates a new PreferenceDescriptionLine if the id parameter is empty
     * @param entity - The PreferenceDescriptionLine to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated PreferenceDescriptionLine
     */
    public async SavePreferenceDescriptionLine(entity: carriers.PreferenceDescriptionLine, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescriptionLine >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SavePreferenceDescriptionLine", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescriptionLine = converters.Create_PreferenceDescriptionLine_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the PreferenceDescriptionLine
     * @param PreferenceDescriptionLineId - The id of the PreferenceDescriptionLine to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeletePreferenceDescriptionLine(PreferenceDescriptionLineId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeletePreferenceDescriptionLine?PreferenceDescriptionLineId=" + PreferenceDescriptionLineId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    private async _SavePreference(request: carriers.Preference_SavePreferenceRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreference", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save this preference
     * @param request - Preference
     * @returns This method has no return value
     */
    public async SavePreference(request: carriers.Preference_SavePreferenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Save this preference
     * @param preference - Preference to be saved. All fields must be filled in, and the preference will be saved on the Associate level only. Setting for other levels is an administrative task and not available through this service.
     * @returns This method has no return value
     */
    public async SavePreference(preference: carriers.Preference, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SavePreference(preference:carriers.Preference|carriers.Preference_SavePreferenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_SavePreferenceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = preference;
        if( typeof( first ) === "object" && first && ( typeof(first.Preference)!='undefined' ) )
        {
            _request = preference as carriers.Preference_SavePreferenceRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Preference: preference as carriers.Preference,
                       };   
            _options = webapi_options;
        }
        return this._SavePreference( _request, _options );
    }


    private async _SaveTabOrder(request: carriers.Preference_SaveTabOrderRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTabOrder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the tab order. The order is saved pr. user.
     * @param request - TabOrder
     * @returns This method has no return value
     */
    public async SaveTabOrder(request: carriers.Preference_SaveTabOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Saves the tab order. The order is saved pr. user.
     * @param tabOrder - Name of the tab control
     * @returns This method has no return value
     */
    public async SaveTabOrder(tabOrder: carriers.TabOrder, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveTabOrder(tabOrder:carriers.TabOrder|carriers.Preference_SaveTabOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_SaveTabOrderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tabOrder;
        if( typeof( first ) === "object" && first && ( typeof(first.TabOrder)!='undefined' ) )
        {
            _request = tabOrder as carriers.Preference_SaveTabOrderRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TabOrder: tabOrder as carriers.TabOrder,
                       };   
            _options = webapi_options;
        }
        return this._SaveTabOrder( _request, _options );
    }


    private async _GetTabOrder(request: carriers.Preference_GetTabOrderRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TabOrder > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TabOrder >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTabOrder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TabOrder = converters.Create_TabOrder_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the tab order.
     * @param request - TabName
     * @returns Tab order. Array of strings. Each string represent a named tab.
     */
    public async GetTabOrder(request: carriers.Preference_GetTabOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TabOrder >;

    /**
     * Gets the tab order.
     * @param tabName - Name of the tab control
     * @returns Tab order. Array of strings. Each string represent a named tab.
     */
    public async GetTabOrder(tabName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TabOrder >;

    public async GetTabOrder(tabName:string|carriers.Preference_GetTabOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TabOrder > {
        let _request : carriers.Preference_GetTabOrderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tabName;
        if( typeof( first ) === "object" && first && ( typeof(first.TabName)!='undefined' ) )
        {
            _request = tabName as carriers.Preference_GetTabOrderRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TabName: tabName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetTabOrder( _request, _options );
    }


    private async _GetPreference(request: carriers.Preference_GetPreferenceRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Preference > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Preference >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreference", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Preference = converters.Create_Preference_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a preference by id
     * @param request - Id
     * @returns The preference loaded
     */
    public async GetPreference(request: carriers.Preference_GetPreferenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;

    /**
     * Get a preference by id
     * @param id - The id of the preference to load
     * @returns The preference loaded
     */
    public async GetPreference(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;

    public async GetPreference(id:number|carriers.Preference_GetPreferenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference > {
        let _request : carriers.Preference_GetPreferenceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.Preference_GetPreferenceRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreference( _request, _options );
    }


    private async _SavePreferenceEntity(request: carriers.Preference_SavePreferenceEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Preference > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Preference >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreferenceEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Preference = converters.Create_Preference_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a complete preference object, on any level and any target. Preference administrator rights are required to use this
     * @param request - Preference, RemoveLowerLevels
     * @returns Returns the saved preference
     */
    public async SavePreferenceEntity(request: carriers.Preference_SavePreferenceEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;

    /**
     * Saves a complete preference object, on any level and any target. Preference administrator rights are required to use this
     * @param preference - The preference object to be saved
     * @param removeLowerLevels - If this is true, all user preferences on lower levels will be deleted
     * @returns Returns the saved preference
     */
    public async SavePreferenceEntity(preference: carriers.Preference, removeLowerLevels: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;

    public async SavePreferenceEntity(preference:carriers.Preference|carriers.Preference_SavePreferenceEntityRequest, removeLowerLevels?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference > {
        let _request : carriers.Preference_SavePreferenceEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = preference;
        if( typeof( first ) === "object" && first && ( typeof(first.Preference)!='undefined' || typeof(first.RemoveLowerLevels)!='undefined' ) )
        {
            _request = preference as carriers.Preference_SavePreferenceEntityRequest;
            _options = removeLowerLevels as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Preference: preference as carriers.Preference,
                       RemoveLowerLevels: removeLowerLevels as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SavePreferenceEntity( _request, _options );
    }


    private async _DeletePreference(request: carriers.Preference_DeletePreferenceRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePreference", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a preference by id
     * @param request - Id
     * @returns This method has no return value
     */
    public async DeletePreference(request: carriers.Preference_DeletePreferenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a preference by id
     * @param id - The id of the preference to delete
     * @returns This method has no return value
     */
    public async DeletePreference(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeletePreference(id:number|carriers.Preference_DeletePreferenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_DeletePreferenceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.Preference_DeletePreferenceRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._DeletePreference( _request, _options );
    }


    private async _DeletePreferences(request: carriers.Preference_DeletePreferencesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePreferences", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete some preferences by id
     * @param request - Ids
     * @returns This method has no return value
     */
    public async DeletePreferences(request: carriers.Preference_DeletePreferencesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete some preferences by id
     * @param ids - The ids of the preference to delete
     * @returns This method has no return value
     */
    public async DeletePreferences(ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeletePreferences(ids:number[]|carriers.Preference_DeletePreferencesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_DeletePreferencesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ids;
        if( typeof( first ) === "object" && first && ( typeof(first.Ids)!='undefined' ) )
        {
            _request = ids as carriers.Preference_DeletePreferencesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Ids: ids as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeletePreferences( _request, _options );
    }


    private async _GetPreferenceByName(request: carriers.Preference_GetPreferenceByNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Preference > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Preference >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferenceByName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Preference = converters.Create_Preference_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a preference by name
     * @param request - PrefSection, PrefKey, PrefLevel
     * @returns The preference. Note that id = 0 and value = null if preference not found in the database at the requested pref-level.
     */
    public async GetPreferenceByName(request: carriers.Preference_GetPreferenceByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;

    /**
     * Get a preference by name
     * @param prefSection - The preference section name. e.g. 'Functions'. See SuperOffice.CRM.UserPreferenceStrings for constants. 
     * @param prefKey - The preference key name. e.g. 'ShowTipsAtStart'. See SuperOffice.CRM.UserPreferenceStrings for constants.
     * @param prefLevel - The preference level to read. Undefined (0) means to return the preference defined closest to the user.
     * @returns The preference. Note that id = 0 and value = null if preference not found in the database at the requested pref-level.
     */
    public async GetPreferenceByName(prefSection: string, prefKey: string, prefLevel: enums.PreferenceLevel, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;

    public async GetPreferenceByName(prefSection:string|carriers.Preference_GetPreferenceByNameRequest, prefKey?:string|base.WebApiRequestOptions, prefLevel?:enums.PreferenceLevel, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference > {
        let _request : carriers.Preference_GetPreferenceByNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = prefSection;
        if( typeof( first ) === "object" && first && ( typeof(first.PrefSection)!='undefined' || typeof(first.PrefKey)!='undefined' || typeof(first.PrefLevel)!='undefined' ) )
        {
            _request = prefSection as carriers.Preference_GetPreferenceByNameRequest;
            _options = prefKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PrefSection: prefSection as string,
                       PrefKey: prefKey as string,
                       PrefLevel: prefLevel as enums.PreferenceLevel,
                       };   
            _options = webapi_options;
        }
        return this._GetPreferenceByName( _request, _options );
    }


    private async _GetPreferenceByNameAndId(request: carriers.Preference_GetPreferenceByNameAndIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Preference > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Preference >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferenceByNameAndId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Preference = converters.Create_Preference_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a preference by name and owner id.
     * @param request - PrefSection, PrefKey, PrefLevel, OwnerId
     * @returns The preference. Note that id = 0 and value = null if preference not found in the database at the requested pref-level.
     */
    public async GetPreferenceByNameAndId(request: carriers.Preference_GetPreferenceByNameAndIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;

    /**
     * Get a preference by name and owner id.
     * @param prefSection - The preference section name. e.g. 'Functions'. See SuperOffice.CRM.UserPreferenceStrings for constants. 
     * @param prefKey - The preference key name. e.g. 'ShowTipsAtStart'. See SuperOffice.CRM.UserPreferenceStrings for constants.
     * @param prefLevel - The preference level to read. Undefined (0) means to return the preference defined closest to the user.
     * @param ownerId - The preference owner id, individual or group.
     * @returns The preference. Note that id = 0 and value = null if preference not found in the database at the requested pref-level.
     */
    public async GetPreferenceByNameAndId(prefSection: string, prefKey: string, prefLevel: enums.PreferenceLevel, ownerId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference >;

    public async GetPreferenceByNameAndId(prefSection:string|carriers.Preference_GetPreferenceByNameAndIdRequest, prefKey?:string|base.WebApiRequestOptions, prefLevel?:enums.PreferenceLevel, ownerId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference > {
        let _request : carriers.Preference_GetPreferenceByNameAndIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = prefSection;
        if( typeof( first ) === "object" && first && ( typeof(first.PrefSection)!='undefined' || typeof(first.PrefKey)!='undefined' || typeof(first.PrefLevel)!='undefined' || typeof(first.OwnerId)!='undefined' ) )
        {
            _request = prefSection as carriers.Preference_GetPreferenceByNameAndIdRequest;
            _options = prefKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PrefSection: prefSection as string,
                       PrefKey: prefKey as string,
                       PrefLevel: prefLevel as enums.PreferenceLevel,
                       OwnerId: ownerId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreferenceByNameAndId( _request, _options );
    }


    private async _GetNetServicesStatusUrl( options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNetServicesStatusUrl", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns URL to status service. e.g. &apos;https://help.superoffice.com/sodispatcher/v1/status&apos; Returns NULL if status does not need to be checked yet.
     * @returns NULL or URL of the status service that returns an XML or JSON block.
     */
    public async GetNetServicesStatusUrl(webapi_options?:base.WebApiRequestOptions) : Promise< string >
    {
        return this._GetNetServicesStatusUrl(webapi_options);
    }


    private async _UpdateNetServicesStatus(request: carriers.Preference_UpdateNetServicesStatusRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateNetServicesStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update the NetServices preferences with values contained in the content from the Status URL
     * @param request - XmlOrJson
     * @returns This method has no return value
     */
    public async UpdateNetServicesStatus(request: carriers.Preference_UpdateNetServicesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Update the NetServices preferences with values contained in the content from the Status URL
     * @param xmlOrJson - The text that was returned by getting the Status URL
     * @returns This method has no return value
     */
    public async UpdateNetServicesStatus(xmlOrJson: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async UpdateNetServicesStatus(xmlOrJson:string|carriers.Preference_UpdateNetServicesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_UpdateNetServicesStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = xmlOrJson;
        if( typeof( first ) === "object" && first && ( typeof(first.XmlOrJson)!='undefined' ) )
        {
            _request = xmlOrJson as carriers.Preference_UpdateNetServicesStatusRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       XmlOrJson: xmlOrJson as string,
                       };   
            _options = webapi_options;
        }
        return this._UpdateNetServicesStatus( _request, _options );
    }


    private async _GetXsrfPaths(request: carriers.Preference_GetXsrfPathsRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetXsrfPaths", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns paths that XSRF cookies should be set on
     * @param request - Hostname
     * @returns Paths that XSRF cookies should be set for: ['/cs', '/crm']
     */
    public async GetXsrfPaths(request: carriers.Preference_GetXsrfPathsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Returns paths that XSRF cookies should be set on
     * @param hostname - The hostname that we are storing paths for.
     * @returns Paths that XSRF cookies should be set for: ['/cs', '/crm']
     */
    public async GetXsrfPaths(hostname: string, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetXsrfPaths(hostname:string|carriers.Preference_GetXsrfPathsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.Preference_GetXsrfPathsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = hostname;
        if( typeof( first ) === "object" && first && ( typeof(first.Hostname)!='undefined' ) )
        {
            _request = hostname as carriers.Preference_GetXsrfPathsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Hostname: hostname as string,
                       };   
            _options = webapi_options;
        }
        return this._GetXsrfPaths( _request, _options );
    }


    private async _SetXsrfPaths(request: carriers.Preference_SetXsrfPathsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetXsrfPaths", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update the paths that need XSRF cookies
     * @param request - Hostname, Paths
     * @returns This method has no return value
     */
    public async SetXsrfPaths(request: carriers.Preference_SetXsrfPathsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Update the paths that need XSRF cookies
     * @param hostname - The hostname that we are storing paths for.
     * @param paths - Paths that XSRF cookies should be set for: ['/cs', '/crm']
     * @returns This method has no return value
     */
    public async SetXsrfPaths(hostname: string, paths: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetXsrfPaths(hostname:string|carriers.Preference_SetXsrfPathsRequest, paths?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_SetXsrfPathsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = hostname;
        if( typeof( first ) === "object" && first && ( typeof(first.Hostname)!='undefined' || typeof(first.Paths)!='undefined' ) )
        {
            _request = hostname as carriers.Preference_SetXsrfPathsRequest;
            _options = paths as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Hostname: hostname as string,
                       Paths: paths as string[],
                       };   
            _options = webapi_options;
        }
        return this._SetXsrfPaths( _request, _options );
    }

    /*
     * Gets a PreferenceDescription object.
     * @param preferenceDescriptionId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PreferenceDescription
     */
    public async GetPreferenceDescription(preferenceDescriptionId: number, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescription >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPreferenceDescription?preferenceDescriptionId=" + preferenceDescriptionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescription_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetFromSectionAndKey(request: carriers.Preference_GetFromSectionAndKeyRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescription >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFromSectionAndKey", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescription = converters.Create_PreferenceDescription_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a PreferenceDescription based on the section and key
     * @param request - Section, Key
     * @returns A PreferenceDescription or null
     */
    public async GetFromSectionAndKey(request: carriers.Preference_GetFromSectionAndKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription >;

    /**
     * Gets a PreferenceDescription based on the section and key
     * @param section - The PreferenceDescription-section
     * @param key - The PreferenceDescription-key
     * @returns A PreferenceDescription or null
     */
    public async GetFromSectionAndKey(section: string, key: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription >;

    public async GetFromSectionAndKey(section:string|carriers.Preference_GetFromSectionAndKeyRequest, key?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription > {
        let _request : carriers.Preference_GetFromSectionAndKeyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = section;
        if( typeof( first ) === "object" && first && ( typeof(first.Section)!='undefined' || typeof(first.Key)!='undefined' ) )
        {
            _request = section as carriers.Preference_GetFromSectionAndKeyRequest;
            _options = key as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Section: section as string,
                       Key: key as string,
                       };   
            _options = webapi_options;
        }
        return this._GetFromSectionAndKey( _request, _options );
    }


    private async _GetAll( options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescription[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAll", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescription[] = converters.Create_PreferenceDescriptionArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets a list of all PreferenceDescriptions in the system.
     * @returns All PreferenceDescriptions in the system
     */
    public async GetAll(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription[] >
    {
        return this._GetAll(webapi_options);
    }


    private async _GetAllFromSection(request: carriers.Preference_GetAllFromSectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescription[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllFromSection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescription[] = converters.Create_PreferenceDescriptionArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets all PreferenceDescription-items in the specified section
     * @param request - Section
     * @returns All PreferenceDescriptions found.
     */
    public async GetAllFromSection(request: carriers.Preference_GetAllFromSectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription[] >;

    /**
     * Gets all PreferenceDescription-items in the specified section
     * @param section - The PreferenceDescription-section
     * @returns All PreferenceDescriptions found.
     */
    public async GetAllFromSection(section: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription[] >;

    public async GetAllFromSection(section:string|carriers.Preference_GetAllFromSectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription[] > {
        let _request : carriers.Preference_GetAllFromSectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = section;
        if( typeof( first ) === "object" && first && ( typeof(first.Section)!='undefined' ) )
        {
            _request = section as carriers.Preference_GetAllFromSectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Section: section as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAllFromSection( _request, _options );
    }


    private async _SaveFromSectionAndKey(request: carriers.Preference_SaveFromSectionAndKeyRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescription >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveFromSectionAndKey", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescription = converters.Create_PreferenceDescription_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update a PreferenceDescription based on the section and key
     * @param request - Section, Key, PreferenceDescription
     * @returns Saved PreferenceDescription
     */
    public async SaveFromSectionAndKey(request: carriers.Preference_SaveFromSectionAndKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription >;

    /**
     * Update a PreferenceDescription based on the section and key
     * @param section - The PreferenceDescription-section
     * @param key - The PreferenceDescription-key
     * @param preferenceDescription - The PreferenceDescription to save.
     * @returns Saved PreferenceDescription
     */
    public async SaveFromSectionAndKey(section: string, key: string, preferenceDescription: carriers.PreferenceDescription, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription >;

    public async SaveFromSectionAndKey(section:string|carriers.Preference_SaveFromSectionAndKeyRequest, key?:string|base.WebApiRequestOptions, preferenceDescription?:carriers.PreferenceDescription, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescription > {
        let _request : carriers.Preference_SaveFromSectionAndKeyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = section;
        if( typeof( first ) === "object" && first && ( typeof(first.Section)!='undefined' || typeof(first.Key)!='undefined' || typeof(first.PreferenceDescription)!='undefined' ) )
        {
            _request = section as carriers.Preference_SaveFromSectionAndKeyRequest;
            _options = key as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Section: section as string,
                       Key: key as string,
                       PreferenceDescription: preferenceDescription as carriers.PreferenceDescription,
                       };   
            _options = webapi_options;
        }
        return this._SaveFromSectionAndKey( _request, _options );
    }


    private async _DeleteFromSectionAndKey(request: carriers.Preference_DeleteFromSectionAndKeyRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteFromSectionAndKey", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a PreferenceDescription based on the section and key
     * @param request - Section, Key
     * @returns This method has no return value
     */
    public async DeleteFromSectionAndKey(request: carriers.Preference_DeleteFromSectionAndKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Gets a PreferenceDescription based on the section and key
     * @param section - The PreferenceDescription-section
     * @param key - The PreferenceDescription-key
     * @returns This method has no return value
     */
    public async DeleteFromSectionAndKey(section: string, key: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteFromSectionAndKey(section:string|carriers.Preference_DeleteFromSectionAndKeyRequest, key?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_DeleteFromSectionAndKeyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = section;
        if( typeof( first ) === "object" && first && ( typeof(first.Section)!='undefined' || typeof(first.Key)!='undefined' ) )
        {
            _request = section as carriers.Preference_DeleteFromSectionAndKeyRequest;
            _options = key as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Section: section as string,
                       Key: key as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteFromSectionAndKey( _request, _options );
    }

    /*
     * Gets a PreferenceDescriptionLine object.
     * @param preferenceDescriptionLineId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PreferenceDescriptionLine
     */
    public async GetPreferenceDescriptionLine(preferenceDescriptionLineId: number, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescriptionLine >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPreferenceDescriptionLine?preferenceDescriptionLineId=" + preferenceDescriptionLineId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescriptionLine_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetPreferenceDescriptionLineFromIdAndValue(request: carriers.Preference_GetPreferenceDescriptionLineFromIdAndValueRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescriptionLine >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferenceDescriptionLineFromIdAndValue", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescriptionLine = converters.Create_PreferenceDescriptionLine_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a preference description line from a prefDesc_id and a prefValue
     * @param request - PrefDescId, PrefValue
     * @returns The preference description line matching the id and the value
     */
    public async GetPreferenceDescriptionLineFromIdAndValue(request: carriers.Preference_GetPreferenceDescriptionLineFromIdAndValueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine >;

    /**
     * Get a preference description line from a prefDesc_id and a prefValue
     * @param prefDescId - The id of the preference description this line is connected to
     * @param prefValue - The value of the description line to return
     * @returns The preference description line matching the id and the value
     */
    public async GetPreferenceDescriptionLineFromIdAndValue(prefDescId: number, prefValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine >;

    public async GetPreferenceDescriptionLineFromIdAndValue(prefDescId:number|carriers.Preference_GetPreferenceDescriptionLineFromIdAndValueRequest, prefValue?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine > {
        let _request : carriers.Preference_GetPreferenceDescriptionLineFromIdAndValueRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = prefDescId;
        if( typeof( first ) === "object" && first && ( typeof(first.PrefDescId)!='undefined' || typeof(first.PrefValue)!='undefined' ) )
        {
            _request = prefDescId as carriers.Preference_GetPreferenceDescriptionLineFromIdAndValueRequest;
            _options = prefValue as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PrefDescId: prefDescId as number,
                       PrefValue: prefValue as string,
                       };   
            _options = webapi_options;
        }
        return this._GetPreferenceDescriptionLineFromIdAndValue( _request, _options );
    }


    private async _GetPreferenceDescriptionLinesByPrefDescId(request: carriers.Preference_GetPreferenceDescriptionLinesByPrefDescIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescriptionLine[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferenceDescriptionLinesByPrefDescId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescriptionLine[] = converters.Create_PreferenceDescriptionLineArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all preference description lines from a prefDesc_id
     * @param request - PrefDescId
     * @returns The preference description lines matching the id
     */
    public async GetPreferenceDescriptionLinesByPrefDescId(request: carriers.Preference_GetPreferenceDescriptionLinesByPrefDescIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] >;

    /**
     * Get all preference description lines from a prefDesc_id
     * @param prefDescId - The id of the preference description this line is connected to
     * @returns The preference description lines matching the id
     */
    public async GetPreferenceDescriptionLinesByPrefDescId(prefDescId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] >;

    public async GetPreferenceDescriptionLinesByPrefDescId(prefDescId:number|carriers.Preference_GetPreferenceDescriptionLinesByPrefDescIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] > {
        let _request : carriers.Preference_GetPreferenceDescriptionLinesByPrefDescIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = prefDescId;
        if( typeof( first ) === "object" && first && ( typeof(first.PrefDescId)!='undefined' ) )
        {
            _request = prefDescId as carriers.Preference_GetPreferenceDescriptionLinesByPrefDescIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PrefDescId: prefDescId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreferenceDescriptionLinesByPrefDescId( _request, _options );
    }


    private async _SavePreferenceDescriptionLines(request: carriers.Preference_SavePreferenceDescriptionLinesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreferenceDescriptionLine[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreferenceDescriptionLines", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreferenceDescriptionLine[] = converters.Create_PreferenceDescriptionLineArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the PreferenceDescriptionLine array in the SuperOffice database
     * @param request - PreferenceDescriptionLines
     * @returns The updated PrefDesc lines (If the PreferenceDescriptionLine array was new, it returns with id's set.
     */
    public async SavePreferenceDescriptionLines(request: carriers.Preference_SavePreferenceDescriptionLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] >;

    /**
     * Saves the PreferenceDescriptionLine array in the SuperOffice database
     * @param preferenceDescriptionLines - The PreferenceDescriptionLine array to save.
     * @returns The updated PrefDesc lines (If the PreferenceDescriptionLine array was new, it returns with id's set.
     */
    public async SavePreferenceDescriptionLines(preferenceDescriptionLines: carriers.PreferenceDescriptionLine[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] >;

    public async SavePreferenceDescriptionLines(preferenceDescriptionLines:carriers.PreferenceDescriptionLine[]|carriers.Preference_SavePreferenceDescriptionLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreferenceDescriptionLine[] > {
        let _request : carriers.Preference_SavePreferenceDescriptionLinesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = preferenceDescriptionLines;
        if( typeof( first ) === "object" && first && ( typeof(first.PreferenceDescriptionLines)!='undefined' ) )
        {
            _request = preferenceDescriptionLines as carriers.Preference_SavePreferenceDescriptionLinesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PreferenceDescriptionLines: preferenceDescriptionLines as carriers.PreferenceDescriptionLine[],
                       };   
            _options = webapi_options;
        }
        return this._SavePreferenceDescriptionLines( _request, _options );
    }


    private async _DeletePreferenceDescriptionLines(request: carriers.Preference_DeletePreferenceDescriptionLinesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePreferenceDescriptionLines", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete the PrefDescLines in the SuperOffice database
     * @param request - PrefDescLineIds
     * @returns Nothing
     */
    public async DeletePreferenceDescriptionLines(request: carriers.Preference_DeletePreferenceDescriptionLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete the PrefDescLines in the SuperOffice database
     * @param prefDescLineIds - Primary keys of the PrefDescLines to delete
     * @returns Nothing
     */
    public async DeletePreferenceDescriptionLines(prefDescLineIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeletePreferenceDescriptionLines(prefDescLineIds:number[]|carriers.Preference_DeletePreferenceDescriptionLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_DeletePreferenceDescriptionLinesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = prefDescLineIds;
        if( typeof( first ) === "object" && first && ( typeof(first.PrefDescLineIds)!='undefined' ) )
        {
            _request = prefDescLineIds as carriers.Preference_DeletePreferenceDescriptionLinesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PrefDescLineIds: prefDescLineIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeletePreferenceDescriptionLines( _request, _options );
    }


    private async _DeletePrefDescLinesByPrefDescId(request: carriers.Preference_DeletePrefDescLinesByPrefDescIdRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePrefDescLinesByPrefDescId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete the PrefDescLines associated with Preference Description Id in the SuperOffice database
     * @param request - PrefDescId
     * @returns Nothing
     */
    public async DeletePrefDescLinesByPrefDescId(request: carriers.Preference_DeletePrefDescLinesByPrefDescIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete the PrefDescLines associated with Preference Description Id in the SuperOffice database
     * @param prefDescId - Primary key of the Preference Description that contains PrefDescLines to delete
     * @returns Nothing
     */
    public async DeletePrefDescLinesByPrefDescId(prefDescId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeletePrefDescLinesByPrefDescId(prefDescId:number|carriers.Preference_DeletePrefDescLinesByPrefDescIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_DeletePrefDescLinesByPrefDescIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = prefDescId;
        if( typeof( first ) === "object" && first && ( typeof(first.PrefDescId)!='undefined' ) )
        {
            _request = prefDescId as carriers.Preference_DeletePrefDescLinesByPrefDescIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PrefDescId: prefDescId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeletePrefDescLinesByPrefDescId( _request, _options );
    }


    private async _DeletePrefDescLinesByPrefDescIds(request: carriers.Preference_DeletePrefDescLinesByPrefDescIdsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePrefDescLinesByPrefDescIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete the PrefDescLines associated with Preference Description Ids in the SuperOffice database
     * @param request - PrefDescIds
     * @returns Nothing
     */
    public async DeletePrefDescLinesByPrefDescIds(request: carriers.Preference_DeletePrefDescLinesByPrefDescIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete the PrefDescLines associated with Preference Description Ids in the SuperOffice database
     * @param prefDescIds - Primary keys of the Preference Descriptions that contains PrefDescLines to delete
     * @returns Nothing
     */
    public async DeletePrefDescLinesByPrefDescIds(prefDescIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeletePrefDescLinesByPrefDescIds(prefDescIds:number[]|carriers.Preference_DeletePrefDescLinesByPrefDescIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_DeletePrefDescLinesByPrefDescIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = prefDescIds;
        if( typeof( first ) === "object" && first && ( typeof(first.PrefDescIds)!='undefined' ) )
        {
            _request = prefDescIds as carriers.Preference_DeletePrefDescLinesByPrefDescIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PrefDescIds: prefDescIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeletePrefDescLinesByPrefDescIds( _request, _options );
    }


    private async _GetPreferences(request: carriers.Preference_GetPreferencesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Preference[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferences", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Preference[] = converters.Create_PreferenceArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get one or more preferences based on a set of specifications.&lt;br/&gt;The prefDisplayvalue and prefDisplaytooltip are blank (faster processing relative to GetPreferencesWithDisplayValues)
     * @param request - Specifications
     * @returns Array of preference values for your given specification(s). More strictly: 'all keys actually set at any accessible level for this associate'; you will NOT get entries for preferences that might exist, but have no set value anywhere.
     */
    public async GetPreferences(request: carriers.Preference_GetPreferencesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] >;

    /**
     * Get one or more preferences based on a set of specifications.&lt;br/&gt;The prefDisplayvalue and prefDisplaytooltip are blank (faster processing relative to GetPreferencesWithDisplayValues)
     * @param specifications - Array of preference specifications. The key value may be * (asterisk), which means 'all keys within section'. Note that the semantics of this are more strictly 'all keys actually set at any accessible level for this associate'; you will NOT get entries for preferences that might exist, but have no set value anywhere. You can also have askerisk as the section name. In that case the specification array must contain exactly one entry and the key must also be asterisk. This will return all known preferences in all sections for your associate. It might be a lot, tests have shown that a heavily used database can accumulate up to 500 preferences on a single associate. If the Sentry table/field right preferences have been used, the number could be a lot greater!
     * @returns Array of preference values for your given specification(s). More strictly: 'all keys actually set at any accessible level for this associate'; you will NOT get entries for preferences that might exist, but have no set value anywhere.
     */
    public async GetPreferences(specifications: carriers.PreferenceSpec[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] >;

    public async GetPreferences(specifications:carriers.PreferenceSpec[]|carriers.Preference_GetPreferencesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] > {
        let _request : carriers.Preference_GetPreferencesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = specifications;
        if( typeof( first ) === "object" && first && ( typeof(first.Specifications)!='undefined' ) )
        {
            _request = specifications as carriers.Preference_GetPreferencesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Specifications: specifications as carriers.PreferenceSpec[],
                       };   
            _options = webapi_options;
        }
        return this._GetPreferences( _request, _options );
    }


    private async _SavePreferences(request: carriers.Preference_SavePreferencesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreferences", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save this set of preferences. Note this method DOES NOT look at level/targetId - it only saves on behalf of the CURRENT USER.
     * @param request - Preferences
     * @returns 
     */
    public async SavePreferences(request: carriers.Preference_SavePreferencesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Save this set of preferences. Note this method DOES NOT look at level/targetId - it only saves on behalf of the CURRENT USER.
     * @param preferences - Preferences to be saved. Note that all fields must be filled in, and the preference will be saved on the Associate level only! Setting for other levels is an administrative task and not available through this service.
     * @returns 
     */
    public async SavePreferences(preferences: carriers.Preference[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SavePreferences(preferences:carriers.Preference[]|carriers.Preference_SavePreferencesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_SavePreferencesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = preferences;
        if( typeof( first ) === "object" && first && ( typeof(first.Preferences)!='undefined' ) )
        {
            _request = preferences as carriers.Preference_SavePreferencesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Preferences: preferences as carriers.Preference[],
                       };   
            _options = webapi_options;
        }
        return this._SavePreferences( _request, _options );
    }


    private async _GetPreferencesWithDisplayValues(request: carriers.Preference_GetPreferencesWithDisplayValuesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Preference[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferencesWithDisplayValues", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Preference[] = converters.Create_PreferenceArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get one or more preferences based on a set of specifications&lt;br/&gt;The PrefDisplayValue and PrefDisplaytooltip are populated, at some additional processing cost.
     * @param request - Specifications
     * @returns Array of preference values for your given specification(s). More strictly: 'all keys actually set at any accessible level for this associate'; you will NOT get entries for preferences that might exist, but have no set value anywhere.<br/>The PrefDisplayValue and PrefDisplaytooltip are populated, at some additional processing cost.
     */
    public async GetPreferencesWithDisplayValues(request: carriers.Preference_GetPreferencesWithDisplayValuesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] >;

    /**
     * Get one or more preferences based on a set of specifications&lt;br/&gt;The PrefDisplayValue and PrefDisplaytooltip are populated, at some additional processing cost.
     * @param specifications - Array of preference specifications. The key value may be * (asterisk), which means 'all keys within section'. Note that the semantics of this are more strictly 'all keys actually set at any accessible level for this associate'; you will NOT get entries for preferences that might exist, but have no set value anywhere. You can also have askerisk as the section name. In that case the specification array must contain exactly one entry and the key must also be asterisk. This will return all known preferences in all sections for your associate. It might be a lot, tests have shown that a heavily used database can accumulate up to 500 preferences on a single associate. If the Sentry table/field right preferences have been used, the number could be a lot greater!
     * @returns Array of preference values for your given specification(s). More strictly: 'all keys actually set at any accessible level for this associate'; you will NOT get entries for preferences that might exist, but have no set value anywhere.<br/>The PrefDisplayValue and PrefDisplaytooltip are populated, at some additional processing cost.
     */
    public async GetPreferencesWithDisplayValues(specifications: carriers.PreferenceSpec[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] >;

    public async GetPreferencesWithDisplayValues(specifications:carriers.PreferenceSpec[]|carriers.Preference_GetPreferencesWithDisplayValuesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Preference[] > {
        let _request : carriers.Preference_GetPreferencesWithDisplayValuesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = specifications;
        if( typeof( first ) === "object" && first && ( typeof(first.Specifications)!='undefined' ) )
        {
            _request = specifications as carriers.Preference_GetPreferencesWithDisplayValuesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Specifications: specifications as carriers.PreferenceSpec[],
                       };   
            _options = webapi_options;
        }
        return this._GetPreferencesWithDisplayValues( _request, _options );
    }


    private async _GetTabOrders( options?:base.WebApiRequestOptions) : Promise< carriers.TabOrder[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TabOrder[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTabOrders", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TabOrder[] = converters.Create_TabOrderArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * 
     * @returns 
     */
    public async GetTabOrders(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TabOrder[] >
    {
        return this._GetTabOrders(webapi_options);
    }


    private async _SaveTabOrders(request: carriers.Preference_SaveTabOrdersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTabOrders", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - TabOrders
     * @returns 
     */
    public async SaveTabOrders(request: carriers.Preference_SaveTabOrdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * 
     * @param tabOrders - 
     * @returns 
     */
    public async SaveTabOrders(tabOrders: carriers.TabOrder[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveTabOrders(tabOrders:carriers.TabOrder[]|carriers.Preference_SaveTabOrdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_SaveTabOrdersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tabOrders;
        if( typeof( first ) === "object" && first && ( typeof(first.TabOrders)!='undefined' ) )
        {
            _request = tabOrders as carriers.Preference_SaveTabOrdersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TabOrders: tabOrders as carriers.TabOrder[],
                       };   
            _options = webapi_options;
        }
        return this._SaveTabOrders( _request, _options );
    }


    private async _SavePreferenceEntities(request: carriers.Preference_SavePreferenceEntitiesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreferenceEntities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save this set of preferences.
     * @param request - Preferences, RemoveLowerLevels
     * @returns 
     */
    public async SavePreferenceEntities(request: carriers.Preference_SavePreferenceEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Save this set of preferences.
     * @param preferences - Preferences to be saved. Note that all fields must be filled in.
     * @param removeLowerLevels - If this is true, all user preferences on lower levels will be deleted
     * @returns 
     */
    public async SavePreferenceEntities(preferences: carriers.Preference[], removeLowerLevels: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SavePreferenceEntities(preferences:carriers.Preference[]|carriers.Preference_SavePreferenceEntitiesRequest, removeLowerLevels?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Preference_SavePreferenceEntitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = preferences;
        if( typeof( first ) === "object" && first && ( typeof(first.Preferences)!='undefined' || typeof(first.RemoveLowerLevels)!='undefined' ) )
        {
            _request = preferences as carriers.Preference_SavePreferenceEntitiesRequest;
            _options = removeLowerLevels as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Preferences: preferences as carriers.Preference[],
                       RemoveLowerLevels: removeLowerLevels as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SavePreferenceEntities( _request, _options );
    }

    } // class v1PreferenceAgentController 



// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/AppointmentAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Collection of all services that works with Appointment data.
 */
export interface IAppointmentAgent {
    CreateDefaultAppointmentEntity(): Promise< carriers.AppointmentEntity >;
    SaveAppointmentEntity(entity: carriers.AppointmentEntity) : Promise< carriers.AppointmentEntity >;
    DeleteAppointmentEntity(AppointmentEntityId: number) : Promise<void>;
    CreateDefaultSuggestedAppointmentEntity(): Promise< carriers.SuggestedAppointmentEntity >;
    SaveSuggestedAppointmentEntity(entity: carriers.SuggestedAppointmentEntity) : Promise< carriers.SuggestedAppointmentEntity >;
    CreateDefaultTaskListItem(): Promise< carriers.TaskListItem >;
    SaveTaskListItem(entity: carriers.TaskListItem) : Promise< carriers.TaskListItem >;
    GetAppointment(appointmentId: number) :  Promise< carriers.Appointment >;
    ToggleAppointmentStatus(request: carriers.Appointment_ToggleAppointmentStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.AppointmentStatus >;
    ToggleAppointmentStatus(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< enums.AppointmentStatus >;
    ToggleActivity(request: carriers.Appointment_ToggleActivityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus >;
    ToggleActivity(activityIdentifier: string, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus >;
    ToggleActivities(request: carriers.Appointment_ToggleActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus >;
    ToggleActivities(activityIdentifier: string[], webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus >;
    SetActivityStatus(request: carriers.Appointment_SetActivityStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetActivityStatus(activityIdentifier: string[], activityStatus: enums.ActivityStatus, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ToggleAndSetActivities(request: carriers.Appointment_ToggleAndSetActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    ToggleAndSetActivities(activityIdentifiers: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetAppointmentEntity(appointmentEntityId: number) :  Promise< carriers.AppointmentEntity >;
    CreateDefaultAppointmentEntityByType(request: carriers.Appointment_CreateDefaultAppointmentEntityByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CreateDefaultAppointmentEntityByType(type: enums.TaskType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    Accept(request: carriers.Appointment_AcceptRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Accept(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateAndAccept(request: carriers.Appointment_CreateAndAcceptRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateAndAccept(emailItemId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AcceptWithEmailConfirmation(request: carriers.Appointment_AcceptWithEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AcceptWithEmailConfirmation(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateAndAcceptWithEmailConfirmation(request: carriers.Appointment_CreateAndAcceptWithEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateAndAcceptWithEmailConfirmation(emailItemId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Reject(request: carriers.Appointment_RejectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Reject(appointmentId: number, rejectReason: string, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RejectWithEmailConfirmation(request: carriers.Appointment_RejectWithEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RejectWithEmailConfirmation(appointmentId: number, rejectReason: string, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeclineInvitationFromEmailItem(request: carriers.Appointment_DeclineInvitationFromEmailItemRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeclineInvitationFromEmailItem(emailItemId: number, rejectReason: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetOrganizerName(request: carriers.Appointment_GetOrganizerNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetOrganizerName(motherAppointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    Save(request: carriers.Appointment_SaveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    Save(appointmentEntity: carriers.AppointmentEntity, updateMode: enums.RecurrenceUpdateMode, sendEmailToParticipants: boolean, smtpEMailConnectionInfo: carriers.EMailConnectionInfo, imapEMailConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    Delete(request: carriers.Appointment_DeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Delete(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, sendEmailToParticipants: boolean, smtpEMailConnectionInfo: carriers.EMailConnectionInfo, imapEMailConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CalculateDays(request: carriers.Appointment_CalculateDaysRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;
    CalculateDays(appointmentEntity: carriers.AppointmentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;
    ValidateDays(request: carriers.Appointment_ValidateDaysRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceDate[] >;
    ValidateDays(appointmentEntity: carriers.AppointmentEntity, dates: Date[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceDate[] >;
    CreateDefaultRecurrence(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;
    AssignTo(request: carriers.Appointment_AssignToRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    AssignTo(appointmentId: number, participant: carriers.ParticipantInfo, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    SetSeen(request: carriers.Appointment_SetSeenRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetSeen(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetSeenMany(request: carriers.Appointment_SetSeenManyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetSeenMany(appointmentIds: number[], updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Move(request: carriers.Appointment_MoveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    Move(appointmentId: number, newStartTime: Date, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    AcceptRejected(request: carriers.Appointment_AcceptRejectedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    AcceptRejected(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CreateDefaultRecurrenceByDate(request: carriers.Appointment_CreateDefaultRecurrenceByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;
    CreateDefaultRecurrenceByDate(startDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;
    CleanUpBookingDeleted(request: carriers.Appointment_CleanUpBookingDeletedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CleanUpBookingDeleted(appointmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CleanUpBookingDeletedWithUpdateMode(request: carriers.Appointment_CleanUpBookingDeletedWithUpdateModeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CleanUpBookingDeletedWithUpdateMode(appointmentIds: number[], updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CleanUpRecurringBookingDeleted(webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CreateDefaultAppointmentEntityByTypeAndAssociate(request: carriers.Appointment_CreateDefaultAppointmentEntityByTypeAndAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CreateDefaultAppointmentEntityByTypeAndAssociate(type: enums.TaskType, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    GetCanInsertForAssociates(request: carriers.Appointment_GetCanInsertForAssociatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean[] >;
    GetCanInsertForAssociates(associateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< boolean[] >;
    GetAppointmentHaveParticipantsWithEmail(request: carriers.Appointment_GetAppointmentHaveParticipantsWithEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetAppointmentHaveParticipantsWithEmail(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CreateDefaultAppointmentEntityFromSaleSuggestion(request: carriers.Appointment_CreateDefaultAppointmentEntityFromSaleSuggestionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CreateDefaultAppointmentEntityFromSaleSuggestion(suggestedAppointmentId: number, saleId: number, createNow: boolean, ownerId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    GetNextSuggestedAppointmentBySale(request: carriers.Appointment_GetNextSuggestedAppointmentBySaleRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointment >;
    GetNextSuggestedAppointmentBySale(saleId: number, currentAppointmentId: number, skipCompleteCheck: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointment >;
    CreateDefaultReOpenAppointment(request: carriers.Appointment_CreateDefaultReOpenAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CreateDefaultReOpenAppointment(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CreateDefaultAppointmentEntityFromProjectSuggestion(request: carriers.Appointment_CreateDefaultAppointmentEntityFromProjectSuggestionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CreateDefaultAppointmentEntityFromProjectSuggestion(suggestedAppointmentId: number, projectId: number, createNow: boolean, ownerId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CreateAppointmentForUID(request: carriers.Appointment_CreateAppointmentForUIDRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CreateAppointmentForUID(appointmentEntity: carriers.AppointmentEntity, uID: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    GetAppointmentFromUID(request: carriers.Appointment_GetAppointmentFromUIDRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    GetAppointmentFromUID(uID: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;
    CanAssignToProjectMember(request: carriers.Appointment_CanAssignToProjectMemberRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CanAssignToProjectMember(projectId: number, suggestedAppointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetUIDFromAppointmentId(request: carriers.Appointment_GetUIDFromAppointmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetUIDFromAppointmentId(appointmentId: number, useMotherId: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    UpdateAppointmentFromIcsResponse(request: carriers.Appointment_UpdateAppointmentFromIcsResponseRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    UpdateAppointmentFromIcsResponse(emailAddress: string, icsData: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ValidateAppointmentEntity(request: carriers.Appointment_ValidateAppointmentEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    ValidateAppointmentEntity(appointmentEntity: carriers.AppointmentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    WillSendEmail(request: carriers.Appointment_WillSendEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    WillSendEmail(appointment: carriers.AppointmentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    AcceptWithSmtpEmailConfirmation(request: carriers.Appointment_AcceptWithSmtpEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AcceptWithSmtpEmailConfirmation(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, smtpEMailConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RejectWithSmtpEmailConfirmation(request: carriers.Appointment_RejectWithSmtpEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RejectWithSmtpEmailConfirmation(appointmentId: number, rejectReason: string, updateMode: enums.RecurrenceUpdateMode, smtpEMailConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetAppointmentList(appointmentIds: number[]) :  Promise< carriers.Appointment[] >;
    GetMyAppointments(request: carriers.Appointment_GetMyAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetMyAppointments(startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointments(request: carriers.Appointment_GetPersonAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointments(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetMyDiary(request: carriers.Appointment_GetMyDiaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetMyDiary(startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetMyTasks(request: carriers.Appointment_GetMyTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetMyTasks(count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonDiary(request: carriers.Appointment_GetPersonDiaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonDiary(personId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonTasks(request: carriers.Appointment_GetPersonTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonTasks(personId: number, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointmentsByType(request: carriers.Appointment_GetPersonAppointmentsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointmentsByType(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, appointmentType: enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointments(request: carriers.Appointment_GetProjectAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointments(projectId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointmentsByType(request: carriers.Appointment_GetProjectAppointmentsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointmentsByType(projectId: number, startTime: Date, endTime: Date, count: number, appointmentType: enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointments(request: carriers.Appointment_GetContactAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointments(contactId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointmentsByType(request: carriers.Appointment_GetContactAppointmentsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointmentsByType(contactId: number, startTime: Date, endTime: Date, count: number, appointmentType: enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointments(request: carriers.Appointment_GetProjectMemberAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointments(personId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointmentsByType(request: carriers.Appointment_GetProjectMemberAppointmentsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointmentsByType(personId: number, startTime: Date, endTime: Date, count: number, appointmentType: enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointmentsByTask(request: carriers.Appointment_GetPersonAppointmentsByTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointmentsByTask(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, taskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointmentsByTasks(request: carriers.Appointment_GetPersonAppointmentsByTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointmentsByTasks(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, taskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointmentsByTaskHeading(request: carriers.Appointment_GetPersonAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPersonAppointmentsByTaskHeading(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointmentsByTask(request: carriers.Appointment_GetProjectAppointmentsByTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointmentsByTask(projectId: number, startTime: Date, endTime: Date, count: number, taskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointmentsByTasks(request: carriers.Appointment_GetProjectAppointmentsByTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointmentsByTasks(projectId: number, startTime: Date, endTime: Date, count: number, taskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointmentsByTaskHeading(request: carriers.Appointment_GetProjectAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectAppointmentsByTaskHeading(projectId: number, startTime: Date, endTime: Date, count: number, taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointmentsByTask(request: carriers.Appointment_GetProjectMemberAppointmentsByTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointmentsByTask(personId: number, startTime: Date, endTime: Date, count: number, taskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointmentsByTasks(request: carriers.Appointment_GetProjectMemberAppointmentsByTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointmentsByTasks(personId: number, startTime: Date, endTime: Date, count: number, taskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointmentsByTaskHeading(request: carriers.Appointment_GetProjectMemberAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetProjectMemberAppointmentsByTaskHeading(personId: number, startTime: Date, endTime: Date, count: number, taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointmentsByTask(request: carriers.Appointment_GetContactAppointmentsByTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointmentsByTask(contactId: number, startTime: Date, endTime: Date, count: number, taskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointmentsByTasks(request: carriers.Appointment_GetContactAppointmentsByTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointmentsByTasks(contactId: number, startTime: Date, endTime: Date, count: number, taskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointmentsByTaskHeading(request: carriers.Appointment_GetContactAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetContactAppointmentsByTaskHeading(contactId: number, startTime: Date, endTime: Date, count: number, taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPublishedAppointment(request: carriers.Appointment_GetPublishedAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;
    GetPublishedAppointment(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;
    GetPublishedAppointments(request: carriers.Appointment_GetPublishedAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPublishedAppointments(appointmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetMyPublishedAppointments(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPublishedProjectAppointments(request: carriers.Appointment_GetPublishedProjectAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetPublishedProjectAppointments(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetAppointmentsByTaskHeading(request: carriers.Appointment_GetAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetAppointmentsByTaskHeading(taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetAssociateDiary(request: carriers.Appointment_GetAssociateDiaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetAssociateDiary(associateId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetDiaryByGroup(request: carriers.Appointment_GetDiaryByGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetDiaryByGroup(groupId: number, groupType: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    UpdateAppointment(request: carriers.Appointment_UpdateAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;
    UpdateAppointment(id: number, startTime: Date, endTime: Date, status: number, type: number, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;
    GetAssociatesDiary(request: carriers.Appointment_GetAssociatesDiaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetAssociatesDiary(associateIds: number[], startTime: Date, endTime: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetAppointmentRecords(request: carriers.Appointment_GetAppointmentRecordsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetAppointmentRecords(motherId: number, recurrenceRuleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;
    GetMySyncAppointments(request: carriers.Appointment_GetMySyncAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentSyncData[] >;
    GetMySyncAppointments(startTime: Date, endTime: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentSyncData[] >;
    GetDayInformationListByDatesAndAssociate(request: carriers.Appointment_GetDayInformationListByDatesAndAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DayInformationListItem[] >;
    GetDayInformationListByDatesAndAssociate(startDate: Date, endDate: Date, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DayInformationListItem[] >;
    GetActivityInformationListByDatesAndAssociate(request: carriers.Appointment_GetActivityInformationListByDatesAndAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ActivityInformationListItem[] >;
    GetActivityInformationListByDatesAndAssociate(startDate: Date, endDate: Date, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ActivityInformationListItem[] >;
    GetRedLetterInformationListByDatesAndAssociate(request: carriers.Appointment_GetRedLetterInformationListByDatesAndAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RedLetterInformationListItem[] >;
    GetRedLetterInformationListByDatesAndAssociate(startDate: Date, endDate: Date, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RedLetterInformationListItem[] >;
    GetAlarms(request: carriers.Appointment_GetAlarmsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MultiAlarmData >;
    GetAlarms(includeInvitations: boolean, includeAllAppointments: boolean, defaultAlarmLeadTimeInMinutes: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MultiAlarmData >;
    GenerateLead(request: carriers.Appointment_GenerateLeadRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity >;
    GenerateLead(associateIdForNewContact: number, leadDescription: string, relation: string, relationId: number, leadContact: string, leadPersonFirstname: string, leadPersonLastname: string, leadPersonEmail: string, leadPhoneNumber: string, creatorsContact: string, creatorsFirstname: string, creatorsLastname: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity >;
    RequestForInfo(request: carriers.Appointment_RequestForInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity >;
    RequestForInfo(associateIdForNewContact: number, channel: string, regarding: string, contactName: string, personFirstname: string, personLastname: string, emailAddress: string, phoneNumber: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity >;
    GetSuggestedAppointment(suggestedAppointmentId: number) :  Promise< carriers.SuggestedAppointment >;
    GetSuggestedAppointmentEntity(suggestedAppointmentEntityId: number) :  Promise< carriers.SuggestedAppointmentEntity >;
    GetTaskListItem(taskListItemId: number) :  Promise< carriers.TaskListItem >;
    GetTaskListItems(request: carriers.Appointment_GetTaskListItemsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] >;
    GetTaskListItems(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] >;
} // interface IAppointmentAgent




/**
 * Collection of all services that works with Appointment data.
 */
export class AppointmentAgent extends base.WebApiBase implements IAppointmentAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Appointment/";
        super(options);
    }



    /**
     * Set default values into a new AppointmentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultAppointmentEntity(options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultAppointmentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing AppointmentEntity or creates a new AppointmentEntity if the id parameter is empty
     * @param entity - The AppointmentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated AppointmentEntity
     */
    public async SaveAppointmentEntity(entity: carriers.AppointmentEntity, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveAppointmentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the AppointmentEntity
     * @param AppointmentEntityId - The id of the AppointmentEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteAppointmentEntity(AppointmentEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteAppointmentEntity?AppointmentEntityId=" + AppointmentEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new SuggestedAppointmentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSuggestedAppointmentEntity(options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SuggestedAppointmentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSuggestedAppointmentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SuggestedAppointmentEntity = converters.Create_SuggestedAppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SuggestedAppointmentEntity or creates a new SuggestedAppointmentEntity if the id parameter is empty
     * @param entity - The SuggestedAppointmentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SuggestedAppointmentEntity
     */
    public async SaveSuggestedAppointmentEntity(entity: carriers.SuggestedAppointmentEntity, options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SuggestedAppointmentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSuggestedAppointmentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SuggestedAppointmentEntity = converters.Create_SuggestedAppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new TaskListItem.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultTaskListItem(options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskListItem >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTaskListItem", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TaskListItem = converters.Create_TaskListItem_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TaskListItem or creates a new TaskListItem if the id parameter is empty
     * @param entity - The TaskListItem to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TaskListItem
     */
    public async SaveTaskListItem(entity: carriers.TaskListItem, options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskListItem >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTaskListItem", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TaskListItem = converters.Create_TaskListItem_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Appointment object.
     * @param appointmentId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Appointment
     */
    public async GetAppointment(appointmentId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAppointment?appointmentId=" + appointmentId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Appointment_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _ToggleAppointmentStatus(request: carriers.Appointment_ToggleAppointmentStatusRequest, options?:base.WebApiRequestOptions) : Promise< enums.AppointmentStatus > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< enums.AppointmentStatus >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleAppointmentStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : enums.AppointmentStatus = response.data as enums.AppointmentStatus;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets an appointment&apos;s status to Completed if the appointment had a different status, or sets the status to started if already set to completed.
     * @param request - AppointmentId
     * @returns The new AppointmentStatus
     */
    public async ToggleAppointmentStatus(request: carriers.Appointment_ToggleAppointmentStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.AppointmentStatus >;

    /**
     * Sets an appointment&apos;s status to Completed if the appointment had a different status, or sets the status to started if already set to completed.
     * @param appointmentId - The appointment id.
     * @returns The new AppointmentStatus
     */
    public async ToggleAppointmentStatus(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< enums.AppointmentStatus >;

    public async ToggleAppointmentStatus(appointmentId:number|carriers.Appointment_ToggleAppointmentStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.AppointmentStatus > {
        let _request : carriers.Appointment_ToggleAppointmentStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_ToggleAppointmentStatusRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._ToggleAppointmentStatus( _request, _options );
    }


    private async _ToggleActivity(request: carriers.Appointment_ToggleActivityRequest, options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< enums.ActivityStatus >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleActivity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : enums.ActivityStatus = response.data as enums.ActivityStatus;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Toggle the completed status for an activity. Activity may be sale, document or appointment. The changes are saved immediately. 
     * @param request - ActivityIdentifier
     * @returns What the result after toggling was.
     */
    public async ToggleActivity(request: carriers.Appointment_ToggleActivityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus >;

    /**
     * Toggle the completed status for an activity. Activity may be sale, document or appointment. The changes are saved immediately. 
     * @param activityIdentifier - May contain of a mix of appointment_id, sale_id, document_id and todo_id
     * @returns What the result after toggling was.
     */
    public async ToggleActivity(activityIdentifier: string, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus >;

    public async ToggleActivity(activityIdentifier:string|carriers.Appointment_ToggleActivityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus > {
        let _request : carriers.Appointment_ToggleActivityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = activityIdentifier;
        if( typeof( first ) === "object" && first && ( typeof(first.ActivityIdentifier)!='undefined' ) )
        {
            _request = activityIdentifier as carriers.Appointment_ToggleActivityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ActivityIdentifier: activityIdentifier as string,
                       };   
            _options = webapi_options;
        }
        return this._ToggleActivity( _request, _options );
    }


    private async _ToggleActivities(request: carriers.Appointment_ToggleActivitiesRequest, options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< enums.ActivityStatus >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleActivities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : enums.ActivityStatus = response.data as enums.ActivityStatus;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Toggle the completed status for an array of activities. 
     * @param request - ActivityIdentifier
     * @returns The resulting ActivityStatus of the first in the array
     */
    public async ToggleActivities(request: carriers.Appointment_ToggleActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus >;

    /**
     * Toggle the completed status for an array of activities. 
     * @param activityIdentifier - Contain of a mix of appointment_id, sale_id, document_id and todo_id.
     * @returns The resulting ActivityStatus of the first in the array
     */
    public async ToggleActivities(activityIdentifier: string[], webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus >;

    public async ToggleActivities(activityIdentifier:string[]|carriers.Appointment_ToggleActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ActivityStatus > {
        let _request : carriers.Appointment_ToggleActivitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = activityIdentifier;
        if( typeof( first ) === "object" && first && ( typeof(first.ActivityIdentifier)!='undefined' ) )
        {
            _request = activityIdentifier as carriers.Appointment_ToggleActivitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ActivityIdentifier: activityIdentifier as string[],
                       };   
            _options = webapi_options;
        }
        return this._ToggleActivities( _request, _options );
    }


    private async _SetActivityStatus(request: carriers.Appointment_SetActivityStatusRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetActivityStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets the completed status for an array of activities. The string activityIdentifier param may contain of a mix of appointment_id, sale_id, document_id and todo_id. The changes are saved immediately. If an invalid id is passed in (nonexistent record), no changes will be made. If there is no write access to the record being changed, a Sentry exception will be thrown in the usual manner.
     * @param request - ActivityIdentifier, ActivityStatus
     * @returns 
     */
    public async SetActivityStatus(request: carriers.Appointment_SetActivityStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sets the completed status for an array of activities. The string activityIdentifier param may contain of a mix of appointment_id, sale_id, document_id and todo_id. The changes are saved immediately. If an invalid id is passed in (nonexistent record), no changes will be made. If there is no write access to the record being changed, a Sentry exception will be thrown in the usual manner.
     * @param activityIdentifier - Array of activity ids. ex. appointment_id=666
     * @param activityStatus - The status to set the activities
     * @returns 
     */
    public async SetActivityStatus(activityIdentifier: string[], activityStatus: enums.ActivityStatus, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetActivityStatus(activityIdentifier:string[]|carriers.Appointment_SetActivityStatusRequest, activityStatus?:enums.ActivityStatus|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_SetActivityStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = activityIdentifier;
        if( typeof( first ) === "object" && first && ( typeof(first.ActivityIdentifier)!='undefined' || typeof(first.ActivityStatus)!='undefined' ) )
        {
            _request = activityIdentifier as carriers.Appointment_SetActivityStatusRequest;
            _options = activityStatus as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ActivityIdentifier: activityIdentifier as string[],
                       ActivityStatus: activityStatus as enums.ActivityStatus,
                       };   
            _options = webapi_options;
        }
        return this._SetActivityStatus( _request, _options );
    }


    private async _ToggleAndSetActivities(request: carriers.Appointment_ToggleAndSetActivitiesRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleAndSetActivities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Toggles the first activity and sets the rest of the activities to the result of the first toggle. However, there are some special rules for appointments that trigger a suggested appointment when they are completed. If more than one appointment in the set of identifiers triggers a suggestion, we will not toggle those appointments. This rule is only active when changing the status of an appointment to complete. There must be more than one appointment that triggers such an event for this rule to take effect.
     * @param request - ActivityIdentifiers
     * @returns The identifiers that were not toggled.
     */
    public async ToggleAndSetActivities(request: carriers.Appointment_ToggleAndSetActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Toggles the first activity and sets the rest of the activities to the result of the first toggle. However, there are some special rules for appointments that trigger a suggested appointment when they are completed. If more than one appointment in the set of identifiers triggers a suggestion, we will not toggle those appointments. This rule is only active when changing the status of an appointment to complete. There must be more than one appointment that triggers such an event for this rule to take effect.
     * @param activityIdentifiers - Array of activity ids. ex. appointment_id=666
     * @returns The identifiers that were not toggled.
     */
    public async ToggleAndSetActivities(activityIdentifiers: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async ToggleAndSetActivities(activityIdentifiers:string[]|carriers.Appointment_ToggleAndSetActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.Appointment_ToggleAndSetActivitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = activityIdentifiers;
        if( typeof( first ) === "object" && first && ( typeof(first.ActivityIdentifiers)!='undefined' ) )
        {
            _request = activityIdentifiers as carriers.Appointment_ToggleAndSetActivitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ActivityIdentifiers: activityIdentifiers as string[],
                       };   
            _options = webapi_options;
        }
        return this._ToggleAndSetActivities( _request, _options );
    }

    /*
     * Gets a AppointmentEntity object.
     * @param appointmentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single AppointmentEntity
     */
    public async GetAppointmentEntity(appointmentEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAppointmentEntity?appointmentEntityId=" + appointmentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _CreateDefaultAppointmentEntityByType(request: carriers.Appointment_CreateDefaultAppointmentEntityByTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultAppointmentEntityByType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a AppointmentEntity populated with the default values for the specific type.
     * @param request - Type
     * @returns AppointmentEntity with default values.
     */
    public async CreateDefaultAppointmentEntityByType(request: carriers.Appointment_CreateDefaultAppointmentEntityByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * Creates a AppointmentEntity populated with the default values for the specific type.
     * @param type - The type of task requested.
     * @returns AppointmentEntity with default values.
     */
    public async CreateDefaultAppointmentEntityByType(type: enums.TaskType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async CreateDefaultAppointmentEntityByType(type:enums.TaskType|carriers.Appointment_CreateDefaultAppointmentEntityByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_CreateDefaultAppointmentEntityByTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' ) )
        {
            _request = type as carriers.Appointment_CreateDefaultAppointmentEntityByTypeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as enums.TaskType,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultAppointmentEntityByType( _request, _options );
    }


    private async _Accept(request: carriers.Appointment_AcceptRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Accept", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Accepting an appointment invitation.
     * @param request - AppointmentId, UpdateMode
     * @returns Updated AppointmentEntity
     */
    public async Accept(request: carriers.Appointment_AcceptRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Accepting an appointment invitation.
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param updateMode - Update mode for a recurring appointment.
     * @returns Updated AppointmentEntity
     */
    public async Accept(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Accept(appointmentId:number|carriers.Appointment_AcceptRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_AcceptRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_AcceptRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._Accept( _request, _options );
    }


    private async _CreateAndAccept(request: carriers.Appointment_CreateAndAcceptRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndAccept", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creating an appointment from an emailItem invitation and accepting it.
     * @param request - EmailItemId, UpdateMode
     * @returns 
     */
    public async CreateAndAccept(request: carriers.Appointment_CreateAndAcceptRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Creating an appointment from an emailItem invitation and accepting it.
     * @param emailItemId - The emailItemId
     * @param updateMode - Update mode for a recurring appointment.
     * @returns 
     */
    public async CreateAndAccept(emailItemId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async CreateAndAccept(emailItemId:number|carriers.Appointment_CreateAndAcceptRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_CreateAndAcceptRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailItemId;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailItemId)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = emailItemId as carriers.Appointment_CreateAndAcceptRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailItemId: emailItemId as number,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._CreateAndAccept( _request, _options );
    }


    private async _AcceptWithEmailConfirmation(request: carriers.Appointment_AcceptWithEmailConfirmationRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AcceptWithEmailConfirmation", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Accepting an appointment invitation and send an email confirmation to the meeting organizer.
     * @param request - AppointmentId, UpdateMode
     * @returns Updated AppointmentEntity
     */
    public async AcceptWithEmailConfirmation(request: carriers.Appointment_AcceptWithEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Accepting an appointment invitation and send an email confirmation to the meeting organizer.
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param updateMode - Update mode for a recurring appointment.
     * @returns Updated AppointmentEntity
     */
    public async AcceptWithEmailConfirmation(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AcceptWithEmailConfirmation(appointmentId:number|carriers.Appointment_AcceptWithEmailConfirmationRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_AcceptWithEmailConfirmationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_AcceptWithEmailConfirmationRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._AcceptWithEmailConfirmation( _request, _options );
    }


    private async _CreateAndAcceptWithEmailConfirmation(request: carriers.Appointment_CreateAndAcceptWithEmailConfirmationRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndAcceptWithEmailConfirmation", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creating an appointment from an emailItem invitation and accepting it with email confirmation to the meeting organizer.
     * @param request - EmailItemId, UpdateMode
     * @returns 
     */
    public async CreateAndAcceptWithEmailConfirmation(request: carriers.Appointment_CreateAndAcceptWithEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Creating an appointment from an emailItem invitation and accepting it with email confirmation to the meeting organizer.
     * @param emailItemId - The emailItemId
     * @param updateMode - Update mode for a recurring appointment.
     * @returns 
     */
    public async CreateAndAcceptWithEmailConfirmation(emailItemId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async CreateAndAcceptWithEmailConfirmation(emailItemId:number|carriers.Appointment_CreateAndAcceptWithEmailConfirmationRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_CreateAndAcceptWithEmailConfirmationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailItemId;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailItemId)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = emailItemId as carriers.Appointment_CreateAndAcceptWithEmailConfirmationRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailItemId: emailItemId as number,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._CreateAndAcceptWithEmailConfirmation( _request, _options );
    }


    private async _Reject(request: carriers.Appointment_RejectRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Reject", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Rejecting an appointment invitation
     * @param request - AppointmentId, RejectReason, UpdateMode
     * @returns Updated AppointmentEntity
     */
    public async Reject(request: carriers.Appointment_RejectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Rejecting an appointment invitation
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param rejectReason - The reason the invitation was rejected.
     * @param updateMode - Update mode for a recurring appointment.
     * @returns Updated AppointmentEntity
     */
    public async Reject(appointmentId: number, rejectReason: string, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Reject(appointmentId:number|carriers.Appointment_RejectRequest, rejectReason?:string|base.WebApiRequestOptions, updateMode?:enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_RejectRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.RejectReason)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_RejectRequest;
            _options = rejectReason as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       RejectReason: rejectReason as string,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._Reject( _request, _options );
    }


    private async _RejectWithEmailConfirmation(request: carriers.Appointment_RejectWithEmailConfirmationRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RejectWithEmailConfirmation", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Rejecting an appointment invitation and send an email confirmation to the meeting organizer.
     * @param request - AppointmentId, RejectReason, UpdateMode
     * @returns Updated AppointmentEntity
     */
    public async RejectWithEmailConfirmation(request: carriers.Appointment_RejectWithEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Rejecting an appointment invitation and send an email confirmation to the meeting organizer.
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param rejectReason - The reason the invitation was rejected.
     * @param updateMode - Update mode for a recurring appointment.
     * @returns Updated AppointmentEntity
     */
    public async RejectWithEmailConfirmation(appointmentId: number, rejectReason: string, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RejectWithEmailConfirmation(appointmentId:number|carriers.Appointment_RejectWithEmailConfirmationRequest, rejectReason?:string|base.WebApiRequestOptions, updateMode?:enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_RejectWithEmailConfirmationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.RejectReason)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_RejectWithEmailConfirmationRequest;
            _options = rejectReason as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       RejectReason: rejectReason as string,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._RejectWithEmailConfirmation( _request, _options );
    }


    private async _DeclineInvitationFromEmailItem(request: carriers.Appointment_DeclineInvitationFromEmailItemRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeclineInvitationFromEmailItem", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Declining an appointment invitation where no tentative appointments have been created.
     * @param request - EmailItemId, RejectReason
     * @returns 
     */
    public async DeclineInvitationFromEmailItem(request: carriers.Appointment_DeclineInvitationFromEmailItemRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Declining an appointment invitation where no tentative appointments have been created.
     * @param emailItemId - The emailItemId.
     * @param rejectReason - The reason the invitation was rejected.
     * @returns 
     */
    public async DeclineInvitationFromEmailItem(emailItemId: number, rejectReason: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeclineInvitationFromEmailItem(emailItemId:number|carriers.Appointment_DeclineInvitationFromEmailItemRequest, rejectReason?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_DeclineInvitationFromEmailItemRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailItemId;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailItemId)!='undefined' || typeof(first.RejectReason)!='undefined' ) )
        {
            _request = emailItemId as carriers.Appointment_DeclineInvitationFromEmailItemRequest;
            _options = rejectReason as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailItemId: emailItemId as number,
                       RejectReason: rejectReason as string,
                       };   
            _options = webapi_options;
        }
        return this._DeclineInvitationFromEmailItem( _request, _options );
    }


    private async _GetOrganizerName(request: carriers.Appointment_GetOrganizerNameRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOrganizerName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Lookup the name / email of an event-organizer
     * @param request - MotherAppointmentId
     * @returns The displayed name of the organizer: name or email
     */
    public async GetOrganizerName(request: carriers.Appointment_GetOrganizerNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Lookup the name / email of an event-organizer
     * @param motherAppointmentId - The id of the mother-appointment.
     * @returns The displayed name of the organizer: name or email
     */
    public async GetOrganizerName(motherAppointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetOrganizerName(motherAppointmentId:number|carriers.Appointment_GetOrganizerNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Appointment_GetOrganizerNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = motherAppointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.MotherAppointmentId)!='undefined' ) )
        {
            _request = motherAppointmentId as carriers.Appointment_GetOrganizerNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MotherAppointmentId: motherAppointmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetOrganizerName( _request, _options );
    }


    private async _Save(request: carriers.Appointment_SaveRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Save", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saving a booking.
     * @param request - AppointmentEntity, UpdateMode, SendEmailToParticipants, SmtpEMailConnectionInfo, ImapEMailConnectionInfo
     * @returns Updated AppointmentEntity
     */
    public async Save(request: carriers.Appointment_SaveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * Saving a booking.
     * @param appointmentEntity - 
     * @param updateMode - Update mode for a recurring appointment.
     * @param sendEmailToParticipants - If true, emails will be sent to all participants that is marked with send email flag. If false no mails will be sent even if the send email flag is true.
     * @param smtpEMailConnectionInfo - Login information for outgoing smtp email server. Will be null if no login information is relevant.
     * @param imapEMailConnectionInfo - Login information for imap server. Will be null if no login information is relevant.
     * @returns Updated AppointmentEntity
     */
    public async Save(appointmentEntity: carriers.AppointmentEntity, updateMode: enums.RecurrenceUpdateMode, sendEmailToParticipants: boolean, smtpEMailConnectionInfo: carriers.EMailConnectionInfo, imapEMailConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async Save(appointmentEntity:carriers.AppointmentEntity|carriers.Appointment_SaveRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, sendEmailToParticipants?:boolean, smtpEMailConnectionInfo?:carriers.EMailConnectionInfo, imapEMailConnectionInfo?:carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_SaveRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentEntity)!='undefined' || typeof(first.UpdateMode)!='undefined' || typeof(first.SendEmailToParticipants)!='undefined' || typeof(first.SmtpEMailConnectionInfo)!='undefined' || typeof(first.ImapEMailConnectionInfo)!='undefined' ) )
        {
            _request = appointmentEntity as carriers.Appointment_SaveRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentEntity: appointmentEntity as carriers.AppointmentEntity,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       SendEmailToParticipants: sendEmailToParticipants as boolean,
                       SmtpEMailConnectionInfo: smtpEMailConnectionInfo as carriers.EMailConnectionInfo,
                       ImapEMailConnectionInfo: imapEMailConnectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._Save( _request, _options );
    }


    private async _Delete(request: carriers.Appointment_DeleteRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Delete", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deleting a booking
     * @param request - AppointmentId, UpdateMode, SendEmailToParticipants, SmtpEMailConnectionInfo, ImapEMailConnectionInfo
     * @returns 
     */
    public async Delete(request: carriers.Appointment_DeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deleting a booking
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param updateMode - Update mode for a recurring appointment.
     * @param sendEmailToParticipants - If true, emails will be sent to all participants that is marked with send email flag. If false no mails will be sent even if the send email flag is true.
     * @param smtpEMailConnectionInfo - Login information for outgoing smtp email server. Will be null if no login information is relevant.
     * @param imapEMailConnectionInfo - Login information for imap server. Will be null if no login information is relevant.
     * @returns 
     */
    public async Delete(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, sendEmailToParticipants: boolean, smtpEMailConnectionInfo: carriers.EMailConnectionInfo, imapEMailConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Delete(appointmentId:number|carriers.Appointment_DeleteRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, sendEmailToParticipants?:boolean, smtpEMailConnectionInfo?:carriers.EMailConnectionInfo, imapEMailConnectionInfo?:carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_DeleteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.UpdateMode)!='undefined' || typeof(first.SendEmailToParticipants)!='undefined' || typeof(first.SmtpEMailConnectionInfo)!='undefined' || typeof(first.ImapEMailConnectionInfo)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_DeleteRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       SendEmailToParticipants: sendEmailToParticipants as boolean,
                       SmtpEMailConnectionInfo: smtpEMailConnectionInfo as carriers.EMailConnectionInfo,
                       ImapEMailConnectionInfo: imapEMailConnectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._Delete( _request, _options );
    }


    private async _CalculateDays(request: carriers.Appointment_CalculateDaysRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RecurrenceInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CalculateDays", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RecurrenceInfo = converters.Create_RecurrenceInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Calculates the set of dates that represents a recurrence pattern. Adds conflict information to each date.
     * @param request - AppointmentEntity
     * @returns 
     */
    public async CalculateDays(request: carriers.Appointment_CalculateDaysRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;

    /**
     * Calculates the set of dates that represents a recurrence pattern. Adds conflict information to each date.
     * @param appointmentEntity - 
     * @returns 
     */
    public async CalculateDays(appointmentEntity: carriers.AppointmentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;

    public async CalculateDays(appointmentEntity:carriers.AppointmentEntity|carriers.Appointment_CalculateDaysRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo > {
        let _request : carriers.Appointment_CalculateDaysRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentEntity)!='undefined' ) )
        {
            _request = appointmentEntity as carriers.Appointment_CalculateDaysRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentEntity: appointmentEntity as carriers.AppointmentEntity,
                       };   
            _options = webapi_options;
        }
        return this._CalculateDays( _request, _options );
    }


    private async _ValidateDays(request: carriers.Appointment_ValidateDaysRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceDate[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RecurrenceDate[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateDays", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RecurrenceDate[] = converters.Create_RecurrenceDateArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Validates the set of dates to calculate any conflicts.
     * @param request - AppointmentEntity, Dates
     * @returns Array of RecurrenceDate object for each validated date.
     */
    public async ValidateDays(request: carriers.Appointment_ValidateDaysRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceDate[] >;

    /**
     * Validates the set of dates to calculate any conflicts.
     * @param appointmentEntity - 
     * @param dates - The dates to validate.
     * @returns Array of RecurrenceDate object for each validated date.
     */
    public async ValidateDays(appointmentEntity: carriers.AppointmentEntity, dates: Date[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceDate[] >;

    public async ValidateDays(appointmentEntity:carriers.AppointmentEntity|carriers.Appointment_ValidateDaysRequest, dates?:Date[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceDate[] > {
        let _request : carriers.Appointment_ValidateDaysRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentEntity)!='undefined' || typeof(first.Dates)!='undefined' ) )
        {
            _request = appointmentEntity as carriers.Appointment_ValidateDaysRequest;
            _options = dates as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentEntity: appointmentEntity as carriers.AppointmentEntity,
                       Dates: dates as Date[],
                       };   
            _options = webapi_options;
        }
        return this._ValidateDays( _request, _options );
    }


    private async _CreateDefaultRecurrence( options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RecurrenceInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultRecurrence", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RecurrenceInfo = converters.Create_RecurrenceInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Creates a RecurrenceInfo object populated with the default values for the specific type.
     * @returns RecurrenceInfo object with default values.
     */
    public async CreateDefaultRecurrence(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >
    {
        return this._CreateDefaultRecurrence(webapi_options);
    }


    private async _AssignTo(request: carriers.Appointment_AssignToRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AssignTo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Assigning an appointment to another person.
     * @param request - AppointmentId, Participant, UpdateMode
     * @returns Updated AppointmentEntity
     */
    public async AssignTo(request: carriers.Appointment_AssignToRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * Assigning an appointment to another person.
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param participant - 
     * @param updateMode - Update mode for a recurring appointment.
     * @returns Updated AppointmentEntity
     */
    public async AssignTo(appointmentId: number, participant: carriers.ParticipantInfo, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async AssignTo(appointmentId:number|carriers.Appointment_AssignToRequest, participant?:carriers.ParticipantInfo|base.WebApiRequestOptions, updateMode?:enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_AssignToRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.Participant)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_AssignToRequest;
            _options = participant as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       Participant: participant as carriers.ParticipantInfo,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._AssignTo( _request, _options );
    }


    private async _SetSeen(request: carriers.Appointment_SetSeenRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetSeen", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets an appointment invitiation to seen.
     * @param request - AppointmentId, UpdateMode
     * @returns 
     */
    public async SetSeen(request: carriers.Appointment_SetSeenRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sets an appointment invitiation to seen.
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param updateMode - Update mode for a recurring appointment.
     * @returns 
     */
    public async SetSeen(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetSeen(appointmentId:number|carriers.Appointment_SetSeenRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_SetSeenRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_SetSeenRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._SetSeen( _request, _options );
    }


    private async _SetSeenMany(request: carriers.Appointment_SetSeenManyRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetSeenMany", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets a list of appointment invitations to seen. The same update mode will be used for all appointments in this batch.
     * @param request - AppointmentIds, UpdateMode
     * @returns 
     */
    public async SetSeenMany(request: carriers.Appointment_SetSeenManyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sets a list of appointment invitations to seen. The same update mode will be used for all appointments in this batch.
     * @param appointmentIds - List of appointment IDs
     * @param updateMode - Update mode for a recurring appointment.
     * @returns 
     */
    public async SetSeenMany(appointmentIds: number[], updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetSeenMany(appointmentIds:number[]|carriers.Appointment_SetSeenManyRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_SetSeenManyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentIds)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentIds as carriers.Appointment_SetSeenManyRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentIds: appointmentIds as number[],
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._SetSeenMany( _request, _options );
    }


    private async _Move(request: carriers.Appointment_MoveRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Move", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Moving a booking to another start time.
     * @param request - AppointmentId, NewStartTime, UpdateMode
     * @returns Updated AppointmentEntity
     */
    public async Move(request: carriers.Appointment_MoveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * Moving a booking to another start time.
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param newStartTime - The new start time for the moved booking.
     * @param updateMode - Update mode for a recurring appointment.
     * @returns Updated AppointmentEntity
     */
    public async Move(appointmentId: number, newStartTime: Date, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async Move(appointmentId:number|carriers.Appointment_MoveRequest, newStartTime?:Date|base.WebApiRequestOptions, updateMode?:enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_MoveRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.NewStartTime)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_MoveRequest;
            _options = newStartTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       NewStartTime: newStartTime as Date,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._Move( _request, _options );
    }


    private async _AcceptRejected(request: carriers.Appointment_AcceptRejectedRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AcceptRejected", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Accept that an invited participant has rejected your invitation or assignment.
     * @param request - AppointmentId, UpdateMode
     * @returns Updated AppointmentEntity
     */
    public async AcceptRejected(request: carriers.Appointment_AcceptRejectedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * Accept that an invited participant has rejected your invitation or assignment.
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param updateMode - Update mode for a recurring appointment.
     * @returns Updated AppointmentEntity
     */
    public async AcceptRejected(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async AcceptRejected(appointmentId:number|carriers.Appointment_AcceptRejectedRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_AcceptRejectedRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_AcceptRejectedRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._AcceptRejected( _request, _options );
    }


    private async _CreateDefaultRecurrenceByDate(request: carriers.Appointment_CreateDefaultRecurrenceByDateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RecurrenceInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultRecurrenceByDate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RecurrenceInfo = converters.Create_RecurrenceInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a RecurrenceInfo object populated with the default values for the specific type. Using startDate as start date for the recurreing pattern.
     * @param request - StartDate
     * @returns 
     */
    public async CreateDefaultRecurrenceByDate(request: carriers.Appointment_CreateDefaultRecurrenceByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;

    /**
     * Creates a RecurrenceInfo object populated with the default values for the specific type. Using startDate as start date for the recurreing pattern.
     * @param startDate - Date of which the recurring pattern should start.
     * @returns 
     */
    public async CreateDefaultRecurrenceByDate(startDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;

    public async CreateDefaultRecurrenceByDate(startDate:Date|carriers.Appointment_CreateDefaultRecurrenceByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo > {
        let _request : carriers.Appointment_CreateDefaultRecurrenceByDateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = startDate;
        if( typeof( first ) === "object" && first && ( typeof(first.StartDate)!='undefined' ) )
        {
            _request = startDate as carriers.Appointment_CreateDefaultRecurrenceByDateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StartDate: startDate as Date,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultRecurrenceByDate( _request, _options );
    }


    private async _CleanUpBookingDeleted(request: carriers.Appointment_CleanUpBookingDeletedRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CleanUpBookingDeleted", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes all appointments(within the appointmentIds array) with status BookingDeleted.
     * @param request - AppointmentIds
     * @returns Number of modified or deleted appointments
     */
    public async CleanUpBookingDeleted(request: carriers.Appointment_CleanUpBookingDeletedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Deletes all appointments(within the appointmentIds array) with status BookingDeleted.
     * @param appointmentIds - 
     * @returns Number of modified or deleted appointments
     */
    public async CleanUpBookingDeleted(appointmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async CleanUpBookingDeleted(appointmentIds:number[]|carriers.Appointment_CleanUpBookingDeletedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Appointment_CleanUpBookingDeletedRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentIds)!='undefined' ) )
        {
            _request = appointmentIds as carriers.Appointment_CleanUpBookingDeletedRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentIds: appointmentIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._CleanUpBookingDeleted( _request, _options );
    }


    private async _CleanUpBookingDeletedWithUpdateMode(request: carriers.Appointment_CleanUpBookingDeletedWithUpdateModeRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CleanUpBookingDeletedWithUpdateMode", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes all appointments(within the appointmentIds array) with status BookingDeleted. All appointments in the list will be deleted using the same recurrence update mode.
     * @param request - AppointmentIds, UpdateMode
     * @returns 
     */
    public async CleanUpBookingDeletedWithUpdateMode(request: carriers.Appointment_CleanUpBookingDeletedWithUpdateModeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes all appointments(within the appointmentIds array) with status BookingDeleted. All appointments in the list will be deleted using the same recurrence update mode.
     * @param appointmentIds - List of appointment IDs
     * @param updateMode - Update mode
     * @returns 
     */
    public async CleanUpBookingDeletedWithUpdateMode(appointmentIds: number[], updateMode: enums.RecurrenceUpdateMode, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async CleanUpBookingDeletedWithUpdateMode(appointmentIds:number[]|carriers.Appointment_CleanUpBookingDeletedWithUpdateModeRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_CleanUpBookingDeletedWithUpdateModeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentIds)!='undefined' || typeof(first.UpdateMode)!='undefined' ) )
        {
            _request = appointmentIds as carriers.Appointment_CleanUpBookingDeletedWithUpdateModeRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentIds: appointmentIds as number[],
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       };   
            _options = webapi_options;
        }
        return this._CleanUpBookingDeletedWithUpdateMode( _request, _options );
    }


    private async _CleanUpRecurringBookingDeleted( options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CleanUpRecurringBookingDeleted", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Deletes all appointments with status BookingDeleted and for in logged user.
     * @returns 
     */
    public async CleanUpRecurringBookingDeleted(webapi_options?:base.WebApiRequestOptions) : Promise< number >
    {
        return this._CleanUpRecurringBookingDeleted(webapi_options);
    }


    private async _CreateDefaultAppointmentEntityByTypeAndAssociate(request: carriers.Appointment_CreateDefaultAppointmentEntityByTypeAndAssociateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultAppointmentEntityByTypeAndAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a AppointmentEntity populated with the default values for the specific type and owner.
     * @param request - Type, AssociateId
     * @returns AppointmentEntity with default values.
     */
    public async CreateDefaultAppointmentEntityByTypeAndAssociate(request: carriers.Appointment_CreateDefaultAppointmentEntityByTypeAndAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * Creates a AppointmentEntity populated with the default values for the specific type and owner.
     * @param type - The type of task requested.
     * @param associateId - The associateId of the appointment owner.
     * @returns AppointmentEntity with default values.
     */
    public async CreateDefaultAppointmentEntityByTypeAndAssociate(type: enums.TaskType, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async CreateDefaultAppointmentEntityByTypeAndAssociate(type:enums.TaskType|carriers.Appointment_CreateDefaultAppointmentEntityByTypeAndAssociateRequest, associateId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_CreateDefaultAppointmentEntityByTypeAndAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' || typeof(first.AssociateId)!='undefined' ) )
        {
            _request = type as carriers.Appointment_CreateDefaultAppointmentEntityByTypeAndAssociateRequest;
            _options = associateId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as enums.TaskType,
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultAppointmentEntityByTypeAndAssociate( _request, _options );
    }


    private async _GetCanInsertForAssociates(request: carriers.Appointment_GetCanInsertForAssociatesRequest, options?:base.WebApiRequestOptions) : Promise< boolean[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCanInsertForAssociates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean[] = response.data as boolean[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check if current associate can create appointments in the diary of other associates.
     * @param request - AssociateIds
     * @returns Returns an array of bool corresponding to the associate array input parameter.
     */
    public async GetCanInsertForAssociates(request: carriers.Appointment_GetCanInsertForAssociatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean[] >;

    /**
     * Check if current associate can create appointments in the diary of other associates.
     * @param associateIds - Array of associate ids to check for.
     * @returns Returns an array of bool corresponding to the associate array input parameter.
     */
    public async GetCanInsertForAssociates(associateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< boolean[] >;

    public async GetCanInsertForAssociates(associateIds:number[]|carriers.Appointment_GetCanInsertForAssociatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean[] > {
        let _request : carriers.Appointment_GetCanInsertForAssociatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateIds)!='undefined' ) )
        {
            _request = associateIds as carriers.Appointment_GetCanInsertForAssociatesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateIds: associateIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetCanInsertForAssociates( _request, _options );
    }


    private async _GetAppointmentHaveParticipantsWithEmail(request: carriers.Appointment_GetAppointmentHaveParticipantsWithEmailRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentHaveParticipantsWithEmail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * GetAppointmentHaveParticipantsWithEmail will check if any of the participants is marked to receive emails on this appointment. If no participants are defined, false will be returned.
     * @param request - AppointmentId
     * @returns Return true or false.
     */
    public async GetAppointmentHaveParticipantsWithEmail(request: carriers.Appointment_GetAppointmentHaveParticipantsWithEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * GetAppointmentHaveParticipantsWithEmail will check if any of the participants is marked to receive emails on this appointment. If no participants are defined, false will be returned.
     * @param appointmentId - The appointmentId.
     * @returns Return true or false.
     */
    public async GetAppointmentHaveParticipantsWithEmail(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async GetAppointmentHaveParticipantsWithEmail(appointmentId:number|carriers.Appointment_GetAppointmentHaveParticipantsWithEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Appointment_GetAppointmentHaveParticipantsWithEmailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_GetAppointmentHaveParticipantsWithEmailRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAppointmentHaveParticipantsWithEmail( _request, _options );
    }


    private async _CreateDefaultAppointmentEntityFromSaleSuggestion(request: carriers.Appointment_CreateDefaultAppointmentEntityFromSaleSuggestionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultAppointmentEntityFromSaleSuggestion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates an appointment based on a suggested appointment. 
     * @param request - SuggestedAppointmentId, SaleId, CreateNow, OwnerId
     * @returns The newly created appointment
     */
    public async CreateDefaultAppointmentEntityFromSaleSuggestion(request: carriers.Appointment_CreateDefaultAppointmentEntityFromSaleSuggestionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * Creates an appointment based on a suggested appointment. 
     * @param suggestedAppointmentId - The id of the suggested appointment
     * @param saleId - This is the id of the sale the appointment is connected to. This will be used to give the appointment it's starting date. If the id is 0 or invalid, we assume the start date is now
     * @param createNow - If this parameter is true, we override the suggested start time and create the appointment with the current date and time
     * @param ownerId - 
     * @returns The newly created appointment
     */
    public async CreateDefaultAppointmentEntityFromSaleSuggestion(suggestedAppointmentId: number, saleId: number, createNow: boolean, ownerId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async CreateDefaultAppointmentEntityFromSaleSuggestion(suggestedAppointmentId:number|carriers.Appointment_CreateDefaultAppointmentEntityFromSaleSuggestionRequest, saleId?:number|base.WebApiRequestOptions, createNow?:boolean, ownerId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_CreateDefaultAppointmentEntityFromSaleSuggestionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = suggestedAppointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.SuggestedAppointmentId)!='undefined' || typeof(first.SaleId)!='undefined' || typeof(first.CreateNow)!='undefined' || typeof(first.OwnerId)!='undefined' ) )
        {
            _request = suggestedAppointmentId as carriers.Appointment_CreateDefaultAppointmentEntityFromSaleSuggestionRequest;
            _options = saleId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SuggestedAppointmentId: suggestedAppointmentId as number,
                       SaleId: saleId as number,
                       CreateNow: createNow as boolean,
                       OwnerId: ownerId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultAppointmentEntityFromSaleSuggestion( _request, _options );
    }


    private async _GetNextSuggestedAppointmentBySale(request: carriers.Appointment_GetNextSuggestedAppointmentBySaleRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SuggestedAppointment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextSuggestedAppointmentBySale", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SuggestedAppointment = converters.Create_SuggestedAppointment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the next suggested appointment for a given sale (or rather a given sale&apos;s guide).
     * @param request - SaleId, CurrentAppointmentId, SkipCompleteCheck
     * @returns  The next suggestion based on the sale id of a guided sale and the id of the current apopintment. If we cannot find a next suggestion or the sale is not guided (or if any of the paramters are invalid), we will return null.
     */
    public async GetNextSuggestedAppointmentBySale(request: carriers.Appointment_GetNextSuggestedAppointmentBySaleRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointment >;

    /**
     * Gets the next suggested appointment for a given sale (or rather a given sale&apos;s guide).
     * @param saleId - The identifier of the (guided) sale from which we want to find a suggested appointment
     * @param currentAppointmentId - The identifier of the appointment from which we calculate the next suggestion. The next suggested appointment is the subsequent appointment defined in the SoAdmin's sales guide.
     * @param skipCompleteCheck - If you want to get the next appointment step in a sales guide for an appointment which is not completed, this value must be true. In all other cases, this value should be false, as it would return the value of null if the current appointment is not completes.
     * @returns  The next suggestion based on the sale id of a guided sale and the id of the current apopintment. If we cannot find a next suggestion or the sale is not guided (or if any of the paramters are invalid), we will return null.
     */
    public async GetNextSuggestedAppointmentBySale(saleId: number, currentAppointmentId: number, skipCompleteCheck: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointment >;

    public async GetNextSuggestedAppointmentBySale(saleId:number|carriers.Appointment_GetNextSuggestedAppointmentBySaleRequest, currentAppointmentId?:number|base.WebApiRequestOptions, skipCompleteCheck?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointment > {
        let _request : carriers.Appointment_GetNextSuggestedAppointmentBySaleRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' || typeof(first.CurrentAppointmentId)!='undefined' || typeof(first.SkipCompleteCheck)!='undefined' ) )
        {
            _request = saleId as carriers.Appointment_GetNextSuggestedAppointmentBySaleRequest;
            _options = currentAppointmentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       CurrentAppointmentId: currentAppointmentId as number,
                       SkipCompleteCheck: skipCompleteCheck as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetNextSuggestedAppointmentBySale( _request, _options );
    }


    private async _CreateDefaultReOpenAppointment(request: carriers.Appointment_CreateDefaultReOpenAppointmentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultReOpenAppointment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * A re-open appointment should be created as a reminder to re-open the sale at a certain date with information regarding the stalled sale. 
     * @param request - SaleId
     * @returns The re-open appointment with start date = the re-open date of the sale and a description matching the sales stalled reason. 
     */
    public async CreateDefaultReOpenAppointment(request: carriers.Appointment_CreateDefaultReOpenAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * A re-open appointment should be created as a reminder to re-open the sale at a certain date with information regarding the stalled sale. 
     * @param saleId - The identifier of the stalled sale from which we create a re-open appointment
     * @returns The re-open appointment with start date = the re-open date of the sale and a description matching the sales stalled reason. 
     */
    public async CreateDefaultReOpenAppointment(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async CreateDefaultReOpenAppointment(saleId:number|carriers.Appointment_CreateDefaultReOpenAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_CreateDefaultReOpenAppointmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' ) )
        {
            _request = saleId as carriers.Appointment_CreateDefaultReOpenAppointmentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultReOpenAppointment( _request, _options );
    }


    private async _CreateDefaultAppointmentEntityFromProjectSuggestion(request: carriers.Appointment_CreateDefaultAppointmentEntityFromProjectSuggestionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultAppointmentEntityFromProjectSuggestion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - SuggestedAppointmentId, ProjectId, CreateNow, OwnerId
     * @returns 
     */
    public async CreateDefaultAppointmentEntityFromProjectSuggestion(request: carriers.Appointment_CreateDefaultAppointmentEntityFromProjectSuggestionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * 
     * @param suggestedAppointmentId - 
     * @param projectId - 
     * @param createNow - 
     * @param ownerId - 
     * @returns 
     */
    public async CreateDefaultAppointmentEntityFromProjectSuggestion(suggestedAppointmentId: number, projectId: number, createNow: boolean, ownerId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async CreateDefaultAppointmentEntityFromProjectSuggestion(suggestedAppointmentId:number|carriers.Appointment_CreateDefaultAppointmentEntityFromProjectSuggestionRequest, projectId?:number|base.WebApiRequestOptions, createNow?:boolean, ownerId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_CreateDefaultAppointmentEntityFromProjectSuggestionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = suggestedAppointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.SuggestedAppointmentId)!='undefined' || typeof(first.ProjectId)!='undefined' || typeof(first.CreateNow)!='undefined' || typeof(first.OwnerId)!='undefined' ) )
        {
            _request = suggestedAppointmentId as carriers.Appointment_CreateDefaultAppointmentEntityFromProjectSuggestionRequest;
            _options = projectId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SuggestedAppointmentId: suggestedAppointmentId as number,
                       ProjectId: projectId as number,
                       CreateNow: createNow as boolean,
                       OwnerId: ownerId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultAppointmentEntityFromProjectSuggestion( _request, _options );
    }


    private async _CreateAppointmentForUID(request: carriers.Appointment_CreateAppointmentForUIDRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAppointmentForUID", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create an invitation record and an appointment with a given UID to reserve it if the UID is unused, otherwise null.
     * @param request - AppointmentEntity, UID
     * @returns The newly created AppointmentEntity or null if the UID is in the DB already.
     */
    public async CreateAppointmentForUID(request: carriers.Appointment_CreateAppointmentForUIDRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * Create an invitation record and an appointment with a given UID to reserve it if the UID is unused, otherwise null.
     * @param appointmentEntity - 
     * @param uID - The UID associated with the appointment
     * @returns The newly created AppointmentEntity or null if the UID is in the DB already.
     */
    public async CreateAppointmentForUID(appointmentEntity: carriers.AppointmentEntity, uID: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async CreateAppointmentForUID(appointmentEntity:carriers.AppointmentEntity|carriers.Appointment_CreateAppointmentForUIDRequest, uID?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_CreateAppointmentForUIDRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentEntity)!='undefined' || typeof(first.UID)!='undefined' ) )
        {
            _request = appointmentEntity as carriers.Appointment_CreateAppointmentForUIDRequest;
            _options = uID as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentEntity: appointmentEntity as carriers.AppointmentEntity,
                       UID: uID as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateAppointmentForUID( _request, _options );
    }


    private async _GetAppointmentFromUID(request: carriers.Appointment_GetAppointmentFromUIDRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentFromUID", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentEntity = converters.Create_AppointmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the appointment that corresponds to the given UID.
     * @param request - UID
     * @returns The corresponding AppointmentEntity if exists or a default appointment entity.
     */
    public async GetAppointmentFromUID(request: carriers.Appointment_GetAppointmentFromUIDRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    /**
     * Get the appointment that corresponds to the given UID.
     * @param uID - The UID associated with the appointment
     * @returns The corresponding AppointmentEntity if exists or a default appointment entity.
     */
    public async GetAppointmentFromUID(uID: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity >;

    public async GetAppointmentFromUID(uID:string|carriers.Appointment_GetAppointmentFromUIDRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentEntity > {
        let _request : carriers.Appointment_GetAppointmentFromUIDRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = uID;
        if( typeof( first ) === "object" && first && ( typeof(first.UID)!='undefined' ) )
        {
            _request = uID as carriers.Appointment_GetAppointmentFromUIDRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UID: uID as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAppointmentFromUID( _request, _options );
    }


    private async _CanAssignToProjectMember(request: carriers.Appointment_CanAssignToProjectMemberRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanAssignToProjectMember", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ProjectId, SuggestedAppointmentId
     * @returns 
     */
    public async CanAssignToProjectMember(request: carriers.Appointment_CanAssignToProjectMemberRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param projectId - 
     * @param suggestedAppointmentId - 
     * @returns 
     */
    public async CanAssignToProjectMember(projectId: number, suggestedAppointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async CanAssignToProjectMember(projectId:number|carriers.Appointment_CanAssignToProjectMemberRequest, suggestedAppointmentId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Appointment_CanAssignToProjectMemberRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.SuggestedAppointmentId)!='undefined' ) )
        {
            _request = projectId as carriers.Appointment_CanAssignToProjectMemberRequest;
            _options = suggestedAppointmentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       SuggestedAppointmentId: suggestedAppointmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._CanAssignToProjectMember( _request, _options );
    }


    private async _GetUIDFromAppointmentId(request: carriers.Appointment_GetUIDFromAppointmentIdRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUIDFromAppointmentId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the UID associated with the appointment id in the Invitation table.
     * @param request - AppointmentId, UseMotherId
     * @returns The associated UID, or null if none exist.
     */
    public async GetUIDFromAppointmentId(request: carriers.Appointment_GetUIDFromAppointmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the UID associated with the appointment id in the Invitation table.
     * @param appointmentId - 
     * @param useMotherId - Uses motherId if no UID is found for appointmentId.
     * @returns The associated UID, or null if none exist.
     */
    public async GetUIDFromAppointmentId(appointmentId: number, useMotherId: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetUIDFromAppointmentId(appointmentId:number|carriers.Appointment_GetUIDFromAppointmentIdRequest, useMotherId?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Appointment_GetUIDFromAppointmentIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.UseMotherId)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_GetUIDFromAppointmentIdRequest;
            _options = useMotherId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       UseMotherId: useMotherId as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetUIDFromAppointmentId( _request, _options );
    }


    private async _UpdateAppointmentFromIcsResponse(request: carriers.Appointment_UpdateAppointmentFromIcsResponseRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateAppointmentFromIcsResponse", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update the attendance to an appointment based on incoming ICS RSVPs.
     * @param request - EmailAddress, IcsData
     * @returns True if successfull.
     */
    public async UpdateAppointmentFromIcsResponse(request: carriers.Appointment_UpdateAppointmentFromIcsResponseRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Update the attendance to an appointment based on incoming ICS RSVPs.
     * @param emailAddress - The email-address of the person responding to our meeting-request.
     * @param icsData - The iCal ICS RSVP-content in byte-form.
     * @returns True if successfull.
     */
    public async UpdateAppointmentFromIcsResponse(emailAddress: string, icsData: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async UpdateAppointmentFromIcsResponse(emailAddress:string|carriers.Appointment_UpdateAppointmentFromIcsResponseRequest, icsData?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Appointment_UpdateAppointmentFromIcsResponseRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailAddress;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailAddress)!='undefined' || typeof(first.IcsData)!='undefined' ) )
        {
            _request = emailAddress as carriers.Appointment_UpdateAppointmentFromIcsResponseRequest;
            _options = icsData as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailAddress: emailAddress as string,
                       IcsData: icsData as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.IcsData = ToBase64(_request.IcsData);
        return this._UpdateAppointmentFromIcsResponse( _request, _options );
    }


    private async _ValidateAppointmentEntity(request: carriers.Appointment_ValidateAppointmentEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateAppointmentEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check that entity is ready for saving.
     * @param request - AppointmentEntity
     * @returns Error messages tagged by field.
     */
    public async ValidateAppointmentEntity(request: carriers.Appointment_ValidateAppointmentEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Check that entity is ready for saving.
     * @param appointmentEntity - Entity to be checked.
     * @returns Error messages tagged by field.
     */
    public async ValidateAppointmentEntity(appointmentEntity: carriers.AppointmentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async ValidateAppointmentEntity(appointmentEntity:carriers.AppointmentEntity|carriers.Appointment_ValidateAppointmentEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Appointment_ValidateAppointmentEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentEntity)!='undefined' ) )
        {
            _request = appointmentEntity as carriers.Appointment_ValidateAppointmentEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentEntity: appointmentEntity as carriers.AppointmentEntity,
                       };   
            _options = webapi_options;
        }
        return this._ValidateAppointmentEntity( _request, _options );
    }


    private async _WillSendEmail(request: carriers.Appointment_WillSendEmailRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("WillSendEmail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns true if the changes will trigger email sending on Save, so you can inform the user.
     * @param request - Appointment
     * @returns True if the changes to the appointment and preference settings etc. indicates an email should be sent.
     */
    public async WillSendEmail(request: carriers.Appointment_WillSendEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Returns true if the changes will trigger email sending on Save, so you can inform the user.
     * @param appointment - The appointment carrier with changes made, before saving the changes.
     * @returns True if the changes to the appointment and preference settings etc. indicates an email should be sent.
     */
    public async WillSendEmail(appointment: carriers.AppointmentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async WillSendEmail(appointment:carriers.AppointmentEntity|carriers.Appointment_WillSendEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Appointment_WillSendEmailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointment;
        if( typeof( first ) === "object" && first && ( typeof(first.Appointment)!='undefined' ) )
        {
            _request = appointment as carriers.Appointment_WillSendEmailRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Appointment: appointment as carriers.AppointmentEntity,
                       };   
            _options = webapi_options;
        }
        return this._WillSendEmail( _request, _options );
    }


    private async _AcceptWithSmtpEmailConfirmation(request: carriers.Appointment_AcceptWithSmtpEmailConfirmationRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AcceptWithSmtpEmailConfirmation", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Accepting an appointment invitation and send an email confirmation to the meeting organizer.
     * @param request - AppointmentId, UpdateMode, SmtpEMailConnectionInfo
     * @returns Updated AppointmentEntity
     */
    public async AcceptWithSmtpEmailConfirmation(request: carriers.Appointment_AcceptWithSmtpEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Accepting an appointment invitation and send an email confirmation to the meeting organizer.
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param updateMode - Update mode for a recurring appointment.
     * @param smtpEMailConnectionInfo - Login information for outgoing smtp email server. Will be null if no login information is relevant.
     * @returns Updated AppointmentEntity
     */
    public async AcceptWithSmtpEmailConfirmation(appointmentId: number, updateMode: enums.RecurrenceUpdateMode, smtpEMailConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AcceptWithSmtpEmailConfirmation(appointmentId:number|carriers.Appointment_AcceptWithSmtpEmailConfirmationRequest, updateMode?:enums.RecurrenceUpdateMode|base.WebApiRequestOptions, smtpEMailConnectionInfo?:carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_AcceptWithSmtpEmailConfirmationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.UpdateMode)!='undefined' || typeof(first.SmtpEMailConnectionInfo)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_AcceptWithSmtpEmailConfirmationRequest;
            _options = updateMode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       SmtpEMailConnectionInfo: smtpEMailConnectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._AcceptWithSmtpEmailConfirmation( _request, _options );
    }


    private async _RejectWithSmtpEmailConfirmation(request: carriers.Appointment_RejectWithSmtpEmailConfirmationRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RejectWithSmtpEmailConfirmation", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Rejecting an appointment invitation and send an email confirmation to the meeting organizer.
     * @param request - AppointmentId, RejectReason, UpdateMode, SmtpEMailConnectionInfo
     * @returns Updated AppointmentEntity
     */
    public async RejectWithSmtpEmailConfirmation(request: carriers.Appointment_RejectWithSmtpEmailConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Rejecting an appointment invitation and send an email confirmation to the meeting organizer.
     * @param appointmentId - The appointmentId. Both master and child record ids are accepted.
     * @param rejectReason - The reason the invitation was rejected.
     * @param updateMode - Update mode for a recurring appointment.
     * @param smtpEMailConnectionInfo - Login information for outgoing smtp email server. Will be null if no login information is relevant.
     * @returns Updated AppointmentEntity
     */
    public async RejectWithSmtpEmailConfirmation(appointmentId: number, rejectReason: string, updateMode: enums.RecurrenceUpdateMode, smtpEMailConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RejectWithSmtpEmailConfirmation(appointmentId:number|carriers.Appointment_RejectWithSmtpEmailConfirmationRequest, rejectReason?:string|base.WebApiRequestOptions, updateMode?:enums.RecurrenceUpdateMode, smtpEMailConnectionInfo?:carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Appointment_RejectWithSmtpEmailConfirmationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' || typeof(first.RejectReason)!='undefined' || typeof(first.UpdateMode)!='undefined' || typeof(first.SmtpEMailConnectionInfo)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_RejectWithSmtpEmailConfirmationRequest;
            _options = rejectReason as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       RejectReason: rejectReason as string,
                       UpdateMode: updateMode as enums.RecurrenceUpdateMode,
                       SmtpEMailConnectionInfo: smtpEMailConnectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._RejectWithSmtpEmailConfirmation( _request, _options );
    }

    /*
     * Gets an array of Appointment objects.
     * @param appointmentIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Appointment
     */
    public async GetAppointmentList(appointmentIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAppointmentList", appointmentIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetMyAppointments(request: carriers.Appointment_GetMyAppointmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyAppointments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the currently logged on user.
     * @param request - StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetMyAppointments(request: carriers.Appointment_GetMyAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the currently logged on user.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetMyAppointments(startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetMyAppointments(startTime:Date|carriers.Appointment_GetMyAppointmentsRequest, endTime?:Date|base.WebApiRequestOptions, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetMyAppointmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = startTime;
        if( typeof( first ) === "object" && first && ( typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = startTime as carriers.Appointment_GetMyAppointmentsRequest;
            _options = endTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetMyAppointments( _request, _options );
    }


    private async _GetPersonAppointments(request: carriers.Appointment_GetPersonAppointmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the person specified. If the person not is a SuperOffice user (associate) or the logged on user is not allowed to view this persons appointments an exception is thrown.
     * @param request - PersonId, IncludeProjectAppointments, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetPersonAppointments(request: carriers.Appointment_GetPersonAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the person specified. If the person not is a SuperOffice user (associate) or the logged on user is not allowed to view this persons appointments an exception is thrown.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectAppointments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetPersonAppointments(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetPersonAppointments(personId:number|carriers.Appointment_GetPersonAppointmentsRequest, includeProjectAppointments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetPersonAppointmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectAppointments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetPersonAppointmentsRequest;
            _options = includeProjectAppointments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectAppointments: includeProjectAppointments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonAppointments( _request, _options );
    }


    private async _GetMyDiary(request: carriers.Appointment_GetMyDiaryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyDiary", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user&apos;s diary. The appointments belong to the currently logged on user.
     * @param request - StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetMyDiary(request: carriers.Appointment_GetMyDiaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user&apos;s diary. The appointments belong to the currently logged on user.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetMyDiary(startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetMyDiary(startTime:Date|carriers.Appointment_GetMyDiaryRequest, endTime?:Date|base.WebApiRequestOptions, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetMyDiaryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = startTime;
        if( typeof( first ) === "object" && first && ( typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = startTime as carriers.Appointment_GetMyDiaryRequest;
            _options = endTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetMyDiary( _request, _options );
    }


    private async _GetMyTasks(request: carriers.Appointment_GetMyTasksRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyTasks", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user&apos;s task list. The appointments belong to the currently logged on user.
     * @param request - Count
     * @returns Array of Appointments.
     */
    public async GetMyTasks(request: carriers.Appointment_GetMyTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user&apos;s task list. The appointments belong to the currently logged on user.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetMyTasks(count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetMyTasks(count:number|carriers.Appointment_GetMyTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetMyTasksRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = count;
        if( typeof( first ) === "object" && first && ( typeof(first.Count)!='undefined' ) )
        {
            _request = count as carriers.Appointment_GetMyTasksRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetMyTasks( _request, _options );
    }


    private async _GetPersonDiary(request: carriers.Appointment_GetPersonDiaryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDiary", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user&apos;s diary. The appointments belong to the person specified. If the person not is a SuperOffice user (associate) or the logged on user is not allowed to view this persons appointments an exception is thrown.
     * @param request - PersonId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetPersonDiary(request: carriers.Appointment_GetPersonDiaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user&apos;s diary. The appointments belong to the person specified. If the person not is a SuperOffice user (associate) or the logged on user is not allowed to view this persons appointments an exception is thrown.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetPersonDiary(personId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetPersonDiary(personId:number|carriers.Appointment_GetPersonDiaryRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetPersonDiaryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetPersonDiaryRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonDiary( _request, _options );
    }


    private async _GetPersonTasks(request: carriers.Appointment_GetPersonTasksRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonTasks", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user&apos;s task list. The appointments belong to the person specified. If the person not is a SuperOffice user (associate) or the logged on user is not allowed to view this persons appointments an exception is thrown.
     * @param request - PersonId, Count
     * @returns Array of Appointments.
     */
    public async GetPersonTasks(request: carriers.Appointment_GetPersonTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user&apos;s task list. The appointments belong to the person specified. If the person not is a SuperOffice user (associate) or the logged on user is not allowed to view this persons appointments an exception is thrown.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetPersonTasks(personId: number, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetPersonTasks(personId:number|carriers.Appointment_GetPersonTasksRequest, count?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetPersonTasksRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetPersonTasksRequest;
            _options = count as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonTasks( _request, _options );
    }


    private async _GetPersonAppointmentsByType(request: carriers.Appointment_GetPersonAppointmentsByTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointmentsByType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the person specified.
     * @param request - PersonId, IncludeProjectAppointments, StartTime, EndTime, Count, AppointmentType
     * @returns Array of Appointments.
     */
    public async GetPersonAppointmentsByType(request: carriers.Appointment_GetPersonAppointmentsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the person specified.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectAppointments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param appointmentType - The appointment type, e.g. inDiary, inChecklist etc.
     * @returns Array of Appointments.
     */
    public async GetPersonAppointmentsByType(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, appointmentType: enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetPersonAppointmentsByType(personId:number|carriers.Appointment_GetPersonAppointmentsByTypeRequest, includeProjectAppointments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, appointmentType?:enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetPersonAppointmentsByTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectAppointments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.AppointmentType)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetPersonAppointmentsByTypeRequest;
            _options = includeProjectAppointments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectAppointments: includeProjectAppointments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       AppointmentType: appointmentType as enums.AppointmentType,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonAppointmentsByType( _request, _options );
    }


    private async _GetProjectAppointments(request: carriers.Appointment_GetProjectAppointmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the project specified. If the logged on user is not allowed to view this projects appointments an exception is thrown.
     * @param request - ProjectId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetProjectAppointments(request: carriers.Appointment_GetProjectAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the project specified. If the logged on user is not allowed to view this projects appointments an exception is thrown.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetProjectAppointments(projectId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectAppointments(projectId:number|carriers.Appointment_GetProjectAppointmentsRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectAppointmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = projectId as carriers.Appointment_GetProjectAppointmentsRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectAppointments( _request, _options );
    }


    private async _GetProjectAppointmentsByType(request: carriers.Appointment_GetProjectAppointmentsByTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointmentsByType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the project specified.
     * @param request - ProjectId, StartTime, EndTime, Count, AppointmentType
     * @returns Array of Appointments.
     */
    public async GetProjectAppointmentsByType(request: carriers.Appointment_GetProjectAppointmentsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the project specified.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param appointmentType - The appointment type, e.g. inDiary, inChecklist etc.
     * @returns Array of Appointments.
     */
    public async GetProjectAppointmentsByType(projectId: number, startTime: Date, endTime: Date, count: number, appointmentType: enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectAppointmentsByType(projectId:number|carriers.Appointment_GetProjectAppointmentsByTypeRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, appointmentType?:enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectAppointmentsByTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.AppointmentType)!='undefined' ) )
        {
            _request = projectId as carriers.Appointment_GetProjectAppointmentsByTypeRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       AppointmentType: appointmentType as enums.AppointmentType,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectAppointmentsByType( _request, _options );
    }


    private async _GetContactAppointments(request: carriers.Appointment_GetContactAppointmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the contact specified. If the logged on user is not allowed to view this persons appointments an exception is thrown.
     * @param request - ContactId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetContactAppointments(request: carriers.Appointment_GetContactAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the contact specified. If the logged on user is not allowed to view this persons appointments an exception is thrown.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetContactAppointments(contactId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetContactAppointments(contactId:number|carriers.Appointment_GetContactAppointmentsRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetContactAppointmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = contactId as carriers.Appointment_GetContactAppointmentsRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactAppointments( _request, _options );
    }


    private async _GetContactAppointmentsByType(request: carriers.Appointment_GetContactAppointmentsByTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointmentsByType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the contact specified. If the logged on user is not allowed to view this contacts appointments an exception is thrown.
     * @param request - ContactId, StartTime, EndTime, Count, AppointmentType
     * @returns Array of Appointments.
     */
    public async GetContactAppointmentsByType(request: carriers.Appointment_GetContactAppointmentsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the contact specified. If the logged on user is not allowed to view this contacts appointments an exception is thrown.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param appointmentType - The appointment type, e.g. inDiary, inChecklist etc.
     * @returns Array of Appointments.
     */
    public async GetContactAppointmentsByType(contactId: number, startTime: Date, endTime: Date, count: number, appointmentType: enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetContactAppointmentsByType(contactId:number|carriers.Appointment_GetContactAppointmentsByTypeRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, appointmentType?:enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetContactAppointmentsByTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.AppointmentType)!='undefined' ) )
        {
            _request = contactId as carriers.Appointment_GetContactAppointmentsByTypeRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       AppointmentType: appointmentType as enums.AppointmentType,
                       };   
            _options = webapi_options;
        }
        return this._GetContactAppointmentsByType( _request, _options );
    }


    private async _GetProjectMemberAppointments(request: carriers.Appointment_GetProjectMemberAppointmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the projects where the person specified is member.
     * @param request - PersonId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointments(request: carriers.Appointment_GetProjectMemberAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the projects where the person specified is member.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointments(personId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectMemberAppointments(personId:number|carriers.Appointment_GetProjectMemberAppointmentsRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectMemberAppointmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetProjectMemberAppointmentsRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointments( _request, _options );
    }


    private async _GetProjectMemberAppointmentsByType(request: carriers.Appointment_GetProjectMemberAppointmentsByTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointmentsByType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the projects where the person specified is member.
     * @param request - PersonId, StartTime, EndTime, Count, AppointmentType
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointmentsByType(request: carriers.Appointment_GetProjectMemberAppointmentsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the projects where the person specified is member.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param appointmentType - The appointment type, e.g. inDiary, inChecklist etc.
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointmentsByType(personId: number, startTime: Date, endTime: Date, count: number, appointmentType: enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectMemberAppointmentsByType(personId:number|carriers.Appointment_GetProjectMemberAppointmentsByTypeRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, appointmentType?:enums.AppointmentType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectMemberAppointmentsByTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.AppointmentType)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetProjectMemberAppointmentsByTypeRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       AppointmentType: appointmentType as enums.AppointmentType,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointmentsByType( _request, _options );
    }


    private async _GetPersonAppointmentsByTask(request: carriers.Appointment_GetPersonAppointmentsByTaskRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointmentsByTask", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the person specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param request - PersonId, IncludeProjectAppointments, StartTime, EndTime, Count, TaskId
     * @returns Array of Appointments.
     */
    public async GetPersonAppointmentsByTask(request: carriers.Appointment_GetPersonAppointmentsByTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the person specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectAppointments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskId - The task id. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetPersonAppointmentsByTask(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, taskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetPersonAppointmentsByTask(personId:number|carriers.Appointment_GetPersonAppointmentsByTaskRequest, includeProjectAppointments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, taskId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetPersonAppointmentsByTaskRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectAppointments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskId)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetPersonAppointmentsByTaskRequest;
            _options = includeProjectAppointments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectAppointments: includeProjectAppointments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskId: taskId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonAppointmentsByTask( _request, _options );
    }


    private async _GetPersonAppointmentsByTasks(request: carriers.Appointment_GetPersonAppointmentsByTasksRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointmentsByTasks", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments from a list of appointment task types within a time range. The appointments belong to the person specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param request - PersonId, IncludeProjectAppointments, StartTime, EndTime, Count, TaskIds
     * @returns Array of Appointments.
     */
    public async GetPersonAppointmentsByTasks(request: carriers.Appointment_GetPersonAppointmentsByTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments from a list of appointment task types within a time range. The appointments belong to the person specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectAppointments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskIds - The task ids as an integer array. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetPersonAppointmentsByTasks(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, taskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetPersonAppointmentsByTasks(personId:number|carriers.Appointment_GetPersonAppointmentsByTasksRequest, includeProjectAppointments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, taskIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetPersonAppointmentsByTasksRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectAppointments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskIds)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetPersonAppointmentsByTasksRequest;
            _options = includeProjectAppointments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectAppointments: includeProjectAppointments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskIds: taskIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetPersonAppointmentsByTasks( _request, _options );
    }


    private async _GetPersonAppointmentsByTaskHeading(request: carriers.Appointment_GetPersonAppointmentsByTaskHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointmentsByTaskHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the person specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param request - PersonId, IncludeProjectAppointments, StartTime, EndTime, Count, TaskHeadingId
     * @returns Array of Appointments.
     */
    public async GetPersonAppointmentsByTaskHeading(request: carriers.Appointment_GetPersonAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the person specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectAppointments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskHeadingId - The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetPersonAppointmentsByTaskHeading(personId: number, includeProjectAppointments: boolean, startTime: Date, endTime: Date, count: number, taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetPersonAppointmentsByTaskHeading(personId:number|carriers.Appointment_GetPersonAppointmentsByTaskHeadingRequest, includeProjectAppointments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, taskHeadingId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetPersonAppointmentsByTaskHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectAppointments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskHeadingId)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetPersonAppointmentsByTaskHeadingRequest;
            _options = includeProjectAppointments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectAppointments: includeProjectAppointments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskHeadingId: taskHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonAppointmentsByTaskHeading( _request, _options );
    }


    private async _GetProjectAppointmentsByTask(request: carriers.Appointment_GetProjectAppointmentsByTaskRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointmentsByTask", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the project specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param request - ProjectId, StartTime, EndTime, Count, TaskId
     * @returns Array of Appointments.
     */
    public async GetProjectAppointmentsByTask(request: carriers.Appointment_GetProjectAppointmentsByTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the project specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskId - The task id. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetProjectAppointmentsByTask(projectId: number, startTime: Date, endTime: Date, count: number, taskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectAppointmentsByTask(projectId:number|carriers.Appointment_GetProjectAppointmentsByTaskRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, taskId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectAppointmentsByTaskRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskId)!='undefined' ) )
        {
            _request = projectId as carriers.Appointment_GetProjectAppointmentsByTaskRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskId: taskId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectAppointmentsByTask( _request, _options );
    }


    private async _GetProjectAppointmentsByTasks(request: carriers.Appointment_GetProjectAppointmentsByTasksRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointmentsByTasks", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments matching the list of appointment task types within a time range. The appointments belong to the project specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param request - ProjectId, StartTime, EndTime, Count, TaskIds
     * @returns Array of Appointments.
     */
    public async GetProjectAppointmentsByTasks(request: carriers.Appointment_GetProjectAppointmentsByTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments matching the list of appointment task types within a time range. The appointments belong to the project specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskIds - The task ids as an integer array. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetProjectAppointmentsByTasks(projectId: number, startTime: Date, endTime: Date, count: number, taskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectAppointmentsByTasks(projectId:number|carriers.Appointment_GetProjectAppointmentsByTasksRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, taskIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectAppointmentsByTasksRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskIds)!='undefined' ) )
        {
            _request = projectId as carriers.Appointment_GetProjectAppointmentsByTasksRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskIds: taskIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetProjectAppointmentsByTasks( _request, _options );
    }


    private async _GetProjectAppointmentsByTaskHeading(request: carriers.Appointment_GetProjectAppointmentsByTaskHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointmentsByTaskHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the project specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param request - ProjectId, StartTime, EndTime, Count, TaskHeadingId
     * @returns Array of Appointments.
     */
    public async GetProjectAppointmentsByTaskHeading(request: carriers.Appointment_GetProjectAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the project specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskHeadingId - The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetProjectAppointmentsByTaskHeading(projectId: number, startTime: Date, endTime: Date, count: number, taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectAppointmentsByTaskHeading(projectId:number|carriers.Appointment_GetProjectAppointmentsByTaskHeadingRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, taskHeadingId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectAppointmentsByTaskHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskHeadingId)!='undefined' ) )
        {
            _request = projectId as carriers.Appointment_GetProjectAppointmentsByTaskHeadingRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskHeadingId: taskHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectAppointmentsByTaskHeading( _request, _options );
    }


    private async _GetProjectMemberAppointmentsByTask(request: carriers.Appointment_GetProjectMemberAppointmentsByTaskRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointmentsByTask", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the projects where the person specified is member. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param request - PersonId, StartTime, EndTime, Count, TaskId
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointmentsByTask(request: carriers.Appointment_GetProjectMemberAppointmentsByTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the projects where the person specified is member. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskId - The task id. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointmentsByTask(personId: number, startTime: Date, endTime: Date, count: number, taskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectMemberAppointmentsByTask(personId:number|carriers.Appointment_GetProjectMemberAppointmentsByTaskRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, taskId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectMemberAppointmentsByTaskRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskId)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetProjectMemberAppointmentsByTaskRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskId: taskId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointmentsByTask( _request, _options );
    }


    private async _GetProjectMemberAppointmentsByTasks(request: carriers.Appointment_GetProjectMemberAppointmentsByTasksRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointmentsByTasks", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments matching a set of appointment task types within a time range. The appointments belong to the projects where the person specified is member. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param request - PersonId, StartTime, EndTime, Count, TaskIds
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointmentsByTasks(request: carriers.Appointment_GetProjectMemberAppointmentsByTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments matching a set of appointment task types within a time range. The appointments belong to the projects where the person specified is member. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskIds - The task ids as an integer array. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointmentsByTasks(personId: number, startTime: Date, endTime: Date, count: number, taskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectMemberAppointmentsByTasks(personId:number|carriers.Appointment_GetProjectMemberAppointmentsByTasksRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, taskIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectMemberAppointmentsByTasksRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskIds)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetProjectMemberAppointmentsByTasksRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskIds: taskIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointmentsByTasks( _request, _options );
    }


    private async _GetProjectMemberAppointmentsByTaskHeading(request: carriers.Appointment_GetProjectMemberAppointmentsByTaskHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointmentsByTaskHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the projects where the person specified is member. Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param request - PersonId, StartTime, EndTime, Count, TaskHeadingId
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointmentsByTaskHeading(request: carriers.Appointment_GetProjectMemberAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the projects where the person specified is member. Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskHeadingId - The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetProjectMemberAppointmentsByTaskHeading(personId: number, startTime: Date, endTime: Date, count: number, taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetProjectMemberAppointmentsByTaskHeading(personId:number|carriers.Appointment_GetProjectMemberAppointmentsByTaskHeadingRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, taskHeadingId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetProjectMemberAppointmentsByTaskHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskHeadingId)!='undefined' ) )
        {
            _request = personId as carriers.Appointment_GetProjectMemberAppointmentsByTaskHeadingRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskHeadingId: taskHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointmentsByTaskHeading( _request, _options );
    }


    private async _GetContactAppointmentsByTask(request: carriers.Appointment_GetContactAppointmentsByTaskRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointmentsByTask", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the contact specified. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param request - ContactId, StartTime, EndTime, Count, TaskId
     * @returns Array of Appointments.
     */
    public async GetContactAppointmentsByTask(request: carriers.Appointment_GetContactAppointmentsByTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the contact specified. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskId - The task id. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetContactAppointmentsByTask(contactId: number, startTime: Date, endTime: Date, count: number, taskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetContactAppointmentsByTask(contactId:number|carriers.Appointment_GetContactAppointmentsByTaskRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, taskId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetContactAppointmentsByTaskRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskId)!='undefined' ) )
        {
            _request = contactId as carriers.Appointment_GetContactAppointmentsByTaskRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskId: taskId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactAppointmentsByTask( _request, _options );
    }


    private async _GetContactAppointmentsByTasks(request: carriers.Appointment_GetContactAppointmentsByTasksRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointmentsByTasks", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments belonging to an array of appointment task types within a time range. The appointments belong to the contact specified. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param request - ContactId, StartTime, EndTime, Count, TaskIds
     * @returns Array of Appointments.
     */
    public async GetContactAppointmentsByTasks(request: carriers.Appointment_GetContactAppointmentsByTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments belonging to an array of appointment task types within a time range. The appointments belong to the contact specified. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskIds - The task ids as an integer array. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetContactAppointmentsByTasks(contactId: number, startTime: Date, endTime: Date, count: number, taskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetContactAppointmentsByTasks(contactId:number|carriers.Appointment_GetContactAppointmentsByTasksRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, taskIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetContactAppointmentsByTasksRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskIds)!='undefined' ) )
        {
            _request = contactId as carriers.Appointment_GetContactAppointmentsByTasksRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskIds: taskIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetContactAppointmentsByTasks( _request, _options );
    }


    private async _GetContactAppointmentsByTaskHeading(request: carriers.Appointment_GetContactAppointmentsByTaskHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointmentsByTaskHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the contact specified. Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param request - ContactId, StartTime, EndTime, Count, TaskHeadingId
     * @returns Array of Appointments.
     */
    public async GetContactAppointmentsByTaskHeading(request: carriers.Appointment_GetContactAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the contact specified. Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param taskHeadingId - The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     * @returns Array of Appointments.
     */
    public async GetContactAppointmentsByTaskHeading(contactId: number, startTime: Date, endTime: Date, count: number, taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetContactAppointmentsByTaskHeading(contactId:number|carriers.Appointment_GetContactAppointmentsByTaskHeadingRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, taskHeadingId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetContactAppointmentsByTaskHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TaskHeadingId)!='undefined' ) )
        {
            _request = contactId as carriers.Appointment_GetContactAppointmentsByTaskHeadingRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TaskHeadingId: taskHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactAppointmentsByTaskHeading( _request, _options );
    }


    private async _GetPublishedAppointment(request: carriers.Appointment_GetPublishedAppointmentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedAppointment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment = converters.Create_Appointment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get published appointment by appointment id.
     * @param request - AppointmentId
     * @returns Appointment
     */
    public async GetPublishedAppointment(request: carriers.Appointment_GetPublishedAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;

    /**
     * Get published appointment by appointment id.
     * @param appointmentId - The appointment id
     * @returns Appointment
     */
    public async GetPublishedAppointment(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;

    public async GetPublishedAppointment(appointmentId:number|carriers.Appointment_GetPublishedAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment > {
        let _request : carriers.Appointment_GetPublishedAppointmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' ) )
        {
            _request = appointmentId as carriers.Appointment_GetPublishedAppointmentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedAppointment( _request, _options );
    }


    private async _GetPublishedAppointments(request: carriers.Appointment_GetPublishedAppointmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedAppointments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get published appointments by appointment ids.
     * @param request - AppointmentIds
     * @returns Array of Appointment
     */
    public async GetPublishedAppointments(request: carriers.Appointment_GetPublishedAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Get published appointments by appointment ids.
     * @param appointmentIds - The array of appointment ids
     * @returns Array of Appointment
     */
    public async GetPublishedAppointments(appointmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetPublishedAppointments(appointmentIds:number[]|carriers.Appointment_GetPublishedAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetPublishedAppointmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentIds)!='undefined' ) )
        {
            _request = appointmentIds as carriers.Appointment_GetPublishedAppointmentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentIds: appointmentIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedAppointments( _request, _options );
    }


    private async _GetMyPublishedAppointments( options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyPublishedAppointments", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get published appointments from the logged in user.
     * @returns Appointments
     */
    public async GetMyPublishedAppointments(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >
    {
        return this._GetMyPublishedAppointments(webapi_options);
    }


    private async _GetPublishedProjectAppointments(request: carriers.Appointment_GetPublishedProjectAppointmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProjectAppointments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get published appointments by project id.
     * @param request - ProjectId
     * @returns Array of Appointment
     */
    public async GetPublishedProjectAppointments(request: carriers.Appointment_GetPublishedProjectAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Get published appointments by project id.
     * @param projectId - The project id
     * @returns Array of Appointment
     */
    public async GetPublishedProjectAppointments(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetPublishedProjectAppointments(projectId:number|carriers.Appointment_GetPublishedProjectAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetPublishedProjectAppointmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Appointment_GetPublishedProjectAppointmentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedProjectAppointments( _request, _options );
    }


    private async _GetAppointmentsByTaskHeading(request: carriers.Appointment_GetAppointmentsByTaskHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentsByTaskHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns appointments of a specific appointment task heading. Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param request - TaskHeadingId
     * @returns Array of Appointments.
     */
    public async GetAppointmentsByTaskHeading(request: carriers.Appointment_GetAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Method that returns appointments of a specific appointment task heading. Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
     * @param taskHeadingId - The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on
     * @returns Array of Appointments.
     */
    public async GetAppointmentsByTaskHeading(taskHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetAppointmentsByTaskHeading(taskHeadingId:number|carriers.Appointment_GetAppointmentsByTaskHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetAppointmentsByTaskHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = taskHeadingId;
        if( typeof( first ) === "object" && first && ( typeof(first.TaskHeadingId)!='undefined' ) )
        {
            _request = taskHeadingId as carriers.Appointment_GetAppointmentsByTaskHeadingRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TaskHeadingId: taskHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAppointmentsByTaskHeading( _request, _options );
    }


    private async _GetAssociateDiary(request: carriers.Appointment_GetAssociateDiaryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAssociateDiary", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateId, StartTime, EndTime, Count
     * @returns 
     */
    public async GetAssociateDiary(request: carriers.Appointment_GetAssociateDiaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * 
     * @param associateId - 
     * @param startTime - 
     * @param endTime - 
     * @param count - 
     * @returns 
     */
    public async GetAssociateDiary(associateId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetAssociateDiary(associateId:number|carriers.Appointment_GetAssociateDiaryRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetAssociateDiaryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = associateId as carriers.Appointment_GetAssociateDiaryRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAssociateDiary( _request, _options );
    }


    private async _GetDiaryByGroup(request: carriers.Appointment_GetDiaryByGroupRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDiaryByGroup", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - GroupId, GroupType, StartTime, EndTime, Count
     * @returns 
     */
    public async GetDiaryByGroup(request: carriers.Appointment_GetDiaryByGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * 
     * @param groupId - 
     * @param groupType - 
     * @param startTime - 
     * @param endTime - 
     * @param count - 
     * @returns 
     */
    public async GetDiaryByGroup(groupId: number, groupType: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetDiaryByGroup(groupId:number|carriers.Appointment_GetDiaryByGroupRequest, groupType?:number|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetDiaryByGroupRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = groupId;
        if( typeof( first ) === "object" && first && ( typeof(first.GroupId)!='undefined' || typeof(first.GroupType)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = groupId as carriers.Appointment_GetDiaryByGroupRequest;
            _options = groupType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GroupId: groupId as number,
                       GroupType: groupType as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDiaryByGroup( _request, _options );
    }


    private async _UpdateAppointment(request: carriers.Appointment_UpdateAppointmentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateAppointment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment = converters.Create_Appointment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Updates an appointment record.
     * @param request - Id, StartTime, EndTime, Status, Type, AssociateId
     * @returns 
     */
    public async UpdateAppointment(request: carriers.Appointment_UpdateAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;

    /**
     * Updates an appointment record.
     * @param id - 
     * @param startTime - 
     * @param endTime - 
     * @param status - 
     * @param type - 
     * @param associateId - The appointment owner's id (associate id)
     * @returns 
     */
    public async UpdateAppointment(id: number, startTime: Date, endTime: Date, status: number, type: number, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;

    public async UpdateAppointment(id:number|carriers.Appointment_UpdateAppointmentRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, status?:number, type?:number, associateId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment > {
        let _request : carriers.Appointment_UpdateAppointmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Status)!='undefined' || typeof(first.Type)!='undefined' || typeof(first.AssociateId)!='undefined' ) )
        {
            _request = id as carriers.Appointment_UpdateAppointmentRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Status: status as number,
                       Type: type as number,
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._UpdateAppointment( _request, _options );
    }


    private async _GetAssociatesDiary(request: carriers.Appointment_GetAssociatesDiaryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAssociatesDiary", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateIds, StartTime, EndTime
     * @returns 
     */
    public async GetAssociatesDiary(request: carriers.Appointment_GetAssociatesDiaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * 
     * @param associateIds - 
     * @param startTime - 
     * @param endTime - 
     * @returns 
     */
    public async GetAssociatesDiary(associateIds: number[], startTime: Date, endTime: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetAssociatesDiary(associateIds:number[]|carriers.Appointment_GetAssociatesDiaryRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetAssociatesDiaryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateIds)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' ) )
        {
            _request = associateIds as carriers.Appointment_GetAssociatesDiaryRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateIds: associateIds as number[],
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       };   
            _options = webapi_options;
        }
        return this._GetAssociatesDiary( _request, _options );
    }


    private async _GetAppointmentRecords(request: carriers.Appointment_GetAppointmentRecordsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentRecords", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment[] = converters.Create_AppointmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all records involved in a booking and/or recurring appointments. MotherId can be zero for repeating appointments or bookings, and recurrenceRuleId can be zero for bookings that are not repeating.
     * @param request - MotherId, RecurrenceRuleId
     * @returns 
     */
    public async GetAppointmentRecords(request: carriers.Appointment_GetAppointmentRecordsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    /**
     * Get all records involved in a booking and/or recurring appointments. MotherId can be zero for repeating appointments or bookings, and recurrenceRuleId can be zero for bookings that are not repeating.
     * @param motherId - Appointment id of the owner of a booking
     * @param recurrenceRuleId - RecurrenceId of a recuring appointment
     * @returns 
     */
    public async GetAppointmentRecords(motherId: number, recurrenceRuleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] >;

    public async GetAppointmentRecords(motherId:number|carriers.Appointment_GetAppointmentRecordsRequest, recurrenceRuleId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment[] > {
        let _request : carriers.Appointment_GetAppointmentRecordsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = motherId;
        if( typeof( first ) === "object" && first && ( typeof(first.MotherId)!='undefined' || typeof(first.RecurrenceRuleId)!='undefined' ) )
        {
            _request = motherId as carriers.Appointment_GetAppointmentRecordsRequest;
            _options = recurrenceRuleId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MotherId: motherId as number,
                       RecurrenceRuleId: recurrenceRuleId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAppointmentRecords( _request, _options );
    }


    private async _GetMySyncAppointments(request: carriers.Appointment_GetMySyncAppointmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentSyncData[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AppointmentSyncData[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMySyncAppointments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AppointmentSyncData[] = converters.Create_AppointmentSyncDataArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the currently logged on user.
     * @param request - StartTime, EndTime
     * @returns Array of Appointments.
     */
    public async GetMySyncAppointments(request: carriers.Appointment_GetMySyncAppointmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentSyncData[] >;

    /**
     * Method that returns a specified number of appointments within a time range. The appointments belong to the currently logged on user.
     * @param startTime - The start of the time interval in which we want appointments. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @returns Array of Appointments.
     */
    public async GetMySyncAppointments(startTime: Date, endTime: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentSyncData[] >;

    public async GetMySyncAppointments(startTime:Date|carriers.Appointment_GetMySyncAppointmentsRequest, endTime?:Date|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AppointmentSyncData[] > {
        let _request : carriers.Appointment_GetMySyncAppointmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = startTime;
        if( typeof( first ) === "object" && first && ( typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' ) )
        {
            _request = startTime as carriers.Appointment_GetMySyncAppointmentsRequest;
            _options = endTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       };   
            _options = webapi_options;
        }
        return this._GetMySyncAppointments( _request, _options );
    }


    private async _GetDayInformationListByDatesAndAssociate(request: carriers.Appointment_GetDayInformationListByDatesAndAssociateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DayInformationListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DayInformationListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDayInformationListByDatesAndAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DayInformationListItem[] = converters.Create_DayInformationListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get combined day information (activity + redletter summary) for one or more days according to the given date interval. The time portion of the dates is ignored. Private appointments are counted, but may not be visible through tooltips or other more detailed services.
     * @param request - StartDate, EndDate, AssociateId
     * @returns Exactly one item per day of the given time span is returned. Days where nothing happens will have all values set to 0, but will still be in the returned array. Start end dates are treated as inclusive.
     */
    public async GetDayInformationListByDatesAndAssociate(request: carriers.Appointment_GetDayInformationListByDatesAndAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DayInformationListItem[] >;

    /**
     * Get combined day information (activity + redletter summary) for one or more days according to the given date interval. The time portion of the dates is ignored. Private appointments are counted, but may not be visible through tooltips or other more detailed services.
     * @param startDate - Start date of interval. Time portion is ignored.
     * @param endDate - End date of interval. Time portion is ignored.
     * @param associateId - Associate id to identify the calendar to scan. If 0 is passed in, the currently authenticated associate is used instead.
     * @returns Exactly one item per day of the given time span is returned. Days where nothing happens will have all values set to 0, but will still be in the returned array. Start end dates are treated as inclusive.
     */
    public async GetDayInformationListByDatesAndAssociate(startDate: Date, endDate: Date, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DayInformationListItem[] >;

    public async GetDayInformationListByDatesAndAssociate(startDate:Date|carriers.Appointment_GetDayInformationListByDatesAndAssociateRequest, endDate?:Date|base.WebApiRequestOptions, associateId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DayInformationListItem[] > {
        let _request : carriers.Appointment_GetDayInformationListByDatesAndAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = startDate;
        if( typeof( first ) === "object" && first && ( typeof(first.StartDate)!='undefined' || typeof(first.EndDate)!='undefined' || typeof(first.AssociateId)!='undefined' ) )
        {
            _request = startDate as carriers.Appointment_GetDayInformationListByDatesAndAssociateRequest;
            _options = endDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StartDate: startDate as Date,
                       EndDate: endDate as Date,
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDayInformationListByDatesAndAssociate( _request, _options );
    }


    private async _GetActivityInformationListByDatesAndAssociate(request: carriers.Appointment_GetActivityInformationListByDatesAndAssociateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ActivityInformationListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ActivityInformationListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetActivityInformationListByDatesAndAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ActivityInformationListItem[] = converters.Create_ActivityInformationListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get activity information for one or more days according to the given date interval. The time portion of the dates is ignored. Private appointments are counted, but may not be visible through tooltips or other more detailed services.
     * @param request - StartDate, EndDate, AssociateId
     * @returns Exactly one item per day of the given time span is returned. Days where nothing happens will have all values set to 0, but will still be in the returned array. Start end dates are treated as inclusive.
     */
    public async GetActivityInformationListByDatesAndAssociate(request: carriers.Appointment_GetActivityInformationListByDatesAndAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ActivityInformationListItem[] >;

    /**
     * Get activity information for one or more days according to the given date interval. The time portion of the dates is ignored. Private appointments are counted, but may not be visible through tooltips or other more detailed services.
     * @param startDate - Start date of interval. Time portion is ignored.
     * @param endDate - End date of interval. Time portion is ignored.
     * @param associateId - Associate id to identify the calendar to scan. If 0 is passed in, the currently authenticated associate is used instead.
     * @returns Exactly one item per day of the given time span is returned. Days where nothing happens will have all values set to 0, but will still be in the returned array. Start end dates are treated as inclusive.
     */
    public async GetActivityInformationListByDatesAndAssociate(startDate: Date, endDate: Date, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ActivityInformationListItem[] >;

    public async GetActivityInformationListByDatesAndAssociate(startDate:Date|carriers.Appointment_GetActivityInformationListByDatesAndAssociateRequest, endDate?:Date|base.WebApiRequestOptions, associateId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ActivityInformationListItem[] > {
        let _request : carriers.Appointment_GetActivityInformationListByDatesAndAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = startDate;
        if( typeof( first ) === "object" && first && ( typeof(first.StartDate)!='undefined' || typeof(first.EndDate)!='undefined' || typeof(first.AssociateId)!='undefined' ) )
        {
            _request = startDate as carriers.Appointment_GetActivityInformationListByDatesAndAssociateRequest;
            _options = endDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StartDate: startDate as Date,
                       EndDate: endDate as Date,
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetActivityInformationListByDatesAndAssociate( _request, _options );
    }


    private async _GetRedLetterInformationListByDatesAndAssociate(request: carriers.Appointment_GetRedLetterInformationListByDatesAndAssociateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RedLetterInformationListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RedLetterInformationListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRedLetterInformationListByDatesAndAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RedLetterInformationListItem[] = converters.Create_RedLetterInformationListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get detailed red letter day information (redletter summary + individual day texts) for one or more days according to the given date interval. The time portion of the dates is ignored. 
     * @param request - StartDate, EndDate, AssociateId
     * @returns Exactly one item per day of the given time span is returned. Days where nothing happens will have all values set to 0, but will still be in the returned array. Start end dates are treated as inclusive.
     */
    public async GetRedLetterInformationListByDatesAndAssociate(request: carriers.Appointment_GetRedLetterInformationListByDatesAndAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RedLetterInformationListItem[] >;

    /**
     * Get detailed red letter day information (redletter summary + individual day texts) for one or more days according to the given date interval. The time portion of the dates is ignored. 
     * @param startDate - Start date of interval. Time portion is ignored.
     * @param endDate - End date of interval. Time portion is ignored.
     * @param associateId - Associate id to identify the calendar to scan. If 0 is passed in, the currently authenticated associate is used instead.
     * @returns Exactly one item per day of the given time span is returned. Days where nothing happens will have all values set to 0, but will still be in the returned array. Start end dates are treated as inclusive.
     */
    public async GetRedLetterInformationListByDatesAndAssociate(startDate: Date, endDate: Date, associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RedLetterInformationListItem[] >;

    public async GetRedLetterInformationListByDatesAndAssociate(startDate:Date|carriers.Appointment_GetRedLetterInformationListByDatesAndAssociateRequest, endDate?:Date|base.WebApiRequestOptions, associateId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RedLetterInformationListItem[] > {
        let _request : carriers.Appointment_GetRedLetterInformationListByDatesAndAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = startDate;
        if( typeof( first ) === "object" && first && ( typeof(first.StartDate)!='undefined' || typeof(first.EndDate)!='undefined' || typeof(first.AssociateId)!='undefined' ) )
        {
            _request = startDate as carriers.Appointment_GetRedLetterInformationListByDatesAndAssociateRequest;
            _options = endDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StartDate: startDate as Date,
                       EndDate: endDate as Date,
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetRedLetterInformationListByDatesAndAssociate( _request, _options );
    }


    private async _GetAlarms(request: carriers.Appointment_GetAlarmsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MultiAlarmData > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MultiAlarmData >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAlarms", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MultiAlarmData = converters.Create_MultiAlarmData_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - IncludeInvitations, IncludeAllAppointments, DefaultAlarmLeadTimeInMinutes
     * @returns 
     */
    public async GetAlarms(request: carriers.Appointment_GetAlarmsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MultiAlarmData >;

    /**
     * 
     * @param includeInvitations - 
     * @param includeAllAppointments - 
     * @param defaultAlarmLeadTimeInMinutes - 
     * @returns 
     */
    public async GetAlarms(includeInvitations: boolean, includeAllAppointments: boolean, defaultAlarmLeadTimeInMinutes: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MultiAlarmData >;

    public async GetAlarms(includeInvitations:boolean|carriers.Appointment_GetAlarmsRequest, includeAllAppointments?:boolean|base.WebApiRequestOptions, defaultAlarmLeadTimeInMinutes?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MultiAlarmData > {
        let _request : carriers.Appointment_GetAlarmsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeInvitations;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeInvitations)!='undefined' || typeof(first.IncludeAllAppointments)!='undefined' || typeof(first.DefaultAlarmLeadTimeInMinutes)!='undefined' ) )
        {
            _request = includeInvitations as carriers.Appointment_GetAlarmsRequest;
            _options = includeAllAppointments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeInvitations: includeInvitations as boolean,
                       IncludeAllAppointments: includeAllAppointments as boolean,
                       DefaultAlarmLeadTimeInMinutes: defaultAlarmLeadTimeInMinutes as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAlarms( _request, _options );
    }


    private async _GenerateLead(request: carriers.Appointment_GenerateLeadRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SalesActivity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateLead", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SalesActivity = converters.Create_SalesActivity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Adds a sales lead (task) to a contact in SuperOffice. If the contact or person is known, the sales lead is added to the current contact. If not, a new contact is created, with the associate with ownerIdForNewContact as responsible (Our Contact). A relation is created between the contact and the person submitting the lead. Based on wether the person the request is made for is found or not, the following happens: If the person is found, the person, person&apos;s contact and sales representative is returned. If neither the person nor the contact is found a new person and contact is created (if sufficient data is supplied), and the person, person&apos;s contact and sales representative is returned. If the contact and not the person is found a new person is created on this contact, and the contact, salesrep, and person is returned (if there was enough data to return the person). If more than one contact is found a list of contacts is returned.
     * @param request - AssociateIdForNewContact, LeadDescription, Relation, RelationId, LeadContact, LeadPersonFirstname, LeadPersonLastname, LeadPersonEmail, LeadPhoneNumber, CreatorsContact, CreatorsFirstname, CreatorsLastname
     * @returns True if successfull.
     */
    public async GenerateLead(request: carriers.Appointment_GenerateLeadRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity >;

    /**
     * Adds a sales lead (task) to a contact in SuperOffice. If the contact or person is known, the sales lead is added to the current contact. If not, a new contact is created, with the associate with ownerIdForNewContact as responsible (Our Contact). A relation is created between the contact and the person submitting the lead. Based on wether the person the request is made for is found or not, the following happens: If the person is found, the person, person&apos;s contact and sales representative is returned. If neither the person nor the contact is found a new person and contact is created (if sufficient data is supplied), and the person, person&apos;s contact and sales representative is returned. If the contact and not the person is found a new person is created on this contact, and the contact, salesrep, and person is returned (if there was enough data to return the person). If more than one contact is found a list of contacts is returned.
     * @param associateIdForNewContact - Associate id of the person set as "Our Contact" if a new Contact is created. Ensures that the sales lead is assigned to the correct salesman.
     * @param leadDescription - Description of the lead. The lead text as shown in SuperOffice
     * @param relation - The relation the person submitting the lead has to the contact.
     * @param relationId - Id of the relation type. Database specific.
     * @param leadContact - Name of the new or existing contact (company) the lead is created for.
     * @param leadPersonFirstname - Firstname of the contact's person.
     * @param leadPersonLastname - Lastname of the contact's person.
     * @param leadPersonEmail - Email to the contact's person.
     * @param leadPhoneNumber - Phone number of the contact or contact's person.
     * @param creatorsContact - The contact (company) of the person creating the lead
     * @param creatorsFirstname - The firstname of the person creating the lead
     * @param creatorsLastname - The lastname of the person creating the lead
     * @returns True if successfull.
     */
    public async GenerateLead(associateIdForNewContact: number, leadDescription: string, relation: string, relationId: number, leadContact: string, leadPersonFirstname: string, leadPersonLastname: string, leadPersonEmail: string, leadPhoneNumber: string, creatorsContact: string, creatorsFirstname: string, creatorsLastname: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity >;

    public async GenerateLead(associateIdForNewContact:number|carriers.Appointment_GenerateLeadRequest, leadDescription?:string|base.WebApiRequestOptions, relation?:string, relationId?:number, leadContact?:string, leadPersonFirstname?:string, leadPersonLastname?:string, leadPersonEmail?:string, leadPhoneNumber?:string, creatorsContact?:string, creatorsFirstname?:string, creatorsLastname?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity > {
        let _request : carriers.Appointment_GenerateLeadRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateIdForNewContact;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateIdForNewContact)!='undefined' || typeof(first.LeadDescription)!='undefined' || typeof(first.Relation)!='undefined' || typeof(first.RelationId)!='undefined' || typeof(first.LeadContact)!='undefined' || typeof(first.LeadPersonFirstname)!='undefined' || typeof(first.LeadPersonLastname)!='undefined' || typeof(first.LeadPersonEmail)!='undefined' || typeof(first.LeadPhoneNumber)!='undefined' || typeof(first.CreatorsContact)!='undefined' || typeof(first.CreatorsFirstname)!='undefined' || typeof(first.CreatorsLastname)!='undefined' ) )
        {
            _request = associateIdForNewContact as carriers.Appointment_GenerateLeadRequest;
            _options = leadDescription as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateIdForNewContact: associateIdForNewContact as number,
                       LeadDescription: leadDescription as string,
                       Relation: relation as string,
                       RelationId: relationId as number,
                       LeadContact: leadContact as string,
                       LeadPersonFirstname: leadPersonFirstname as string,
                       LeadPersonLastname: leadPersonLastname as string,
                       LeadPersonEmail: leadPersonEmail as string,
                       LeadPhoneNumber: leadPhoneNumber as string,
                       CreatorsContact: creatorsContact as string,
                       CreatorsFirstname: creatorsFirstname as string,
                       CreatorsLastname: creatorsLastname as string,
                       };   
            _options = webapi_options;
        }
        return this._GenerateLead( _request, _options );
    }


    private async _RequestForInfo(request: carriers.Appointment_RequestForInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SalesActivity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RequestForInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SalesActivity = converters.Create_SalesActivity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Submits a request for information. The request is added to the task list of the user that is responsible for this contact. Based on wether the person the request is made for is found or not, the following happens: If the person is found, the person, person&apos;s contact and sales representative is returned. If neither the person nor the contact is found a new person and contact is created (if sufficient data is supplied), and the person, person&apos;s contact and sales representative is returned. If the contact and not the person is found a new person is created on this contact, and the contact, salesrep, and person is returned (if there was enough data to return the person). If more than one contact is found a list of contacts is returned.
     * @param request - AssociateIdForNewContact, Channel, Regarding, ContactName, PersonFirstname, PersonLastname, EmailAddress, PhoneNumber
     * @returns True if the submission was successful.
     */
    public async RequestForInfo(request: carriers.Appointment_RequestForInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity >;

    /**
     * Submits a request for information. The request is added to the task list of the user that is responsible for this contact. Based on wether the person the request is made for is found or not, the following happens: If the person is found, the person, person&apos;s contact and sales representative is returned. If neither the person nor the contact is found a new person and contact is created (if sufficient data is supplied), and the person, person&apos;s contact and sales representative is returned. If the contact and not the person is found a new person is created on this contact, and the contact, salesrep, and person is returned (if there was enough data to return the person). If more than one contact is found a list of contacts is returned.
     * @param associateIdForNewContact - Associate id of the person set as "Our Contact" if a new Contact is created. Ensures that the request is assigned to the correct salesman.
     * @param channel - The requested channel, e.g. "Phone"
     * @param regarding - The text submitted by the user.
     * @param contactName - The name of the contact that the RFI will be added to. May be empty.
     * @param personFirstname - The firstname of the person that the RFI will be added to. May be empty.
     * @param personLastname - The lastname of the person that the RFI will be added to. May be empty.
     * @param emailAddress - The email address of the person that the RFI will be added to.
     * @param phoneNumber - Phone number of the contact or contact's person.
     * @returns True if the submission was successful.
     */
    public async RequestForInfo(associateIdForNewContact: number, channel: string, regarding: string, contactName: string, personFirstname: string, personLastname: string, emailAddress: string, phoneNumber: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity >;

    public async RequestForInfo(associateIdForNewContact:number|carriers.Appointment_RequestForInfoRequest, channel?:string|base.WebApiRequestOptions, regarding?:string, contactName?:string, personFirstname?:string, personLastname?:string, emailAddress?:string, phoneNumber?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SalesActivity > {
        let _request : carriers.Appointment_RequestForInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateIdForNewContact;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateIdForNewContact)!='undefined' || typeof(first.Channel)!='undefined' || typeof(first.Regarding)!='undefined' || typeof(first.ContactName)!='undefined' || typeof(first.PersonFirstname)!='undefined' || typeof(first.PersonLastname)!='undefined' || typeof(first.EmailAddress)!='undefined' || typeof(first.PhoneNumber)!='undefined' ) )
        {
            _request = associateIdForNewContact as carriers.Appointment_RequestForInfoRequest;
            _options = channel as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateIdForNewContact: associateIdForNewContact as number,
                       Channel: channel as string,
                       Regarding: regarding as string,
                       ContactName: contactName as string,
                       PersonFirstname: personFirstname as string,
                       PersonLastname: personLastname as string,
                       EmailAddress: emailAddress as string,
                       PhoneNumber: phoneNumber as string,
                       };   
            _options = webapi_options;
        }
        return this._RequestForInfo( _request, _options );
    }

    /*
     * Gets a SuggestedAppointment object.
     * @param suggestedAppointmentId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SuggestedAppointment
     */
    public async GetSuggestedAppointment(suggestedAppointmentId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SuggestedAppointment >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSuggestedAppointment?suggestedAppointmentId=" + suggestedAppointmentId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedAppointment_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a SuggestedAppointmentEntity object.
     * @param suggestedAppointmentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SuggestedAppointmentEntity
     */
    public async GetSuggestedAppointmentEntity(suggestedAppointmentEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedAppointmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SuggestedAppointmentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSuggestedAppointmentEntity?suggestedAppointmentEntityId=" + suggestedAppointmentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedAppointmentEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a TaskListItem object.
     * @param taskListItemId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TaskListItem
     */
    public async GetTaskListItem(taskListItemId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskListItem >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTaskListItem?taskListItemId=" + taskListItemId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskListItem_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetTaskListItems(request: carriers.Appointment_GetTaskListItemsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTaskListItems", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TaskListItem[] = converters.Create_TaskListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets all takslist items
     * @param request - IncludeDeleted
     * @returns An array of tasklist items
     */
    public async GetTaskListItems(request: carriers.Appointment_GetTaskListItemsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] >;

    /**
     * Gets all takslist items
     * @param includeDeleted - Include deleted items
     * @returns An array of tasklist items
     */
    public async GetTaskListItems(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] >;

    public async GetTaskListItems(includeDeleted:boolean|carriers.Appointment_GetTaskListItemsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] > {
        let _request : carriers.Appointment_GetTaskListItemsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.Appointment_GetTaskListItemsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetTaskListItems( _request, _options );
    }

    } // class v1AppointmentAgentController 



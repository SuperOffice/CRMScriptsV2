// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/UserAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * User administration
 * 
 * **Online Restricted:** This agent is not available in Online by default. User management is not allowed for partner apps.
 */
export interface IUserAgent {
    CreateDefaultRoleEntity(): Promise< carriers.RoleEntity >;
    SaveRoleEntity(entity: carriers.RoleEntity) : Promise< carriers.RoleEntity >;
    CreateDefaultServiceAuth(): Promise< carriers.ServiceAuth >;
    SaveServiceAuth(entity: carriers.ServiceAuth) : Promise< carriers.ServiceAuth >;
    DeleteServiceAuth(ServiceAuthId: number) : Promise<void>;
    CreateDefaultUntrustedCredentials(): Promise< carriers.UntrustedCredentials >;
    CreateDefaultUser(): Promise< carriers.User >;
    SaveUser(entity: carriers.User) : Promise< carriers.User >;
    DeleteUser(UserId: number) : Promise<void>;
    GetAccessGatewayInfo(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >;
    GetOrRegisterAccessGatewayInfo(request: carriers.User_GetOrRegisterAccessGatewayInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >;
    GetOrRegisterAccessGatewayInfo(redirectUri: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >;
    RegisterWithAccessGateway(request: carriers.User_RegisterWithAccessGatewayRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >;
    RegisterWithAccessGateway(redirectUri: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >;
    CheckAccessGatewayRegistration(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SaveCredential(request: carriers.User_SaveCredentialRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SaveCredential(userId: number, credential: carriers.Credential, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    DeleteCredential(request: carriers.User_DeleteCredentialRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    DeleteCredential(userId: number, credentialType: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    FindCredentialsGroups(request: carriers.User_FindCredentialsGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroup[] >;
    FindCredentialsGroups(type: string, searchString: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroup[] >;
    FindCredentialUsers(request: carriers.User_FindCredentialUsersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers >;
    FindCredentialUsers(type: string, searchString: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers >;
    GetCredentialUsersInGroup(request: carriers.User_GetCredentialUsersInGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers >;
    GetCredentialUsersInGroup(type: string, groupName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers >;
    GetRole(roleId: number) :  Promise< carriers.Role >;
    GetRoleEntity(roleEntityId: number) :  Promise< carriers.RoleEntity >;
    DeleteRole(request: carriers.User_DeleteRoleRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteRole(roleIdToDelete: number, replacingRoleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetAllRoles(request: carriers.User_GetAllRolesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetAllRoles(roleType: enums.RoleType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetAllFunctionalRights(request: carriers.User_GetAllFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetAllFunctionalRights(roleType: enums.RoleType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetFunctionalRights(request: carriers.User_GetFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetFunctionalRights(roleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SetFunctionalRights(request: carriers.User_SetFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetFunctionalRights(roleId: number, functionalRightIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetDataRight(request: carriers.User_SetDataRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetDataRight(roleId: number, tableName: string, relationToOwner: enums.RoleRelationToOwner, dataRightValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetDataRight(request: carriers.User_GetDataRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDataRight(roleId: number, tableName: string, relationToOwner: enums.RoleRelationToOwner, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDataRights(request: carriers.User_GetDataRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetDataRights(roleId: number, tableName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    CreateDefaultRoleEntityFromType(request: carriers.User_CreateDefaultRoleEntityFromTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RoleEntity >;
    CreateDefaultRoleEntityFromType(type: enums.RoleType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RoleEntity >;
    FindRolesWithFunctionalRight(request: carriers.User_FindRolesWithFunctionalRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    FindRolesWithFunctionalRight(functionalRightName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    FindRolesWithFunctionalRights(request: carriers.User_FindRolesWithFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    FindRolesWithFunctionalRights(functionalRightNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    FindRolesWithoutFunctionalRights(request: carriers.User_FindRolesWithoutFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    FindRolesWithoutFunctionalRights(functionalRightNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    GetServiceAuth(serviceAuthId: number) :  Promise< carriers.ServiceAuth >;
    SaveExternalTokens(request: carriers.User_SaveExternalTokensRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SaveExternalTokens(tokenManagementInfo: carriers.TokenManagementInfo, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    DecryptAndSaveExternalTokens(request: carriers.User_DecryptAndSaveExternalTokensRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    DecryptAndSaveExternalTokens(tokenManagementInfo: carriers.TokenManagementInfo, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetExternalTokens(request: carriers.User_GetExternalTokensRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TokenManagementInfo >;
    GetExternalTokens(key: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TokenManagementInfo >;
    GetUser(userId: number) :  Promise< carriers.User >;
    GetUserFromName(request: carriers.User_GetUserFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    GetUserFromName(userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    SaveUserFromName(request: carriers.User_SaveUserFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    SaveUserFromName(userName: string, user: carriers.User, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    DeleteUserFromName(request: carriers.User_DeleteUserFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteUserFromName(userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetCredentialTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialType[] >;
    GetCredentialTypesForUserType(request: carriers.User_GetCredentialTypesForUserTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialType[] >;
    GetCredentialTypesForUserType(userType: enums.UserType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialType[] >;
    SaveUntrustedCredentials(request: carriers.User_SaveUntrustedCredentialsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveUntrustedCredentials(type: string, credentials: carriers.UntrustedCredentials, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetUntrustedCredentials(request: carriers.User_GetUntrustedCredentialsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] >;
    GetUntrustedCredentials(type: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] >;
    GetUntrustedCredentialsForAssociate(request: carriers.User_GetUntrustedCredentialsForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] >;
    GetUntrustedCredentialsForAssociate(associateId: number, type: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] >;
    SaveUntrustedCredentialsForAssociate(request: carriers.User_SaveUntrustedCredentialsForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveUntrustedCredentialsForAssociate(associateId: number, type: string, credentials: carriers.UntrustedCredentials, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveUntrustedCredentials(request: carriers.User_RemoveUntrustedCredentialsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveUntrustedCredentials(type: string, publicValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveUntrustedCredentialsForAssociate(request: carriers.User_RemoveUntrustedCredentialsForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveUntrustedCredentialsForAssociate(associateId: number, type: string, publicValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateExternalUser(request: carriers.User_CreateExternalUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CreateExternalUser(personId: number, userName: string, password: string, roleId: number, isActive: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    DeleteExternalUser(request: carriers.User_DeleteExternalUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteExternalUser(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetExternalUserInfo(request: carriers.User_SetExternalUserInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetExternalUserInfo(associateId: number, userName: string, password: string, isActive: boolean, roleId: number, externalUserInfoModification: enums.ExternalUserInfoModification, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GenerateNewPasswordForExternalUser(request: carriers.User_GenerateNewPasswordForExternalUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GenerateNewPasswordForExternalUser(associateName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    CanChangePassword(request: carriers.User_CanChangePasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CanChangePassword(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetSupportedChangePasswordTypes(request: carriers.User_GetSupportedChangePasswordTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ChangePasswordType[] >;
    GetSupportedChangePasswordTypes(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ChangePasswordType[] >;
    ChangePassword(request: carriers.User_ChangePasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ChangePassword(associateId: number, oldPassword: string, newPassword: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SendChangePasswordEMail(request: carriers.User_SendChangePasswordEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.OperationResult >;
    SendChangePasswordEMail(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.OperationResult >;
    GetUserFromPersonId(request: carriers.User_GetUserFromPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] >;
    GetUserFromPersonId(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] >;
    CreateDefaultUserFromUserTypeAndPersonId(request: carriers.User_CreateDefaultUserFromUserTypeAndPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    CreateDefaultUserFromUserTypeAndPersonId(userType: enums.UserType, personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    CreateDefaultUserFromUserType(request: carriers.User_CreateDefaultUserFromUserTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    CreateDefaultUserFromUserType(userType: enums.UserType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    GetUserFromEjUserId(request: carriers.User_GetUserFromEjUserIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] >;
    GetUserFromEjUserId(ejUserId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] >;
    SetPasswordFromName(request: carriers.User_SetPasswordFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SetPasswordFromName(associateName: string, password: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SetPassword(request: carriers.User_SetPasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SetPassword(associateId: number, password: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ChangeOwnPassword(request: carriers.User_ChangeOwnPasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ChangeOwnPassword(oldPassword: string, newPassword: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ChangePasswordFromName(request: carriers.User_ChangePasswordFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ChangePasswordFromName(associateName: string, oldPassword: string, newPassword: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsUserNameValid(request: carriers.User_IsUserNameValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsUserNameValid(associateId: number, type: enums.UserType, personId: number, userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsPasswordValid(request: carriers.User_IsPasswordValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsPasswordValid(associateId: number, type: enums.UserType, personId: number, password: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SetGeneratedPassword(request: carriers.User_SetGeneratedPasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SetGeneratedPassword(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SetGeneratedPasswordFromName(request: carriers.User_SetGeneratedPasswordFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SetGeneratedPasswordFromName(associateName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    IsPasswordValidWithReason(request: carriers.User_IsPasswordValidWithReasonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult >;
    IsPasswordValidWithReason(associateId: number, type: enums.UserType, personId: number, password: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult >;
    IsUserNameValidWithReason(request: carriers.User_IsUserNameValidWithReasonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult >;
    IsUserNameValidWithReason(associateId: number, type: enums.UserType, personId: number, userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult >;
    ChangeUserType(request: carriers.User_ChangeUserTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    ChangeUserType(user: carriers.User, userType: enums.UserType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    CreateDefaultUserFromUserTypeAndCredential(request: carriers.User_CreateDefaultUserFromUserTypeAndCredentialRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    CreateDefaultUserFromUserTypeAndCredential(userType: enums.UserType, contactId: number, credentialType: string, credentialValue: string, credentialDisplayValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;
    GetValidUserName(request: carriers.User_GetValidUserNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetValidUserName(associateId: number, type: enums.UserType, personId: number, userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    RemoveLicenses(request: carriers.User_RemoveLicensesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveLicenses(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MakeRetired(request: carriers.User_MakeRetiredRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MakeRetired(associateId: number, retired: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddOwnerContact(request: carriers.User_AddOwnerContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddOwnerContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveOwnerContact(request: carriers.User_RemoveOwnerContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveOwnerContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ResolveUserFromInfo(request: carriers.User_ResolveUserFromInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedUser >;
    ResolveUserFromInfo(contactId: number, personName: string, phoneNumbers: string[], emails: string[], userType: enums.UserType, credential: carriers.Credential, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedUser >;
    GetAccessToken(request: carriers.User_GetAccessTokenRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetAccessToken(appToken: string, includeCsSession: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetValidUserNameForNewUser(request: carriers.User_GetValidUserNameForNewUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetValidUserNameForNewUser(user: carriers.User, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDefaultAssociateUserName(request: carriers.User_GetDefaultAssociateUserNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDefaultAssociateUserName(user: carriers.User, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    IsNickNameUnique(request: carriers.User_IsNickNameUniqueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsNickNameUnique(associateId: number, nickName: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ValidateUser(request: carriers.User_ValidateUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    ValidateUser(user: carriers.User, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetUserPresenceStatus(request: carriers.User_GetUserPresenceStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus >;
    GetUserPresenceStatus(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus >;
    SetUserPresenceStatus(request: carriers.User_SetUserPresenceStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus >;
    SetUserPresenceStatus(associateId: number, userPresenceStatus: carriers.UserPresenceStatus, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus >;
    GetUserGroup(userGroupId: number) :  Promise< carriers.UserGroup >;
    SaveUserGroup(request: carriers.User_SaveUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup >;
    SaveUserGroup(userGroup: carriers.UserGroup, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup >;
    GetAllUserGroups(request: carriers.User_GetAllUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup[] >;
    GetAllUserGroups(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup[] >;
    CreateUserGroup(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup >;
    DeleteUserGroup(request: carriers.User_DeleteUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteUserGroup(userGroupToDelete: number, userGroupToMoveTo: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetUserGroupList(userGroupIds: number[]) :  Promise< carriers.UserGroup[] >;
    GetUserInfo(userInfoId: number) :  Promise< carriers.UserInfo >;
    GetUserInfoList(userInfoIds: number[]) :  Promise< carriers.UserInfo[] >;
} // interface IUserAgent




/**
 * User administration
 */
export class UserAgent extends base.WebApiBase implements IUserAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/User/";
        super(options);
    }



    /**
     * Set default values into a new RoleEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultRoleEntity(options?:base.WebApiRequestOptions) : Promise< carriers.RoleEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RoleEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultRoleEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RoleEntity = converters.Create_RoleEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing RoleEntity or creates a new RoleEntity if the id parameter is empty
     * @param entity - The RoleEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated RoleEntity
     */
    public async SaveRoleEntity(entity: carriers.RoleEntity, options?:base.WebApiRequestOptions) : Promise< carriers.RoleEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RoleEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveRoleEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RoleEntity = converters.Create_RoleEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ServiceAuth.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultServiceAuth(options?:base.WebApiRequestOptions) : Promise< carriers.ServiceAuth > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ServiceAuth >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultServiceAuth", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ServiceAuth = converters.Create_ServiceAuth_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ServiceAuth or creates a new ServiceAuth if the id parameter is empty
     * @param entity - The ServiceAuth to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ServiceAuth
     */
    public async SaveServiceAuth(entity: carriers.ServiceAuth, options?:base.WebApiRequestOptions) : Promise< carriers.ServiceAuth > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ServiceAuth >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveServiceAuth", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ServiceAuth = converters.Create_ServiceAuth_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ServiceAuth
     * @param ServiceAuthId - The id of the ServiceAuth to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteServiceAuth(ServiceAuthId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteServiceAuth?ServiceAuthId=" + ServiceAuthId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new UntrustedCredentials.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultUntrustedCredentials(options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UntrustedCredentials >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultUntrustedCredentials", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UntrustedCredentials = converters.Create_UntrustedCredentials_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new User.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultUser(options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultUser", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User = converters.Create_User_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing User or creates a new User if the id parameter is empty
     * @param entity - The User to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated User
     */
    public async SaveUser(entity: carriers.User, options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveUser", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User = converters.Create_User_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Get registered custom commands for User
     * @param request - The User entity to get commands for.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns Custom commands for the requested User.
     */
    public async GetUserCommands(request: carriers.GetUserCommandsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CustomCommand[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CustomCommand[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserCommands", request, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CustomCommand[] = converters.Create_CustomCommandArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Executes the custom command for User
     * @param request - The name of the command to execute. The User to execute commands on.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns Result of the executed command: Success + Message + CommandActionResult
     */
    public async ExecuteUserCommand(request: carriers.ExecuteUserCommandRequest, options?:base.WebApiRequestOptions ) : Promise< carriers.CommandResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CommandResult >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("ExecuteUserCommand", request, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CommandResult = converters.Create_CommandResult_From( response.data ); 
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the User
     * @param UserId - The id of the User to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteUser(UserId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteUser?UserId=" + UserId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    private async _GetAccessGatewayInfo( options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AccessGatewayInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAccessGatewayInfo", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AccessGatewayInfo = converters.Create_AccessGatewayInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns accessgateway registration info
     * @returns 
     */
    public async GetAccessGatewayInfo(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >
    {
        return this._GetAccessGatewayInfo(webapi_options);
    }


    private async _GetOrRegisterAccessGatewayInfo(request: carriers.User_GetOrRegisterAccessGatewayInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AccessGatewayInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOrRegisterAccessGatewayInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AccessGatewayInfo = converters.Create_AccessGatewayInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns accessgateway registration info and registers a new or adds the url if necessary
     * @param request - RedirectUri
     * @returns 
     */
    public async GetOrRegisterAccessGatewayInfo(request: carriers.User_GetOrRegisterAccessGatewayInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >;

    /**
     * Returns accessgateway registration info and registers a new or adds the url if necessary
     * @param redirectUri - This is the registered redirect_uri for AccessGateway OIDC.
     * @returns 
     */
    public async GetOrRegisterAccessGatewayInfo(redirectUri: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >;

    public async GetOrRegisterAccessGatewayInfo(redirectUri:string|carriers.User_GetOrRegisterAccessGatewayInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo > {
        let _request : carriers.User_GetOrRegisterAccessGatewayInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = redirectUri;
        if( typeof( first ) === "object" && first && ( typeof(first.RedirectUri)!='undefined' ) )
        {
            _request = redirectUri as carriers.User_GetOrRegisterAccessGatewayInfoRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RedirectUri: redirectUri as string,
                       };   
            _options = webapi_options;
        }
        return this._GetOrRegisterAccessGatewayInfo( _request, _options );
    }


    private async _RegisterWithAccessGateway(request: carriers.User_RegisterWithAccessGatewayRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AccessGatewayInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RegisterWithAccessGateway", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AccessGatewayInfo = converters.Create_AccessGatewayInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Registers with access gateway if not already done, otherwise will attempt to update
     * @param request - RedirectUri
     * @returns 
     */
    public async RegisterWithAccessGateway(request: carriers.User_RegisterWithAccessGatewayRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >;

    /**
     * Registers with access gateway if not already done, otherwise will attempt to update
     * @param redirectUri - This is the registered redirect_uri for AccessGateway OIDC.
     * @returns 
     */
    public async RegisterWithAccessGateway(redirectUri: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo >;

    public async RegisterWithAccessGateway(redirectUri:string|carriers.User_RegisterWithAccessGatewayRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AccessGatewayInfo > {
        let _request : carriers.User_RegisterWithAccessGatewayRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = redirectUri;
        if( typeof( first ) === "object" && first && ( typeof(first.RedirectUri)!='undefined' ) )
        {
            _request = redirectUri as carriers.User_RegisterWithAccessGatewayRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RedirectUri: redirectUri as string,
                       };   
            _options = webapi_options;
        }
        return this._RegisterWithAccessGateway( _request, _options );
    }


    private async _CheckAccessGatewayRegistration( options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckAccessGatewayRegistration", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Checks if AccessGatewayRegistration is valid
     * @returns True if the registration is usable
     */
    public async CheckAccessGatewayRegistration(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >
    {
        return this._CheckAccessGatewayRegistration(webapi_options);
    }


    private async _SaveCredential(request: carriers.User_SaveCredentialRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveCredential", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save (adds/replaces) current credential of the same type for the user.
     * @param request - UserId, Credential
     * @returns True if the credential was successfully saved.
     */
    public async SaveCredential(request: carriers.User_SaveCredentialRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Save (adds/replaces) current credential of the same type for the user.
     * @param userId - Primary key of the user (i.e. associate)
     * @param credential - Credentials supported for authentication
     * @returns True if the credential was successfully saved.
     */
    public async SaveCredential(userId: number, credential: carriers.Credential, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async SaveCredential(userId:number|carriers.User_SaveCredentialRequest, credential?:carriers.Credential|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_SaveCredentialRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userId;
        if( typeof( first ) === "object" && first && ( typeof(first.UserId)!='undefined' || typeof(first.Credential)!='undefined' ) )
        {
            _request = userId as carriers.User_SaveCredentialRequest;
            _options = credential as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserId: userId as number,
                       Credential: credential as carriers.Credential,
                       };   
            _options = webapi_options;
        }
        return this._SaveCredential( _request, _options );
    }


    private async _DeleteCredential(request: carriers.User_DeleteCredentialRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteCredential", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove credential of a specific type for a user
     * @param request - UserId, CredentialType
     * @returns True if credential was sucessfully removed.
     */
    public async DeleteCredential(request: carriers.User_DeleteCredentialRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Remove credential of a specific type for a user
     * @param userId - Primary key of the user (i.e. associate)
     * @param credentialType - Type of credentials, corresponding to name of plugin and type in the credentials table
     * @returns True if credential was sucessfully removed.
     */
    public async DeleteCredential(userId: number, credentialType: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async DeleteCredential(userId:number|carriers.User_DeleteCredentialRequest, credentialType?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_DeleteCredentialRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userId;
        if( typeof( first ) === "object" && first && ( typeof(first.UserId)!='undefined' || typeof(first.CredentialType)!='undefined' ) )
        {
            _request = userId as carriers.User_DeleteCredentialRequest;
            _options = credentialType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserId: userId as number,
                       CredentialType: credentialType as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteCredential( _request, _options );
    }


    private async _FindCredentialsGroups(request: carriers.User_FindCredentialsGroupsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroup[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CredentialsGroup[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindCredentialsGroups", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CredentialsGroup[] = converters.Create_CredentialsGroupArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get user groups holding users filtered by the searchString.  This method is only relevant if the CredentialType control is of type link.  There will allways be at least one groups even if the underlying provider does not support groups.
     * @param request - Type, SearchString
     * @returns 
     */
    public async FindCredentialsGroups(request: carriers.User_FindCredentialsGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroup[] >;

    /**
     * Get user groups holding users filtered by the searchString.  This method is only relevant if the CredentialType control is of type link.  There will allways be at least one groups even if the underlying provider does not support groups.
     * @param type - Type of credentials, corresponding to name of plugin and type in the credentials table.
     * @param searchString - Partly name of domain group.
     * @returns 
     */
    public async FindCredentialsGroups(type: string, searchString: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroup[] >;

    public async FindCredentialsGroups(type:string|carriers.User_FindCredentialsGroupsRequest, searchString?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroup[] > {
        let _request : carriers.User_FindCredentialsGroupsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' || typeof(first.SearchString)!='undefined' ) )
        {
            _request = type as carriers.User_FindCredentialsGroupsRequest;
            _options = searchString as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as string,
                       SearchString: searchString as string,
                       };   
            _options = webapi_options;
        }
        return this._FindCredentialsGroups( _request, _options );
    }


    private async _FindCredentialUsers(request: carriers.User_FindCredentialUsersRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CredentialsGroupUsers >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindCredentialUsers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CredentialsGroupUsers = converters.Create_CredentialsGroupUsers_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Find users matching the partial name.
     * @param request - Type, SearchString
     * @returns 
     */
    public async FindCredentialUsers(request: carriers.User_FindCredentialUsersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers >;

    /**
     * Find users matching the partial name.
     * @param type - Type of credentials, corresponding to name of plugin and type in the credentials table.
     * @param searchString - Partly name of the user group
     * @returns 
     */
    public async FindCredentialUsers(type: string, searchString: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers >;

    public async FindCredentialUsers(type:string|carriers.User_FindCredentialUsersRequest, searchString?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers > {
        let _request : carriers.User_FindCredentialUsersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' || typeof(first.SearchString)!='undefined' ) )
        {
            _request = type as carriers.User_FindCredentialUsersRequest;
            _options = searchString as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as string,
                       SearchString: searchString as string,
                       };   
            _options = webapi_options;
        }
        return this._FindCredentialUsers( _request, _options );
    }


    private async _GetCredentialUsersInGroup(request: carriers.User_GetCredentialUsersInGroupRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CredentialsGroupUsers >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCredentialUsersInGroup", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CredentialsGroupUsers = converters.Create_CredentialsGroupUsers_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get credential users within a user group
     * @param request - Type, GroupName
     * @returns 
     */
    public async GetCredentialUsersInGroup(request: carriers.User_GetCredentialUsersInGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers >;

    /**
     * Get credential users within a user group
     * @param type - Type of credentials, corresponding to name of plugin and type in the credentials table.
     * @param groupName - Name of user group needed to discover the users.
     * @returns 
     */
    public async GetCredentialUsersInGroup(type: string, groupName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers >;

    public async GetCredentialUsersInGroup(type:string|carriers.User_GetCredentialUsersInGroupRequest, groupName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialsGroupUsers > {
        let _request : carriers.User_GetCredentialUsersInGroupRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' || typeof(first.GroupName)!='undefined' ) )
        {
            _request = type as carriers.User_GetCredentialUsersInGroupRequest;
            _options = groupName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as string,
                       GroupName: groupName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetCredentialUsersInGroup( _request, _options );
    }

    /*
     * Gets a Role object.
     * @param roleId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Role
     */
    public async GetRole(roleId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Role > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Role >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRole?roleId=" + roleId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Role_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a RoleEntity object.
     * @param roleEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single RoleEntity
     */
    public async GetRoleEntity(roleEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.RoleEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RoleEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRoleEntity?roleEntityId=" + roleEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RoleEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _DeleteRole(request: carriers.User_DeleteRoleRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteRole", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete the specified role and move all users associated with the role to the replacingRoleId
     * @param request - RoleIdToDelete, ReplacingRoleId
     * @returns 
     */
    public async DeleteRole(request: carriers.User_DeleteRoleRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete the specified role and move all users associated with the role to the replacingRoleId
     * @param roleIdToDelete - The roleId to delete
     * @param replacingRoleId - The roleId which all associated users will be moved to.
     * @returns 
     */
    public async DeleteRole(roleIdToDelete: number, replacingRoleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteRole(roleIdToDelete:number|carriers.User_DeleteRoleRequest, replacingRoleId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_DeleteRoleRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = roleIdToDelete;
        if( typeof( first ) === "object" && first && ( typeof(first.RoleIdToDelete)!='undefined' || typeof(first.ReplacingRoleId)!='undefined' ) )
        {
            _request = roleIdToDelete as carriers.User_DeleteRoleRequest;
            _options = replacingRoleId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RoleIdToDelete: roleIdToDelete as number,
                       ReplacingRoleId: replacingRoleId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteRole( _request, _options );
    }


    private async _GetAllRoles(request: carriers.User_GetAllRolesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllRoles", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list of all roles for the given type of role. MDO List name = &apos;Roles&apos;, extra=&apos;0&apos; (roleType) 
     * @param request - RoleType
     * @returns FunctionRight items with name and description. Code name for function right is in the extra-info property.
     */
    public async GetAllRoles(request: carriers.User_GetAllRolesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * Get a list of all roles for the given type of role. MDO List name = &apos;Roles&apos;, extra=&apos;0&apos; (roleType) 
     * @param roleType - Type of role (Employee/External/Anonymous/System)
     * @returns FunctionRight items with name and description. Code name for function right is in the extra-info property.
     */
    public async GetAllRoles(roleType: enums.RoleType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetAllRoles(roleType:enums.RoleType|carriers.User_GetAllRolesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.User_GetAllRolesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = roleType;
        if( typeof( first ) === "object" && first && ( typeof(first.RoleType)!='undefined' ) )
        {
            _request = roleType as carriers.User_GetAllRolesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RoleType: roleType as enums.RoleType,
                       };   
            _options = webapi_options;
        }
        return this._GetAllRoles( _request, _options );
    }


    private async _GetAllFunctionalRights(request: carriers.User_GetAllFunctionalRightsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllFunctionalRights", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list of all functional rights for the given type of role. MDO List name = &apos;FunctionRights&apos;, extra=&apos;roleType=0&apos; 
     * @param request - RoleType
     * @returns FunctionRight items with name and description. Code name for function right is in the extra-info property.
     */
    public async GetAllFunctionalRights(request: carriers.User_GetAllFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * Get a list of all functional rights for the given type of role. MDO List name = &apos;FunctionRights&apos;, extra=&apos;roleType=0&apos; 
     * @param roleType - Type of role (Employee/External/Anonymous/System)
     * @returns FunctionRight items with name and description. Code name for function right is in the extra-info property.
     */
    public async GetAllFunctionalRights(roleType: enums.RoleType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetAllFunctionalRights(roleType:enums.RoleType|carriers.User_GetAllFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.User_GetAllFunctionalRightsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = roleType;
        if( typeof( first ) === "object" && first && ( typeof(first.RoleType)!='undefined' ) )
        {
            _request = roleType as carriers.User_GetAllFunctionalRightsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RoleType: roleType as enums.RoleType,
                       };   
            _options = webapi_options;
        }
        return this._GetAllFunctionalRights( _request, _options );
    }


    private async _GetFunctionalRights(request: carriers.User_GetFunctionalRightsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFunctionalRights", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all functional rights for the given role. Functional rights not set on the role are not included. MDO List name = &apos;FunctionRights&apos;, extra=&apos;role=123&apos;
     * @param request - RoleId
     * @returns FunctionRight items with name and description. Code name for function right is in the extra-info property.
     */
    public async GetFunctionalRights(request: carriers.User_GetFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * Get all functional rights for the given role. Functional rights not set on the role are not included. MDO List name = &apos;FunctionRights&apos;, extra=&apos;role=123&apos;
     * @param roleId - The role id to get the functional rights for.
     * @returns FunctionRight items with name and description. Code name for function right is in the extra-info property.
     */
    public async GetFunctionalRights(roleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetFunctionalRights(roleId:number|carriers.User_GetFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.User_GetFunctionalRightsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = roleId;
        if( typeof( first ) === "object" && first && ( typeof(first.RoleId)!='undefined' ) )
        {
            _request = roleId as carriers.User_GetFunctionalRightsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RoleId: roleId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetFunctionalRights( _request, _options );
    }


    private async _SetFunctionalRights(request: carriers.User_SetFunctionalRightsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetFunctionalRights", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set all functional rights for the given role. Functional rights not specified here will be removed from the role. 
     * @param request - RoleId, FunctionalRightIds
     * @returns 
     */
    public async SetFunctionalRights(request: carriers.User_SetFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set all functional rights for the given role. Functional rights not specified here will be removed from the role. 
     * @param roleId - The role id to set the functional rights for
     * @param functionalRightIds - An array of functional rights ids to set for this role. Rights not included here are removed from the role.
     * @returns 
     */
    public async SetFunctionalRights(roleId: number, functionalRightIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetFunctionalRights(roleId:number|carriers.User_SetFunctionalRightsRequest, functionalRightIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_SetFunctionalRightsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = roleId;
        if( typeof( first ) === "object" && first && ( typeof(first.RoleId)!='undefined' || typeof(first.FunctionalRightIds)!='undefined' ) )
        {
            _request = roleId as carriers.User_SetFunctionalRightsRequest;
            _options = functionalRightIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RoleId: roleId as number,
                       FunctionalRightIds: functionalRightIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetFunctionalRights( _request, _options );
    }


    private async _SetDataRight(request: carriers.User_SetDataRightRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDataRight", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set one specific data right at the given position. An exception will be thrown if non existing position is specified.
     * @param request - RoleId, TableName, RelationToOwner, DataRightValue
     * @returns 
     */
    public async SetDataRight(request: carriers.User_SetDataRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set one specific data right at the given position. An exception will be thrown if non existing position is specified.
     * @param roleId - The role id to set the data right for
     * @param tableName - The name of the entity/table
     * @param relationToOwner - The id of the relation to owner
     * @param dataRightValue - The data right value to set at the specified position (CRUD)
     * @returns 
     */
    public async SetDataRight(roleId: number, tableName: string, relationToOwner: enums.RoleRelationToOwner, dataRightValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetDataRight(roleId:number|carriers.User_SetDataRightRequest, tableName?:string|base.WebApiRequestOptions, relationToOwner?:enums.RoleRelationToOwner, dataRightValue?:string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_SetDataRightRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = roleId;
        if( typeof( first ) === "object" && first && ( typeof(first.RoleId)!='undefined' || typeof(first.TableName)!='undefined' || typeof(first.RelationToOwner)!='undefined' || typeof(first.DataRightValue)!='undefined' ) )
        {
            _request = roleId as carriers.User_SetDataRightRequest;
            _options = tableName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RoleId: roleId as number,
                       TableName: tableName as string,
                       RelationToOwner: relationToOwner as enums.RoleRelationToOwner,
                       DataRightValue: dataRightValue as string,
                       };   
            _options = webapi_options;
        }
        return this._SetDataRight( _request, _options );
    }


    private async _GetDataRight(request: carriers.User_GetDataRightRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDataRight", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Read one specific data right at the given position. An exception will be thrown if non existing position is specified.
     * @param request - RoleId, TableName, RelationToOwner
     * @returns The data right value at the specified position (C, CR, CRU, or CRUD)
     */
    public async GetDataRight(request: carriers.User_GetDataRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Read one specific data right at the given position. An exception will be thrown if non existing position is specified.
     * @param roleId - The role id to set the data right for
     * @param tableName - The name of the entity/table
     * @param relationToOwner - The id of the relation to owner
     * @returns The data right value at the specified position (C, CR, CRU, or CRUD)
     */
    public async GetDataRight(roleId: number, tableName: string, relationToOwner: enums.RoleRelationToOwner, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetDataRight(roleId:number|carriers.User_GetDataRightRequest, tableName?:string|base.WebApiRequestOptions, relationToOwner?:enums.RoleRelationToOwner, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_GetDataRightRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = roleId;
        if( typeof( first ) === "object" && first && ( typeof(first.RoleId)!='undefined' || typeof(first.TableName)!='undefined' || typeof(first.RelationToOwner)!='undefined' ) )
        {
            _request = roleId as carriers.User_GetDataRightRequest;
            _options = tableName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RoleId: roleId as number,
                       TableName: tableName as string,
                       RelationToOwner: relationToOwner as enums.RoleRelationToOwner,
                       };   
            _options = webapi_options;
        }
        return this._GetDataRight( _request, _options );
    }


    private async _GetDataRights(request: carriers.User_GetDataRightsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDataRights", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Read specific a set of data rights at the given row in the rights matrix. An exception will be thrown if non existing position is specified.
     * @param request - RoleId, TableName
     * @returns The data right values for all the defined relationships (C, CR, CRU, or CRUD)
     */
    public async GetDataRights(request: carriers.User_GetDataRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Read specific a set of data rights at the given row in the rights matrix. An exception will be thrown if non existing position is specified.
     * @param roleId - The role id to set the data right for
     * @param tableName - The name of the entity/table
     * @returns The data right values for all the defined relationships (C, CR, CRU, or CRUD)
     */
    public async GetDataRights(roleId: number, tableName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async GetDataRights(roleId:number|carriers.User_GetDataRightsRequest, tableName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.User_GetDataRightsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = roleId;
        if( typeof( first ) === "object" && first && ( typeof(first.RoleId)!='undefined' || typeof(first.TableName)!='undefined' ) )
        {
            _request = roleId as carriers.User_GetDataRightsRequest;
            _options = tableName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RoleId: roleId as number,
                       TableName: tableName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetDataRights( _request, _options );
    }


    private async _CreateDefaultRoleEntityFromType(request: carriers.User_CreateDefaultRoleEntityFromTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RoleEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RoleEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultRoleEntityFromType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RoleEntity = converters.Create_RoleEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new role entity of the specified role type. The role type cannot be changed after the entity is created.
     * @param request - Type
     * @returns A blank role.
     */
    public async CreateDefaultRoleEntityFromType(request: carriers.User_CreateDefaultRoleEntityFromTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RoleEntity >;

    /**
     * Create a new role entity of the specified role type. The role type cannot be changed after the entity is created.
     * @param type - Type of role (Employee/External/Anonymous/System)
     * @returns A blank role.
     */
    public async CreateDefaultRoleEntityFromType(type: enums.RoleType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RoleEntity >;

    public async CreateDefaultRoleEntityFromType(type:enums.RoleType|carriers.User_CreateDefaultRoleEntityFromTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RoleEntity > {
        let _request : carriers.User_CreateDefaultRoleEntityFromTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' ) )
        {
            _request = type as carriers.User_CreateDefaultRoleEntityFromTypeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as enums.RoleType,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultRoleEntityFromType( _request, _options );
    }


    private async _FindRolesWithFunctionalRight(request: carriers.User_FindRolesWithFunctionalRightRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindRolesWithFunctionalRight", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MDOListItem[] = converters.Create_MDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Find all roles with a given functional right. The roles matched must contain the specified functional right. 
     * @param request - FunctionalRightName
     * @returns Roles that contains the given functional right
     */
    public async FindRolesWithFunctionalRight(request: carriers.User_FindRolesWithFunctionalRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    /**
     * Find all roles with a given functional right. The roles matched must contain the specified functional right. 
     * @param functionalRightName - Functional right name to search for
     * @returns Roles that contains the given functional right
     */
    public async FindRolesWithFunctionalRight(functionalRightName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    public async FindRolesWithFunctionalRight(functionalRightName:string|carriers.User_FindRolesWithFunctionalRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        let _request : carriers.User_FindRolesWithFunctionalRightRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = functionalRightName;
        if( typeof( first ) === "object" && first && ( typeof(first.FunctionalRightName)!='undefined' ) )
        {
            _request = functionalRightName as carriers.User_FindRolesWithFunctionalRightRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FunctionalRightName: functionalRightName as string,
                       };   
            _options = webapi_options;
        }
        return this._FindRolesWithFunctionalRight( _request, _options );
    }


    private async _FindRolesWithFunctionalRights(request: carriers.User_FindRolesWithFunctionalRightsRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindRolesWithFunctionalRights", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Find all roles with a given set of functional rights. The roles matched must contain one or more of the specified functional rights. 
     * @param request - FunctionalRightNames
     * @returns Role ids that contains your functional rights
     */
    public async FindRolesWithFunctionalRights(request: carriers.User_FindRolesWithFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * Find all roles with a given set of functional rights. The roles matched must contain one or more of the specified functional rights. 
     * @param functionalRightNames - An array of functional rights names to search for
     * @returns Role ids that contains your functional rights
     */
    public async FindRolesWithFunctionalRights(functionalRightNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async FindRolesWithFunctionalRights(functionalRightNames:string[]|carriers.User_FindRolesWithFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.User_FindRolesWithFunctionalRightsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = functionalRightNames;
        if( typeof( first ) === "object" && first && ( typeof(first.FunctionalRightNames)!='undefined' ) )
        {
            _request = functionalRightNames as carriers.User_FindRolesWithFunctionalRightsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FunctionalRightNames: functionalRightNames as string[],
                       };   
            _options = webapi_options;
        }
        return this._FindRolesWithFunctionalRights( _request, _options );
    }


    private async _FindRolesWithoutFunctionalRights(request: carriers.User_FindRolesWithoutFunctionalRightsRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindRolesWithoutFunctionalRights", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Find all roles without a given set of functional rights. The roles matched must not contain any of the specified functional rights. 
     * @param request - FunctionalRightNames
     * @returns Role ids that without your functional rights
     */
    public async FindRolesWithoutFunctionalRights(request: carriers.User_FindRolesWithoutFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * Find all roles without a given set of functional rights. The roles matched must not contain any of the specified functional rights. 
     * @param functionalRightNames - An array of functional rights names to search for
     * @returns Role ids that without your functional rights
     */
    public async FindRolesWithoutFunctionalRights(functionalRightNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async FindRolesWithoutFunctionalRights(functionalRightNames:string[]|carriers.User_FindRolesWithoutFunctionalRightsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.User_FindRolesWithoutFunctionalRightsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = functionalRightNames;
        if( typeof( first ) === "object" && first && ( typeof(first.FunctionalRightNames)!='undefined' ) )
        {
            _request = functionalRightNames as carriers.User_FindRolesWithoutFunctionalRightsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FunctionalRightNames: functionalRightNames as string[],
                       };   
            _options = webapi_options;
        }
        return this._FindRolesWithoutFunctionalRights( _request, _options );
    }

    /*
     * Gets a ServiceAuth object.
     * @param serviceAuthId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ServiceAuth
     */
    public async GetServiceAuth(serviceAuthId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ServiceAuth > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ServiceAuth >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetServiceAuth?serviceAuthId=" + serviceAuthId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ServiceAuth_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SaveExternalTokens(request: carriers.User_SaveExternalTokensRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveExternalTokens", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the external tokens to the DB and returns a key that can be used to retrieve them
     * @param request - TokenManagementInfo
     * @returns Key that can be used to retrieve the tokens
     */
    public async SaveExternalTokens(request: carriers.User_SaveExternalTokensRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Saves the external tokens to the DB and returns a key that can be used to retrieve them
     * @param tokenManagementInfo - Token information.
     * @returns Key that can be used to retrieve the tokens
     */
    public async SaveExternalTokens(tokenManagementInfo: carriers.TokenManagementInfo, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SaveExternalTokens(tokenManagementInfo:carriers.TokenManagementInfo|carriers.User_SaveExternalTokensRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_SaveExternalTokensRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tokenManagementInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.TokenManagementInfo)!='undefined' ) )
        {
            _request = tokenManagementInfo as carriers.User_SaveExternalTokensRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TokenManagementInfo: tokenManagementInfo as carriers.TokenManagementInfo,
                       };   
            _options = webapi_options;
        }
        return this._SaveExternalTokens( _request, _options );
    }


    private async _DecryptAndSaveExternalTokens(request: carriers.User_DecryptAndSaveExternalTokensRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DecryptAndSaveExternalTokens", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * First asks AccessGateway to decrypt the tokens, then saves the external tokens to the DB and returns a key that can be used to retrieve them
     * @param request - TokenManagementInfo
     * @returns Key that can be used to retrieve the tokens
     */
    public async DecryptAndSaveExternalTokens(request: carriers.User_DecryptAndSaveExternalTokensRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * First asks AccessGateway to decrypt the tokens, then saves the external tokens to the DB and returns a key that can be used to retrieve them
     * @param tokenManagementInfo - Token information.
     * @returns Key that can be used to retrieve the tokens
     */
    public async DecryptAndSaveExternalTokens(tokenManagementInfo: carriers.TokenManagementInfo, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async DecryptAndSaveExternalTokens(tokenManagementInfo:carriers.TokenManagementInfo|carriers.User_DecryptAndSaveExternalTokensRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_DecryptAndSaveExternalTokensRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tokenManagementInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.TokenManagementInfo)!='undefined' ) )
        {
            _request = tokenManagementInfo as carriers.User_DecryptAndSaveExternalTokensRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TokenManagementInfo: tokenManagementInfo as carriers.TokenManagementInfo,
                       };   
            _options = webapi_options;
        }
        return this._DecryptAndSaveExternalTokens( _request, _options );
    }


    private async _GetExternalTokens(request: carriers.User_GetExternalTokensRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TokenManagementInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TokenManagementInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetExternalTokens", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TokenManagementInfo = converters.Create_TokenManagementInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve the tokens from the DB based on the given key
     * @param request - Key
     * @returns Key to retrieve tokens
     */
    public async GetExternalTokens(request: carriers.User_GetExternalTokensRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TokenManagementInfo >;

    /**
     * Retrieve the tokens from the DB based on the given key
     * @param key - Token retrievel key
     * @returns Key to retrieve tokens
     */
    public async GetExternalTokens(key: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TokenManagementInfo >;

    public async GetExternalTokens(key:string|carriers.User_GetExternalTokensRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TokenManagementInfo > {
        let _request : carriers.User_GetExternalTokensRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = key;
        if( typeof( first ) === "object" && first && ( typeof(first.Key)!='undefined' ) )
        {
            _request = key as carriers.User_GetExternalTokensRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Key: key as string,
                       };   
            _options = webapi_options;
        }
        return this._GetExternalTokens( _request, _options );
    }

    /*
     * Gets a User object.
     * @param userId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single User
     */
    public async GetUser(userId: number, options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUser?userId=" + userId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetUserFromName(request: carriers.User_GetUserFromNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User = converters.Create_User_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a user, with lookup based on user name.
     * @param request - UserName
     * @returns User retrieved by name
     */
    public async GetUserFromName(request: carriers.User_GetUserFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    /**
     * Get a user, with lookup based on user name.
     * @param userName - User name of the user to get.
     * @returns User retrieved by name
     */
    public async GetUserFromName(userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    public async GetUserFromName(userName:string|carriers.User_GetUserFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        let _request : carriers.User_GetUserFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userName;
        if( typeof( first ) === "object" && first && ( typeof(first.UserName)!='undefined' ) )
        {
            _request = userName as carriers.User_GetUserFromNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserName: userName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetUserFromName( _request, _options );
    }


    private async _SaveUserFromName(request: carriers.User_SaveUserFromNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveUserFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User = converters.Create_User_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a user, with lookup based on the user name.
     * @param request - UserName, User
     * @returns User retrieved by name
     */
    public async SaveUserFromName(request: carriers.User_SaveUserFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    /**
     * Save a user, with lookup based on the user name.
     * @param userName - User name of the user to get.
     * @param user - User object to save.
     * @returns User retrieved by name
     */
    public async SaveUserFromName(userName: string, user: carriers.User, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    public async SaveUserFromName(userName:string|carriers.User_SaveUserFromNameRequest, user?:carriers.User|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        let _request : carriers.User_SaveUserFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userName;
        if( typeof( first ) === "object" && first && ( typeof(first.UserName)!='undefined' || typeof(first.User)!='undefined' ) )
        {
            _request = userName as carriers.User_SaveUserFromNameRequest;
            _options = user as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserName: userName as string,
                       User: user as carriers.User,
                       };   
            _options = webapi_options;
        }
        return this._SaveUserFromName( _request, _options );
    }


    private async _DeleteUserFromName(request: carriers.User_DeleteUserFromNameRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteUserFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a user, with lookup based on the user name.
     * @param request - UserName
     * @returns This method has no return value
     */
    public async DeleteUserFromName(request: carriers.User_DeleteUserFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a user, with lookup based on the user name.
     * @param userName - User name of the user to delete.
     * @returns This method has no return value
     */
    public async DeleteUserFromName(userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteUserFromName(userName:string|carriers.User_DeleteUserFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_DeleteUserFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userName;
        if( typeof( first ) === "object" && first && ( typeof(first.UserName)!='undefined' ) )
        {
            _request = userName as carriers.User_DeleteUserFromNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserName: userName as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteUserFromName( _request, _options );
    }


    private async _GetCredentialTypes( options?:base.WebApiRequestOptions) : Promise< carriers.CredentialType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CredentialType[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCredentialTypes", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CredentialType[] = converters.Create_CredentialTypeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get available credential types that can be used for authentication
     * @returns Credential types that can be used for authentication
     */
    public async GetCredentialTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialType[] >
    {
        return this._GetCredentialTypes(webapi_options);
    }


    private async _GetCredentialTypesForUserType(request: carriers.User_GetCredentialTypesForUserTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CredentialType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CredentialType[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCredentialTypesForUserType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CredentialType[] = converters.Create_CredentialTypeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get available credential types that can be used for the specified user type.
     * @param request - UserType
     * @returns Credential types that can be used for authentication
     */
    public async GetCredentialTypesForUserType(request: carriers.User_GetCredentialTypesForUserTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialType[] >;

    /**
     * Get available credential types that can be used for the specified user type.
     * @param userType - The user type to retrieve credential types for
     * @returns Credential types that can be used for authentication
     */
    public async GetCredentialTypesForUserType(userType: enums.UserType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialType[] >;

    public async GetCredentialTypesForUserType(userType:enums.UserType|carriers.User_GetCredentialTypesForUserTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CredentialType[] > {
        let _request : carriers.User_GetCredentialTypesForUserTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userType;
        if( typeof( first ) === "object" && first && ( typeof(first.UserType)!='undefined' ) )
        {
            _request = userType as carriers.User_GetCredentialTypesForUserTypeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserType: userType as enums.UserType,
                       };   
            _options = webapi_options;
        }
        return this._GetCredentialTypesForUserType( _request, _options );
    }


    private async _SaveUntrustedCredentials(request: carriers.User_SaveUntrustedCredentialsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveUntrustedCredentials", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save credentials for authenticated user.
     * @param request - Type, Credentials
     * @returns 
     */
    public async SaveUntrustedCredentials(request: carriers.User_SaveUntrustedCredentialsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Save credentials for authenticated user.
     * @param type - Type of credential(Ex: "imap", "smtp")
     * @param credentials - Credentials to save.
     * @returns 
     */
    public async SaveUntrustedCredentials(type: string, credentials: carriers.UntrustedCredentials, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveUntrustedCredentials(type:string|carriers.User_SaveUntrustedCredentialsRequest, credentials?:carriers.UntrustedCredentials|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_SaveUntrustedCredentialsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' || typeof(first.Credentials)!='undefined' ) )
        {
            _request = type as carriers.User_SaveUntrustedCredentialsRequest;
            _options = credentials as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as string,
                       Credentials: credentials as carriers.UntrustedCredentials,
                       };   
            _options = webapi_options;
        }
        return this._SaveUntrustedCredentials( _request, _options );
    }


    private async _GetUntrustedCredentials(request: carriers.User_GetUntrustedCredentialsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UntrustedCredentials[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUntrustedCredentials", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UntrustedCredentials[] = converters.Create_UntrustedCredentialsArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a set of credentials of a specified type for authenticated user.
     * @param request - Type
     * @returns Array of credentials of the specified type.
     */
    public async GetUntrustedCredentials(request: carriers.User_GetUntrustedCredentialsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] >;

    /**
     * Get a set of credentials of a specified type for authenticated user.
     * @param type - Type of credential(Ex: "imap", "smtp").
     * @returns Array of credentials of the specified type.
     */
    public async GetUntrustedCredentials(type: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] >;

    public async GetUntrustedCredentials(type:string|carriers.User_GetUntrustedCredentialsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] > {
        let _request : carriers.User_GetUntrustedCredentialsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' ) )
        {
            _request = type as carriers.User_GetUntrustedCredentialsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as string,
                       };   
            _options = webapi_options;
        }
        return this._GetUntrustedCredentials( _request, _options );
    }


    private async _GetUntrustedCredentialsForAssociate(request: carriers.User_GetUntrustedCredentialsForAssociateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UntrustedCredentials[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUntrustedCredentialsForAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UntrustedCredentials[] = converters.Create_UntrustedCredentialsArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a set of credentials of a specified type for a specified user. SecretValue is only populated for authenticated user, and system users.
     * @param request - AssociateId, Type
     * @returns Array of credentials of the specified type.
     */
    public async GetUntrustedCredentialsForAssociate(request: carriers.User_GetUntrustedCredentialsForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] >;

    /**
     * Get a set of credentials of a specified type for a specified user. SecretValue is only populated for authenticated user, and system users.
     * @param associateId - Id of user to retrieve credentials for.
     * @param type - Type of credential(Ex: "imap", "smtp").
     * @returns Array of credentials of the specified type.
     */
    public async GetUntrustedCredentialsForAssociate(associateId: number, type: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] >;

    public async GetUntrustedCredentialsForAssociate(associateId:number|carriers.User_GetUntrustedCredentialsForAssociateRequest, type?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UntrustedCredentials[] > {
        let _request : carriers.User_GetUntrustedCredentialsForAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Type)!='undefined' ) )
        {
            _request = associateId as carriers.User_GetUntrustedCredentialsForAssociateRequest;
            _options = type as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Type: type as string,
                       };   
            _options = webapi_options;
        }
        return this._GetUntrustedCredentialsForAssociate( _request, _options );
    }


    private async _SaveUntrustedCredentialsForAssociate(request: carriers.User_SaveUntrustedCredentialsForAssociateRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveUntrustedCredentialsForAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save credentials for a specified user.
     * @param request - AssociateId, Type, Credentials
     * @returns 
     */
    public async SaveUntrustedCredentialsForAssociate(request: carriers.User_SaveUntrustedCredentialsForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Save credentials for a specified user.
     * @param associateId - Id of user to save credentials for.
     * @param type - Type of credential(Ex: "imap", "smtp")
     * @param credentials - Credentials to save.
     * @returns 
     */
    public async SaveUntrustedCredentialsForAssociate(associateId: number, type: string, credentials: carriers.UntrustedCredentials, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveUntrustedCredentialsForAssociate(associateId:number|carriers.User_SaveUntrustedCredentialsForAssociateRequest, type?:string|base.WebApiRequestOptions, credentials?:carriers.UntrustedCredentials, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_SaveUntrustedCredentialsForAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Type)!='undefined' || typeof(first.Credentials)!='undefined' ) )
        {
            _request = associateId as carriers.User_SaveUntrustedCredentialsForAssociateRequest;
            _options = type as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Type: type as string,
                       Credentials: credentials as carriers.UntrustedCredentials,
                       };   
            _options = webapi_options;
        }
        return this._SaveUntrustedCredentialsForAssociate( _request, _options );
    }


    private async _RemoveUntrustedCredentials(request: carriers.User_RemoveUntrustedCredentialsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveUntrustedCredentials", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove a credentials entry for authenticated user.
     * @param request - Type, PublicValue
     * @returns 
     */
    public async RemoveUntrustedCredentials(request: carriers.User_RemoveUntrustedCredentialsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Remove a credentials entry for authenticated user.
     * @param type - Type of credential(Ex: "imap", "smtp")
     * @param publicValue - PublicValue field of credentials to remove.
     * @returns 
     */
    public async RemoveUntrustedCredentials(type: string, publicValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveUntrustedCredentials(type:string|carriers.User_RemoveUntrustedCredentialsRequest, publicValue?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_RemoveUntrustedCredentialsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' || typeof(first.PublicValue)!='undefined' ) )
        {
            _request = type as carriers.User_RemoveUntrustedCredentialsRequest;
            _options = publicValue as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as string,
                       PublicValue: publicValue as string,
                       };   
            _options = webapi_options;
        }
        return this._RemoveUntrustedCredentials( _request, _options );
    }


    private async _RemoveUntrustedCredentialsForAssociate(request: carriers.User_RemoveUntrustedCredentialsForAssociateRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveUntrustedCredentialsForAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove a credentials entry for a specified user.
     * @param request - AssociateId, Type, PublicValue
     * @returns 
     */
    public async RemoveUntrustedCredentialsForAssociate(request: carriers.User_RemoveUntrustedCredentialsForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Remove a credentials entry for a specified user.
     * @param associateId - Id of user to remove credentials for.
     * @param type - Type of credential(Ex: "imap", "smtp")
     * @param publicValue - PublicValue field of credentials to remove.
     * @returns 
     */
    public async RemoveUntrustedCredentialsForAssociate(associateId: number, type: string, publicValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveUntrustedCredentialsForAssociate(associateId:number|carriers.User_RemoveUntrustedCredentialsForAssociateRequest, type?:string|base.WebApiRequestOptions, publicValue?:string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_RemoveUntrustedCredentialsForAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Type)!='undefined' || typeof(first.PublicValue)!='undefined' ) )
        {
            _request = associateId as carriers.User_RemoveUntrustedCredentialsForAssociateRequest;
            _options = type as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Type: type as string,
                       PublicValue: publicValue as string,
                       };   
            _options = webapi_options;
        }
        return this._RemoveUntrustedCredentialsForAssociate( _request, _options );
    }


    private async _CreateExternalUser(request: carriers.User_CreateExternalUserRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateExternalUser", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates an associate of type external user.
     * @param request - PersonId, UserName, Password, RoleId, IsActive
     * @returns Returns the created associateId.
     */
    public async CreateExternalUser(request: carriers.User_CreateExternalUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Creates an associate of type external user.
     * @param personId - The personId to create an external user for.
     * @param userName - Login username.
     * @param password - Login password.
     * @param roleId - Id of role for the external user. The role must be a role of type external users.
     * @param isActive - Set isActive to true to enable the external user to log in.
     * @returns Returns the created associateId.
     */
    public async CreateExternalUser(personId: number, userName: string, password: string, roleId: number, isActive: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async CreateExternalUser(personId:number|carriers.User_CreateExternalUserRequest, userName?:string|base.WebApiRequestOptions, password?:string, roleId?:number, isActive?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.User_CreateExternalUserRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.UserName)!='undefined' || typeof(first.Password)!='undefined' || typeof(first.RoleId)!='undefined' || typeof(first.IsActive)!='undefined' ) )
        {
            _request = personId as carriers.User_CreateExternalUserRequest;
            _options = userName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       UserName: userName as string,
                       Password: password as string,
                       RoleId: roleId as number,
                       IsActive: isActive as boolean,
                       };   
            _options = webapi_options;
        }
        return this._CreateExternalUser( _request, _options );
    }


    private async _DeleteExternalUser(request: carriers.User_DeleteExternalUserRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteExternalUser", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes an associate of type external user.
     * @param request - AssociateId
     * @returns 
     */
    public async DeleteExternalUser(request: carriers.User_DeleteExternalUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes an associate of type external user.
     * @param associateId - The associateId to delete the associate entry for.
     * @returns 
     */
    public async DeleteExternalUser(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteExternalUser(associateId:number|carriers.User_DeleteExternalUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_DeleteExternalUserRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.User_DeleteExternalUserRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteExternalUser( _request, _options );
    }


    private async _SetExternalUserInfo(request: carriers.User_SetExternalUserInfoRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetExternalUserInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Modifies an external user. Changes external users information according to the flags set in  externalUserInfoModification.
     * @param request - AssociateId, UserName, Password, IsActive, RoleId, ExternalUserInfoModification
     * @returns 
     */
    public async SetExternalUserInfo(request: carriers.User_SetExternalUserInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Modifies an external user. Changes external users information according to the flags set in  externalUserInfoModification.
     * @param associateId - The associateId to alter.
     * @param userName - Login username.
     * @param password - Login password.
     * @param isActive - Set isActive to true to enable the external user to log in.
     * @param roleId - Id of role for the external user. The role must be a role of type external users.
     * @param externalUserInfoModification - externalUserInfoModification is a flag describing what to change. <see cref="SuperOffice.CRM.Services.Util.ExternalUserInfoModification"/>.
     * @returns 
     */
    public async SetExternalUserInfo(associateId: number, userName: string, password: string, isActive: boolean, roleId: number, externalUserInfoModification: enums.ExternalUserInfoModification, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetExternalUserInfo(associateId:number|carriers.User_SetExternalUserInfoRequest, userName?:string|base.WebApiRequestOptions, password?:string, isActive?:boolean, roleId?:number, externalUserInfoModification?:enums.ExternalUserInfoModification, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_SetExternalUserInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.UserName)!='undefined' || typeof(first.Password)!='undefined' || typeof(first.IsActive)!='undefined' || typeof(first.RoleId)!='undefined' || typeof(first.ExternalUserInfoModification)!='undefined' ) )
        {
            _request = associateId as carriers.User_SetExternalUserInfoRequest;
            _options = userName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       UserName: userName as string,
                       Password: password as string,
                       IsActive: isActive as boolean,
                       RoleId: roleId as number,
                       ExternalUserInfoModification: externalUserInfoModification as enums.ExternalUserInfoModification,
                       };   
            _options = webapi_options;
        }
        return this._SetExternalUserInfo( _request, _options );
    }


    private async _GenerateNewPasswordForExternalUser(request: carriers.User_GenerateNewPasswordForExternalUserRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateNewPasswordForExternalUser", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Generates a new password for an external user.
     * @param request - AssociateName
     * @returns Returns the generated password.
     */
    public async GenerateNewPasswordForExternalUser(request: carriers.User_GenerateNewPasswordForExternalUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Generates a new password for an external user.
     * @param associateName - The name of the associate to change the password for.
     * @returns Returns the generated password.
     */
    public async GenerateNewPasswordForExternalUser(associateName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GenerateNewPasswordForExternalUser(associateName:string|carriers.User_GenerateNewPasswordForExternalUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_GenerateNewPasswordForExternalUserRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateName;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateName)!='undefined' ) )
        {
            _request = associateName as carriers.User_GenerateNewPasswordForExternalUserRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateName: associateName as string,
                       };   
            _options = webapi_options;
        }
        return this._GenerateNewPasswordForExternalUser( _request, _options );
    }


    private async _CanChangePassword(request: carriers.User_CanChangePasswordRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanChangePassword", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check if the current assoicate can change the password for an associate
     * @param request - AssociateId
     * @returns True if the associate can change the password
     */
    public async CanChangePassword(request: carriers.User_CanChangePasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Check if the current assoicate can change the password for an associate
     * @param associateId - AssociateId of the user to check if password can be changed
     * @returns True if the associate can change the password
     */
    public async CanChangePassword(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async CanChangePassword(associateId:number|carriers.User_CanChangePasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_CanChangePasswordRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.User_CanChangePasswordRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._CanChangePassword( _request, _options );
    }


    private async _GetSupportedChangePasswordTypes(request: carriers.User_GetSupportedChangePasswordTypesRequest, options?:base.WebApiRequestOptions) : Promise< enums.ChangePasswordType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< enums.ChangePasswordType[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSupportedChangePasswordTypes", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : enums.ChangePasswordType[] = response.data as enums.ChangePasswordType[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the different methods the user can use to change password
     * @param request - AssociateId
     * @returns List of types - empty if the user cannot change password in any way
     */
    public async GetSupportedChangePasswordTypes(request: carriers.User_GetSupportedChangePasswordTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ChangePasswordType[] >;

    /**
     * Get the different methods the user can use to change password
     * @param associateId - AssociateId of the user to check if password can be changed
     * @returns List of types - empty if the user cannot change password in any way
     */
    public async GetSupportedChangePasswordTypes(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ChangePasswordType[] >;

    public async GetSupportedChangePasswordTypes(associateId:number|carriers.User_GetSupportedChangePasswordTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< enums.ChangePasswordType[] > {
        let _request : carriers.User_GetSupportedChangePasswordTypesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.User_GetSupportedChangePasswordTypesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetSupportedChangePasswordTypes( _request, _options );
    }


    private async _ChangePassword(request: carriers.User_ChangePasswordRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangePassword", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change password for a user.
     * @param request - AssociateId, OldPassword, NewPassword
     * @returns True if the password was successfully changed.
     */
    public async ChangePassword(request: carriers.User_ChangePasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Change password for a user.
     * @param associateId - AssociateId of the user to change password for.
     * @param oldPassword - The current password of the user.  Administrators can leave this blank to force a new password upon a user.
     * @param newPassword - The new password for the user
     * @returns True if the password was successfully changed.
     */
    public async ChangePassword(associateId: number, oldPassword: string, newPassword: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async ChangePassword(associateId:number|carriers.User_ChangePasswordRequest, oldPassword?:string|base.WebApiRequestOptions, newPassword?:string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_ChangePasswordRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.OldPassword)!='undefined' || typeof(first.NewPassword)!='undefined' ) )
        {
            _request = associateId as carriers.User_ChangePasswordRequest;
            _options = oldPassword as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       OldPassword: oldPassword as string,
                       NewPassword: newPassword as string,
                       };   
            _options = webapi_options;
        }
        return this._ChangePassword( _request, _options );
    }


    private async _SendChangePasswordEMail(request: carriers.User_SendChangePasswordEMailRequest, options?:base.WebApiRequestOptions) : Promise< carriers.OperationResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.OperationResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendChangePasswordEMail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.OperationResult = converters.Create_OperationResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Send a change password email to this users registered address.
     * @param request - AssociateId
     * @returns Result - with result flag and optional error reason.
     */
    public async SendChangePasswordEMail(request: carriers.User_SendChangePasswordEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.OperationResult >;

    /**
     * Send a change password email to this users registered address.
     * @param associateId - AssociateId of the user to change password for.
     * @returns Result - with result flag and optional error reason.
     */
    public async SendChangePasswordEMail(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.OperationResult >;

    public async SendChangePasswordEMail(associateId:number|carriers.User_SendChangePasswordEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.OperationResult > {
        let _request : carriers.User_SendChangePasswordEMailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.User_SendChangePasswordEMailRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._SendChangePasswordEMail( _request, _options );
    }


    private async _GetUserFromPersonId(request: carriers.User_GetUserFromPersonIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.User[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserFromPersonId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User[] = converters.Create_UserArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the user associated with the supplied person id
     * @param request - PersonId
     * @returns 
     */
    public async GetUserFromPersonId(request: carriers.User_GetUserFromPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] >;

    /**
     * Returns the user associated with the supplied person id
     * @param personId - 
     * @returns 
     */
    public async GetUserFromPersonId(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] >;

    public async GetUserFromPersonId(personId:number|carriers.User_GetUserFromPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] > {
        let _request : carriers.User_GetUserFromPersonIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.User_GetUserFromPersonIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetUserFromPersonId( _request, _options );
    }


    private async _CreateDefaultUserFromUserTypeAndPersonId(request: carriers.User_CreateDefaultUserFromUserTypeAndPersonIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultUserFromUserTypeAndPersonId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User = converters.Create_User_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create default User providing the associate type and person id.  System and Anonymous users can be created without an exsisting person and permits person id to be 0.
     * @param request - UserType, PersonId
     * @returns New user object with defalt values set.
     */
    public async CreateDefaultUserFromUserTypeAndPersonId(request: carriers.User_CreateDefaultUserFromUserTypeAndPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    /**
     * Create default User providing the associate type and person id.  System and Anonymous users can be created without an exsisting person and permits person id to be 0.
     * @param userType - Type of associate for the user
     * @param personId - Primary key of the person to become a user.
     * @returns New user object with defalt values set.
     */
    public async CreateDefaultUserFromUserTypeAndPersonId(userType: enums.UserType, personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    public async CreateDefaultUserFromUserTypeAndPersonId(userType:enums.UserType|carriers.User_CreateDefaultUserFromUserTypeAndPersonIdRequest, personId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        let _request : carriers.User_CreateDefaultUserFromUserTypeAndPersonIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userType;
        if( typeof( first ) === "object" && first && ( typeof(first.UserType)!='undefined' || typeof(first.PersonId)!='undefined' ) )
        {
            _request = userType as carriers.User_CreateDefaultUserFromUserTypeAndPersonIdRequest;
            _options = personId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserType: userType as enums.UserType,
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultUserFromUserTypeAndPersonId( _request, _options );
    }


    private async _CreateDefaultUserFromUserType(request: carriers.User_CreateDefaultUserFromUserTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultUserFromUserType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User = converters.Create_User_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create default User providing the user type.  Only System and Anonymous users can be created without an exsisting person.  Use CreateDefaultUserFromUserTypeAndPersonId to create internal (i.e. Employee) or external users.
     * @param request - UserType
     * @returns New user object with defalt values set.
     */
    public async CreateDefaultUserFromUserType(request: carriers.User_CreateDefaultUserFromUserTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    /**
     * Create default User providing the user type.  Only System and Anonymous users can be created without an exsisting person.  Use CreateDefaultUserFromUserTypeAndPersonId to create internal (i.e. Employee) or external users.
     * @param userType - Type of associate for the user.  This can only be System or Anonymous. Use CreateDefaultUserFromUserTypeAndPersonId to create internal (i.e. Employee) or external users.
     * @returns New user object with defalt values set.
     */
    public async CreateDefaultUserFromUserType(userType: enums.UserType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    public async CreateDefaultUserFromUserType(userType:enums.UserType|carriers.User_CreateDefaultUserFromUserTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        let _request : carriers.User_CreateDefaultUserFromUserTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userType;
        if( typeof( first ) === "object" && first && ( typeof(first.UserType)!='undefined' ) )
        {
            _request = userType as carriers.User_CreateDefaultUserFromUserTypeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserType: userType as enums.UserType,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultUserFromUserType( _request, _options );
    }


    private async _GetUserFromEjUserId(request: carriers.User_GetUserFromEjUserIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.User[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserFromEjUserId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User[] = converters.Create_UserArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get user from ejUserId - used for eJournal Legacy Support.
     * @param request - EjUserId
     * @returns 
     */
    public async GetUserFromEjUserId(request: carriers.User_GetUserFromEjUserIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] >;

    /**
     * Get user from ejUserId - used for eJournal Legacy Support.
     * @param ejUserId - ejUserId - 
     * @returns 
     */
    public async GetUserFromEjUserId(ejUserId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] >;

    public async GetUserFromEjUserId(ejUserId:number|carriers.User_GetUserFromEjUserIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User[] > {
        let _request : carriers.User_GetUserFromEjUserIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ejUserId;
        if( typeof( first ) === "object" && first && ( typeof(first.EjUserId)!='undefined' ) )
        {
            _request = ejUserId as carriers.User_GetUserFromEjUserIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EjUserId: ejUserId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetUserFromEjUserId( _request, _options );
    }


    private async _SetPasswordFromName(request: carriers.User_SetPasswordFromNameRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPasswordFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change password for a user.
     * @param request - AssociateName, Password
     * @returns Succeeded?
     */
    public async SetPasswordFromName(request: carriers.User_SetPasswordFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Change password for a user.
     * @param associateName - Username to set password for
     * @param password - New password
     * @returns Succeeded?
     */
    public async SetPasswordFromName(associateName: string, password: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async SetPasswordFromName(associateName:string|carriers.User_SetPasswordFromNameRequest, password?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_SetPasswordFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateName;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateName)!='undefined' || typeof(first.Password)!='undefined' ) )
        {
            _request = associateName as carriers.User_SetPasswordFromNameRequest;
            _options = password as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateName: associateName as string,
                       Password: password as string,
                       };   
            _options = webapi_options;
        }
        return this._SetPasswordFromName( _request, _options );
    }


    private async _SetPassword(request: carriers.User_SetPasswordRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPassword", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change password for a user.
     * @param request - AssociateId, Password
     * @returns Succeeded?
     */
    public async SetPassword(request: carriers.User_SetPasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Change password for a user.
     * @param associateId - Id of User to set password for
     * @param password - New password
     * @returns Succeeded?
     */
    public async SetPassword(associateId: number, password: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async SetPassword(associateId:number|carriers.User_SetPasswordRequest, password?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_SetPasswordRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Password)!='undefined' ) )
        {
            _request = associateId as carriers.User_SetPasswordRequest;
            _options = password as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Password: password as string,
                       };   
            _options = webapi_options;
        }
        return this._SetPassword( _request, _options );
    }


    private async _ChangeOwnPassword(request: carriers.User_ChangeOwnPasswordRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeOwnPassword", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change password for a user.
     * @param request - OldPassword, NewPassword
     * @returns True if the password was successfully changed.
     */
    public async ChangeOwnPassword(request: carriers.User_ChangeOwnPasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Change password for a user.
     * @param oldPassword - The current password of the user.  Administrators can leave this blank to force a new password upon a user.
     * @param newPassword - The new password for the user
     * @returns True if the password was successfully changed.
     */
    public async ChangeOwnPassword(oldPassword: string, newPassword: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async ChangeOwnPassword(oldPassword:string|carriers.User_ChangeOwnPasswordRequest, newPassword?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_ChangeOwnPasswordRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = oldPassword;
        if( typeof( first ) === "object" && first && ( typeof(first.OldPassword)!='undefined' || typeof(first.NewPassword)!='undefined' ) )
        {
            _request = oldPassword as carriers.User_ChangeOwnPasswordRequest;
            _options = newPassword as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       OldPassword: oldPassword as string,
                       NewPassword: newPassword as string,
                       };   
            _options = webapi_options;
        }
        return this._ChangeOwnPassword( _request, _options );
    }


    private async _ChangePasswordFromName(request: carriers.User_ChangePasswordFromNameRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangePasswordFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change password for a user.
     * @param request - AssociateName, OldPassword, NewPassword
     * @returns True if the password was successfully changed.
     */
    public async ChangePasswordFromName(request: carriers.User_ChangePasswordFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Change password for a user.
     * @param associateName - Username of the user to change password for.
     * @param oldPassword - The current password of the user.  Administrators can leave this blank to force a new password upon a user.
     * @param newPassword - The new password for the user
     * @returns True if the password was successfully changed.
     */
    public async ChangePasswordFromName(associateName: string, oldPassword: string, newPassword: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async ChangePasswordFromName(associateName:string|carriers.User_ChangePasswordFromNameRequest, oldPassword?:string|base.WebApiRequestOptions, newPassword?:string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_ChangePasswordFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateName;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateName)!='undefined' || typeof(first.OldPassword)!='undefined' || typeof(first.NewPassword)!='undefined' ) )
        {
            _request = associateName as carriers.User_ChangePasswordFromNameRequest;
            _options = oldPassword as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateName: associateName as string,
                       OldPassword: oldPassword as string,
                       NewPassword: newPassword as string,
                       };   
            _options = webapi_options;
        }
        return this._ChangePasswordFromName( _request, _options );
    }


    private async _IsUserNameValid(request: carriers.User_IsUserNameValidRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsUserNameValid", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateId, Type, PersonId, UserName
     * @returns 
     */
    public async IsUserNameValid(request: carriers.User_IsUserNameValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param associateId - 
     * @param type - 
     * @param personId - 
     * @param userName - 
     * @returns 
     */
    public async IsUserNameValid(associateId: number, type: enums.UserType, personId: number, userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async IsUserNameValid(associateId:number|carriers.User_IsUserNameValidRequest, type?:enums.UserType|base.WebApiRequestOptions, personId?:number, userName?:string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_IsUserNameValidRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Type)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.UserName)!='undefined' ) )
        {
            _request = associateId as carriers.User_IsUserNameValidRequest;
            _options = type as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Type: type as enums.UserType,
                       PersonId: personId as number,
                       UserName: userName as string,
                       };   
            _options = webapi_options;
        }
        return this._IsUserNameValid( _request, _options );
    }


    private async _IsPasswordValid(request: carriers.User_IsPasswordValidRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsPasswordValid", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateId, Type, PersonId, Password
     * @returns 
     */
    public async IsPasswordValid(request: carriers.User_IsPasswordValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param associateId - 
     * @param type - 
     * @param personId - 
     * @param password - 
     * @returns 
     */
    public async IsPasswordValid(associateId: number, type: enums.UserType, personId: number, password: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async IsPasswordValid(associateId:number|carriers.User_IsPasswordValidRequest, type?:enums.UserType|base.WebApiRequestOptions, personId?:number, password?:string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_IsPasswordValidRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Type)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.Password)!='undefined' ) )
        {
            _request = associateId as carriers.User_IsPasswordValidRequest;
            _options = type as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Type: type as enums.UserType,
                       PersonId: personId as number,
                       Password: password as string,
                       };   
            _options = webapi_options;
        }
        return this._IsPasswordValid( _request, _options );
    }


    private async _SetGeneratedPassword(request: carriers.User_SetGeneratedPasswordRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetGeneratedPassword", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateId
     * @returns 
     */
    public async SetGeneratedPassword(request: carriers.User_SetGeneratedPasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * 
     * @param associateId - 
     * @returns 
     */
    public async SetGeneratedPassword(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SetGeneratedPassword(associateId:number|carriers.User_SetGeneratedPasswordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_SetGeneratedPasswordRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.User_SetGeneratedPasswordRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._SetGeneratedPassword( _request, _options );
    }


    private async _SetGeneratedPasswordFromName(request: carriers.User_SetGeneratedPasswordFromNameRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetGeneratedPasswordFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateName
     * @returns 
     */
    public async SetGeneratedPasswordFromName(request: carriers.User_SetGeneratedPasswordFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * 
     * @param associateName - 
     * @returns 
     */
    public async SetGeneratedPasswordFromName(associateName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SetGeneratedPasswordFromName(associateName:string|carriers.User_SetGeneratedPasswordFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_SetGeneratedPasswordFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateName;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateName)!='undefined' ) )
        {
            _request = associateName as carriers.User_SetGeneratedPasswordFromNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateName: associateName as string,
                       };   
            _options = webapi_options;
        }
        return this._SetGeneratedPasswordFromName( _request, _options );
    }


    private async _IsPasswordValidWithReason(request: carriers.User_IsPasswordValidWithReasonRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserValidationResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsPasswordValidWithReason", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UserValidationResult = converters.Create_UserValidationResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateId, Type, PersonId, Password
     * @returns 
     */
    public async IsPasswordValidWithReason(request: carriers.User_IsPasswordValidWithReasonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult >;

    /**
     * 
     * @param associateId - 
     * @param type - 
     * @param personId - 
     * @param password - 
     * @returns 
     */
    public async IsPasswordValidWithReason(associateId: number, type: enums.UserType, personId: number, password: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult >;

    public async IsPasswordValidWithReason(associateId:number|carriers.User_IsPasswordValidWithReasonRequest, type?:enums.UserType|base.WebApiRequestOptions, personId?:number, password?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult > {
        let _request : carriers.User_IsPasswordValidWithReasonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Type)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.Password)!='undefined' ) )
        {
            _request = associateId as carriers.User_IsPasswordValidWithReasonRequest;
            _options = type as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Type: type as enums.UserType,
                       PersonId: personId as number,
                       Password: password as string,
                       };   
            _options = webapi_options;
        }
        return this._IsPasswordValidWithReason( _request, _options );
    }


    private async _IsUserNameValidWithReason(request: carriers.User_IsUserNameValidWithReasonRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserValidationResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsUserNameValidWithReason", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UserValidationResult = converters.Create_UserValidationResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateId, Type, PersonId, UserName
     * @returns 
     */
    public async IsUserNameValidWithReason(request: carriers.User_IsUserNameValidWithReasonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult >;

    /**
     * 
     * @param associateId - 
     * @param type - 
     * @param personId - 
     * @param userName - 
     * @returns 
     */
    public async IsUserNameValidWithReason(associateId: number, type: enums.UserType, personId: number, userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult >;

    public async IsUserNameValidWithReason(associateId:number|carriers.User_IsUserNameValidWithReasonRequest, type?:enums.UserType|base.WebApiRequestOptions, personId?:number, userName?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserValidationResult > {
        let _request : carriers.User_IsUserNameValidWithReasonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Type)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.UserName)!='undefined' ) )
        {
            _request = associateId as carriers.User_IsUserNameValidWithReasonRequest;
            _options = type as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Type: type as enums.UserType,
                       PersonId: personId as number,
                       UserName: userName as string,
                       };   
            _options = webapi_options;
        }
        return this._IsUserNameValidWithReason( _request, _options );
    }


    private async _ChangeUserType(request: carriers.User_ChangeUserTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeUserType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User = converters.Create_User_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a user from the user name.
     * @param request - User, UserType
     * @returns User retrieved by name
     */
    public async ChangeUserType(request: carriers.User_ChangeUserTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    /**
     * Get a user from the user name.
     * @param user - User name of the user to get.
     * @param userType - 
     * @returns User retrieved by name
     */
    public async ChangeUserType(user: carriers.User, userType: enums.UserType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    public async ChangeUserType(user:carriers.User|carriers.User_ChangeUserTypeRequest, userType?:enums.UserType|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        let _request : carriers.User_ChangeUserTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = user;
        if( typeof( first ) === "object" && first && ( typeof(first.User)!='undefined' || typeof(first.UserType)!='undefined' ) )
        {
            _request = user as carriers.User_ChangeUserTypeRequest;
            _options = userType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       User: user as carriers.User,
                       UserType: userType as enums.UserType,
                       };   
            _options = webapi_options;
        }
        return this._ChangeUserType( _request, _options );
    }


    private async _CreateDefaultUserFromUserTypeAndCredential(request: carriers.User_CreateDefaultUserFromUserTypeAndCredentialRequest, options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.User >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultUserFromUserTypeAndCredential", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.User = converters.Create_User_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a PersonEntity with default values based on the contactId and credentials.
     * @param request - UserType, ContactId, CredentialType, CredentialValue, CredentialDisplayValue
     * @returns 
     */
    public async CreateDefaultUserFromUserTypeAndCredential(request: carriers.User_CreateDefaultUserFromUserTypeAndCredentialRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    /**
     * Creates a PersonEntity with default values based on the contactId and credentials.
     * @param userType - Type of associate for the user
     * @param contactId - Contact id of the person
     * @param credentialType - Type of credentials, corresponding to name of plugin and type in the credentials table.
     * @param credentialValue - This is the actuall value of the credentials.  This will typically be the password or teh users SID in active directory
     * @param credentialDisplayValue - The value displayed to the user. this will typically be the users login name in active directory.
     * @returns 
     */
    public async CreateDefaultUserFromUserTypeAndCredential(userType: enums.UserType, contactId: number, credentialType: string, credentialValue: string, credentialDisplayValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User >;

    public async CreateDefaultUserFromUserTypeAndCredential(userType:enums.UserType|carriers.User_CreateDefaultUserFromUserTypeAndCredentialRequest, contactId?:number|base.WebApiRequestOptions, credentialType?:string, credentialValue?:string, credentialDisplayValue?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.User > {
        let _request : carriers.User_CreateDefaultUserFromUserTypeAndCredentialRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userType;
        if( typeof( first ) === "object" && first && ( typeof(first.UserType)!='undefined' || typeof(first.ContactId)!='undefined' || typeof(first.CredentialType)!='undefined' || typeof(first.CredentialValue)!='undefined' || typeof(first.CredentialDisplayValue)!='undefined' ) )
        {
            _request = userType as carriers.User_CreateDefaultUserFromUserTypeAndCredentialRequest;
            _options = contactId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserType: userType as enums.UserType,
                       ContactId: contactId as number,
                       CredentialType: credentialType as string,
                       CredentialValue: credentialValue as string,
                       CredentialDisplayValue: credentialDisplayValue as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultUserFromUserTypeAndCredential( _request, _options );
    }


    private async _GetValidUserName(request: carriers.User_GetValidUserNameRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetValidUserName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateId, Type, PersonId, UserName
     * @returns 
     */
    public async GetValidUserName(request: carriers.User_GetValidUserNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * 
     * @param associateId - 
     * @param type - 
     * @param personId - 
     * @param userName - 
     * @returns 
     */
    public async GetValidUserName(associateId: number, type: enums.UserType, personId: number, userName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetValidUserName(associateId:number|carriers.User_GetValidUserNameRequest, type?:enums.UserType|base.WebApiRequestOptions, personId?:number, userName?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_GetValidUserNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Type)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.UserName)!='undefined' ) )
        {
            _request = associateId as carriers.User_GetValidUserNameRequest;
            _options = type as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Type: type as enums.UserType,
                       PersonId: personId as number,
                       UserName: userName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetValidUserName( _request, _options );
    }


    private async _RemoveLicenses(request: carriers.User_RemoveLicensesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveLicenses", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove all user licenses.
     * @param request - AssociateId
     * @returns 
     */
    public async RemoveLicenses(request: carriers.User_RemoveLicensesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Remove all user licenses.
     * @param associateId - 
     * @returns 
     */
    public async RemoveLicenses(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveLicenses(associateId:number|carriers.User_RemoveLicensesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_RemoveLicensesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.User_RemoveLicensesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._RemoveLicenses( _request, _options );
    }


    private async _MakeRetired(request: carriers.User_MakeRetiredRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MakeRetired", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retiring a user means to remove all licenses, setting person.retired=1 and associate.deleted=1. Unretiering a user means setting  person.retired=0 and associate.deleted=0
     * @param request - AssociateId, Retired
     * @returns 
     */
    public async MakeRetired(request: carriers.User_MakeRetiredRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Retiring a user means to remove all licenses, setting person.retired=1 and associate.deleted=1. Unretiering a user means setting  person.retired=0 and associate.deleted=0
     * @param associateId - 
     * @param retired - 
     * @returns 
     */
    public async MakeRetired(associateId: number, retired: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MakeRetired(associateId:number|carriers.User_MakeRetiredRequest, retired?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_MakeRetiredRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Retired)!='undefined' ) )
        {
            _request = associateId as carriers.User_MakeRetiredRequest;
            _options = retired as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Retired: retired as boolean,
                       };   
            _options = webapi_options;
        }
        return this._MakeRetired( _request, _options );
    }


    private async _AddOwnerContact(request: carriers.User_AddOwnerContactRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddOwnerContact", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ContactId
     * @returns 
     */
    public async AddOwnerContact(request: carriers.User_AddOwnerContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * 
     * @param contactId - Id of the contact to add as a owner contact
     * @returns 
     */
    public async AddOwnerContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddOwnerContact(contactId:number|carriers.User_AddOwnerContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_AddOwnerContactRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.User_AddOwnerContactRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._AddOwnerContact( _request, _options );
    }


    private async _RemoveOwnerContact(request: carriers.User_RemoveOwnerContactRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveOwnerContact", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove a contact from the ownercontactlink table
     * @param request - ContactId
     * @returns 
     */
    public async RemoveOwnerContact(request: carriers.User_RemoveOwnerContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Remove a contact from the ownercontactlink table
     * @param contactId - The id of the contact to remove
     * @returns 
     */
    public async RemoveOwnerContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveOwnerContact(contactId:number|carriers.User_RemoveOwnerContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_RemoveOwnerContactRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.User_RemoveOwnerContactRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._RemoveOwnerContact( _request, _options );
    }


    private async _ResolveUserFromInfo(request: carriers.User_ResolveUserFromInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedUser > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ResolvedUser >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResolveUserFromInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ResolvedUser = converters.Create_ResolvedUser_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a user from the provided information. If the user or associated person does not exist, it will be created on demand.
     * @param request - ContactId, PersonName, PhoneNumbers, Emails, UserType, Credential
     * @returns The results of the resolve-operation.
     */
    public async ResolveUserFromInfo(request: carriers.User_ResolveUserFromInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedUser >;

    /**
     * Get a user from the provided information. If the user or associated person does not exist, it will be created on demand.
     * @param contactId - The contact Id of the contact which the person belongs to. Cannot be 0.
     * @param personName - The full name of the person to be resolved. Optional.
     * @param phoneNumbers - Phone numbers registered on the person. Optional.
     * @param emails - Email-addresses registered on the person. Optional.
     * @param userType - The type of user to look up or create.
     * @param credential - The credentials to be used for the user. Required.
     * @returns The results of the resolve-operation.
     */
    public async ResolveUserFromInfo(contactId: number, personName: string, phoneNumbers: string[], emails: string[], userType: enums.UserType, credential: carriers.Credential, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedUser >;

    public async ResolveUserFromInfo(contactId:number|carriers.User_ResolveUserFromInfoRequest, personName?:string|base.WebApiRequestOptions, phoneNumbers?:string[], emails?:string[], userType?:enums.UserType, credential?:carriers.Credential, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedUser > {
        let _request : carriers.User_ResolveUserFromInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.PersonName)!='undefined' || typeof(first.PhoneNumbers)!='undefined' || typeof(first.Emails)!='undefined' || typeof(first.UserType)!='undefined' || typeof(first.Credential)!='undefined' ) )
        {
            _request = contactId as carriers.User_ResolveUserFromInfoRequest;
            _options = personName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       PersonName: personName as string,
                       PhoneNumbers: phoneNumbers as string[],
                       Emails: emails as string[],
                       UserType: userType as enums.UserType,
                       Credential: credential as carriers.Credential,
                       };   
            _options = webapi_options;
        }
        return this._ResolveUserFromInfo( _request, _options );
    }


    private async _GetAccessToken(request: carriers.User_GetAccessTokenRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAccessToken", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an access token based on the current user&apos;s session.
     * @param request - AppToken, IncludeCsSession
     * @returns An access token. "8A:xyz123=="
     */
    public async GetAccessToken(request: carriers.User_GetAccessTokenRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get an access token based on the current user&apos;s session.
     * @param appToken - Application token to get access on behalf of. Optional.
     * @param includeCsSession - Initialize CS session for this access token?.
     * @returns An access token. "8A:xyz123=="
     */
    public async GetAccessToken(appToken: string, includeCsSession: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetAccessToken(appToken:string|carriers.User_GetAccessTokenRequest, includeCsSession?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_GetAccessTokenRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appToken;
        if( typeof( first ) === "object" && first && ( typeof(first.AppToken)!='undefined' || typeof(first.IncludeCsSession)!='undefined' ) )
        {
            _request = appToken as carriers.User_GetAccessTokenRequest;
            _options = includeCsSession as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppToken: appToken as string,
                       IncludeCsSession: includeCsSession as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAccessToken( _request, _options );
    }


    private async _GetValidUserNameForNewUser(request: carriers.User_GetValidUserNameForNewUserRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetValidUserNameForNewUser", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Generates a valid username for an unsaved user
     * @param request - User
     * @returns 
     */
    public async GetValidUserNameForNewUser(request: carriers.User_GetValidUserNameForNewUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Generates a valid username for an unsaved user
     * @param user - 
     * @returns 
     */
    public async GetValidUserNameForNewUser(user: carriers.User, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetValidUserNameForNewUser(user:carriers.User|carriers.User_GetValidUserNameForNewUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_GetValidUserNameForNewUserRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = user;
        if( typeof( first ) === "object" && first && ( typeof(first.User)!='undefined' ) )
        {
            _request = user as carriers.User_GetValidUserNameForNewUserRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       User: user as carriers.User,
                       };   
            _options = webapi_options;
        }
        return this._GetValidUserNameForNewUser( _request, _options );
    }


    private async _GetDefaultAssociateUserName(request: carriers.User_GetDefaultAssociateUserNameRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultAssociateUserName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the default username for a person
     * @param request - User
     * @returns 
     */
    public async GetDefaultAssociateUserName(request: carriers.User_GetDefaultAssociateUserNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the default username for a person
     * @param user - 
     * @returns 
     */
    public async GetDefaultAssociateUserName(user: carriers.User, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetDefaultAssociateUserName(user:carriers.User|carriers.User_GetDefaultAssociateUserNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.User_GetDefaultAssociateUserNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = user;
        if( typeof( first ) === "object" && first && ( typeof(first.User)!='undefined' ) )
        {
            _request = user as carriers.User_GetDefaultAssociateUserNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       User: user as carriers.User,
                       };   
            _options = webapi_options;
        }
        return this._GetDefaultAssociateUserName( _request, _options );
    }


    private async _IsNickNameUnique(request: carriers.User_IsNickNameUniqueRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNickNameUnique", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateId, NickName
     * @returns 
     */
    public async IsNickNameUnique(request: carriers.User_IsNickNameUniqueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param associateId - 
     * @param nickName - 
     * @returns 
     */
    public async IsNickNameUnique(associateId: number, nickName: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async IsNickNameUnique(associateId:number|carriers.User_IsNickNameUniqueRequest, nickName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.User_IsNickNameUniqueRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.NickName)!='undefined' ) )
        {
            _request = associateId as carriers.User_IsNickNameUniqueRequest;
            _options = nickName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       NickName: nickName as string,
                       };   
            _options = webapi_options;
        }
        return this._IsNickNameUnique( _request, _options );
    }


    private async _ValidateUser(request: carriers.User_ValidateUserRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateUser", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param request - User
     * @returns Error messages tagged by field.
     */
    public async ValidateUser(request: carriers.User_ValidateUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param user - Entity to be checked for errors.
     * @returns Error messages tagged by field.
     */
    public async ValidateUser(user: carriers.User, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async ValidateUser(user:carriers.User|carriers.User_ValidateUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.User_ValidateUserRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = user;
        if( typeof( first ) === "object" && first && ( typeof(first.User)!='undefined' ) )
        {
            _request = user as carriers.User_ValidateUserRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       User: user as carriers.User,
                       };   
            _options = webapi_options;
        }
        return this._ValidateUser( _request, _options );
    }


    private async _GetUserPresenceStatus(request: carriers.User_GetUserPresenceStatusRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserPresenceStatus >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserPresenceStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UserPresenceStatus = converters.Create_UserPresenceStatus_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get user presence status
     * @param request - AssociateId
     * @returns User presence status
     */
    public async GetUserPresenceStatus(request: carriers.User_GetUserPresenceStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus >;

    /**
     * Get user presence status
     * @param associateId - AssociateId of user to retrieve status for.
     * @returns User presence status
     */
    public async GetUserPresenceStatus(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus >;

    public async GetUserPresenceStatus(associateId:number|carriers.User_GetUserPresenceStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus > {
        let _request : carriers.User_GetUserPresenceStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.User_GetUserPresenceStatusRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetUserPresenceStatus( _request, _options );
    }


    private async _SetUserPresenceStatus(request: carriers.User_SetUserPresenceStatusRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserPresenceStatus >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetUserPresenceStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UserPresenceStatus = converters.Create_UserPresenceStatus_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set user presence status
     * @param request - AssociateId, UserPresenceStatus
     * @returns User presence status
     */
    public async SetUserPresenceStatus(request: carriers.User_SetUserPresenceStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus >;

    /**
     * Set user presence status
     * @param associateId - AssociateId of user to set status for.
     * @param userPresenceStatus - User presence status to set
     * @returns User presence status
     */
    public async SetUserPresenceStatus(associateId: number, userPresenceStatus: carriers.UserPresenceStatus, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus >;

    public async SetUserPresenceStatus(associateId:number|carriers.User_SetUserPresenceStatusRequest, userPresenceStatus?:carriers.UserPresenceStatus|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserPresenceStatus > {
        let _request : carriers.User_SetUserPresenceStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.UserPresenceStatus)!='undefined' ) )
        {
            _request = associateId as carriers.User_SetUserPresenceStatusRequest;
            _options = userPresenceStatus as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       UserPresenceStatus: userPresenceStatus as carriers.UserPresenceStatus,
                       };   
            _options = webapi_options;
        }
        return this._SetUserPresenceStatus( _request, _options );
    }

    /*
     * Gets a UserGroup object.
     * @param userGroupId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single UserGroup
     */
    public async GetUserGroup(userGroupId: number, options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserGroup >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserGroup?userGroupId=" + userGroupId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserGroup_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SaveUserGroup(request: carriers.User_SaveUserGroupRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserGroup >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveUserGroup", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UserGroup = converters.Create_UserGroup_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a user group.  Set UserGroup.Deleted to mark a user group as deleted and invisible in the user interface.
     * @param request - UserGroup
     * @returns UserGroup as saved to the database
     */
    public async SaveUserGroup(request: carriers.User_SaveUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup >;

    /**
     * Save a user group.  Set UserGroup.Deleted to mark a user group as deleted and invisible in the user interface.
     * @param userGroup - UserGroup to save
     * @returns UserGroup as saved to the database
     */
    public async SaveUserGroup(userGroup: carriers.UserGroup, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup >;

    public async SaveUserGroup(userGroup:carriers.UserGroup|carriers.User_SaveUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup > {
        let _request : carriers.User_SaveUserGroupRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userGroup;
        if( typeof( first ) === "object" && first && ( typeof(first.UserGroup)!='undefined' ) )
        {
            _request = userGroup as carriers.User_SaveUserGroupRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserGroup: userGroup as carriers.UserGroup,
                       };   
            _options = webapi_options;
        }
        return this._SaveUserGroup( _request, _options );
    }


    private async _GetAllUserGroups(request: carriers.User_GetAllUserGroupsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserGroup[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllUserGroups", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UserGroup[] = converters.Create_UserGroupArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all user groups
     * @param request - IncludeDeleted
     * @returns All user groups
     */
    public async GetAllUserGroups(request: carriers.User_GetAllUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup[] >;

    /**
     * Get all user groups
     * @param includeDeleted - Include user groups with Deleted set to true
     * @returns All user groups
     */
    public async GetAllUserGroups(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup[] >;

    public async GetAllUserGroups(includeDeleted:boolean|carriers.User_GetAllUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup[] > {
        let _request : carriers.User_GetAllUserGroupsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.User_GetAllUserGroupsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllUserGroups( _request, _options );
    }


    private async _CreateUserGroup( options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserGroup >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateUserGroup", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UserGroup = converters.Create_UserGroup_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Create UserGroup (Rank is assigned to the highest rank)
     * @returns 
     */
    public async CreateUserGroup(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup >
    {
        return this._CreateUserGroup(webapi_options);
    }


    private async _DeleteUserGroup(request: carriers.User_DeleteUserGroupRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteUserGroup", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a usergroup and move its members to another usergroup
     * @param request - UserGroupToDelete, UserGroupToMoveTo
     * @returns 
     */
    public async DeleteUserGroup(request: carriers.User_DeleteUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a usergroup and move its members to another usergroup
     * @param userGroupToDelete - The id of the userGroup to delete
     * @param userGroupToMoveTo - The id of the userGroup to move the members to
     * @returns 
     */
    public async DeleteUserGroup(userGroupToDelete: number, userGroupToMoveTo: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteUserGroup(userGroupToDelete:number|carriers.User_DeleteUserGroupRequest, userGroupToMoveTo?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.User_DeleteUserGroupRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userGroupToDelete;
        if( typeof( first ) === "object" && first && ( typeof(first.UserGroupToDelete)!='undefined' || typeof(first.UserGroupToMoveTo)!='undefined' ) )
        {
            _request = userGroupToDelete as carriers.User_DeleteUserGroupRequest;
            _options = userGroupToMoveTo as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserGroupToDelete: userGroupToDelete as number,
                       UserGroupToMoveTo: userGroupToMoveTo as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteUserGroup( _request, _options );
    }

    /*
     * Gets an array of UserGroup objects.
     * @param userGroupIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of UserGroup
     */
    public async GetUserGroupList(userGroupIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.UserGroup[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserGroup[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserGroupList", userGroupIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserGroupArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a UserInfo object.
     * @param userInfoId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single UserInfo
     */
    public async GetUserInfo(userInfoId: number, options?:base.WebApiRequestOptions) : Promise< carriers.UserInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserInfo >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserInfo?userInfoId=" + userInfoId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserInfo_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of UserInfo objects.
     * @param userInfoIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of UserInfo
     */
    public async GetUserInfoList(userInfoIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.UserInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserInfo[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserInfoList", userInfoIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserInfoArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    } // class v1UserAgentController 



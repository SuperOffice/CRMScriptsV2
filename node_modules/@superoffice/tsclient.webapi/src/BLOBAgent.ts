// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/BLOBAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Collection of all services that works with binary objects (BLOBS), e.g. Images and documents.
 */
export interface IBLOBAgent {
    CreateDefaultBlobEntity(): Promise< carriers.BlobEntity >;
    SaveBlobEntity(entity: carriers.BlobEntity) : Promise< carriers.BlobEntity >;
    DeleteBlobEntity(BlobEntityId: number) : Promise<void>;
    GetBlobEntity(blobEntityId: number) :  Promise< carriers.BlobEntity >;
    SetBlobStream(request: carriers.BLOB_SetBlobStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetBlobStream(blobEntityId: number, stream: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetBlobStream(request: carriers.BLOB_GetBlobStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetBlobStream(blobEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetProjectImage(request: carriers.BLOB_GetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetProjectImage(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetPersonImage(request: carriers.BLOB_GetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetPersonImage(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SetProjectImage(request: carriers.BLOB_SetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetProjectImage(projectId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetPersonImage(request: carriers.BLOB_SetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetPersonImage(personId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangeProjectImage(request: carriers.BLOB_ChangeProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangeProjectImage(projectId: number, blobId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveProjectImage(request: carriers.BLOB_SaveProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveProjectImage(description: string, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetBlobEntityOnProject(request: carriers.BLOB_GetBlobEntityOnProjectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    GetBlobEntityOnProject(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    GetBlobEntityOnPerson(request: carriers.BLOB_GetBlobEntityOnPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    GetBlobEntityOnPerson(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    GetBlobEntityOnCountry(request: carriers.BLOB_GetBlobEntityOnCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    GetBlobEntityOnCountry(countryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    GetBlobEntityOnProduct(request: carriers.BLOB_GetBlobEntityOnProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    GetBlobEntityOnProduct(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    ChangePersonImage(request: carriers.BLOB_ChangePersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangePersonImage(personId: number, blobId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveImageStream(request: carriers.BLOB_SaveImageStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    SaveImageStream(type: enums.BlobLinkType, image: ArrayBuffer|string, description: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetProductImage(request: carriers.BLOB_GetProductImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetProductImage(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SetProductImage(request: carriers.BLOB_SetProductImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetProductImage(productId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetProductThumbnail(request: carriers.BLOB_GetProductThumbnailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetProductThumbnail(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SetProductThumbnail(request: carriers.BLOB_SetProductThumbnailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetProductThumbnail(productId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangeProductImage(request: carriers.BLOB_ChangeProductImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangeProductImage(productId: number, blobId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetQuoteLineImage(request: carriers.BLOB_GetQuoteLineImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetQuoteLineImage(quoteLineId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetAppData(request: carriers.BLOB_GetAppDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetAppData(key: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SetAppData(request: carriers.BLOB_SetAppDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetAppData(key: string, data: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPersonImageWithSize(request: carriers.BLOB_GetPersonImageWithSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetPersonImageWithSize(personId: number, width: number, height: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetProjectImageWithSize(request: carriers.BLOB_GetProjectImageWithSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetProjectImageWithSize(projectId: number, width: number, height: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetChatImageWithSize(request: carriers.BLOB_GetChatImageWithSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetChatImageWithSize(chatTopicId: number, width: number, height: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetContactImage(request: carriers.BLOB_GetContactImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetContactImage(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SetContactImage(request: carriers.BLOB_SetContactImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetContactImage(contactId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangeContactImage(request: carriers.BLOB_ChangeContactImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangeContactImage(contactId: number, blobId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetBlobEntityOnContact(request: carriers.BLOB_GetBlobEntityOnContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    GetBlobEntityOnContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;
    GetContactImageWithSize(request: carriers.BLOB_GetContactImageWithSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetContactImageWithSize(contactId: number, width: number, height: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetOutputFromBatch(request: carriers.BLOB_GetOutputFromBatchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetOutputFromBatch(batchTaskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    CleanupBatchTask(request: carriers.BLOB_CleanupBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CleanupBatchTask(batchTaskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
} // interface IBLOBAgent




/**
 * Collection of all services that works with binary objects (BLOBS), e.g. Images and documents.
 */
export class BLOBAgent extends base.WebApiBase implements IBLOBAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/BLOB/";
        super(options);
    }



    /**
     * Set default values into a new BlobEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultBlobEntity(options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BlobEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultBlobEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BlobEntity = converters.Create_BlobEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing BlobEntity or creates a new BlobEntity if the id parameter is empty
     * @param entity - The BlobEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated BlobEntity
     */
    public async SaveBlobEntity(entity: carriers.BlobEntity, options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BlobEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveBlobEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BlobEntity = converters.Create_BlobEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the BlobEntity
     * @param BlobEntityId - The id of the BlobEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteBlobEntity(BlobEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteBlobEntity?BlobEntityId=" + BlobEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a BlobEntity object.
     * @param blobEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single BlobEntity
     */
    public async GetBlobEntity(blobEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BlobEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetBlobEntity?blobEntityId=" + blobEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BlobEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SetBlobStream(request: carriers.BLOB_SetBlobStreamRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetBlobStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Store a binary object from it&apos;s stream
     * @param request - BlobEntityId, Stream
     * @returns 
     */
    public async SetBlobStream(request: carriers.BLOB_SetBlobStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Store a binary object from it&apos;s stream
     * @param blobEntityId - Id of the BLOB entity object that the binary data should be stored to.
     * @param stream - The binary object as a Stream
     * @returns 
     */
    public async SetBlobStream(blobEntityId: number, stream: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetBlobStream(blobEntityId:number|carriers.BLOB_SetBlobStreamRequest, stream?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_SetBlobStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = blobEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.BlobEntityId)!='undefined' || typeof(first.Stream)!='undefined' ) )
        {
            _request = blobEntityId as carriers.BLOB_SetBlobStreamRequest;
            _options = stream as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       BlobEntityId: blobEntityId as number,
                       Stream: stream as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Stream = ToBase64(_request.Stream);
        return this._SetBlobStream( _request, _options );
    }


    private async _GetBlobStream(request: carriers.BLOB_GetBlobStreamRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobStream", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the binary object as a stream
     * @param request - BlobEntityId
     * @returns The binary object as a Stream
     */
    public async GetBlobStream(request: carriers.BLOB_GetBlobStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Get the binary object as a stream
     * @param blobEntityId - The ID of the BLOB entity object that refers to the binary data
     * @returns The binary object as a Stream
     */
    public async GetBlobStream(blobEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetBlobStream(blobEntityId:number|carriers.BLOB_GetBlobStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetBlobStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = blobEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.BlobEntityId)!='undefined' ) )
        {
            _request = blobEntityId as carriers.BLOB_GetBlobStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       BlobEntityId: blobEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetBlobStream( _request, _options );
    }


    private async _GetProjectImage(request: carriers.BLOB_GetProjectImageRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectImage", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the project image that is displayed in the CRM application.
     * @param request - ProjectId
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetProjectImage(request: carriers.BLOB_GetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the project image that is displayed in the CRM application.
     * @param projectId - The project id of the project the image belongs to.
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetProjectImage(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetProjectImage(projectId:number|carriers.BLOB_GetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetProjectImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.BLOB_GetProjectImageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectImage( _request, _options );
    }


    private async _GetPersonImage(request: carriers.BLOB_GetPersonImageRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonImage", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the person image that is displayed in the CRM application.
     * @param request - PersonId
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetPersonImage(request: carriers.BLOB_GetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the person image that is displayed in the CRM application.
     * @param personId - The person id of the person the image belongs to.
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetPersonImage(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetPersonImage(personId:number|carriers.BLOB_GetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetPersonImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.BLOB_GetPersonImageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonImage( _request, _options );
    }


    private async _SetProjectImage(request: carriers.BLOB_SetProjectImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetProjectImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Stores the project image that is displayed in the CRM application.
     * @param request - ProjectId, Image
     * @returns 
     */
    public async SetProjectImage(request: carriers.BLOB_SetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Stores the project image that is displayed in the CRM application.
     * @param projectId - The project id of the project the image belongs to.
     * @param image - The image that is stored on the project (System.Drawing.Image)
     * @returns 
     */
    public async SetProjectImage(projectId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetProjectImage(projectId:number|carriers.BLOB_SetProjectImageRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_SetProjectImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.Image)!='undefined' ) )
        {
            _request = projectId as carriers.BLOB_SetProjectImageRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       Image: image as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SetProjectImage( _request, _options );
    }


    private async _SetPersonImage(request: carriers.BLOB_SetPersonImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPersonImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Stores the person image that is displayed in the CRM application.
     * @param request - PersonId, Image
     * @returns 
     */
    public async SetPersonImage(request: carriers.BLOB_SetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Stores the person image that is displayed in the CRM application.
     * @param personId - The person id of the person the image belongs to.
     * @param image - The image that is stored on the person (System.Drawing.Image)
     * @returns 
     */
    public async SetPersonImage(personId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetPersonImage(personId:number|carriers.BLOB_SetPersonImageRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_SetPersonImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.Image)!='undefined' ) )
        {
            _request = personId as carriers.BLOB_SetPersonImageRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       Image: image as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SetPersonImage( _request, _options );
    }


    private async _ChangeProjectImage(request: carriers.BLOB_ChangeProjectImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeProjectImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Changes the project image link. If the Binary object id is 0, any image link is removed from the project.
     * @param request - ProjectId, BlobId
     * @returns 
     */
    public async ChangeProjectImage(request: carriers.BLOB_ChangeProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Changes the project image link. If the Binary object id is 0, any image link is removed from the project.
     * @param projectId - The project the image is linked to
     * @param blobId - The Binary object id. If the Binary object id is 0, any image link is removed from the project.
     * @returns 
     */
    public async ChangeProjectImage(projectId: number, blobId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ChangeProjectImage(projectId:number|carriers.BLOB_ChangeProjectImageRequest, blobId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_ChangeProjectImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.BlobId)!='undefined' ) )
        {
            _request = projectId as carriers.BLOB_ChangeProjectImageRequest;
            _options = blobId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       BlobId: blobId as number,
                       };   
            _options = webapi_options;
        }
        return this._ChangeProjectImage( _request, _options );
    }


    private async _SaveProjectImage(request: carriers.BLOB_SaveProjectImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveProjectImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a project image that is displayed in the CRM application&apos;s project image selection dialog to the database.
     * @param request - Description, Image
     * @returns 
     */
    public async SaveProjectImage(request: carriers.BLOB_SaveProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Saves a project image that is displayed in the CRM application&apos;s project image selection dialog to the database.
     * @param description - Image description. Should be image name (e.g. winter.jpg) for project images
     * @param image - The project image (System.Drawing.Image)
     * @returns 
     */
    public async SaveProjectImage(description: string, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveProjectImage(description:string|carriers.BLOB_SaveProjectImageRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_SaveProjectImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = description;
        if( typeof( first ) === "object" && first && ( typeof(first.Description)!='undefined' || typeof(first.Image)!='undefined' ) )
        {
            _request = description as carriers.BLOB_SaveProjectImageRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Description: description as string,
                       Image: image as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SaveProjectImage( _request, _options );
    }


    private async _GetBlobEntityOnProject(request: carriers.BLOB_GetBlobEntityOnProjectRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BlobEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnProject", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BlobEntity = converters.Create_BlobEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the blob entity that represents the project image binary object.
     * @param request - ProjectId
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnProject(request: carriers.BLOB_GetBlobEntityOnProjectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    /**
     * Gets the blob entity that represents the project image binary object.
     * @param projectId - The project id
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnProject(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    public async GetBlobEntityOnProject(projectId:number|carriers.BLOB_GetBlobEntityOnProjectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        let _request : carriers.BLOB_GetBlobEntityOnProjectRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.BLOB_GetBlobEntityOnProjectRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetBlobEntityOnProject( _request, _options );
    }


    private async _GetBlobEntityOnPerson(request: carriers.BLOB_GetBlobEntityOnPersonRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BlobEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnPerson", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BlobEntity = converters.Create_BlobEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the blob entity that represents the person image binary object.
     * @param request - PersonId
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnPerson(request: carriers.BLOB_GetBlobEntityOnPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    /**
     * Gets the blob entity that represents the person image binary object.
     * @param personId - The person id
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnPerson(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    public async GetBlobEntityOnPerson(personId:number|carriers.BLOB_GetBlobEntityOnPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        let _request : carriers.BLOB_GetBlobEntityOnPersonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.BLOB_GetBlobEntityOnPersonRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetBlobEntityOnPerson( _request, _options );
    }


    private async _GetBlobEntityOnCountry(request: carriers.BLOB_GetBlobEntityOnCountryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BlobEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnCountry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BlobEntity = converters.Create_BlobEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the blob entity that represents the country flag binary object.
     * @param request - CountryId
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnCountry(request: carriers.BLOB_GetBlobEntityOnCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    /**
     * Gets the blob entity that represents the country flag binary object.
     * @param countryId - The country id
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnCountry(countryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    public async GetBlobEntityOnCountry(countryId:number|carriers.BLOB_GetBlobEntityOnCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        let _request : carriers.BLOB_GetBlobEntityOnCountryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = countryId;
        if( typeof( first ) === "object" && first && ( typeof(first.CountryId)!='undefined' ) )
        {
            _request = countryId as carriers.BLOB_GetBlobEntityOnCountryRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       CountryId: countryId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetBlobEntityOnCountry( _request, _options );
    }


    private async _GetBlobEntityOnProduct(request: carriers.BLOB_GetBlobEntityOnProductRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BlobEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnProduct", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BlobEntity = converters.Create_BlobEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the blob entity that represents the product image binary object.
     * @param request - ProductId
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnProduct(request: carriers.BLOB_GetBlobEntityOnProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    /**
     * Gets the blob entity that represents the product image binary object.
     * @param productId - The product id
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnProduct(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    public async GetBlobEntityOnProduct(productId:number|carriers.BLOB_GetBlobEntityOnProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        let _request : carriers.BLOB_GetBlobEntityOnProductRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = productId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProductId)!='undefined' ) )
        {
            _request = productId as carriers.BLOB_GetBlobEntityOnProductRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProductId: productId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetBlobEntityOnProduct( _request, _options );
    }


    private async _ChangePersonImage(request: carriers.BLOB_ChangePersonImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangePersonImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - PersonId, BlobId
     * @returns 
     */
    public async ChangePersonImage(request: carriers.BLOB_ChangePersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * 
     * @param personId - The person the image is linked to
     * @param blobId - The Binary object id. If the Binary object id is 0, any image link is removed from the person.
     * @returns 
     */
    public async ChangePersonImage(personId: number, blobId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ChangePersonImage(personId:number|carriers.BLOB_ChangePersonImageRequest, blobId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_ChangePersonImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.BlobId)!='undefined' ) )
        {
            _request = personId as carriers.BLOB_ChangePersonImageRequest;
            _options = blobId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       BlobId: blobId as number,
                       };   
            _options = webapi_options;
        }
        return this._ChangePersonImage( _request, _options );
    }


    private async _SaveImageStream(request: carriers.BLOB_SaveImageStreamRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveImageStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Stores an image in the database without linking it to a project or a person. It is possible to ChangePersonImage or ChangeProjectImage to attach image later.
     * @param request - Type, Image, Description
     * @returns The blob id
     */
    public async SaveImageStream(request: carriers.BLOB_SaveImageStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Stores an image in the database without linking it to a project or a person. It is possible to ChangePersonImage or ChangeProjectImage to attach image later.
     * @param type - The type of the image.
     * @param image - Image to store
     * @param description - Image description
     * @returns The blob id
     */
    public async SaveImageStream(type: enums.BlobLinkType, image: ArrayBuffer|string, description: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async SaveImageStream(type:enums.BlobLinkType|carriers.BLOB_SaveImageStreamRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, description?:string, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.BLOB_SaveImageStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = type;
        if( typeof( first ) === "object" && first && ( typeof(first.Type)!='undefined' || typeof(first.Image)!='undefined' || typeof(first.Description)!='undefined' ) )
        {
            _request = type as carriers.BLOB_SaveImageStreamRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Type: type as enums.BlobLinkType,
                       Image: image as ArrayBuffer|string,
                       Description: description as string,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SaveImageStream( _request, _options );
    }


    private async _GetProductImage(request: carriers.BLOB_GetProductImageRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductImage", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the product image (rank=1) that is displayed in the CRM application.
     * @param request - ProductId
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetProductImage(request: carriers.BLOB_GetProductImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the product image (rank=1) that is displayed in the CRM application.
     * @param productId - The product id of the product the image belongs to.
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetProductImage(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetProductImage(productId:number|carriers.BLOB_GetProductImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetProductImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = productId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProductId)!='undefined' ) )
        {
            _request = productId as carriers.BLOB_GetProductImageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProductId: productId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProductImage( _request, _options );
    }


    private async _SetProductImage(request: carriers.BLOB_SetProductImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetProductImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Stores the product image that is displayed in the CRM application. The image is scaled down to max 1000x1000. This method operates only the main (rank=1) image; future extensions may support multiple images. A thumbnail of size 75x75 is also automatically set.
     * @param request - ProductId, Image
     * @returns 
     */
    public async SetProductImage(request: carriers.BLOB_SetProductImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Stores the product image that is displayed in the CRM application. The image is scaled down to max 1000x1000. This method operates only the main (rank=1) image; future extensions may support multiple images. A thumbnail of size 75x75 is also automatically set.
     * @param productId - The product id of the product the image belongs to.
     * @param image - The image that is stored on the product (System.Drawing.Image), scaled down to no more than 1000x1000
     * @returns 
     */
    public async SetProductImage(productId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetProductImage(productId:number|carriers.BLOB_SetProductImageRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_SetProductImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = productId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProductId)!='undefined' || typeof(first.Image)!='undefined' ) )
        {
            _request = productId as carriers.BLOB_SetProductImageRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProductId: productId as number,
                       Image: image as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SetProductImage( _request, _options );
    }


    private async _GetProductThumbnail(request: carriers.BLOB_GetProductThumbnailRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductThumbnail", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the product thumbnail that is displayed in the CRM application.
     * @param request - ProductId
     * @returns The thumbnail as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetProductThumbnail(request: carriers.BLOB_GetProductThumbnailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the product thumbnail that is displayed in the CRM application.
     * @param productId - The product id of the product the thumbnail belongs to.
     * @returns The thumbnail as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetProductThumbnail(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetProductThumbnail(productId:number|carriers.BLOB_GetProductThumbnailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetProductThumbnailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = productId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProductId)!='undefined' ) )
        {
            _request = productId as carriers.BLOB_GetProductThumbnailRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProductId: productId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProductThumbnail( _request, _options );
    }


    private async _SetProductThumbnail(request: carriers.BLOB_SetProductThumbnailRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetProductThumbnail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Stores the product thumbnail that is displayed in the CRM application. The image is scaled down to max 200x200 pixels.
     * @param request - ProductId, Image
     * @returns 
     */
    public async SetProductThumbnail(request: carriers.BLOB_SetProductThumbnailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Stores the product thumbnail that is displayed in the CRM application. The image is scaled down to max 200x200 pixels.
     * @param productId - The product id of the product the image belongs to.
     * @param image - The image that is stored on the product (System.Drawing.Image); scaled down to no more than 200x200
     * @returns 
     */
    public async SetProductThumbnail(productId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetProductThumbnail(productId:number|carriers.BLOB_SetProductThumbnailRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_SetProductThumbnailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = productId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProductId)!='undefined' || typeof(first.Image)!='undefined' ) )
        {
            _request = productId as carriers.BLOB_SetProductThumbnailRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProductId: productId as number,
                       Image: image as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SetProductThumbnail( _request, _options );
    }


    private async _ChangeProductImage(request: carriers.BLOB_ChangeProductImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeProductImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ProductId, BlobId
     * @returns 
     */
    public async ChangeProductImage(request: carriers.BLOB_ChangeProductImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * 
     * @param productId - The product the image is linked to
     * @param blobId - The Binary object id. If the Binary object id is 0, any image link is removed from the product.
     * @returns 
     */
    public async ChangeProductImage(productId: number, blobId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ChangeProductImage(productId:number|carriers.BLOB_ChangeProductImageRequest, blobId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_ChangeProductImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = productId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProductId)!='undefined' || typeof(first.BlobId)!='undefined' ) )
        {
            _request = productId as carriers.BLOB_ChangeProductImageRequest;
            _options = blobId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProductId: productId as number,
                       BlobId: blobId as number,
                       };   
            _options = webapi_options;
        }
        return this._ChangeProductImage( _request, _options );
    }


    private async _GetQuoteLineImage(request: carriers.BLOB_GetQuoteLineImageRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLineImage", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the quoteline image (rank=1) that is displayed in the CRM application.
     * @param request - QuoteLineId
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetQuoteLineImage(request: carriers.BLOB_GetQuoteLineImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the quoteline image (rank=1) that is displayed in the CRM application.
     * @param quoteLineId - The product id of the quoteline the image belongs to.
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetQuoteLineImage(quoteLineId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetQuoteLineImage(quoteLineId:number|carriers.BLOB_GetQuoteLineImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetQuoteLineImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineId)!='undefined' ) )
        {
            _request = quoteLineId as carriers.BLOB_GetQuoteLineImageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineId: quoteLineId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteLineImage( _request, _options );
    }


    private async _GetAppData(request: carriers.BLOB_GetAppDataRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppData", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a CLOB (limited to a reasonable size by the mechanics of Web Services) according to a string key; ALSO limits to the current ApplicationToken if any
     * @param request - Key
     * @returns The applications value, suggested to be a JSON, XML or other readable structure
     */
    public async GetAppData(request: carriers.BLOB_GetAppDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get a CLOB (limited to a reasonable size by the mechanics of Web Services) according to a string key; ALSO limits to the current ApplicationToken if any
     * @param key - The key string, less than 200 characters. Must be unique within each application.
     * @returns The applications value, suggested to be a JSON, XML or other readable structure
     */
    public async GetAppData(key: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetAppData(key:string|carriers.BLOB_GetAppDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.BLOB_GetAppDataRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = key;
        if( typeof( first ) === "object" && first && ( typeof(first.Key)!='undefined' ) )
        {
            _request = key as carriers.BLOB_GetAppDataRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Key: key as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAppData( _request, _options );
    }


    private async _SetAppData(request: carriers.BLOB_SetAppDataRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetAppData", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a CLOB (limited to a reasonable size by the mechanics of Web Services) according to a string key; ALSO limits to the current ApplicationToken if any. Existing data, if any, will be overwritten. Overwrite with a blank value to delete.
     * @param request - Key, Data
     * @returns This method has no return value
     */
    public async SetAppData(request: carriers.BLOB_SetAppDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Get a CLOB (limited to a reasonable size by the mechanics of Web Services) according to a string key; ALSO limits to the current ApplicationToken if any. Existing data, if any, will be overwritten. Overwrite with a blank value to delete.
     * @param key - The key string, less than 200 characters. Must be unique within each application.
     * @param data - The applications value, suggested to be a JSON, XML or other readable structure
     * @returns This method has no return value
     */
    public async SetAppData(key: string, data: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetAppData(key:string|carriers.BLOB_SetAppDataRequest, data?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_SetAppDataRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = key;
        if( typeof( first ) === "object" && first && ( typeof(first.Key)!='undefined' || typeof(first.Data)!='undefined' ) )
        {
            _request = key as carriers.BLOB_SetAppDataRequest;
            _options = data as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Key: key as string,
                       Data: data as string,
                       };   
            _options = webapi_options;
        }
        return this._SetAppData( _request, _options );
    }


    private async _GetPersonImageWithSize(request: carriers.BLOB_GetPersonImageWithSizeRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonImageWithSize", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the person image that is displayed in the CRM application with a specified maximum size.
     * @param request - PersonId, Width, Height
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a jpeg/base64 encoded string.)
     */
    public async GetPersonImageWithSize(request: carriers.BLOB_GetPersonImageWithSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the person image that is displayed in the CRM application with a specified maximum size.
     * @param personId - The person id of the person the image belongs to.
     * @param width - The maximum with of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     * @param height - The maximum height of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a jpeg/base64 encoded string.)
     */
    public async GetPersonImageWithSize(personId: number, width: number, height: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetPersonImageWithSize(personId:number|carriers.BLOB_GetPersonImageWithSizeRequest, width?:number|base.WebApiRequestOptions, height?:number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetPersonImageWithSizeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.Width)!='undefined' || typeof(first.Height)!='undefined' ) )
        {
            _request = personId as carriers.BLOB_GetPersonImageWithSizeRequest;
            _options = width as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       Width: width as number,
                       Height: height as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonImageWithSize( _request, _options );
    }


    private async _GetProjectImageWithSize(request: carriers.BLOB_GetProjectImageWithSizeRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectImageWithSize", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the project image that is displayed in the CRM application with a specified maximum size.
     * @param request - ProjectId, Width, Height
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a jpeg/base64 encoded string.)
     */
    public async GetProjectImageWithSize(request: carriers.BLOB_GetProjectImageWithSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the project image that is displayed in the CRM application with a specified maximum size.
     * @param projectId - The project id of the project the image belongs to.
     * @param width - The maximum with of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     * @param height - The maximum height of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a jpeg/base64 encoded string.)
     */
    public async GetProjectImageWithSize(projectId: number, width: number, height: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetProjectImageWithSize(projectId:number|carriers.BLOB_GetProjectImageWithSizeRequest, width?:number|base.WebApiRequestOptions, height?:number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetProjectImageWithSizeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.Width)!='undefined' || typeof(first.Height)!='undefined' ) )
        {
            _request = projectId as carriers.BLOB_GetProjectImageWithSizeRequest;
            _options = width as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       Width: width as number,
                       Height: height as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectImageWithSize( _request, _options );
    }


    private async _GetChatImageWithSize(request: carriers.BLOB_GetChatImageWithSizeRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatImageWithSize", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the chat image that is displayed in chat with a specified maximum size.
     * @param request - ChatTopicId, Width, Height
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a jpeg/base64 encoded string.)
     */
    public async GetChatImageWithSize(request: carriers.BLOB_GetChatImageWithSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the chat image that is displayed in chat with a specified maximum size.
     * @param chatTopicId - The project id of the project the image belongs to.
     * @param width - The maximum with of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     * @param height - The maximum height of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a jpeg/base64 encoded string.)
     */
    public async GetChatImageWithSize(chatTopicId: number, width: number, height: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetChatImageWithSize(chatTopicId:number|carriers.BLOB_GetChatImageWithSizeRequest, width?:number|base.WebApiRequestOptions, height?:number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetChatImageWithSizeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatTopicId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatTopicId)!='undefined' || typeof(first.Width)!='undefined' || typeof(first.Height)!='undefined' ) )
        {
            _request = chatTopicId as carriers.BLOB_GetChatImageWithSizeRequest;
            _options = width as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatTopicId: chatTopicId as number,
                       Width: width as number,
                       Height: height as number,
                       };   
            _options = webapi_options;
        }
        return this._GetChatImageWithSize( _request, _options );
    }


    private async _GetContactImage(request: carriers.BLOB_GetContactImageRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactImage", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the contact image that is displayed in the CRM application.
     * @param request - ContactId
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetContactImage(request: carriers.BLOB_GetContactImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the contact image that is displayed in the CRM application.
     * @param contactId - The contact id of the contact the image belongs to.
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetContactImage(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetContactImage(contactId:number|carriers.BLOB_GetContactImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetContactImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.BLOB_GetContactImageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactImage( _request, _options );
    }


    private async _SetContactImage(request: carriers.BLOB_SetContactImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetContactImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Stores the contact image that is displayed in the CRM application.
     * @param request - ContactId, Image
     * @returns 
     */
    public async SetContactImage(request: carriers.BLOB_SetContactImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Stores the contact image that is displayed in the CRM application.
     * @param contactId - The contact id of the contact the image belongs to.
     * @param image - The image that is stored on the contact (System.Drawing.Image)
     * @returns 
     */
    public async SetContactImage(contactId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetContactImage(contactId:number|carriers.BLOB_SetContactImageRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_SetContactImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.Image)!='undefined' ) )
        {
            _request = contactId as carriers.BLOB_SetContactImageRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       Image: image as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SetContactImage( _request, _options );
    }


    private async _ChangeContactImage(request: carriers.BLOB_ChangeContactImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeContactImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Changes the contact image link. If the Binary object id is 0, any image link is removed from the contact.
     * @param request - ContactId, BlobId
     * @returns 
     */
    public async ChangeContactImage(request: carriers.BLOB_ChangeContactImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Changes the contact image link. If the Binary object id is 0, any image link is removed from the contact.
     * @param contactId - The Contact the image is linked to
     * @param blobId - The Binary object id. If the Binary object id is 0, any image link is removed from the Contact.
     * @returns 
     */
    public async ChangeContactImage(contactId: number, blobId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ChangeContactImage(contactId:number|carriers.BLOB_ChangeContactImageRequest, blobId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_ChangeContactImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.BlobId)!='undefined' ) )
        {
            _request = contactId as carriers.BLOB_ChangeContactImageRequest;
            _options = blobId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       BlobId: blobId as number,
                       };   
            _options = webapi_options;
        }
        return this._ChangeContactImage( _request, _options );
    }


    private async _GetBlobEntityOnContact(request: carriers.BLOB_GetBlobEntityOnContactRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BlobEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnContact", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BlobEntity = converters.Create_BlobEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the blob entity that represents the contact image binary object.
     * @param request - ContactId
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnContact(request: carriers.BLOB_GetBlobEntityOnContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    /**
     * Gets the blob entity that represents the contact image binary object.
     * @param contactId - The Contact id
     * @returns BlobEntity object
     */
    public async GetBlobEntityOnContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity >;

    public async GetBlobEntityOnContact(contactId:number|carriers.BLOB_GetBlobEntityOnContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BlobEntity > {
        let _request : carriers.BLOB_GetBlobEntityOnContactRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.BLOB_GetBlobEntityOnContactRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetBlobEntityOnContact( _request, _options );
    }


    private async _GetContactImageWithSize(request: carriers.BLOB_GetContactImageWithSizeRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactImageWithSize", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the contact image that is displayed in the CRM application with a specified maximum size.
     * @param request - ContactId, Width, Height
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a jpeg/base64 encoded string.)
     */
    public async GetContactImageWithSize(request: carriers.BLOB_GetContactImageWithSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the contact image that is displayed in the CRM application with a specified maximum size.
     * @param contactId - The contact id of the Contact the image belongs to.
     * @param width - The maximum with of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     * @param height - The maximum height of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a jpeg/base64 encoded string.)
     */
    public async GetContactImageWithSize(contactId: number, width: number, height: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetContactImageWithSize(contactId:number|carriers.BLOB_GetContactImageWithSizeRequest, width?:number|base.WebApiRequestOptions, height?:number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetContactImageWithSizeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.Width)!='undefined' || typeof(first.Height)!='undefined' ) )
        {
            _request = contactId as carriers.BLOB_GetContactImageWithSizeRequest;
            _options = width as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       Width: width as number,
                       Height: height as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactImageWithSize( _request, _options );
    }


    private async _GetOutputFromBatch(request: carriers.BLOB_GetOutputFromBatchRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOutputFromBatch", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the output of a batchtask as a stream
     * @param request - BatchTaskId
     * @returns The binary object as a Stream
     */
    public async GetOutputFromBatch(request: carriers.BLOB_GetOutputFromBatchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Get the output of a batchtask as a stream
     * @param batchTaskId - The ID of the batchtask that created the output data
     * @returns The binary object as a Stream
     */
    public async GetOutputFromBatch(batchTaskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetOutputFromBatch(batchTaskId:number|carriers.BLOB_GetOutputFromBatchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.BLOB_GetOutputFromBatchRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = batchTaskId;
        if( typeof( first ) === "object" && first && ( typeof(first.BatchTaskId)!='undefined' ) )
        {
            _request = batchTaskId as carriers.BLOB_GetOutputFromBatchRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       BatchTaskId: batchTaskId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetOutputFromBatch( _request, _options );
    }


    private async _CleanupBatchTask(request: carriers.BLOB_CleanupBatchTaskRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CleanupBatchTask", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes the binary objects linked to the batch task, the links themselves and the batch task.
     * @param request - BatchTaskId
     * @returns 
     */
    public async CleanupBatchTask(request: carriers.BLOB_CleanupBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Removes the binary objects linked to the batch task, the links themselves and the batch task.
     * @param batchTaskId - The ID of the batchtask that created the output data
     * @returns 
     */
    public async CleanupBatchTask(batchTaskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async CleanupBatchTask(batchTaskId:number|carriers.BLOB_CleanupBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.BLOB_CleanupBatchTaskRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = batchTaskId;
        if( typeof( first ) === "object" && first && ( typeof(first.BatchTaskId)!='undefined' ) )
        {
            _request = batchTaskId as carriers.BLOB_CleanupBatchTaskRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       BatchTaskId: batchTaskId as number,
                       };   
            _options = webapi_options;
        }
        return this._CleanupBatchTask( _request, _options );
    }

    } // class v1BLOBAgentController 



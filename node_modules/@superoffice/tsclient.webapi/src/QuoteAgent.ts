// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/QuoteAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Services for the Quote Management feature, part of the Sale module
 */
export interface IQuoteAgent {
    CreateDefaultPriceList(): Promise< carriers.PriceList >;
    SavePriceList(entity: carriers.PriceList) : Promise< carriers.PriceList >;
    DeletePriceList(PriceListId: number) : Promise<void>;
    CreateDefaultProduct(): Promise< carriers.Product >;
    SaveProduct(entity: carriers.Product) : Promise< carriers.Product >;
    DeleteProduct(ProductId: number) : Promise<void>;
    CreateDefaultQuoteAlternative(): Promise< carriers.QuoteAlternative >;
    SaveQuoteAlternative(entity: carriers.QuoteAlternative) : Promise< carriers.QuoteAlternative >;
    GetConfigurationFields(request: carriers.Quote_GetConfigurationFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadataDictionary >;
    GetConfigurationFields(connectionId: number, connectorName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadataDictionary >;
    TestConnection(request: carriers.Quote_TestConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    TestConnection(connectorName: string, connectionData: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    GetPriceList(priceListId: number) :  Promise< carriers.PriceList >;
    CopySuperOfficePriceList(request: carriers.Quote_CopySuperOfficePriceListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList >;
    CopySuperOfficePriceList(originalPriceListId: number, newName: string, validFrom: Date, validTo: Date, newCurrencyId: number, convertCurrency: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList >;
    GetProductImage(request: carriers.Quote_GetProductImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetProductImage(quoteConnectionId: number, eRPProductKey: string, rank: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    FindProduct(request: carriers.Quote_FindProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product[] >;
    FindProduct(quoteAlternativeId: number, userInput: string, priceListKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product[] >;
    GetProduct(request: carriers.Quote_GetProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product >;
    GetProduct(quoteConnectionId: number, eRPProductKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product >;
    GetProductFromDbId(request: carriers.Quote_GetProductFromDbIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product >;
    GetProductFromDbId(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product >;
    RemoveProduct(request: carriers.Quote_RemoveProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveProduct(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ToggleProductInAssortment(request: carriers.Quote_ToggleProductInAssortmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ToggleProductInAssortment(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveQuote(request: carriers.Quote_SaveQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;
    SaveQuote(quote: carriers.Quote, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;
    GetQuote(request: carriers.Quote_GetQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;
    GetQuote(quoteId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;
    GetQuoteFromSaleId(request: carriers.Quote_GetQuoteFromSaleIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;
    GetQuoteFromSaleId(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;
    GetQuoteAlternative(quoteAlternativeId: number) :  Promise< carriers.QuoteAlternative >;
    RecalculateQuoteAlternative(request: carriers.Quote_RecalculateQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternativeRecalculated >;
    RecalculateQuoteAlternative(quoteAlternative: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternativeRecalculated >;
    GetQuoteAlternatives(request: carriers.Quote_GetQuoteAlternativesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative[] >;
    GetQuoteAlternatives(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative[] >;
    MoveQuoteLine(request: carriers.Quote_MoveQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveQuoteLine(quoteLineId: number, direction: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateQuoteAlternative(request: carriers.Quote_CreateQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative >;
    CreateQuoteAlternative(quoteVersionId: number, quoteAlternativeName: string, quoteAlternativeDescription: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative >;
    CopyQuoteAlternative(request: carriers.Quote_CopyQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative >;
    CopyQuoteAlternative(quoteVersionId: number, quoteAlternativeId: number, quoteAlternativeName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative >;
    DeleteQuoteAlternative(request: carriers.Quote_DeleteQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteQuoteAlternative(quoteAlternativeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    HasConnections(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    GetAllInstalledQuoteConnections(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >;
    GetAllAvailableQuoteConnections(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >;
    GetAllAvailableQuoteConnectionsWithPriceLists(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >;
    CreateConnectionFromConnectorName(request: carriers.Quote_CreateConnectionFromConnectorNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;
    CreateConnectionFromConnectorName(connectorName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;
    GetConnection(request: carriers.Quote_GetConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;
    GetConnection(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;
    SaveConnection(request: carriers.Quote_SaveConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;
    SaveConnection(connection: carriers.QuoteConnection, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;
    DeleteConnection(request: carriers.Quote_DeleteConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteConnection(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RestoreConnection(request: carriers.Quote_RestoreConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RestoreConnection(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetConnectionsForAssociate(request: carriers.Quote_GetConnectionsForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >;
    GetConnectionsForAssociate(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >;
    GetActivePriceLists(request: carriers.Quote_GetActivePriceListsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;
    GetActivePriceLists(quoteConnectionId: number, currency: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;
    GetActivePriceListsByCurrencyId(request: carriers.Quote_GetActivePriceListsByCurrencyIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;
    GetActivePriceListsByCurrencyId(quoteConnectionId: number, currencyId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;
    GetAllPriceLists(request: carriers.Quote_GetAllPriceListsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;
    GetAllPriceLists(quoteConnectionId: number, currency: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;
    GetAllPriceListsByCurrencyId(request: carriers.Quote_GetAllPriceListsByCurrencyIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;
    GetAllPriceListsByCurrencyId(quoteConnectionId: number, currencyId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;
    GetConnectorCapabilityNames(request: carriers.Quote_GetConnectorCapabilityNamesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetConnectorCapabilityNames(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetConnectorCapabilities(request: carriers.Quote_GetConnectorCapabilitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetConnectorCapabilities(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    CanConnectorProvideCapability(request: carriers.Quote_CanConnectorProvideCapabilityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CanConnectorProvideCapability(quoteConnectionId: number, capabilityName: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetConnectionStartupErrors(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse[] >;
    GetConnectionStartupResponse(request: carriers.Quote_GetConnectionStartupResponseRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    GetConnectionStartupResponse(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    GetConnectionConfigFields(request: carriers.Quote_GetConnectionConfigFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetConnectionConfigFields(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    SaveConnectionConfigFields(request: carriers.Quote_SaveConnectionConfigFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    SaveConnectionConfigFields(quoteConnectionId: number, connectionConfigFields: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    CreateAndSaveQuote(request: carriers.Quote_CreateAndSaveQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    CreateAndSaveQuote(saleId: number, connectionId: number, firstAlternativeName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    GetQuoteEntity(request: carriers.Quote_GetQuoteEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    GetQuoteEntity(quoteId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    GetQuoteEntityFromSaleId(request: carriers.Quote_GetQuoteEntityFromSaleIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    GetQuoteEntityFromSaleId(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    SaveQuoteEntity(request: carriers.Quote_SaveQuoteEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    SaveQuoteEntity(quoteEntity: carriers.QuoteEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    CreateAndSaveQuoteFromSale(request: carriers.Quote_CreateAndSaveQuoteFromSaleRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    CreateAndSaveQuoteFromSale(copyFromSaleId: number, copyToSaleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;
    PlaceOrder(request: carriers.Quote_PlaceOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;
    PlaceOrder(quoteAlternativeId: number, markSaleAsSold: boolean, poNumber: string, orderComment: string, culture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;
    GetOrderState(request: carriers.Quote_GetOrderStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;
    GetOrderState(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;
    DeleteQuote(request: carriers.Quote_DeleteQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteQuote(quoteId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateQuoteLine(request: carriers.Quote_CreateQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    CreateQuoteLine(quoteAlternativeId: number, eRPProductKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    CreateQuoteLineFromProduct(request: carriers.Quote_CreateQuoteLineFromProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    CreateQuoteLineFromProduct(quoteAlternativeId: number, product: carriers.Product, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    SaveQuoteLine(request: carriers.Quote_SaveQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    SaveQuoteLine(quoteLine: carriers.QuoteLine, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    SaveQuoteLines(request: carriers.Quote_SaveQuoteLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] >;
    SaveQuoteLines(quoteLines: carriers.QuoteLine[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] >;
    GetQuoteLine(request: carriers.Quote_GetQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    GetQuoteLine(quoteLineId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    GetQuoteLines(request: carriers.Quote_GetQuoteLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] >;
    GetQuoteLines(quoteAlternativeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] >;
    DeleteQuoteLine(request: carriers.Quote_DeleteQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteQuoteLine(quoteLineId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteQuoteLines(request: carriers.Quote_DeleteQuoteLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteQuoteLines(quoteLineIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RecalculateQuoteLine(request: carriers.Quote_RecalculateQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    RecalculateQuoteLine(quoteLine: carriers.QuoteLine, changedFields: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;
    GetQuoteLineImage(request: carriers.Quote_GetQuoteLineImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetQuoteLineImage(quoteLineId: number, rank: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SaveQuoteLineImage(request: carriers.Quote_SaveQuoteLineImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveQuoteLineImage(quoteLineId: number, image: ArrayBuffer|string, rank: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetExtraInfo(request: carriers.Quote_GetExtraInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductExtraDataField[] >;
    GetExtraInfo(quoteLineExtraData: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductExtraDataField[] >;
    GetQuoteLineConfiguration(request: carriers.Quote_GetQuoteLineConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;
    GetQuoteLineConfiguration(quoteLineConfigurationId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;
    GetQuoteLineConfigurationFromFieldName(request: carriers.Quote_GetQuoteLineConfigurationFromFieldNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;
    GetQuoteLineConfigurationFromFieldName(fieldName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;
    GetAllQuoteLineConfigurations(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] >;
    GetInUseQuoteLineConfigurations(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] >;
    SaveQuoteLineConfiguration(request: carriers.Quote_SaveQuoteLineConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;
    SaveQuoteLineConfiguration(quoteLineConfiguration: carriers.QuoteLineConfiguration, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;
    SaveQuoteLineConfigurations(request: carriers.Quote_SaveQuoteLineConfigurationsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] >;
    SaveQuoteLineConfigurations(quoteLineConfigurations: carriers.QuoteLineConfiguration[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] >;
    GetQuoteList(request: carriers.Quote_GetQuoteListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteListItem[] >;
    GetQuoteList(quoteListType: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteListItem[] >;
    ValidateQuoteVersion(request: carriers.Quote_ValidateQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated >;
    ValidateQuoteVersion(quoteVersionId: number, action: enums.QuoteVersionButtonAction, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated >;
    CreateAndSaveQuoteVersion(request: carriers.Quote_CreateAndSaveQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;
    CreateAndSaveQuoteVersion(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;
    GetQuoteVersion(request: carriers.Quote_GetQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;
    GetQuoteVersion(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;
    GetQuoteVersions(request: carriers.Quote_GetQuoteVersionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion[] >;
    GetQuoteVersions(quoteId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion[] >;
    SendQuoteVersion(request: carriers.Quote_SendQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;
    SendQuoteVersion(quoteVersionId: number, expiryDate: Date, followupDate: Date, followupText: string, culture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;
    SaveQuoteVersion(request: carriers.Quote_SaveQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;
    SaveQuoteVersion(quoteVersion: carriers.QuoteVersion, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;
    ApproveQuoteVersion(request: carriers.Quote_ApproveQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse >;
    ApproveQuoteVersion(quoteVersionId: number, approvedByText: string, approvedByAssociateId: number, approvalText: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse >;
    RejectQuoteVersion(request: carriers.Quote_RejectQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse >;
    RejectQuoteVersion(quoteVersionId: number, rejectedByText: string, rejectedByAssociateId: number, rejectionText: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse >;
    GenerateQuoteDocuments(request: carriers.Quote_GenerateQuoteDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuotePublishDocuments >;
    GenerateQuoteDocuments(quoteVersionId: number, emailBodyTemplateId: number, attachMainDocument: boolean, quotedProductsTemplateId: number, includeAttachments: boolean, rawMailSubject: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuotePublishDocuments >;
    GetOrderConfirmation(request: carriers.Quote_GetOrderConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetOrderConfirmation(quoteVersionId: number, confirmationTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetQuoteVersionWorkflowState(request: carriers.Quote_GetQuoteVersionWorkflowStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState >;
    GetQuoteVersionWorkflowState(quoteVersionId: number, quoteAlternativeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState >;
    UpdateQuoteVersionPrices(request: carriers.Quote_UpdateQuoteVersionPricesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated >;
    UpdateQuoteVersionPrices(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated >;
    SaveQuoteVersionNumber(request: carriers.Quote_SaveQuoteVersionNumberRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SaveQuoteVersionNumber(quoteVersionId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetQuoteVersionWorkflowImageState(request: carriers.Quote_GetQuoteVersionWorkflowImageStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionButtonState >;
    GetQuoteVersionWorkflowImageState(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionButtonState >;
    GetQuoteVersionWorkflowButtonStates(request: carriers.Quote_GetQuoteVersionWorkflowButtonStatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState >;
    GetQuoteVersionWorkflowButtonStates(quoteVersionId: number, quoteAlternativeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState >;
    GetQuoteVersionWorkflowStatusInfo(request: carriers.Quote_GetQuoteVersionWorkflowStatusInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionStatusInformation >;
    GetQuoteVersionWorkflowStatusInfo(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionStatusInformation >;
    RequestApproval(request: carriers.Quote_RequestApprovalRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    RequestApproval(quoteVersionId: number, associateId: number, comment: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    CancelApprovalRequest(request: carriers.Quote_CancelApprovalRequestRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    CancelApprovalRequest(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;
    CreateOrUpdateQuoteVersionAttachments(request: carriers.Quote_CreateOrUpdateQuoteVersionAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionAttachment[] >;
    CreateOrUpdateQuoteVersionAttachments(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionAttachment[] >;
    IncludeQuoteVersionAttachment(request: carriers.Quote_IncludeQuoteVersionAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IncludeQuoteVersionAttachment(quoteVersionId: number, documentId: number, include: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ToggleSaleTypeQuoteAttachmentDefaultIncluded(request: carriers.Quote_ToggleSaleTypeQuoteAttachmentDefaultIncludedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ToggleSaleTypeQuoteAttachmentDefaultIncluded(saleTypeQuoteAttachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    AddSaleTypeQuoteAttachment(request: carriers.Quote_AddSaleTypeQuoteAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    AddSaleTypeQuoteAttachment(saleTypeId: number, documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    DeleteSaleTypeQuoteAttachment(request: carriers.Quote_DeleteSaleTypeQuoteAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteSaleTypeQuoteAttachment(saleTypeQuoteAttachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ToggleQuoteVersionAttachmentIncluded(request: carriers.Quote_ToggleQuoteVersionAttachmentIncludedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ToggleQuoteVersionAttachmentIncluded(quoteVersionAttachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
} // interface IQuoteAgent




/**
 * Services for the Quote Management feature, part of the Sale module
 */
export class QuoteAgent extends base.WebApiBase implements IQuoteAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Quote/";
        super(options);
    }



    /**
     * Set default values into a new PriceList.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultPriceList(options?:base.WebApiRequestOptions) : Promise< carriers.PriceList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PriceList >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPriceList", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PriceList = converters.Create_PriceList_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing PriceList or creates a new PriceList if the id parameter is empty
     * @param entity - The PriceList to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated PriceList
     */
    public async SavePriceList(entity: carriers.PriceList, options?:base.WebApiRequestOptions) : Promise< carriers.PriceList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PriceList >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SavePriceList", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PriceList = converters.Create_PriceList_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the PriceList
     * @param PriceListId - The id of the PriceList to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeletePriceList(PriceListId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeletePriceList?PriceListId=" + PriceListId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new Product.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultProduct(options?:base.WebApiRequestOptions) : Promise< carriers.Product > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Product >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProduct", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Product = converters.Create_Product_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing Product or creates a new Product if the id parameter is empty
     * @param entity - The Product to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated Product
     */
    public async SaveProduct(entity: carriers.Product, options?:base.WebApiRequestOptions) : Promise< carriers.Product > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Product >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProduct", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Product = converters.Create_Product_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the Product
     * @param ProductId - The id of the Product to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteProduct(ProductId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteProduct?ProductId=" + ProductId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new QuoteAlternative.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultQuoteAlternative(options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteAlternative >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultQuoteAlternative", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteAlternative = converters.Create_QuoteAlternative_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing QuoteAlternative or creates a new QuoteAlternative if the id parameter is empty
     * @param entity - The QuoteAlternative to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated QuoteAlternative
     */
    public async SaveQuoteAlternative(entity: carriers.QuoteAlternative, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteAlternative >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveQuoteAlternative", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteAlternative = converters.Create_QuoteAlternative_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    private async _GetConfigurationFields(request: carriers.Quote_GetConfigurationFieldsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadataDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.FieldMetadataDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConfigurationFields", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.FieldMetadataDictionary = converters.Create_FieldMetadataDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Used by ADMIN. Asks for metadata needed to populate admin dialog that takes in the information needed to create a connection to an ERP system. The values entered in the dialog are stored in SuperOffice db and used when InitializeConnector is called by the client.
     * @param request - ConnectionId, ConnectorName
     * @returns carriers
     */
    public async GetConfigurationFields(request: carriers.Quote_GetConfigurationFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadataDictionary >;

    /**
     * Used by ADMIN. Asks for metadata needed to populate admin dialog that takes in the information needed to create a connection to an ERP system. The values entered in the dialog are stored in SuperOffice db and used when InitializeConnector is called by the client.
     * @param connectionId - Id of an existing connection, if any. Initializes connection with current config values if non-zero.
     * @param connectorName - Name of the connector. Ignored if connectionId is non-zero.
     * @returns carriers
     */
    public async GetConfigurationFields(connectionId: number, connectorName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadataDictionary >;

    public async GetConfigurationFields(connectionId:number|carriers.Quote_GetConfigurationFieldsRequest, connectorName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FieldMetadataDictionary > {
        let _request : carriers.Quote_GetConfigurationFieldsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionId)!='undefined' || typeof(first.ConnectorName)!='undefined' ) )
        {
            _request = connectionId as carriers.Quote_GetConfigurationFieldsRequest;
            _options = connectorName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionId: connectionId as number,
                       ConnectorName: connectorName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetConfigurationFields( _request, _options );
    }


    private async _TestConnection(request: carriers.Quote_TestConnectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestConnection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Used by the Admin clients. Testing if the connection data is sufficient to get a connection with the ERP system. The Connector should try to do some operations to check if the connection has sufficient rights to run. The connection has not been created yet. TestConnection is called without InitializeConnector being called first.
     * @param request - ConnectorName, ConnectionData
     * @returns How the test went
     */
    public async TestConnection(request: carriers.Quote_TestConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    /**
     * Used by the Admin clients. Testing if the connection data is sufficient to get a connection with the ERP system. The Connector should try to do some operations to check if the connection has sufficient rights to run. The connection has not been created yet. TestConnection is called without InitializeConnector being called first.
     * @param connectorName - Name of the connector.
     * @param connectionData - Basically the name/value collection of the configuration data requested to create a connection
     * @returns How the test went
     */
    public async TestConnection(connectorName: string, connectionData: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    public async TestConnection(connectorName:string|carriers.Quote_TestConnectionRequest, connectionData?:carriers.StringDictionary|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        let _request : carriers.Quote_TestConnectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectorName;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectorName)!='undefined' || typeof(first.ConnectionData)!='undefined' ) )
        {
            _request = connectorName as carriers.Quote_TestConnectionRequest;
            _options = connectionData as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectorName: connectorName as string,
                       ConnectionData: connectionData as carriers.StringDictionary,
                       };   
            _options = webapi_options;
        }
        return this._TestConnection( _request, _options );
    }

    /*
     * Gets a PriceList object.
     * @param priceListId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PriceList
     */
    public async GetPriceList(priceListId: number, options?:base.WebApiRequestOptions) : Promise< carriers.PriceList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PriceList >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPriceList?priceListId=" + priceListId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriceList_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _CopySuperOfficePriceList(request: carriers.Quote_CopySuperOfficePriceListRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PriceList > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PriceList >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopySuperOfficePriceList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PriceList = converters.Create_PriceList_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a copy of a PriceList in the SuperOffice database
     * @param request - OriginalPriceListId, NewName, ValidFrom, ValidTo, NewCurrencyId, ConvertCurrency
     * @returns The copied PriceList
     */
    public async CopySuperOfficePriceList(request: carriers.Quote_CopySuperOfficePriceListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList >;

    /**
     * Create a copy of a PriceList in the SuperOffice database
     * @param originalPriceListId - Id of the PriceList to be copied
     * @param newName - Name of the copied PriceList
     * @param validFrom - Start date for the new pricelist.
     * @param validTo - End date for the new pricelist.
     * @param newCurrencyId - Currency id of the copied PriceList. If 0 or the same as the original the copied products will keep their prices and the currency will be the same as the original.
     * @param convertCurrency - If true, product prices will be recalculated to the new currency. If false, product prices will be set to zero.
     * @returns The copied PriceList
     */
    public async CopySuperOfficePriceList(originalPriceListId: number, newName: string, validFrom: Date, validTo: Date, newCurrencyId: number, convertCurrency: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList >;

    public async CopySuperOfficePriceList(originalPriceListId:number|carriers.Quote_CopySuperOfficePriceListRequest, newName?:string|base.WebApiRequestOptions, validFrom?:Date, validTo?:Date, newCurrencyId?:number, convertCurrency?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList > {
        let _request : carriers.Quote_CopySuperOfficePriceListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = originalPriceListId;
        if( typeof( first ) === "object" && first && ( typeof(first.OriginalPriceListId)!='undefined' || typeof(first.NewName)!='undefined' || typeof(first.ValidFrom)!='undefined' || typeof(first.ValidTo)!='undefined' || typeof(first.NewCurrencyId)!='undefined' || typeof(first.ConvertCurrency)!='undefined' ) )
        {
            _request = originalPriceListId as carriers.Quote_CopySuperOfficePriceListRequest;
            _options = newName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       OriginalPriceListId: originalPriceListId as number,
                       NewName: newName as string,
                       ValidFrom: validFrom as Date,
                       ValidTo: validTo as Date,
                       NewCurrencyId: newCurrencyId as number,
                       ConvertCurrency: convertCurrency as boolean,
                       };   
            _options = webapi_options;
        }
        return this._CopySuperOfficePriceList( _request, _options );
    }


    private async _GetProductImage(request: carriers.Quote_GetProductImageRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets an image connected to a product, from the ProductProvider
     * @param request - QuoteConnectionId, ERPProductKey, Rank
     * @returns The base64 encoded image as a string.
     */
    public async GetProductImage(request: carriers.Quote_GetProductImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Gets an image connected to a product, from the ProductProvider
     * @param quoteConnectionId - The connection this product comes from.
     * @param eRPProductKey - Primary key of the Product in the ProductProvider 
     * @param rank - The rank of the image.
     * @returns The base64 encoded image as a string.
     */
    public async GetProductImage(quoteConnectionId: number, eRPProductKey: string, rank: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetProductImage(quoteConnectionId:number|carriers.Quote_GetProductImageRequest, eRPProductKey?:string|base.WebApiRequestOptions, rank?:number, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Quote_GetProductImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' || typeof(first.ERPProductKey)!='undefined' || typeof(first.Rank)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetProductImageRequest;
            _options = eRPProductKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       ERPProductKey: eRPProductKey as string,
                       Rank: rank as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProductImage( _request, _options );
    }


    private async _FindProduct(request: carriers.Quote_FindProductRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Product[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Product[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindProduct", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Product[] = converters.Create_ProductArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a product, from the ProductProvider
     * @param request - QuoteAlternativeId, UserInput, PriceListKey
     * @returns Product array
     */
    public async FindProduct(request: carriers.Quote_FindProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product[] >;

    /**
     * Gets a product, from the ProductProvider
     * @param quoteAlternativeId - Quote alternative to search in.
     * @param userInput - search string
     * @param priceListKey - If the pricelist is null or empty, the function will search in all active pricelists.
     * @returns Product array
     */
    public async FindProduct(quoteAlternativeId: number, userInput: string, priceListKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product[] >;

    public async FindProduct(quoteAlternativeId:number|carriers.Quote_FindProductRequest, userInput?:string|base.WebApiRequestOptions, priceListKey?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product[] > {
        let _request : carriers.Quote_FindProductRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteAlternativeId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteAlternativeId)!='undefined' || typeof(first.UserInput)!='undefined' || typeof(first.PriceListKey)!='undefined' ) )
        {
            _request = quoteAlternativeId as carriers.Quote_FindProductRequest;
            _options = userInput as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteAlternativeId: quoteAlternativeId as number,
                       UserInput: userInput as string,
                       PriceListKey: priceListKey as string,
                       };   
            _options = webapi_options;
        }
        return this._FindProduct( _request, _options );
    }


    private async _GetProduct(request: carriers.Quote_GetProductRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Product > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Product >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProduct", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Product = converters.Create_Product_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a product with the given key
     * @param request - QuoteConnectionId, ERPProductKey
     * @returns 
     */
    public async GetProduct(request: carriers.Quote_GetProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product >;

    /**
     * Get a product with the given key
     * @param quoteConnectionId - The connection this product comes from.
     * @param eRPProductKey - Primary key of the Product in the ProductProvider
     * @returns 
     */
    public async GetProduct(quoteConnectionId: number, eRPProductKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product >;

    public async GetProduct(quoteConnectionId:number|carriers.Quote_GetProductRequest, eRPProductKey?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product > {
        let _request : carriers.Quote_GetProductRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' || typeof(first.ERPProductKey)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetProductRequest;
            _options = eRPProductKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       ERPProductKey: eRPProductKey as string,
                       };   
            _options = webapi_options;
        }
        return this._GetProduct( _request, _options );
    }


    private async _GetProductFromDbId(request: carriers.Quote_GetProductFromDbIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Product > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Product >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductFromDbId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Product = converters.Create_Product_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a product with the given database id
     * @param request - ProductId
     * @returns The product info
     */
    public async GetProductFromDbId(request: carriers.Quote_GetProductFromDbIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product >;

    /**
     * Get a product with the given database id
     * @param productId - The database id of the product
     * @returns The product info
     */
    public async GetProductFromDbId(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product >;

    public async GetProductFromDbId(productId:number|carriers.Quote_GetProductFromDbIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Product > {
        let _request : carriers.Quote_GetProductFromDbIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = productId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProductId)!='undefined' ) )
        {
            _request = productId as carriers.Quote_GetProductFromDbIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProductId: productId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProductFromDbId( _request, _options );
    }


    private async _RemoveProduct(request: carriers.Quote_RemoveProductRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveProduct", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes a product from the database
     * @param request - ProductId
     * @returns 
     */
    public async RemoveProduct(request: carriers.Quote_RemoveProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Removes a product from the database
     * @param productId - The database id of the product to remove
     * @returns 
     */
    public async RemoveProduct(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveProduct(productId:number|carriers.Quote_RemoveProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_RemoveProductRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = productId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProductId)!='undefined' ) )
        {
            _request = productId as carriers.Quote_RemoveProductRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProductId: productId as number,
                       };   
            _options = webapi_options;
        }
        return this._RemoveProduct( _request, _options );
    }


    private async _ToggleProductInAssortment(request: carriers.Quote_ToggleProductInAssortmentRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleProductInAssortment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Toggles if the prdouct is in assortment or not
     * @param request - ProductId
     * @returns 
     */
    public async ToggleProductInAssortment(request: carriers.Quote_ToggleProductInAssortmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Toggles if the prdouct is in assortment or not
     * @param productId - The database id of the product to toggle is assortment value of
     * @returns 
     */
    public async ToggleProductInAssortment(productId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ToggleProductInAssortment(productId:number|carriers.Quote_ToggleProductInAssortmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_ToggleProductInAssortmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = productId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProductId)!='undefined' ) )
        {
            _request = productId as carriers.Quote_ToggleProductInAssortmentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProductId: productId as number,
                       };   
            _options = webapi_options;
        }
        return this._ToggleProductInAssortment( _request, _options );
    }


    private async _SaveQuote(request: carriers.Quote_SaveQuoteRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Quote > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Quote >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuote", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Quote = converters.Create_Quote_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a Quote
     * @param request - Quote
     * @returns The saved Quote
     */
    public async SaveQuote(request: carriers.Quote_SaveQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;

    /**
     * Saves a Quote
     * @param quote - The Quote to save
     * @returns The saved Quote
     */
    public async SaveQuote(quote: carriers.Quote, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;

    public async SaveQuote(quote:carriers.Quote|carriers.Quote_SaveQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote > {
        let _request : carriers.Quote_SaveQuoteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quote;
        if( typeof( first ) === "object" && first && ( typeof(first.Quote)!='undefined' ) )
        {
            _request = quote as carriers.Quote_SaveQuoteRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Quote: quote as carriers.Quote,
                       };   
            _options = webapi_options;
        }
        return this._SaveQuote( _request, _options );
    }


    private async _GetQuote(request: carriers.Quote_GetQuoteRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Quote > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Quote >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuote", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Quote = converters.Create_Quote_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a Quote
     * @param request - QuoteId
     * @returns The Quote
     */
    public async GetQuote(request: carriers.Quote_GetQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;

    /**
     * Get a Quote
     * @param quoteId - QuoteId of the Quote to get.
     * @returns The Quote
     */
    public async GetQuote(quoteId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;

    public async GetQuote(quoteId:number|carriers.Quote_GetQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote > {
        let _request : carriers.Quote_GetQuoteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteId)!='undefined' ) )
        {
            _request = quoteId as carriers.Quote_GetQuoteRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteId: quoteId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuote( _request, _options );
    }


    private async _GetQuoteFromSaleId(request: carriers.Quote_GetQuoteFromSaleIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Quote > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Quote >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteFromSaleId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Quote = converters.Create_Quote_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a Quote for a sale
     * @param request - SaleId
     * @returns The Quote
     */
    public async GetQuoteFromSaleId(request: carriers.Quote_GetQuoteFromSaleIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;

    /**
     * Get a Quote for a sale
     * @param saleId - SaleId of the Quote to get.
     * @returns The Quote
     */
    public async GetQuoteFromSaleId(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote >;

    public async GetQuoteFromSaleId(saleId:number|carriers.Quote_GetQuoteFromSaleIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Quote > {
        let _request : carriers.Quote_GetQuoteFromSaleIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' ) )
        {
            _request = saleId as carriers.Quote_GetQuoteFromSaleIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteFromSaleId( _request, _options );
    }

    /*
     * Gets a QuoteAlternative object.
     * @param quoteAlternativeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single QuoteAlternative
     */
    public async GetQuoteAlternative(quoteAlternativeId: number, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteAlternative >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteAlternative?quoteAlternativeId=" + quoteAlternativeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteAlternative_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _RecalculateQuoteAlternative(request: carriers.Quote_RecalculateQuoteAlternativeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternativeRecalculated > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteAlternativeRecalculated >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RecalculateQuoteAlternative", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteAlternativeRecalculated = converters.Create_QuoteAlternativeRecalculated_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * When the user changes one or more values in a quoteline or a quoteAlternative, the connector gets to change the QuoteLines and the alternative, for instance calculate VAT. RecalculateQuoteAlternative shall be called when the user changes any of the following fields: Quantity, DiscountAmount, DiscountPercent, listprice (if allowed). RecalculateQuoteAlternative will calculate the TotalPrice and the VAT (if possible) for the lines and the alternative.
     * @param request - QuoteAlternative
     * @returns The updated quote version.
     */
    public async RecalculateQuoteAlternative(request: carriers.Quote_RecalculateQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternativeRecalculated >;

    /**
     * When the user changes one or more values in a quoteline or a quoteAlternative, the connector gets to change the QuoteLines and the alternative, for instance calculate VAT. RecalculateQuoteAlternative shall be called when the user changes any of the following fields: Quantity, DiscountAmount, DiscountPercent, listprice (if allowed). RecalculateQuoteAlternative will calculate the TotalPrice and the VAT (if possible) for the lines and the alternative.
     * @param quoteAlternative - The alternative to be recalculated
     * @returns The updated quote version.
     */
    public async RecalculateQuoteAlternative(quoteAlternative: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternativeRecalculated >;

    public async RecalculateQuoteAlternative(quoteAlternative:number|carriers.Quote_RecalculateQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternativeRecalculated > {
        let _request : carriers.Quote_RecalculateQuoteAlternativeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteAlternative;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteAlternative)!='undefined' ) )
        {
            _request = quoteAlternative as carriers.Quote_RecalculateQuoteAlternativeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteAlternative: quoteAlternative as number,
                       };   
            _options = webapi_options;
        }
        return this._RecalculateQuoteAlternative( _request, _options );
    }


    private async _GetQuoteAlternatives(request: carriers.Quote_GetQuoteAlternativesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteAlternative[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteAlternatives", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteAlternative[] = converters.Create_QuoteAlternativeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all quote alternatives for a quote version
     * @param request - QuoteVersionId
     * @returns Array of Quote alternatives
     */
    public async GetQuoteAlternatives(request: carriers.Quote_GetQuoteAlternativesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative[] >;

    /**
     * Get all quote alternatives for a quote version
     * @param quoteVersionId - QuoteVersionId of the revison to get alternatives for.
     * @returns Array of Quote alternatives
     */
    public async GetQuoteAlternatives(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative[] >;

    public async GetQuoteAlternatives(quoteVersionId:number|carriers.Quote_GetQuoteAlternativesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative[] > {
        let _request : carriers.Quote_GetQuoteAlternativesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_GetQuoteAlternativesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteAlternatives( _request, _options );
    }


    private async _MoveQuoteLine(request: carriers.Quote_MoveQuoteLineRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveQuoteLine", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Move quote line rank up/down
     * @param request - QuoteLineId, Direction
     * @returns Void return
     */
    public async MoveQuoteLine(request: carriers.Quote_MoveQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Move quote line rank up/down
     * @param quoteLineId - Id of quote line to move up/down
     * @param direction - True is up, false is down
     * @returns Void return
     */
    public async MoveQuoteLine(quoteLineId: number, direction: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MoveQuoteLine(quoteLineId:number|carriers.Quote_MoveQuoteLineRequest, direction?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_MoveQuoteLineRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineId)!='undefined' || typeof(first.Direction)!='undefined' ) )
        {
            _request = quoteLineId as carriers.Quote_MoveQuoteLineRequest;
            _options = direction as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineId: quoteLineId as number,
                       Direction: direction as boolean,
                       };   
            _options = webapi_options;
        }
        return this._MoveQuoteLine( _request, _options );
    }


    private async _CreateQuoteAlternative(request: carriers.Quote_CreateQuoteAlternativeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteAlternative >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateQuoteAlternative", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteAlternative = converters.Create_QuoteAlternative_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new quote alternative on a version.
     * @param request - QuoteVersionId, QuoteAlternativeName, QuoteAlternativeDescription
     * @returns The newly created QuoteAlternative.
     */
    public async CreateQuoteAlternative(request: carriers.Quote_CreateQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative >;

    /**
     * Create a new quote alternative on a version.
     * @param quoteVersionId - QuoteVersionId of the version to create the alternative on.
     * @param quoteAlternativeName - The name to set on the new alternative.
     * @param quoteAlternativeDescription - The description to set on the new alternative.
     * @returns The newly created QuoteAlternative.
     */
    public async CreateQuoteAlternative(quoteVersionId: number, quoteAlternativeName: string, quoteAlternativeDescription: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative >;

    public async CreateQuoteAlternative(quoteVersionId:number|carriers.Quote_CreateQuoteAlternativeRequest, quoteAlternativeName?:string|base.WebApiRequestOptions, quoteAlternativeDescription?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative > {
        let _request : carriers.Quote_CreateQuoteAlternativeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.QuoteAlternativeName)!='undefined' || typeof(first.QuoteAlternativeDescription)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_CreateQuoteAlternativeRequest;
            _options = quoteAlternativeName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       QuoteAlternativeName: quoteAlternativeName as string,
                       QuoteAlternativeDescription: quoteAlternativeDescription as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateQuoteAlternative( _request, _options );
    }


    private async _CopyQuoteAlternative(request: carriers.Quote_CopyQuoteAlternativeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteAlternative >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyQuoteAlternative", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteAlternative = converters.Create_QuoteAlternative_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Copy a quote alternative from the same sale and adds it to a version.
     * @param request - QuoteVersionId, QuoteAlternativeId, QuoteAlternativeName
     * @returns The copied QuoteAlternative.
     */
    public async CopyQuoteAlternative(request: carriers.Quote_CopyQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative >;

    /**
     * Copy a quote alternative from the same sale and adds it to a version.
     * @param quoteVersionId - QuoteVersionId of the version to copy the alternative to.
     * @param quoteAlternativeId - QuoteAlternativeId of the alternative to make a copy of.
     * @param quoteAlternativeName - The name to set on the new alternative.
     * @returns The copied QuoteAlternative.
     */
    public async CopyQuoteAlternative(quoteVersionId: number, quoteAlternativeId: number, quoteAlternativeName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative >;

    public async CopyQuoteAlternative(quoteVersionId:number|carriers.Quote_CopyQuoteAlternativeRequest, quoteAlternativeId?:number|base.WebApiRequestOptions, quoteAlternativeName?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteAlternative > {
        let _request : carriers.Quote_CopyQuoteAlternativeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.QuoteAlternativeId)!='undefined' || typeof(first.QuoteAlternativeName)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_CopyQuoteAlternativeRequest;
            _options = quoteAlternativeId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       QuoteAlternativeId: quoteAlternativeId as number,
                       QuoteAlternativeName: quoteAlternativeName as string,
                       };   
            _options = webapi_options;
        }
        return this._CopyQuoteAlternative( _request, _options );
    }


    private async _DeleteQuoteAlternative(request: carriers.Quote_DeleteQuoteAlternativeRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteQuoteAlternative", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a quote alternative
     * @param request - QuoteAlternativeId
     * @returns A void return
     */
    public async DeleteQuoteAlternative(request: carriers.Quote_DeleteQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a quote alternative
     * @param quoteAlternativeId - Id of the quote alternative to delete.
     * @returns A void return
     */
    public async DeleteQuoteAlternative(quoteAlternativeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteQuoteAlternative(quoteAlternativeId:number|carriers.Quote_DeleteQuoteAlternativeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_DeleteQuoteAlternativeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteAlternativeId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteAlternativeId)!='undefined' ) )
        {
            _request = quoteAlternativeId as carriers.Quote_DeleteQuoteAlternativeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteAlternativeId: quoteAlternativeId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteQuoteAlternative( _request, _options );
    }


    private async _HasConnections( options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasConnections", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Whether or not the system has any connections available for this user.
     * @returns The response
     */
    public async HasConnections(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >
    {
        return this._HasConnections(webapi_options);
    }


    private async _GetAllInstalledQuoteConnections( options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteConnection[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllInstalledQuoteConnections", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteConnection[] = converters.Create_QuoteConnectionArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get all installed connections. Some installed connections may not be available to the user.
     * @returns List of connections
     */
    public async GetAllInstalledQuoteConnections(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >
    {
        return this._GetAllInstalledQuoteConnections(webapi_options);
    }


    private async _GetAllAvailableQuoteConnections( options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteConnection[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllAvailableQuoteConnections", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteConnection[] = converters.Create_QuoteConnectionArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get all available connections. Some installed connections may not be available to the user. Use GetAllAvailableQuoteConnectionsWithPriceLists if you need the pricelists on the connections as well.
     * @returns List of connections
     */
    public async GetAllAvailableQuoteConnections(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >
    {
        return this._GetAllAvailableQuoteConnections(webapi_options);
    }


    private async _GetAllAvailableQuoteConnectionsWithPriceLists( options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteConnection[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllAvailableQuoteConnectionsWithPriceLists", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteConnection[] = converters.Create_QuoteConnectionArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get all available connections. Some installed connections may not be available to the user. Includes pricelists for the connection. This is a heavy call
     * @returns List of connections
     */
    public async GetAllAvailableQuoteConnectionsWithPriceLists(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >
    {
        return this._GetAllAvailableQuoteConnectionsWithPriceLists(webapi_options);
    }


    private async _CreateConnectionFromConnectorName(request: carriers.Quote_CreateConnectionFromConnectorNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteConnection >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateConnectionFromConnectorName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteConnection = converters.Create_QuoteConnection_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new connection.
     * @param request - ConnectorName
     * @returns The created connection
     */
    public async CreateConnectionFromConnectorName(request: carriers.Quote_CreateConnectionFromConnectorNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;

    /**
     * Create a new connection.
     * @param connectorName - The name of the connector to create this connection for.
     * @returns The created connection
     */
    public async CreateConnectionFromConnectorName(connectorName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;

    public async CreateConnectionFromConnectorName(connectorName:string|carriers.Quote_CreateConnectionFromConnectorNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection > {
        let _request : carriers.Quote_CreateConnectionFromConnectorNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectorName;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectorName)!='undefined' ) )
        {
            _request = connectorName as carriers.Quote_CreateConnectionFromConnectorNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectorName: connectorName as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateConnectionFromConnectorName( _request, _options );
    }


    private async _GetConnection(request: carriers.Quote_GetConnectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteConnection >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteConnection = converters.Create_QuoteConnection_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the specified connection.
     * @param request - QuoteConnectionId
     * @returns The connection
     */
    public async GetConnection(request: carriers.Quote_GetConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;

    /**
     * Returns the specified connection.
     * @param quoteConnectionId - Primary key of the connection
     * @returns The connection
     */
    public async GetConnection(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;

    public async GetConnection(quoteConnectionId:number|carriers.Quote_GetConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection > {
        let _request : carriers.Quote_GetConnectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetConnectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConnection( _request, _options );
    }


    private async _SaveConnection(request: carriers.Quote_SaveConnectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteConnection >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConnection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteConnection = converters.Create_QuoteConnection_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a connection to the database.
     * @param request - Connection
     * @returns The resulting connection.
     */
    public async SaveConnection(request: carriers.Quote_SaveConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;

    /**
     * Saves a connection to the database.
     * @param connection - The connection to save.
     * @returns The resulting connection.
     */
    public async SaveConnection(connection: carriers.QuoteConnection, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection >;

    public async SaveConnection(connection:carriers.QuoteConnection|carriers.Quote_SaveConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection > {
        let _request : carriers.Quote_SaveConnectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connection;
        if( typeof( first ) === "object" && first && ( typeof(first.Connection)!='undefined' ) )
        {
            _request = connection as carriers.Quote_SaveConnectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Connection: connection as carriers.QuoteConnection,
                       };   
            _options = webapi_options;
        }
        return this._SaveConnection( _request, _options );
    }


    private async _DeleteConnection(request: carriers.Quote_DeleteConnectionRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteConnection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Marks a connection as deleted.
     * @param request - QuoteConnectionId
     * @returns A void return
     */
    public async DeleteConnection(request: carriers.Quote_DeleteConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Marks a connection as deleted.
     * @param quoteConnectionId - Primary key of the connection to delete
     * @returns A void return
     */
    public async DeleteConnection(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteConnection(quoteConnectionId:number|carriers.Quote_DeleteConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_DeleteConnectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_DeleteConnectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteConnection( _request, _options );
    }


    private async _RestoreConnection(request: carriers.Quote_RestoreConnectionRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RestoreConnection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Restores a connection marked as deleted.
     * @param request - QuoteConnectionId
     * @returns A void return
     */
    public async RestoreConnection(request: carriers.Quote_RestoreConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Restores a connection marked as deleted.
     * @param quoteConnectionId - Primary key of the connection to restore
     * @returns A void return
     */
    public async RestoreConnection(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RestoreConnection(quoteConnectionId:number|carriers.Quote_RestoreConnectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_RestoreConnectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_RestoreConnectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._RestoreConnection( _request, _options );
    }


    private async _GetConnectionsForAssociate(request: carriers.Quote_GetConnectionsForAssociateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteConnection[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionsForAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteConnection[] = converters.Create_QuoteConnectionArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all connections available for the specified user.
     * @param request - AssociateId
     * @returns The connections
     */
    public async GetConnectionsForAssociate(request: carriers.Quote_GetConnectionsForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >;

    /**
     * Returns all connections available for the specified user.
     * @param associateId - Primary key of the user
     * @returns The connections
     */
    public async GetConnectionsForAssociate(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] >;

    public async GetConnectionsForAssociate(associateId:number|carriers.Quote_GetConnectionsForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteConnection[] > {
        let _request : carriers.Quote_GetConnectionsForAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.Quote_GetConnectionsForAssociateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConnectionsForAssociate( _request, _options );
    }


    private async _GetActivePriceLists(request: carriers.Quote_GetActivePriceListsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PriceList[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetActivePriceLists", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PriceList[] = converters.Create_PriceListArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the available active PriceLists in a specific currency. Will return empty array if there is no PriceList with the stated currency available.
     * @param request - QuoteConnectionId, Currency
     * @returns The PriceLists that supports a specific currency
     */
    public async GetActivePriceLists(request: carriers.Quote_GetActivePriceListsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;

    /**
     * Gets the available active PriceLists in a specific currency. Will return empty array if there is no PriceList with the stated currency available.
     * @param quoteConnectionId - Primary key of the connection
     * @param currency - Iso currency like: USD or NOK. See http://www.currency-iso.org/dl_iso_table_a1.xls for details. Case insensitive. Will return empty array if there is no PriceList with the stated currency available.
     * @returns The PriceLists that supports a specific currency
     */
    public async GetActivePriceLists(quoteConnectionId: number, currency: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;

    public async GetActivePriceLists(quoteConnectionId:number|carriers.Quote_GetActivePriceListsRequest, currency?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] > {
        let _request : carriers.Quote_GetActivePriceListsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' || typeof(first.Currency)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetActivePriceListsRequest;
            _options = currency as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       Currency: currency as string,
                       };   
            _options = webapi_options;
        }
        return this._GetActivePriceLists( _request, _options );
    }


    private async _GetActivePriceListsByCurrencyId(request: carriers.Quote_GetActivePriceListsByCurrencyIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PriceList[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetActivePriceListsByCurrencyId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PriceList[] = converters.Create_PriceListArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the available active PriceLists in a specific currency. Will return empty array if there is no PriceList with the stated currency available.
     * @param request - QuoteConnectionId, CurrencyId
     * @returns The PriceLists that supports a specific currency
     */
    public async GetActivePriceListsByCurrencyId(request: carriers.Quote_GetActivePriceListsByCurrencyIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;

    /**
     * Gets the available active PriceLists in a specific currency. Will return empty array if there is no PriceList with the stated currency available.
     * @param quoteConnectionId - Primary key of the connection
     * @param currencyId - SuperOffice currency id.
     * @returns The PriceLists that supports a specific currency
     */
    public async GetActivePriceListsByCurrencyId(quoteConnectionId: number, currencyId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;

    public async GetActivePriceListsByCurrencyId(quoteConnectionId:number|carriers.Quote_GetActivePriceListsByCurrencyIdRequest, currencyId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] > {
        let _request : carriers.Quote_GetActivePriceListsByCurrencyIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' || typeof(first.CurrencyId)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetActivePriceListsByCurrencyIdRequest;
            _options = currencyId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       CurrencyId: currencyId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetActivePriceListsByCurrencyId( _request, _options );
    }


    private async _GetAllPriceLists(request: carriers.Quote_GetAllPriceListsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PriceList[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllPriceLists", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PriceList[] = converters.Create_PriceListArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the all PriceLists in all currencies, including those inactive. Will return empty array if there is no PriceList available.
     * @param request - QuoteConnectionId, Currency
     * @returns The PriceLists that supports a specific currency
     */
    public async GetAllPriceLists(request: carriers.Quote_GetAllPriceListsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;

    /**
     * Gets the all PriceLists in all currencies, including those inactive. Will return empty array if there is no PriceList available.
     * @param quoteConnectionId - Primary key of the connection
     * @param currency - Iso currency like: USD or NOK. See http://www.currency-iso.org/dl_iso_table_a1.xls for details. Case insensitive. Will return empty array if there is no PriceList with the stated currency available.
     * @returns The PriceLists that supports a specific currency
     */
    public async GetAllPriceLists(quoteConnectionId: number, currency: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;

    public async GetAllPriceLists(quoteConnectionId:number|carriers.Quote_GetAllPriceListsRequest, currency?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] > {
        let _request : carriers.Quote_GetAllPriceListsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' || typeof(first.Currency)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetAllPriceListsRequest;
            _options = currency as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       Currency: currency as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAllPriceLists( _request, _options );
    }


    private async _GetAllPriceListsByCurrencyId(request: carriers.Quote_GetAllPriceListsByCurrencyIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PriceList[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllPriceListsByCurrencyId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PriceList[] = converters.Create_PriceListArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the all PriceLists in all currencies, including those inactive. Will return empty array if there is no PriceList available.
     * @param request - QuoteConnectionId, CurrencyId
     * @returns The PriceLists that supports a specific currency
     */
    public async GetAllPriceListsByCurrencyId(request: carriers.Quote_GetAllPriceListsByCurrencyIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;

    /**
     * Gets the all PriceLists in all currencies, including those inactive. Will return empty array if there is no PriceList available.
     * @param quoteConnectionId - Primary key of the connection
     * @param currencyId - SuperOffice currency id.
     * @returns The PriceLists that supports a specific currency
     */
    public async GetAllPriceListsByCurrencyId(quoteConnectionId: number, currencyId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] >;

    public async GetAllPriceListsByCurrencyId(quoteConnectionId:number|carriers.Quote_GetAllPriceListsByCurrencyIdRequest, currencyId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PriceList[] > {
        let _request : carriers.Quote_GetAllPriceListsByCurrencyIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' || typeof(first.CurrencyId)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetAllPriceListsByCurrencyIdRequest;
            _options = currencyId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       CurrencyId: currencyId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAllPriceListsByCurrencyId( _request, _options );
    }


    private async _GetConnectorCapabilityNames(request: carriers.Quote_GetConnectorCapabilityNamesRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectorCapabilityNames", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a list of all possible connector capabilities
     * @param request - QuoteConnectionId
     * @returns Capabilities names
     */
    public async GetConnectorCapabilityNames(request: carriers.Quote_GetConnectorCapabilityNamesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Gets a list of all possible connector capabilities
     * @param quoteConnectionId - Primary key of the connection
     * @returns Capabilities names
     */
    public async GetConnectorCapabilityNames(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetConnectorCapabilityNames(quoteConnectionId:number|carriers.Quote_GetConnectorCapabilityNamesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.Quote_GetConnectorCapabilityNamesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetConnectorCapabilityNamesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConnectorCapabilityNames( _request, _options );
    }


    private async _GetConnectorCapabilities(request: carriers.Quote_GetConnectorCapabilitiesRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectorCapabilities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a list of connector capabilities
     * @param request - QuoteConnectionId
     * @returns Capabilities
     */
    public async GetConnectorCapabilities(request: carriers.Quote_GetConnectorCapabilitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Gets a list of connector capabilities
     * @param quoteConnectionId - Primary key of the connection
     * @returns Capabilities
     */
    public async GetConnectorCapabilities(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetConnectorCapabilities(quoteConnectionId:number|carriers.Quote_GetConnectorCapabilitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.Quote_GetConnectorCapabilitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetConnectorCapabilitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConnectorCapabilities( _request, _options );
    }


    private async _CanConnectorProvideCapability(request: carriers.Quote_CanConnectorProvideCapabilityRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanConnectorProvideCapability", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Can the connector provide the capability
     * @param request - QuoteConnectionId, CapabilityName
     * @returns Capability name
     */
    public async CanConnectorProvideCapability(request: carriers.Quote_CanConnectorProvideCapabilityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Can the connector provide the capability
     * @param quoteConnectionId - Primary key of the connection
     * @param capabilityName - Capability name
     * @returns Capability name
     */
    public async CanConnectorProvideCapability(quoteConnectionId: number, capabilityName: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async CanConnectorProvideCapability(quoteConnectionId:number|carriers.Quote_CanConnectorProvideCapabilityRequest, capabilityName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Quote_CanConnectorProvideCapabilityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' || typeof(first.CapabilityName)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_CanConnectorProvideCapabilityRequest;
            _options = capabilityName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       CapabilityName: capabilityName as string,
                       };   
            _options = webapi_options;
        }
        return this._CanConnectorProvideCapability( _request, _options );
    }


    private async _GetConnectionStartupErrors( options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionStartupErrors", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse[] = converters.Create_PluginResponseArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns an array of PluginResponseInfos for all failed connection initializations.
     * @returns Array of PluginResponseInfos for each failed connection initialization.
     */
    public async GetConnectionStartupErrors(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse[] >
    {
        return this._GetConnectionStartupErrors(webapi_options);
    }


    private async _GetConnectionStartupResponse(request: carriers.Quote_GetConnectionStartupResponseRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionStartupResponse", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the PluginResponseInfo for the connection initialization. Does not initialize the connection, just returns what happened when initialize was called.
     * @param request - QuoteConnectionId
     * @returns PluginResponseInfo for the connection initialization.
     */
    public async GetConnectionStartupResponse(request: carriers.Quote_GetConnectionStartupResponseRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    /**
     * Returns the PluginResponseInfo for the connection initialization. Does not initialize the connection, just returns what happened when initialize was called.
     * @param quoteConnectionId - Primary key of the connection
     * @returns PluginResponseInfo for the connection initialization.
     */
    public async GetConnectionStartupResponse(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    public async GetConnectionStartupResponse(quoteConnectionId:number|carriers.Quote_GetConnectionStartupResponseRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        let _request : carriers.Quote_GetConnectionStartupResponseRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetConnectionStartupResponseRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConnectionStartupResponse( _request, _options );
    }


    private async _GetConnectionConfigFields(request: carriers.Quote_GetConnectionConfigFieldsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionConfigFields", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the config fields for the connection.
     * @param request - QuoteConnectionId
     * @returns Config Fields
     */
    public async GetConnectionConfigFields(request: carriers.Quote_GetConnectionConfigFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Returns the config fields for the connection.
     * @param quoteConnectionId - Primary key of the connection
     * @returns Config Fields
     */
    public async GetConnectionConfigFields(quoteConnectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async GetConnectionConfigFields(quoteConnectionId:number|carriers.Quote_GetConnectionConfigFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Quote_GetConnectionConfigFieldsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_GetConnectionConfigFieldsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConnectionConfigFields( _request, _options );
    }


    private async _SaveConnectionConfigFields(request: carriers.Quote_SaveConnectionConfigFieldsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConnectionConfigFields", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the connection config fields
     * @param request - QuoteConnectionId, ConnectionConfigFields
     * @returns Config Fields
     */
    public async SaveConnectionConfigFields(request: carriers.Quote_SaveConnectionConfigFieldsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Saves the connection config fields
     * @param quoteConnectionId - Primary key of the connection
     * @param connectionConfigFields - ConnectionConfigFields to save.
     * @returns Config Fields
     */
    public async SaveConnectionConfigFields(quoteConnectionId: number, connectionConfigFields: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async SaveConnectionConfigFields(quoteConnectionId:number|carriers.Quote_SaveConnectionConfigFieldsRequest, connectionConfigFields?:carriers.StringDictionary|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Quote_SaveConnectionConfigFieldsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteConnectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteConnectionId)!='undefined' || typeof(first.ConnectionConfigFields)!='undefined' ) )
        {
            _request = quoteConnectionId as carriers.Quote_SaveConnectionConfigFieldsRequest;
            _options = connectionConfigFields as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteConnectionId: quoteConnectionId as number,
                       ConnectionConfigFields: connectionConfigFields as carriers.StringDictionary,
                       };   
            _options = webapi_options;
        }
        return this._SaveConnectionConfigFields( _request, _options );
    }


    private async _CreateAndSaveQuote(request: carriers.Quote_CreateAndSaveQuoteRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndSaveQuote", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteEntity = converters.Create_QuoteEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a new quote on a sale.
     * @param request - SaleId, ConnectionId, FirstAlternativeName
     * @returns Quote carrier
     */
    public async CreateAndSaveQuote(request: carriers.Quote_CreateAndSaveQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    /**
     * Creates a new quote on a sale.
     * @param saleId - SaleId of the connected sale
     * @param connectionId - ConnectionId
     * @param firstAlternativeName - Name to be given to the default alternative
     * @returns Quote carrier
     */
    public async CreateAndSaveQuote(saleId: number, connectionId: number, firstAlternativeName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    public async CreateAndSaveQuote(saleId:number|carriers.Quote_CreateAndSaveQuoteRequest, connectionId?:number|base.WebApiRequestOptions, firstAlternativeName?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        let _request : carriers.Quote_CreateAndSaveQuoteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' || typeof(first.ConnectionId)!='undefined' || typeof(first.FirstAlternativeName)!='undefined' ) )
        {
            _request = saleId as carriers.Quote_CreateAndSaveQuoteRequest;
            _options = connectionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       ConnectionId: connectionId as number,
                       FirstAlternativeName: firstAlternativeName as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateAndSaveQuote( _request, _options );
    }


    private async _GetQuoteEntity(request: carriers.Quote_GetQuoteEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteEntity = converters.Create_QuoteEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a Quote
     * @param request - QuoteId
     * @returns The Quote
     */
    public async GetQuoteEntity(request: carriers.Quote_GetQuoteEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    /**
     * Get a Quote
     * @param quoteId - QuoteId of the Quote to get.
     * @returns The Quote
     */
    public async GetQuoteEntity(quoteId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    public async GetQuoteEntity(quoteId:number|carriers.Quote_GetQuoteEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        let _request : carriers.Quote_GetQuoteEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteId)!='undefined' ) )
        {
            _request = quoteId as carriers.Quote_GetQuoteEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteId: quoteId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteEntity( _request, _options );
    }


    private async _GetQuoteEntityFromSaleId(request: carriers.Quote_GetQuoteEntityFromSaleIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteEntityFromSaleId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteEntity = converters.Create_QuoteEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a Quote for a sale
     * @param request - SaleId
     * @returns The Quote
     */
    public async GetQuoteEntityFromSaleId(request: carriers.Quote_GetQuoteEntityFromSaleIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    /**
     * Get a Quote for a sale
     * @param saleId - SaleId of the Quote to get.
     * @returns The Quote
     */
    public async GetQuoteEntityFromSaleId(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    public async GetQuoteEntityFromSaleId(saleId:number|carriers.Quote_GetQuoteEntityFromSaleIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        let _request : carriers.Quote_GetQuoteEntityFromSaleIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' ) )
        {
            _request = saleId as carriers.Quote_GetQuoteEntityFromSaleIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteEntityFromSaleId( _request, _options );
    }


    private async _SaveQuoteEntity(request: carriers.Quote_SaveQuoteEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteEntity = converters.Create_QuoteEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a QuoteEntity. Versions and alternatives will not be saved by this call.
     * @param request - QuoteEntity
     * @returns The saved Quote
     */
    public async SaveQuoteEntity(request: carriers.Quote_SaveQuoteEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    /**
     * Saves a QuoteEntity. Versions and alternatives will not be saved by this call.
     * @param quoteEntity - The Quote entity to save
     * @returns The saved Quote
     */
    public async SaveQuoteEntity(quoteEntity: carriers.QuoteEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    public async SaveQuoteEntity(quoteEntity:carriers.QuoteEntity|carriers.Quote_SaveQuoteEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        let _request : carriers.Quote_SaveQuoteEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteEntity)!='undefined' ) )
        {
            _request = quoteEntity as carriers.Quote_SaveQuoteEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteEntity: quoteEntity as carriers.QuoteEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveQuoteEntity( _request, _options );
    }


    private async _CreateAndSaveQuoteFromSale(request: carriers.Quote_CreateAndSaveQuoteFromSaleRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndSaveQuoteFromSale", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteEntity = converters.Create_QuoteEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a copy the active version with connected alternatives and quotelines from another sale.
     * @param request - CopyFromSaleId, CopyToSaleId
     * @returns The created Quote
     */
    public async CreateAndSaveQuoteFromSale(request: carriers.Quote_CreateAndSaveQuoteFromSaleRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    /**
     * Creates a copy the active version with connected alternatives and quotelines from another sale.
     * @param copyFromSaleId - Id of the sale to copy the active quote from.
     * @param copyToSaleId - Id of the sale to copy the active quote to.
     * @returns The created Quote
     */
    public async CreateAndSaveQuoteFromSale(copyFromSaleId: number, copyToSaleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity >;

    public async CreateAndSaveQuoteFromSale(copyFromSaleId:number|carriers.Quote_CreateAndSaveQuoteFromSaleRequest, copyToSaleId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteEntity > {
        let _request : carriers.Quote_CreateAndSaveQuoteFromSaleRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = copyFromSaleId;
        if( typeof( first ) === "object" && first && ( typeof(first.CopyFromSaleId)!='undefined' || typeof(first.CopyToSaleId)!='undefined' ) )
        {
            _request = copyFromSaleId as carriers.Quote_CreateAndSaveQuoteFromSaleRequest;
            _options = copyToSaleId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       CopyFromSaleId: copyFromSaleId as number,
                       CopyToSaleId: copyToSaleId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateAndSaveQuoteFromSale( _request, _options );
    }


    private async _PlaceOrder(request: carriers.Quote_PlaceOrderRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginUrlResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PlaceOrder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginUrlResponse = converters.Create_PluginUrlResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Place an order in the ERP system.
     * @param request - QuoteAlternativeId, MarkSaleAsSold, PoNumber, OrderComment, Culture
     * @returns Status for the placed order: OkWithInfo / Warn / Error with message or URL to open.
     */
    public async PlaceOrder(request: carriers.Quote_PlaceOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;

    /**
     * Place an order in the ERP system.
     * @param quoteAlternativeId - Id of the alternative to place the order on.
     * @param markSaleAsSold - Should the state of the owning Sale be set to sold
     * @param poNumber - Purchase order number, saved to Quote record
     * @param orderComment - Order comment, saved to Quote record
     * @param culture - Desired culture for email body and other culture-sensitive templates/content
     * @returns Status for the placed order: OkWithInfo / Warn / Error with message or URL to open.
     */
    public async PlaceOrder(quoteAlternativeId: number, markSaleAsSold: boolean, poNumber: string, orderComment: string, culture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;

    public async PlaceOrder(quoteAlternativeId:number|carriers.Quote_PlaceOrderRequest, markSaleAsSold?:boolean|base.WebApiRequestOptions, poNumber?:string, orderComment?:string, culture?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse > {
        let _request : carriers.Quote_PlaceOrderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteAlternativeId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteAlternativeId)!='undefined' || typeof(first.MarkSaleAsSold)!='undefined' || typeof(first.PoNumber)!='undefined' || typeof(first.OrderComment)!='undefined' || typeof(first.Culture)!='undefined' ) )
        {
            _request = quoteAlternativeId as carriers.Quote_PlaceOrderRequest;
            _options = markSaleAsSold as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteAlternativeId: quoteAlternativeId as number,
                       MarkSaleAsSold: markSaleAsSold as boolean,
                       PoNumber: poNumber as string,
                       OrderComment: orderComment as string,
                       Culture: culture as string,
                       };   
            _options = webapi_options;
        }
        return this._PlaceOrder( _request, _options );
    }


    private async _GetOrderState(request: carriers.Quote_GetOrderStateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginUrlResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOrderState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginUrlResponse = converters.Create_PluginUrlResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * If there is a problem with a quoteline, the error description shall be placed in the status and reason fields of the quoteline, if there is a problem with the alternative, the error description shall be placed in the status and reason fields of the alternative. A summary of all the problems (if any) should be placed in the response object. Requires that the Create-Order capability is true.
     * @param request - QuoteVersionId
     * @returns The order state. If a new quoteversion is created, the QuoteVersionId will be found in Changes.AddedRecords.
     */
    public async GetOrderState(request: carriers.Quote_GetOrderStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;

    /**
     * If there is a problem with a quoteline, the error description shall be placed in the status and reason fields of the quoteline, if there is a problem with the alternative, the error description shall be placed in the status and reason fields of the alternative. A summary of all the problems (if any) should be placed in the response object. Requires that the Create-Order capability is true.
     * @param quoteVersionId - the QuoteVersionId of the ordered version.
     * @returns The order state. If a new quoteversion is created, the QuoteVersionId will be found in Changes.AddedRecords.
     */
    public async GetOrderState(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;

    public async GetOrderState(quoteVersionId:number|carriers.Quote_GetOrderStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse > {
        let _request : carriers.Quote_GetOrderStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_GetOrderStateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetOrderState( _request, _options );
    }


    private async _DeleteQuote(request: carriers.Quote_DeleteQuoteRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteQuote", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a Quote
     * @param request - QuoteId
     * @returns 
     */
    public async DeleteQuote(request: carriers.Quote_DeleteQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a Quote
     * @param quoteId - QuoteId of the Quote to delete.
     * @returns 
     */
    public async DeleteQuote(quoteId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteQuote(quoteId:number|carriers.Quote_DeleteQuoteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_DeleteQuoteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteId)!='undefined' ) )
        {
            _request = quoteId as carriers.Quote_DeleteQuoteRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteId: quoteId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteQuote( _request, _options );
    }


    private async _CreateQuoteLine(request: carriers.Quote_CreateQuoteLineRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLine >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateQuoteLine", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLine = converters.Create_QuoteLine_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a quoteline based on a product key.
     * @param request - QuoteAlternativeId, ERPProductKey
     * @returns The updated quote line.
     */
    public async CreateQuoteLine(request: carriers.Quote_CreateQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    /**
     * Create a quoteline based on a product key.
     * @param quoteAlternativeId - Primary key of the alternative
     * @param eRPProductKey - Primary key of the product in the ProductProvider
     * @returns The updated quote line.
     */
    public async CreateQuoteLine(quoteAlternativeId: number, eRPProductKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    public async CreateQuoteLine(quoteAlternativeId:number|carriers.Quote_CreateQuoteLineRequest, eRPProductKey?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        let _request : carriers.Quote_CreateQuoteLineRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteAlternativeId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteAlternativeId)!='undefined' || typeof(first.ERPProductKey)!='undefined' ) )
        {
            _request = quoteAlternativeId as carriers.Quote_CreateQuoteLineRequest;
            _options = eRPProductKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteAlternativeId: quoteAlternativeId as number,
                       ERPProductKey: eRPProductKey as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateQuoteLine( _request, _options );
    }


    private async _CreateQuoteLineFromProduct(request: carriers.Quote_CreateQuoteLineFromProductRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLine >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateQuoteLineFromProduct", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLine = converters.Create_QuoteLine_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a quoteline based on a product.
     * @param request - QuoteAlternativeId, Product
     * @returns The updated quote line.
     */
    public async CreateQuoteLineFromProduct(request: carriers.Quote_CreateQuoteLineFromProductRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    /**
     * Create a quoteline based on a product.
     * @param quoteAlternativeId - Primary key of the alternative
     * @param product - Product carrier
     * @returns The updated quote line.
     */
    public async CreateQuoteLineFromProduct(quoteAlternativeId: number, product: carriers.Product, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    public async CreateQuoteLineFromProduct(quoteAlternativeId:number|carriers.Quote_CreateQuoteLineFromProductRequest, product?:carriers.Product|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        let _request : carriers.Quote_CreateQuoteLineFromProductRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteAlternativeId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteAlternativeId)!='undefined' || typeof(first.Product)!='undefined' ) )
        {
            _request = quoteAlternativeId as carriers.Quote_CreateQuoteLineFromProductRequest;
            _options = product as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteAlternativeId: quoteAlternativeId as number,
                       Product: product as carriers.Product,
                       };   
            _options = webapi_options;
        }
        return this._CreateQuoteLineFromProduct( _request, _options );
    }


    private async _SaveQuoteLine(request: carriers.Quote_SaveQuoteLineRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLine >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLine", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLine = converters.Create_QuoteLine_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the QuoteLine in the SuperOffice database
     * @param request - QuoteLine
     * @returns The updated quote line (If the quoteline was new, it returns with id's set.
     */
    public async SaveQuoteLine(request: carriers.Quote_SaveQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    /**
     * Saves the QuoteLine in the SuperOffice database
     * @param quoteLine - The QuoteLine to save.
     * @returns The updated quote line (If the quoteline was new, it returns with id's set.
     */
    public async SaveQuoteLine(quoteLine: carriers.QuoteLine, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    public async SaveQuoteLine(quoteLine:carriers.QuoteLine|carriers.Quote_SaveQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        let _request : carriers.Quote_SaveQuoteLineRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLine;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLine)!='undefined' ) )
        {
            _request = quoteLine as carriers.Quote_SaveQuoteLineRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLine: quoteLine as carriers.QuoteLine,
                       };   
            _options = webapi_options;
        }
        return this._SaveQuoteLine( _request, _options );
    }


    private async _SaveQuoteLines(request: carriers.Quote_SaveQuoteLinesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLine[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLines", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLine[] = converters.Create_QuoteLineArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the QuoteLines in the SuperOffice database
     * @param request - QuoteLines
     * @returns The updated quote lines (If the quoteline was new, it returns with id's set.
     */
    public async SaveQuoteLines(request: carriers.Quote_SaveQuoteLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] >;

    /**
     * Saves the QuoteLines in the SuperOffice database
     * @param quoteLines - The QuoteLines to save.
     * @returns The updated quote lines (If the quoteline was new, it returns with id's set.
     */
    public async SaveQuoteLines(quoteLines: carriers.QuoteLine[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] >;

    public async SaveQuoteLines(quoteLines:carriers.QuoteLine[]|carriers.Quote_SaveQuoteLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] > {
        let _request : carriers.Quote_SaveQuoteLinesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLines;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLines)!='undefined' ) )
        {
            _request = quoteLines as carriers.Quote_SaveQuoteLinesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLines: quoteLines as carriers.QuoteLine[],
                       };   
            _options = webapi_options;
        }
        return this._SaveQuoteLines( _request, _options );
    }


    private async _GetQuoteLine(request: carriers.Quote_GetQuoteLineRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLine >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLine", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLine = converters.Create_QuoteLine_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get QuoteLine from database
     * @param request - QuoteLineId
     * @returns The updated quote line (If the quoteline was new, it returns with id's set.
     */
    public async GetQuoteLine(request: carriers.Quote_GetQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    /**
     * Get QuoteLine from database
     * @param quoteLineId - Primary key of the quoteline to get.
     * @returns The updated quote line (If the quoteline was new, it returns with id's set.
     */
    public async GetQuoteLine(quoteLineId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    public async GetQuoteLine(quoteLineId:number|carriers.Quote_GetQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        let _request : carriers.Quote_GetQuoteLineRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineId)!='undefined' ) )
        {
            _request = quoteLineId as carriers.Quote_GetQuoteLineRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineId: quoteLineId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteLine( _request, _options );
    }


    private async _GetQuoteLines(request: carriers.Quote_GetQuoteLinesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLine[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLines", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLine[] = converters.Create_QuoteLineArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all QuoteLines from an alternative
     * @param request - QuoteAlternativeId
     * @returns QuoteLine array
     */
    public async GetQuoteLines(request: carriers.Quote_GetQuoteLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] >;

    /**
     * Get all QuoteLines from an alternative
     * @param quoteAlternativeId - Id of the alternative to return the quotelines for
     * @returns QuoteLine array
     */
    public async GetQuoteLines(quoteAlternativeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] >;

    public async GetQuoteLines(quoteAlternativeId:number|carriers.Quote_GetQuoteLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine[] > {
        let _request : carriers.Quote_GetQuoteLinesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteAlternativeId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteAlternativeId)!='undefined' ) )
        {
            _request = quoteAlternativeId as carriers.Quote_GetQuoteLinesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteAlternativeId: quoteAlternativeId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteLines( _request, _options );
    }


    private async _DeleteQuoteLine(request: carriers.Quote_DeleteQuoteLineRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteQuoteLine", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes the QuoteLine in the SuperOffice database
     * @param request - QuoteLineId
     * @returns Nothing
     */
    public async DeleteQuoteLine(request: carriers.Quote_DeleteQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes the QuoteLine in the SuperOffice database
     * @param quoteLineId - Primary key of the quoteline to delete
     * @returns Nothing
     */
    public async DeleteQuoteLine(quoteLineId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteQuoteLine(quoteLineId:number|carriers.Quote_DeleteQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_DeleteQuoteLineRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineId)!='undefined' ) )
        {
            _request = quoteLineId as carriers.Quote_DeleteQuoteLineRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineId: quoteLineId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteQuoteLine( _request, _options );
    }


    private async _DeleteQuoteLines(request: carriers.Quote_DeleteQuoteLinesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteQuoteLines", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete the QuoteLines in the SuperOffice database
     * @param request - QuoteLineIds
     * @returns Nothing
     */
    public async DeleteQuoteLines(request: carriers.Quote_DeleteQuoteLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete the QuoteLines in the SuperOffice database
     * @param quoteLineIds - Primary keys of the quotelines to delete
     * @returns Nothing
     */
    public async DeleteQuoteLines(quoteLineIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteQuoteLines(quoteLineIds:number[]|carriers.Quote_DeleteQuoteLinesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_DeleteQuoteLinesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineIds;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineIds)!='undefined' ) )
        {
            _request = quoteLineIds as carriers.Quote_DeleteQuoteLinesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineIds: quoteLineIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeleteQuoteLines( _request, _options );
    }


    private async _RecalculateQuoteLine(request: carriers.Quote_RecalculateQuoteLineRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLine >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RecalculateQuoteLine", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLine = converters.Create_QuoteLine_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * When the user changes one or more values in a quoteline, the connector gets to change the QuoteLine, for instance calculate VAT. Shall be called when the user changes any of the following fields: Quantity, DiscountAmount, DiscountPercent, ListPrice (if allowed). Will calculate the TotalPrice and the VAT (if possible) for the line.
     * @param request - QuoteLine, ChangedFields
     * @returns The updated quote line.
     */
    public async RecalculateQuoteLine(request: carriers.Quote_RecalculateQuoteLineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    /**
     * When the user changes one or more values in a quoteline, the connector gets to change the QuoteLine, for instance calculate VAT. Shall be called when the user changes any of the following fields: Quantity, DiscountAmount, DiscountPercent, ListPrice (if allowed). Will calculate the TotalPrice and the VAT (if possible) for the line.
     * @param quoteLine - The QuoteLine to recalculate
     * @param changedFields - The id of the changed fields in the form 'TableName.FieldName'
     * @returns The updated quote line.
     */
    public async RecalculateQuoteLine(quoteLine: carriers.QuoteLine, changedFields: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine >;

    public async RecalculateQuoteLine(quoteLine:carriers.QuoteLine|carriers.Quote_RecalculateQuoteLineRequest, changedFields?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLine > {
        let _request : carriers.Quote_RecalculateQuoteLineRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLine;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLine)!='undefined' || typeof(first.ChangedFields)!='undefined' ) )
        {
            _request = quoteLine as carriers.Quote_RecalculateQuoteLineRequest;
            _options = changedFields as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLine: quoteLine as carriers.QuoteLine,
                       ChangedFields: changedFields as string[],
                       };   
            _options = webapi_options;
        }
        return this._RecalculateQuoteLine( _request, _options );
    }


    private async _GetQuoteLineImage(request: carriers.Quote_GetQuoteLineImageRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLineImage", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets an image connected to a quoteline, either from the ERPProvider or from the SuperOffice database
     * @param request - QuoteLineId, Rank
     * @returns The image. Returns null if no image available.
     */
    public async GetQuoteLineImage(request: carriers.Quote_GetQuoteLineImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Gets an image connected to a quoteline, either from the ERPProvider or from the SuperOffice database
     * @param quoteLineId - Primary key of the quoteline
     * @param rank - The rank of the image.
     * @returns The image. Returns null if no image available.
     */
    public async GetQuoteLineImage(quoteLineId: number, rank: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetQuoteLineImage(quoteLineId:number|carriers.Quote_GetQuoteLineImageRequest, rank?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Quote_GetQuoteLineImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineId)!='undefined' || typeof(first.Rank)!='undefined' ) )
        {
            _request = quoteLineId as carriers.Quote_GetQuoteLineImageRequest;
            _options = rank as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineId: quoteLineId as number,
                       Rank: rank as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteLineImage( _request, _options );
    }


    private async _SaveQuoteLineImage(request: carriers.Quote_SaveQuoteLineImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLineImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the image connected to a quoteline in the SuperOffice database
     * @param request - QuoteLineId, Image, Rank
     * @returns Nothing
     */
    public async SaveQuoteLineImage(request: carriers.Quote_SaveQuoteLineImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Saves the image connected to a quoteline in the SuperOffice database
     * @param quoteLineId - Primary key of the quoteline
     * @param image - The image.
     * @param rank - The rank of the image.
     * @returns Nothing
     */
    public async SaveQuoteLineImage(quoteLineId: number, image: ArrayBuffer|string, rank: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveQuoteLineImage(quoteLineId:number|carriers.Quote_SaveQuoteLineImageRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, rank?:number, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_SaveQuoteLineImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineId)!='undefined' || typeof(first.Image)!='undefined' || typeof(first.Rank)!='undefined' ) )
        {
            _request = quoteLineId as carriers.Quote_SaveQuoteLineImageRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineId: quoteLineId as number,
                       Image: image as ArrayBuffer|string,
                       Rank: rank as number,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SaveQuoteLineImage( _request, _options );
    }


    private async _GetExtraInfo(request: carriers.Quote_GetExtraInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ProductExtraDataField[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProductExtraDataField[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetExtraInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProductExtraDataField[] = converters.Create_ProductExtraDataFieldArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Converts an xml string into an object representation.
     * @param request - QuoteLineExtraData
     * @returns An object representation on the xml
     */
    public async GetExtraInfo(request: carriers.Quote_GetExtraInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductExtraDataField[] >;

    /**
     * Converts an xml string into an object representation.
     * @param quoteLineExtraData - The extra data as xml.
     * @returns An object representation on the xml
     */
    public async GetExtraInfo(quoteLineExtraData: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductExtraDataField[] >;

    public async GetExtraInfo(quoteLineExtraData:string|carriers.Quote_GetExtraInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductExtraDataField[] > {
        let _request : carriers.Quote_GetExtraInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineExtraData;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineExtraData)!='undefined' ) )
        {
            _request = quoteLineExtraData as carriers.Quote_GetExtraInfoRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineExtraData: quoteLineExtraData as string,
                       };   
            _options = webapi_options;
        }
        return this._GetExtraInfo( _request, _options );
    }


    private async _GetQuoteLineConfiguration(request: carriers.Quote_GetQuoteLineConfigurationRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLineConfiguration >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLineConfiguration", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLineConfiguration = converters.Create_QuoteLineConfiguration_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the configuration field with the given id
     * @param request - QuoteLineConfigurationId
     * @returns QuoteLineConfiguration
     */
    public async GetQuoteLineConfiguration(request: carriers.Quote_GetQuoteLineConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;

    /**
     * Returns the configuration field with the given id
     * @param quoteLineConfigurationId - Id of the QuoteLineConfiguration to get.
     * @returns QuoteLineConfiguration
     */
    public async GetQuoteLineConfiguration(quoteLineConfigurationId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;

    public async GetQuoteLineConfiguration(quoteLineConfigurationId:number|carriers.Quote_GetQuoteLineConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration > {
        let _request : carriers.Quote_GetQuoteLineConfigurationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineConfigurationId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineConfigurationId)!='undefined' ) )
        {
            _request = quoteLineConfigurationId as carriers.Quote_GetQuoteLineConfigurationRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineConfigurationId: quoteLineConfigurationId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteLineConfiguration( _request, _options );
    }


    private async _GetQuoteLineConfigurationFromFieldName(request: carriers.Quote_GetQuoteLineConfigurationFromFieldNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLineConfiguration >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLineConfigurationFromFieldName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLineConfiguration = converters.Create_QuoteLineConfiguration_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the configuration field with the given field name
     * @param request - FieldName
     * @returns QuoteLineConfiguration
     */
    public async GetQuoteLineConfigurationFromFieldName(request: carriers.Quote_GetQuoteLineConfigurationFromFieldNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;

    /**
     * Returns the configuration field with the given field name
     * @param fieldName - Field name of the QuoteLineConfiguration to get.
     * @returns QuoteLineConfiguration
     */
    public async GetQuoteLineConfigurationFromFieldName(fieldName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;

    public async GetQuoteLineConfigurationFromFieldName(fieldName:string|carriers.Quote_GetQuoteLineConfigurationFromFieldNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration > {
        let _request : carriers.Quote_GetQuoteLineConfigurationFromFieldNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = fieldName;
        if( typeof( first ) === "object" && first && ( typeof(first.FieldName)!='undefined' ) )
        {
            _request = fieldName as carriers.Quote_GetQuoteLineConfigurationFromFieldNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FieldName: fieldName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteLineConfigurationFromFieldName( _request, _options );
    }


    private async _GetAllQuoteLineConfigurations( options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLineConfiguration[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllQuoteLineConfigurations", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLineConfiguration[] = converters.Create_QuoteLineConfigurationArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all the configuration fields
     * @returns Array of QuoteLineConfigurations
     */
    public async GetAllQuoteLineConfigurations(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] >
    {
        return this._GetAllQuoteLineConfigurations(webapi_options);
    }


    private async _GetInUseQuoteLineConfigurations( options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLineConfiguration[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetInUseQuoteLineConfigurations", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLineConfiguration[] = converters.Create_QuoteLineConfigurationArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns the configuration fields that should be visible in the GUI.
     * @returns Array of QuoteLineConfigurations
     */
    public async GetInUseQuoteLineConfigurations(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] >
    {
        return this._GetInUseQuoteLineConfigurations(webapi_options);
    }


    private async _SaveQuoteLineConfiguration(request: carriers.Quote_SaveQuoteLineConfigurationRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLineConfiguration >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLineConfiguration", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLineConfiguration = converters.Create_QuoteLineConfiguration_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a QuoteLineConfiguration object. It is not possible to add a new configuration.
     * @param request - QuoteLineConfiguration
     * @returns The saved QuoteLineConfiguration.
     */
    public async SaveQuoteLineConfiguration(request: carriers.Quote_SaveQuoteLineConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;

    /**
     * Save a QuoteLineConfiguration object. It is not possible to add a new configuration.
     * @param quoteLineConfiguration - The QuoteLineConfiguration to save.
     * @returns The saved QuoteLineConfiguration.
     */
    public async SaveQuoteLineConfiguration(quoteLineConfiguration: carriers.QuoteLineConfiguration, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration >;

    public async SaveQuoteLineConfiguration(quoteLineConfiguration:carriers.QuoteLineConfiguration|carriers.Quote_SaveQuoteLineConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration > {
        let _request : carriers.Quote_SaveQuoteLineConfigurationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineConfiguration;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineConfiguration)!='undefined' ) )
        {
            _request = quoteLineConfiguration as carriers.Quote_SaveQuoteLineConfigurationRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineConfiguration: quoteLineConfiguration as carriers.QuoteLineConfiguration,
                       };   
            _options = webapi_options;
        }
        return this._SaveQuoteLineConfiguration( _request, _options );
    }


    private async _SaveQuoteLineConfigurations(request: carriers.Quote_SaveQuoteLineConfigurationsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteLineConfiguration[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLineConfigurations", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteLineConfiguration[] = converters.Create_QuoteLineConfigurationArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a collection of QuoteLineConfigurations. It is not possible to add a new configurations.
     * @param request - QuoteLineConfigurations
     * @returns The saved QuoteLineConfigurations.
     */
    public async SaveQuoteLineConfigurations(request: carriers.Quote_SaveQuoteLineConfigurationsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] >;

    /**
     * Save a collection of QuoteLineConfigurations. It is not possible to add a new configurations.
     * @param quoteLineConfigurations - The QuoteLineConfigurations to save.
     * @returns The saved QuoteLineConfigurations.
     */
    public async SaveQuoteLineConfigurations(quoteLineConfigurations: carriers.QuoteLineConfiguration[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] >;

    public async SaveQuoteLineConfigurations(quoteLineConfigurations:carriers.QuoteLineConfiguration[]|carriers.Quote_SaveQuoteLineConfigurationsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteLineConfiguration[] > {
        let _request : carriers.Quote_SaveQuoteLineConfigurationsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteLineConfigurations;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteLineConfigurations)!='undefined' ) )
        {
            _request = quoteLineConfigurations as carriers.Quote_SaveQuoteLineConfigurationsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteLineConfigurations: quoteLineConfigurations as carriers.QuoteLineConfiguration[],
                       };   
            _options = webapi_options;
        }
        return this._SaveQuoteLineConfigurations( _request, _options );
    }


    private async _GetQuoteList(request: carriers.Quote_GetQuoteListRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteListItem[] = converters.Create_QuoteListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a named list from the connector Return array of QuoteListItems. Return NULL if the given list is not supported.
     * @param request - QuoteListType
     * @returns The list items
     */
    public async GetQuoteList(request: carriers.Quote_GetQuoteListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteListItem[] >;

    /**
     * Gets a named list from the connector Return array of QuoteListItems. Return NULL if the given list is not supported.
     * @param quoteListType - The name of the requested list, for instance: ProductCategory, ProductFamily, ProductType, PaymentTerms, PaymentType, DeliveryTerms, DeliveryType.
     * @returns The list items
     */
    public async GetQuoteList(quoteListType: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteListItem[] >;

    public async GetQuoteList(quoteListType:string|carriers.Quote_GetQuoteListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteListItem[] > {
        let _request : carriers.Quote_GetQuoteListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteListType;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteListType)!='undefined' ) )
        {
            _request = quoteListType as carriers.Quote_GetQuoteListRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteListType: quoteListType as string,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteList( _request, _options );
    }


    private async _ValidateQuoteVersion(request: carriers.Quote_ValidateQuoteVersionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersionValidated >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateQuoteVersion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersionValidated = converters.Create_QuoteVersionValidated_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * When the user changes one or more values in a quoteline or a quoteAlternative, the connector gets to change the QuoteLines and the alternative, for instance calculate VAT. ValidateQuoteVersion shall be called when the user presses the validate button, presses the send button or closes the quote dialog. RecalculateQuoteAlternative should typically validate all alternatives, set values in extrafields, and set the state in the version.
     * @param request - QuoteVersionId, Action
     * @returns The updated quote version.
     */
    public async ValidateQuoteVersion(request: carriers.Quote_ValidateQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated >;

    /**
     * When the user changes one or more values in a quoteline or a quoteAlternative, the connector gets to change the QuoteLines and the alternative, for instance calculate VAT. ValidateQuoteVersion shall be called when the user presses the validate button, presses the send button or closes the quote dialog. RecalculateQuoteAlternative should typically validate all alternatives, set values in extrafields, and set the state in the version.
     * @param quoteVersionId - The version to be validated
     * @param action - The action, if any, related to the validate call, like PlaceOrder or SendQuote
     * @returns The updated quote version.
     */
    public async ValidateQuoteVersion(quoteVersionId: number, action: enums.QuoteVersionButtonAction, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated >;

    public async ValidateQuoteVersion(quoteVersionId:number|carriers.Quote_ValidateQuoteVersionRequest, action?:enums.QuoteVersionButtonAction|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated > {
        let _request : carriers.Quote_ValidateQuoteVersionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.Action)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_ValidateQuoteVersionRequest;
            _options = action as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       Action: action as enums.QuoteVersionButtonAction,
                       };   
            _options = webapi_options;
        }
        return this._ValidateQuoteVersion( _request, _options );
    }


    private async _CreateAndSaveQuoteVersion(request: carriers.Quote_CreateAndSaveQuoteVersionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersion >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndSaveQuoteVersion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersion = converters.Create_QuoteVersion_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Created a new QuoteVersion based on another QuoteVersion on the same Quote.
     * @param request - QuoteVersionId
     * @returns The Quote version
     */
    public async CreateAndSaveQuoteVersion(request: carriers.Quote_CreateAndSaveQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;

    /**
     * Created a new QuoteVersion based on another QuoteVersion on the same Quote.
     * @param quoteVersionId - QuoteVersionId of the version to copy the contents from.
     * @returns The Quote version
     */
    public async CreateAndSaveQuoteVersion(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;

    public async CreateAndSaveQuoteVersion(quoteVersionId:number|carriers.Quote_CreateAndSaveQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion > {
        let _request : carriers.Quote_CreateAndSaveQuoteVersionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_CreateAndSaveQuoteVersionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateAndSaveQuoteVersion( _request, _options );
    }


    private async _GetQuoteVersion(request: carriers.Quote_GetQuoteVersionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersion >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersion = converters.Create_QuoteVersion_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a QuoteVersion
     * @param request - QuoteVersionId
     * @returns Array of Quote versions
     */
    public async GetQuoteVersion(request: carriers.Quote_GetQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;

    /**
     * Get a QuoteVersion
     * @param quoteVersionId - QuoteVersionId to get information from
     * @returns Array of Quote versions
     */
    public async GetQuoteVersion(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;

    public async GetQuoteVersion(quoteVersionId:number|carriers.Quote_GetQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion > {
        let _request : carriers.Quote_GetQuoteVersionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_GetQuoteVersionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteVersion( _request, _options );
    }


    private async _GetQuoteVersions(request: carriers.Quote_GetQuoteVersionsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersion[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersions", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersion[] = converters.Create_QuoteVersionArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all quote versions for a sale
     * @param request - QuoteId
     * @returns Array of Quote versions
     */
    public async GetQuoteVersions(request: carriers.Quote_GetQuoteVersionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion[] >;

    /**
     * Get all quote versions for a sale
     * @param quoteId - QuoteId of the quote to get versions from
     * @returns Array of Quote versions
     */
    public async GetQuoteVersions(quoteId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion[] >;

    public async GetQuoteVersions(quoteId:number|carriers.Quote_GetQuoteVersionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion[] > {
        let _request : carriers.Quote_GetQuoteVersionsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteId)!='undefined' ) )
        {
            _request = quoteId as carriers.Quote_GetQuoteVersionsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteId: quoteId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteVersions( _request, _options );
    }


    private async _SendQuoteVersion(request: carriers.Quote_SendQuoteVersionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginUrlResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendQuoteVersion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginUrlResponse = converters.Create_PluginUrlResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Send the quote to the user&apos;s customer. More parameters to be added later...
     * @param request - QuoteVersionId, ExpiryDate, FollowupDate, FollowupText, Culture
     * @returns Response of the operation
     */
    public async SendQuoteVersion(request: carriers.Quote_SendQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;

    /**
     * Send the quote to the user&apos;s customer. More parameters to be added later...
     * @param quoteVersionId - QuoteVersionId of the quoteversion to send
     * @param expiryDate - Date the quote expires
     * @param followupDate - Date for the followup task, to remind the sales rep about the quote
     * @param followupText - The body text for the follwup appointment, resolved to the correct culture (no resources please)
     * @param culture - Desired culture for email body and other culture-sensitive templates/content
     * @returns Response of the operation
     */
    public async SendQuoteVersion(quoteVersionId: number, expiryDate: Date, followupDate: Date, followupText: string, culture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse >;

    public async SendQuoteVersion(quoteVersionId:number|carriers.Quote_SendQuoteVersionRequest, expiryDate?:Date|base.WebApiRequestOptions, followupDate?:Date, followupText?:string, culture?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginUrlResponse > {
        let _request : carriers.Quote_SendQuoteVersionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.ExpiryDate)!='undefined' || typeof(first.FollowupDate)!='undefined' || typeof(first.FollowupText)!='undefined' || typeof(first.Culture)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_SendQuoteVersionRequest;
            _options = expiryDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       ExpiryDate: expiryDate as Date,
                       FollowupDate: followupDate as Date,
                       FollowupText: followupText as string,
                       Culture: culture as string,
                       };   
            _options = webapi_options;
        }
        return this._SendQuoteVersion( _request, _options );
    }


    private async _SaveQuoteVersion(request: carriers.Quote_SaveQuoteVersionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersion >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteVersion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersion = converters.Create_QuoteVersion_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a quote version
     * @param request - QuoteVersion
     * @returns The saved quote version
     */
    public async SaveQuoteVersion(request: carriers.Quote_SaveQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;

    /**
     * Saves a quote version
     * @param quoteVersion - The quote version to save
     * @returns The saved quote version
     */
    public async SaveQuoteVersion(quoteVersion: carriers.QuoteVersion, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion >;

    public async SaveQuoteVersion(quoteVersion:carriers.QuoteVersion|carriers.Quote_SaveQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersion > {
        let _request : carriers.Quote_SaveQuoteVersionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersion;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersion)!='undefined' ) )
        {
            _request = quoteVersion as carriers.Quote_SaveQuoteVersionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersion: quoteVersion as carriers.QuoteVersion,
                       };   
            _options = webapi_options;
        }
        return this._SaveQuoteVersion( _request, _options );
    }


    private async _ApproveQuoteVersion(request: carriers.Quote_ApproveQuoteVersionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ApproveRejectResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ApproveQuoteVersion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ApproveRejectResponse = converters.Create_ApproveRejectResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Approves a quote version
     * @param request - QuoteVersionId, ApprovedByText, ApprovedByAssociateId, ApprovalText
     * @returns Response of the the operation
     */
    public async ApproveQuoteVersion(request: carriers.Quote_ApproveQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse >;

    /**
     * Approves a quote version
     * @param quoteVersionId - QuoteVersionId to approve.
     * @param approvedByText - 'Approved by' prefix to ApprovalText used when creating appointment task to log approval. Must be passed since service does not know which language to use for 'Approved By' string.
     * @param approvedByAssociateId - AssociateId of the associate who approved the quote version.
     * @param approvalText - Approval text.
     * @returns Response of the the operation
     */
    public async ApproveQuoteVersion(quoteVersionId: number, approvedByText: string, approvedByAssociateId: number, approvalText: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse >;

    public async ApproveQuoteVersion(quoteVersionId:number|carriers.Quote_ApproveQuoteVersionRequest, approvedByText?:string|base.WebApiRequestOptions, approvedByAssociateId?:number, approvalText?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse > {
        let _request : carriers.Quote_ApproveQuoteVersionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.ApprovedByText)!='undefined' || typeof(first.ApprovedByAssociateId)!='undefined' || typeof(first.ApprovalText)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_ApproveQuoteVersionRequest;
            _options = approvedByText as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       ApprovedByText: approvedByText as string,
                       ApprovedByAssociateId: approvedByAssociateId as number,
                       ApprovalText: approvalText as string,
                       };   
            _options = webapi_options;
        }
        return this._ApproveQuoteVersion( _request, _options );
    }


    private async _RejectQuoteVersion(request: carriers.Quote_RejectQuoteVersionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ApproveRejectResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RejectQuoteVersion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ApproveRejectResponse = converters.Create_ApproveRejectResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Rejects a quote version
     * @param request - QuoteVersionId, RejectedByText, RejectedByAssociateId, RejectionText
     * @returns Response of the the operation
     */
    public async RejectQuoteVersion(request: carriers.Quote_RejectQuoteVersionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse >;

    /**
     * Rejects a quote version
     * @param quoteVersionId - QuoteVersionId to approve.
     * @param rejectedByText - 'Rejected by' prefix to RejectionText used when creating appointment task to log rejection. Must be passed since service does not know which language to use for 'Rejected By' string.
     * @param rejectedByAssociateId - AssociateId of the associate who rejected the quote version.
     * @param rejectionText - Rejection text.
     * @returns Response of the the operation
     */
    public async RejectQuoteVersion(quoteVersionId: number, rejectedByText: string, rejectedByAssociateId: number, rejectionText: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse >;

    public async RejectQuoteVersion(quoteVersionId:number|carriers.Quote_RejectQuoteVersionRequest, rejectedByText?:string|base.WebApiRequestOptions, rejectedByAssociateId?:number, rejectionText?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ApproveRejectResponse > {
        let _request : carriers.Quote_RejectQuoteVersionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.RejectedByText)!='undefined' || typeof(first.RejectedByAssociateId)!='undefined' || typeof(first.RejectionText)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_RejectQuoteVersionRequest;
            _options = rejectedByText as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       RejectedByText: rejectedByText as string,
                       RejectedByAssociateId: rejectedByAssociateId as number,
                       RejectionText: rejectionText as string,
                       };   
            _options = webapi_options;
        }
        return this._RejectQuoteVersion( _request, _options );
    }


    private async _GenerateQuoteDocuments(request: carriers.Quote_GenerateQuoteDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuotePublishDocuments > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuotePublishDocuments >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateQuoteDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuotePublishDocuments = converters.Create_QuotePublishDocuments_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Generate all the documents required to send the Quote as an email to the prospect - or an Order Confirmation; it just depends on the template id&apos;s for the lines doc and mail body. Quote version status is not changed by this method.
     * @param request - QuoteVersionId, EmailBodyTemplateId, AttachMainDocument, QuotedProductsTemplateId, IncludeAttachments, RawMailSubject
     * @returns Carrier specifying the document id's of all the documents, as well as other results
     */
    public async GenerateQuoteDocuments(request: carriers.Quote_GenerateQuoteDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuotePublishDocuments >;

    /**
     * Generate all the documents required to send the Quote as an email to the prospect - or an Order Confirmation; it just depends on the template id&apos;s for the lines doc and mail body. Quote version status is not changed by this method.
     * @param quoteVersionId - VersionId of the quote to be sent; the status of the version will not be changed by calling this method
     * @param emailBodyTemplateId - Id of the template for the email body, must be nonzero and refer to either a Quote mail body or Order Confirmation mail body, with html content
     * @param attachMainDocument - Should the main quote document be attached to the email; generally false for Order Confirmations
     * @param quotedProductsTemplateId - Id of the template for the quote- or order confirmation-lines; zero if no document should be produced
     * @param includeAttachments - If true, then the currently specified (in the database) attachments will be included
     * @param rawMailSubject - Subject line for email, in the correct language, sent in here to have any template variables substituted
     * @returns Carrier specifying the document id's of all the documents, as well as other results
     */
    public async GenerateQuoteDocuments(quoteVersionId: number, emailBodyTemplateId: number, attachMainDocument: boolean, quotedProductsTemplateId: number, includeAttachments: boolean, rawMailSubject: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuotePublishDocuments >;

    public async GenerateQuoteDocuments(quoteVersionId:number|carriers.Quote_GenerateQuoteDocumentsRequest, emailBodyTemplateId?:number|base.WebApiRequestOptions, attachMainDocument?:boolean, quotedProductsTemplateId?:number, includeAttachments?:boolean, rawMailSubject?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuotePublishDocuments > {
        let _request : carriers.Quote_GenerateQuoteDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.EmailBodyTemplateId)!='undefined' || typeof(first.AttachMainDocument)!='undefined' || typeof(first.QuotedProductsTemplateId)!='undefined' || typeof(first.IncludeAttachments)!='undefined' || typeof(first.RawMailSubject)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_GenerateQuoteDocumentsRequest;
            _options = emailBodyTemplateId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       EmailBodyTemplateId: emailBodyTemplateId as number,
                       AttachMainDocument: attachMainDocument as boolean,
                       QuotedProductsTemplateId: quotedProductsTemplateId as number,
                       IncludeAttachments: includeAttachments as boolean,
                       RawMailSubject: rawMailSubject as string,
                       };   
            _options = webapi_options;
        }
        return this._GenerateQuoteDocuments( _request, _options );
    }


    private async _GetOrderConfirmation(request: carriers.Quote_GetOrderConfirmationRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOrderConfirmation", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a base64-encoded data stream that is just the order confirmation document, for the given quote version; no permanent document is created or stored anywhere; the result is a PDF
     * @param request - QuoteVersionId, ConfirmationTemplateId
     * @returns Base64-encoded binary data, that is in fact a PDF document that should be shown to the user
     */
    public async GetOrderConfirmation(request: carriers.Quote_GetOrderConfirmationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get a base64-encoded data stream that is just the order confirmation document, for the given quote version; no permanent document is created or stored anywhere; the result is a PDF
     * @param quoteVersionId - VersionId of the quote to be sent; the status of the version will not be changed by calling this method
     * @param confirmationTemplateId - Id of the template for the order confirmation lines document
     * @returns Base64-encoded binary data, that is in fact a PDF document that should be shown to the user
     */
    public async GetOrderConfirmation(quoteVersionId: number, confirmationTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetOrderConfirmation(quoteVersionId:number|carriers.Quote_GetOrderConfirmationRequest, confirmationTemplateId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Quote_GetOrderConfirmationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.ConfirmationTemplateId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_GetOrderConfirmationRequest;
            _options = confirmationTemplateId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       ConfirmationTemplateId: confirmationTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetOrderConfirmation( _request, _options );
    }


    private async _GetQuoteVersionWorkflowState(request: carriers.Quote_GetQuoteVersionWorkflowStateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersionWorkflowState >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionWorkflowState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersionWorkflowState = converters.Create_QuoteVersionWorkflowState_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all button states for the Quote version dialog. Packages ImageState, Button states and status info into one call. Collects most important warnings/errors from across all quotelines/alternatives in this quote version.
     * @param request - QuoteVersionId, QuoteAlternativeId
     * @returns Workflow state information
     */
    public async GetQuoteVersionWorkflowState(request: carriers.Quote_GetQuoteVersionWorkflowStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState >;

    /**
     * Get all button states for the Quote version dialog. Packages ImageState, Button states and status info into one call. Collects most important warnings/errors from across all quotelines/alternatives in this quote version.
     * @param quoteVersionId - Id of the quote version to get the button states for.
     * @param quoteAlternativeId - Id of the active quote alternative id.
     * @returns Workflow state information
     */
    public async GetQuoteVersionWorkflowState(quoteVersionId: number, quoteAlternativeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState >;

    public async GetQuoteVersionWorkflowState(quoteVersionId:number|carriers.Quote_GetQuoteVersionWorkflowStateRequest, quoteAlternativeId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState > {
        let _request : carriers.Quote_GetQuoteVersionWorkflowStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.QuoteAlternativeId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_GetQuoteVersionWorkflowStateRequest;
            _options = quoteAlternativeId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       QuoteAlternativeId: quoteAlternativeId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteVersionWorkflowState( _request, _options );
    }


    private async _UpdateQuoteVersionPrices(request: carriers.Quote_UpdateQuoteVersionPricesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersionValidated >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateQuoteVersionPrices", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersionValidated = converters.Create_QuoteVersionValidated_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update price on the all the quotelines for each alternative in the current quote version
     * @param request - QuoteVersionId
     * @returns The updated quote version.
     */
    public async UpdateQuoteVersionPrices(request: carriers.Quote_UpdateQuoteVersionPricesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated >;

    /**
     * Update price on the all the quotelines for each alternative in the current quote version
     * @param quoteVersionId - The version to be update prices for
     * @returns The updated quote version.
     */
    public async UpdateQuoteVersionPrices(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated >;

    public async UpdateQuoteVersionPrices(quoteVersionId:number|carriers.Quote_UpdateQuoteVersionPricesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionValidated > {
        let _request : carriers.Quote_UpdateQuoteVersionPricesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_UpdateQuoteVersionPricesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._UpdateQuoteVersionPrices( _request, _options );
    }


    private async _SaveQuoteVersionNumber(request: carriers.Quote_SaveQuoteVersionNumberRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteVersionNumber", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save the quote version number if it is valid
     * @param request - QuoteVersionId, Number
     * @returns True if the number was valid and then saved
     */
    public async SaveQuoteVersionNumber(request: carriers.Quote_SaveQuoteVersionNumberRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Save the quote version number if it is valid
     * @param quoteVersionId - VersionId of the quote version
     * @param number - The number to save
     * @returns True if the number was valid and then saved
     */
    public async SaveQuoteVersionNumber(quoteVersionId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async SaveQuoteVersionNumber(quoteVersionId:number|carriers.Quote_SaveQuoteVersionNumberRequest, number?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Quote_SaveQuoteVersionNumberRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.Number)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_SaveQuoteVersionNumberRequest;
            _options = number as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       Number: number as string,
                       };   
            _options = webapi_options;
        }
        return this._SaveQuoteVersionNumber( _request, _options );
    }


    private async _GetQuoteVersionWorkflowImageState(request: carriers.Quote_GetQuoteVersionWorkflowImageStateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionButtonState > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersionButtonState >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionWorkflowImageState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersionButtonState = converters.Create_QuoteVersionButtonState_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get state icon and name for the Quote version dialog header.
     * @param request - QuoteVersionId
     * @returns Image and state name information
     */
    public async GetQuoteVersionWorkflowImageState(request: carriers.Quote_GetQuoteVersionWorkflowImageStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionButtonState >;

    /**
     * Get state icon and name for the Quote version dialog header.
     * @param quoteVersionId - Id of the quote version to get the version state for.
     * @returns Image and state name information
     */
    public async GetQuoteVersionWorkflowImageState(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionButtonState >;

    public async GetQuoteVersionWorkflowImageState(quoteVersionId:number|carriers.Quote_GetQuoteVersionWorkflowImageStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionButtonState > {
        let _request : carriers.Quote_GetQuoteVersionWorkflowImageStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_GetQuoteVersionWorkflowImageStateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteVersionWorkflowImageState( _request, _options );
    }


    private async _GetQuoteVersionWorkflowButtonStates(request: carriers.Quote_GetQuoteVersionWorkflowButtonStatesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersionWorkflowState >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionWorkflowButtonStates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersionWorkflowState = converters.Create_QuoteVersionWorkflowState_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all button states for the Quote version dialog.
     * @param request - QuoteVersionId, QuoteAlternativeId
     * @returns Workflow state information
     */
    public async GetQuoteVersionWorkflowButtonStates(request: carriers.Quote_GetQuoteVersionWorkflowButtonStatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState >;

    /**
     * Get all button states for the Quote version dialog.
     * @param quoteVersionId - Id of the quote version to get the button states for.
     * @param quoteAlternativeId - Id of the active quote alternative id.
     * @returns Workflow state information
     */
    public async GetQuoteVersionWorkflowButtonStates(quoteVersionId: number, quoteAlternativeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState >;

    public async GetQuoteVersionWorkflowButtonStates(quoteVersionId:number|carriers.Quote_GetQuoteVersionWorkflowButtonStatesRequest, quoteAlternativeId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionWorkflowState > {
        let _request : carriers.Quote_GetQuoteVersionWorkflowButtonStatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.QuoteAlternativeId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_GetQuoteVersionWorkflowButtonStatesRequest;
            _options = quoteAlternativeId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       QuoteAlternativeId: quoteAlternativeId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteVersionWorkflowButtonStates( _request, _options );
    }


    private async _GetQuoteVersionWorkflowStatusInfo(request: carriers.Quote_GetQuoteVersionWorkflowStatusInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionStatusInformation > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersionStatusInformation >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionWorkflowStatusInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersionStatusInformation = converters.Create_QuoteVersionStatusInformation_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get status info for the Quote version dialog header. Collects most important warnings/errors from across all quotelines/alternatives in this quote version.
     * @param request - QuoteVersionId
     * @returns Most important status text + icon information.
     */
    public async GetQuoteVersionWorkflowStatusInfo(request: carriers.Quote_GetQuoteVersionWorkflowStatusInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionStatusInformation >;

    /**
     * Get status info for the Quote version dialog header. Collects most important warnings/errors from across all quotelines/alternatives in this quote version.
     * @param quoteVersionId - Id of the quote version to get the status info for.
     * @returns Most important status text + icon information.
     */
    public async GetQuoteVersionWorkflowStatusInfo(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionStatusInformation >;

    public async GetQuoteVersionWorkflowStatusInfo(quoteVersionId:number|carriers.Quote_GetQuoteVersionWorkflowStatusInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionStatusInformation > {
        let _request : carriers.Quote_GetQuoteVersionWorkflowStatusInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_GetQuoteVersionWorkflowStatusInfoRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteVersionWorkflowStatusInfo( _request, _options );
    }


    private async _RequestApproval(request: carriers.Quote_RequestApprovalRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RequestApproval", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Notifies specified associate that this quote needs approval.
     * @param request - QuoteVersionId, AssociateId, Comment
     * @returns Response of the the operation
     */
    public async RequestApproval(request: carriers.Quote_RequestApprovalRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    /**
     * Notifies specified associate that this quote needs approval.
     * @param quoteVersionId - The quoteversion to be approved.
     * @param associateId - The associate that should be notified.
     * @param comment - Details or reason for request
     * @returns Response of the the operation
     */
    public async RequestApproval(quoteVersionId: number, associateId: number, comment: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    public async RequestApproval(quoteVersionId:number|carriers.Quote_RequestApprovalRequest, associateId?:number|base.WebApiRequestOptions, comment?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        let _request : carriers.Quote_RequestApprovalRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.AssociateId)!='undefined' || typeof(first.Comment)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_RequestApprovalRequest;
            _options = associateId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       AssociateId: associateId as number,
                       Comment: comment as string,
                       };   
            _options = webapi_options;
        }
        return this._RequestApproval( _request, _options );
    }


    private async _CancelApprovalRequest(request: carriers.Quote_CancelApprovalRequestRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PluginResponse >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CancelApprovalRequest", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PluginResponse = converters.Create_PluginResponse_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Cancel a pending quote approval request.
     * @param request - QuoteVersionId
     * @returns Response of the the operation
     */
    public async CancelApprovalRequest(request: carriers.Quote_CancelApprovalRequestRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    /**
     * Cancel a pending quote approval request.
     * @param quoteVersionId - The quoteversion for which approval was previously sent.
     * @returns Response of the the operation
     */
    public async CancelApprovalRequest(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse >;

    public async CancelApprovalRequest(quoteVersionId:number|carriers.Quote_CancelApprovalRequestRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PluginResponse > {
        let _request : carriers.Quote_CancelApprovalRequestRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_CancelApprovalRequestRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._CancelApprovalRequest( _request, _options );
    }


    private async _CreateOrUpdateQuoteVersionAttachments(request: carriers.Quote_CreateOrUpdateQuoteVersionAttachmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionAttachment[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteVersionAttachment[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateOrUpdateQuoteVersionAttachments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteVersionAttachment[] = converters.Create_QuoteVersionAttachmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Look at the Quote version, related sale and sale type, and ensure that the correct QuoteVersionAttachment records exist. This method may create or delete records
     * @param request - QuoteVersionId
     * @returns The current attachments for the given Quote version, after all updates have been completed
     */
    public async CreateOrUpdateQuoteVersionAttachments(request: carriers.Quote_CreateOrUpdateQuoteVersionAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionAttachment[] >;

    /**
     * Look at the Quote version, related sale and sale type, and ensure that the correct QuoteVersionAttachment records exist. This method may create or delete records
     * @param quoteVersionId - The ID of the quote version
     * @returns The current attachments for the given Quote version, after all updates have been completed
     */
    public async CreateOrUpdateQuoteVersionAttachments(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionAttachment[] >;

    public async CreateOrUpdateQuoteVersionAttachments(quoteVersionId:number|carriers.Quote_CreateOrUpdateQuoteVersionAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteVersionAttachment[] > {
        let _request : carriers.Quote_CreateOrUpdateQuoteVersionAttachmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_CreateOrUpdateQuoteVersionAttachmentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateOrUpdateQuoteVersionAttachments( _request, _options );
    }


    private async _IncludeQuoteVersionAttachment(request: carriers.Quote_IncludeQuoteVersionAttachmentRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IncludeQuoteVersionAttachment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Toggle the &apos;included&apos; state of a quote version attachment; will throw exceptions if called on locked versions
     * @param request - QuoteVersionId, DocumentId, Include
     * @returns The new state
     */
    public async IncludeQuoteVersionAttachment(request: carriers.Quote_IncludeQuoteVersionAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Toggle the &apos;included&apos; state of a quote version attachment; will throw exceptions if called on locked versions
     * @param quoteVersionId - The ID of the Quote version
     * @param documentId - The ID of the document
     * @param include - Desired state
     * @returns The new state
     */
    public async IncludeQuoteVersionAttachment(quoteVersionId: number, documentId: number, include: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async IncludeQuoteVersionAttachment(quoteVersionId:number|carriers.Quote_IncludeQuoteVersionAttachmentRequest, documentId?:number|base.WebApiRequestOptions, include?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Quote_IncludeQuoteVersionAttachmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.DocumentId)!='undefined' || typeof(first.Include)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Quote_IncludeQuoteVersionAttachmentRequest;
            _options = documentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       DocumentId: documentId as number,
                       Include: include as boolean,
                       };   
            _options = webapi_options;
        }
        return this._IncludeQuoteVersionAttachment( _request, _options );
    }


    private async _ToggleSaleTypeQuoteAttachmentDefaultIncluded(request: carriers.Quote_ToggleSaleTypeQuoteAttachmentDefaultIncludedRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleSaleTypeQuoteAttachmentDefaultIncluded", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Toggle the &apos;default included&apos; state of a sale type quote attachment
     * @param request - SaleTypeQuoteAttachmentId
     * @returns The new state
     */
    public async ToggleSaleTypeQuoteAttachmentDefaultIncluded(request: carriers.Quote_ToggleSaleTypeQuoteAttachmentDefaultIncludedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Toggle the &apos;default included&apos; state of a sale type quote attachment
     * @param saleTypeQuoteAttachmentId - The ID of the sale type quote attachment row
     * @returns The new state
     */
    public async ToggleSaleTypeQuoteAttachmentDefaultIncluded(saleTypeQuoteAttachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async ToggleSaleTypeQuoteAttachmentDefaultIncluded(saleTypeQuoteAttachmentId:number|carriers.Quote_ToggleSaleTypeQuoteAttachmentDefaultIncludedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Quote_ToggleSaleTypeQuoteAttachmentDefaultIncludedRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleTypeQuoteAttachmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleTypeQuoteAttachmentId)!='undefined' ) )
        {
            _request = saleTypeQuoteAttachmentId as carriers.Quote_ToggleSaleTypeQuoteAttachmentDefaultIncludedRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleTypeQuoteAttachmentId: saleTypeQuoteAttachmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._ToggleSaleTypeQuoteAttachmentDefaultIncluded( _request, _options );
    }


    private async _AddSaleTypeQuoteAttachment(request: carriers.Quote_AddSaleTypeQuoteAttachmentRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddSaleTypeQuoteAttachment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Adds a new quote attachment document to a sale type
     * @param request - SaleTypeId, DocumentId
     * @returns ID of the new sale type quote attachment row
     */
    public async AddSaleTypeQuoteAttachment(request: carriers.Quote_AddSaleTypeQuoteAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Adds a new quote attachment document to a sale type
     * @param saleTypeId - The ID of the sale type
     * @param documentId - The ID of the document
     * @returns ID of the new sale type quote attachment row
     */
    public async AddSaleTypeQuoteAttachment(saleTypeId: number, documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async AddSaleTypeQuoteAttachment(saleTypeId:number|carriers.Quote_AddSaleTypeQuoteAttachmentRequest, documentId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Quote_AddSaleTypeQuoteAttachmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleTypeId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleTypeId)!='undefined' || typeof(first.DocumentId)!='undefined' ) )
        {
            _request = saleTypeId as carriers.Quote_AddSaleTypeQuoteAttachmentRequest;
            _options = documentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleTypeId: saleTypeId as number,
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._AddSaleTypeQuoteAttachment( _request, _options );
    }


    private async _DeleteSaleTypeQuoteAttachment(request: carriers.Quote_DeleteSaleTypeQuoteAttachmentRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteSaleTypeQuoteAttachment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes the sale type quote attachment with the given id
     * @param request - SaleTypeQuoteAttachmentId
     * @returns 
     */
    public async DeleteSaleTypeQuoteAttachment(request: carriers.Quote_DeleteSaleTypeQuoteAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes the sale type quote attachment with the given id
     * @param saleTypeQuoteAttachmentId - The ID of the sale type quote attachment row to delete
     * @returns 
     */
    public async DeleteSaleTypeQuoteAttachment(saleTypeQuoteAttachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteSaleTypeQuoteAttachment(saleTypeQuoteAttachmentId:number|carriers.Quote_DeleteSaleTypeQuoteAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Quote_DeleteSaleTypeQuoteAttachmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleTypeQuoteAttachmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleTypeQuoteAttachmentId)!='undefined' ) )
        {
            _request = saleTypeQuoteAttachmentId as carriers.Quote_DeleteSaleTypeQuoteAttachmentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleTypeQuoteAttachmentId: saleTypeQuoteAttachmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteSaleTypeQuoteAttachment( _request, _options );
    }


    private async _ToggleQuoteVersionAttachmentIncluded(request: carriers.Quote_ToggleQuoteVersionAttachmentIncludedRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleQuoteVersionAttachmentIncluded", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Toggle the &apos;included&apos; state of a quote version attachment
     * @param request - QuoteVersionAttachmentId
     * @returns The new state
     */
    public async ToggleQuoteVersionAttachmentIncluded(request: carriers.Quote_ToggleQuoteVersionAttachmentIncludedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Toggle the &apos;included&apos; state of a quote version attachment
     * @param quoteVersionAttachmentId - The ID of the quote version attachment row
     * @returns The new state
     */
    public async ToggleQuoteVersionAttachmentIncluded(quoteVersionAttachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async ToggleQuoteVersionAttachmentIncluded(quoteVersionAttachmentId:number|carriers.Quote_ToggleQuoteVersionAttachmentIncludedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Quote_ToggleQuoteVersionAttachmentIncludedRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionAttachmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionAttachmentId)!='undefined' ) )
        {
            _request = quoteVersionAttachmentId as carriers.Quote_ToggleQuoteVersionAttachmentIncludedRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionAttachmentId: quoteVersionAttachmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._ToggleQuoteVersionAttachmentIncluded( _request, _options );
    }

    } // class v1QuoteAgentController 



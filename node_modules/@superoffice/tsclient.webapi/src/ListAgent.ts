// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/ListAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Collection of all services that works with Lists. These are typical lists of data shown in dropdown list, checkbox lists, etc.
 */
export interface IListAgent {
    CreateDefaultAmountClassEntity(): Promise< carriers.AmountClassEntity >;
    SaveAmountClassEntity(entity: carriers.AmountClassEntity) : Promise< carriers.AmountClassEntity >;
    CreateDefaultTaskMenu(): Promise< carriers.TaskMenu >;
    SaveTaskMenu(entity: carriers.TaskMenu) : Promise< carriers.TaskMenu >;
    DeleteTaskMenu(TaskMenuId: number) : Promise<void>;
    CreateDefaultCurrencyEntity(): Promise< carriers.CurrencyEntity >;
    SaveCurrencyEntity(entity: carriers.CurrencyEntity) : Promise< carriers.CurrencyEntity >;
    CreateDefaultDocumentTemplateEntity(): Promise< carriers.DocumentTemplateEntity >;
    SaveDocumentTemplateEntity(entity: carriers.DocumentTemplateEntity) : Promise< carriers.DocumentTemplateEntity >;
    CreateDefaultExtAppEntity(): Promise< carriers.ExtAppEntity >;
    SaveExtAppEntity(entity: carriers.ExtAppEntity) : Promise< carriers.ExtAppEntity >;
    CreateDefaultHeadingEntity(): Promise< carriers.HeadingEntity >;
    SaveHeadingEntity(entity: carriers.HeadingEntity) : Promise< carriers.HeadingEntity >;
    CreateDefaultHierarchyEntity(): Promise< carriers.HierarchyEntity >;
    SaveHierarchyEntity(entity: carriers.HierarchyEntity) : Promise< carriers.HierarchyEntity >;
    DeleteHierarchyEntity(HierarchyEntityId: number) : Promise<void>;
    CreateDefaultListEntity(): Promise< carriers.ListEntity >;
    SaveListEntity(entity: carriers.ListEntity) : Promise< carriers.ListEntity >;
    DeleteListEntity(ListEntityId: number) : Promise<void>;
    CreateDefaultListItemEntity(): Promise< carriers.ListItemEntity >;
    CreateDefaultProjectTypeEntity(): Promise< carriers.ProjectTypeEntity >;
    SaveProjectTypeEntity(entity: carriers.ProjectTypeEntity) : Promise< carriers.ProjectTypeEntity >;
    CreateDefaultRelationDefinitionEntity(): Promise< carriers.RelationDefinitionEntity >;
    SaveRelationDefinitionEntity(entity: carriers.RelationDefinitionEntity) : Promise< carriers.RelationDefinitionEntity >;
    CreateDefaultResourceEntity(): Promise< carriers.ResourceEntity >;
    SaveResourceEntity(entity: carriers.ResourceEntity) : Promise< carriers.ResourceEntity >;
    DeleteResourceEntity(ResourceEntityId: number) : Promise<void>;
    CreateDefaultSaleStageEntity(): Promise< carriers.SaleStageEntity >;
    SaveSaleStageEntity(entity: carriers.SaleStageEntity) : Promise< carriers.SaleStageEntity >;
    CreateDefaultSaleTypeEntity(): Promise< carriers.SaleTypeEntity >;
    SaveSaleTypeEntity(entity: carriers.SaleTypeEntity) : Promise< carriers.SaleTypeEntity >;
    CreateDefaultTicketCategoryEntity(): Promise< carriers.TicketCategoryEntity >;
    SaveTicketCategoryEntity(entity: carriers.TicketCategoryEntity) : Promise< carriers.TicketCategoryEntity >;
    DeleteTicketCategoryEntity(TicketCategoryEntityId: number) : Promise<void>;
    CreateDefaultTicketPriorityEntity(): Promise< carriers.TicketPriorityEntity >;
    SaveTicketPriorityEntity(entity: carriers.TicketPriorityEntity) : Promise< carriers.TicketPriorityEntity >;
    DeleteTicketPriorityEntity(TicketPriorityEntityId: number) : Promise<void>;
    CreateDefaultTicketStatusEntity(): Promise< carriers.TicketStatusEntity >;
    SaveTicketStatusEntity(entity: carriers.TicketStatusEntity) : Promise< carriers.TicketStatusEntity >;
    DeleteTicketStatusEntity(TicketStatusEntityId: number) : Promise<void>;
    CreateDefaultWebPanelEntity(): Promise< carriers.WebPanelEntity >;
    SaveWebPanelEntity(entity: carriers.WebPanelEntity) : Promise< carriers.WebPanelEntity >;
    GetAmountClassEntity(amountClassEntityId: number) :  Promise< carriers.AmountClassEntity >;
    GetBusiness(businessId: number) :  Promise< carriers.Business >;
    GetBusinessList(businessIds: number[]) :  Promise< carriers.Business[] >;
    GetBusinesses(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Business[] >;
    GetCategory(categoryId: number) :  Promise< carriers.Category >;
    GetCategoryList(categoryIds: number[]) :  Promise< carriers.Category[] >;
    GetCategories(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Category[] >;
    GetCompetitor(competitorId: number) :  Promise< carriers.Competitor >;
    GetCompetitorList(competitorIds: number[]) :  Promise< carriers.Competitor[] >;
    GetCompetitors(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Competitor[] >;
    GetTaskMenu(taskMenuId: number) :  Promise< carriers.TaskMenu >;
    GetAppTaskMenus(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu[] >;
    DeleteAppTaskMenus(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetTaskMenuByProgId(request: carriers.List_GetTaskMenuByProgIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu >;
    GetTaskMenuByProgId(progId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu >;
    GetConsentPurpose(consentPurposeId: number) :  Promise< carriers.ConsentPurpose >;
    SaveConsentPurpose(request: carriers.List_SaveConsentPurposeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose >;
    SaveConsentPurpose(consentPurpose: carriers.ConsentPurpose, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose >;
    SetEmarketingStrictMode(request: carriers.List_SetEmarketingStrictModeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetEmarketingStrictMode(enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetEmarketingStrictMode(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetConsentPurposeList(consentPurposeIds: number[]) :  Promise< carriers.ConsentPurpose[] >;
    GetConsentPurposes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose[] >;
    GetConsentSource(consentSourceId: number) :  Promise< carriers.ConsentSource >;
    SaveConsentSource(request: carriers.List_SaveConsentSourceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource >;
    SaveConsentSource(consentSource: carriers.ConsentSource, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource >;
    GetConsentSourceList(consentSourceIds: number[]) :  Promise< carriers.ConsentSource[] >;
    GetConsentSources(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource[] >;
    GetCountry(countryId: number) :  Promise< carriers.Country >;
    SaveCountry(request: carriers.List_SaveCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country >;
    SaveCountry(country: carriers.Country, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country >;
    CreateDefaultCountry(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country >;
    GetCountryList(countryIds: number[]) :  Promise< carriers.Country[] >;
    GetCountries(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country[] >;
    GetAllCountries(request: carriers.List_GetAllCountriesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country[] >;
    GetAllCountries(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country[] >;
    GetCredited(creditedId: number) :  Promise< carriers.Credited >;
    GetCreditedList(creditedIds: number[]) :  Promise< carriers.Credited[] >;
    GetCrediteds(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Credited[] >;
    GetCurrency(currencyId: number) :  Promise< carriers.Currency >;
    GetOurCurrency(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Currency >;
    ChangeCurrency(request: carriers.List_ChangeCurrencyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    ChangeCurrency(amount: number, fromCurrency: string, toCurrency: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetOwnerCompanysCurrency(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Currency >;
    GetCurrencyEntity(currencyEntityId: number) :  Promise< carriers.CurrencyEntity >;
    GetBaseCurrency(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity >;
    GetCurrencyList(currencyIds: number[]) :  Promise< carriers.Currency[] >;
    GetCurrencies(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Currency[] >;
    GetAllCurrencies(request: carriers.List_GetAllCurrenciesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity[] >;
    GetAllCurrencies(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity[] >;
    GetCustomerLanguage(customerLanguageId: number) :  Promise< carriers.CustomerLanguage >;
    GetCustomerLanguageList(customerLanguageIds: number[]) :  Promise< carriers.CustomerLanguage[] >;
    GetCustomerLanguages(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CustomerLanguage[] >;
    GetDeliveryTerm(deliveryTermId: number) :  Promise< carriers.DeliveryTerm >;
    GetDeliveryTerms(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DeliveryTerm[] >;
    GetDeliveryType(deliveryTypeId: number) :  Promise< carriers.DeliveryType >;
    GetDeliveryTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DeliveryType[] >;
    GetDepartment(departmentId: number) :  Promise< carriers.Department >;
    GetDepartmentList(departmentIds: number[]) :  Promise< carriers.Department[] >;
    GetDepartments(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Department[] >;
    GetDocumentTemplate(documentTemplateId: number) :  Promise< carriers.DocumentTemplate >;
    GetDocumentTemplateEntity(documentTemplateEntityId: number) :  Promise< carriers.DocumentTemplateEntity >;
    SetDocumentTemplateStream(request: carriers.List_SetDocumentTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity >;
    SetDocumentTemplateStream(documentTemplateEntity: carriers.DocumentTemplateEntity, stream: ArrayBuffer|string, languageCode: string, pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity >;
    GetDocumentTemplateUsedInSalesStage(request: carriers.List_GetDocumentTemplateUsedInSalesStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetDocumentTemplateUsedInSalesStage(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetDocumentTemplateUsedInProjectStage(request: carriers.List_GetDocumentTemplateUsedInProjectStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetDocumentTemplateUsedInProjectStage(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetDocumentTemplateUrl(request: carriers.List_GetDocumentTemplateUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDocumentTemplateUrl(documentTemplateId: number, writableUrl: boolean, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDocumentTemplateProperties(request: carriers.List_GetDocumentTemplatePropertiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetDocumentTemplateProperties(documentTemplateId: number, requestedProperties: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetDocumentTemplateLanguages(request: carriers.List_GetDocumentTemplateLanguagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetDocumentTemplateLanguages(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    CreateDefaultDocumentTemplateLanguage(request: carriers.List_CreateDefaultDocumentTemplateLanguageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateDefaultDocumentTemplateLanguage(documentTemplateId: number, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteDocumentTemplateLanguage(request: carriers.List_DeleteDocumentTemplateLanguageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteDocumentTemplateLanguage(documentTemplateId: number, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetDocumentTemplateExtension(request: carriers.List_GetDocumentTemplateExtensionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDocumentTemplateExtension(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SetDocumentTemplateFromDocumentTemplate(request: carriers.List_SetDocumentTemplateFromDocumentTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity >;
    SetDocumentTemplateFromDocumentTemplate(sourceDocumentTemplateId: number, documentTemplateEntity: carriers.DocumentTemplateEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity >;
    GetDocumentTemplateStreamFromId(request: carriers.List_GetDocumentTemplateStreamFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetDocumentTemplateStreamFromId(documentTemplateId: number, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SaveDocumentTemplateStream(request: carriers.List_SaveDocumentTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo >;
    SaveDocumentTemplateStream(documentTemplateId: number, content: ArrayBuffer|string, languageCode: string, pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo >;
    GetPluginList(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetPluginCapabilities(request: carriers.List_GetPluginCapabilitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetPluginCapabilities(pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetDocumentTypesForPlugin(request: carriers.List_GetDocumentTypesForPluginRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.IntStringDictionary >;
    GetDocumentTypesForPlugin(pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.IntStringDictionary >;
    GetDocumentTemplateList(documentTemplateIds: number[]) :  Promise< carriers.DocumentTemplate[] >;
    GetDocumentTemplates(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplate[] >;
    GetAllDocumentTemplates(request: carriers.List_GetAllDocumentTemplatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity[] >;
    GetAllDocumentTemplates(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity[] >;
    SetDocumentPluginForAllDocumentTemplates(request: carriers.List_SetDocumentPluginForAllDocumentTemplatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetDocumentPluginForAllDocumentTemplates(documentPluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetExtAppEntity(extAppEntityId: number) :  Promise< carriers.ExtAppEntity >;
    GetHeadingEntity(headingEntityId: number) :  Promise< carriers.HeadingEntity >;
    CreateDefaultHeadingFromListDefinition(request: carriers.List_CreateDefaultHeadingFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;
    CreateDefaultHeadingFromListDefinition(udListDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;
    GetHierarchyEntity(hierarchyEntityId: number) :  Promise< carriers.HierarchyEntity >;
    GetAllDomains(webapi_options?:base.WebApiRequestOptions) : Promise< enums.Domain[] >;
    GetAllInDomain(request: carriers.List_GetAllInDomainRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity[] >;
    GetAllInDomain(domain: enums.Domain, children: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity[] >;
    GetHierarchyFromPath(request: carriers.List_GetHierarchyFromPathRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;
    GetHierarchyFromPath(domain: enums.Domain, path: string, children: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;
    AddHierarchyToPath(request: carriers.List_AddHierarchyToPathRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;
    AddHierarchyToPath(domain: enums.Domain, path: string, name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;
    UpdateHierarchyFromPath(request: carriers.List_UpdateHierarchyFromPathRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;
    UpdateHierarchyFromPath(domain: enums.Domain, path: string, entity: carriers.HierarchyEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;
    DeleteHierarchyFromPath(request: carriers.List_DeleteHierarchyFromPathRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteHierarchyFromPath(domain: enums.Domain, path: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetLanguageInfo(languageInfoId: number) :  Promise< carriers.LanguageInfo >;
    GetLanguageInfoList(languageInfoIds: number[]) :  Promise< carriers.LanguageInfo[] >;
    GetInstalledLanguages(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LanguageInfo[] >;
    GetLegalBase(legalBaseId: number) :  Promise< carriers.LegalBase >;
    SaveLegalBase(request: carriers.List_SaveLegalBaseRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase >;
    SaveLegalBase(legalBase: carriers.LegalBase, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase >;
    GetLegalBaseList(legalBaseIds: number[]) :  Promise< carriers.LegalBase[] >;
    GetLegalBases(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase[] >;
    GetLink(linkId: number) :  Promise< carriers.Link >;
    GetLinkList(linkIds: number[]) :  Promise< carriers.Link[] >;
    GetListEntity(listEntityId: number) :  Promise< carriers.ListEntity >;
    GetListDefinitions(request: carriers.List_GetListDefinitionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity[] >;
    GetListDefinitions(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity[] >;
    GetListEntityByName(request: carriers.List_GetListEntityByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity >;
    GetListEntityByName(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity >;
    SaveListEntityByName(request: carriers.List_SaveListEntityByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity >;
    SaveListEntityByName(name: string, listEntity: carriers.ListEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity >;
    DeleteListEntityByName(request: carriers.List_DeleteListEntityByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteListEntityByName(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveListItemEntity(request: carriers.List_SaveListItemEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    SaveListItemEntity(listItemEntity: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    SortListItems(request: carriers.List_SortListItemsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SortListItems(udListDefinitionId: number, cultureName: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveListItem(request: carriers.List_MoveListItemRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveListItem(udListDefinitionId: number, listItemId: number, direction: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetVisibleForUserGroups(request: carriers.List_GetVisibleForUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetVisibleForUserGroups(udListDefinitionId: number, listItemId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetVisibleForUserGroupsFromListName(request: carriers.List_GetVisibleForUserGroupsFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetVisibleForUserGroupsFromListName(udListDefinitionName: string, listItemId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SetVisibleForUserGroups(request: carriers.List_SetVisibleForUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SetVisibleForUserGroups(udListDefinitionId: number, listItemId: number, userGroups: carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SetVisibleForUserGroupsFromListName(request: carriers.List_SetVisibleForUserGroupsFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SetVisibleForUserGroupsFromListName(udListDefinitionName: string, listItemId: number, userGroups: carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SetVisibleForUserGroup(request: carriers.List_SetVisibleForUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetVisibleForUserGroup(udListDefinitionId: number, listItemId: number, userGroupId: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetListItemsForUserGroup(request: carriers.List_GetListItemsForUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetListItemsForUserGroup(udListDefinitionId: number, groupId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetListItemsForUserGroupFromListName(request: carriers.List_GetListItemsForUserGroupFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetListItemsForUserGroupFromListName(udListDefinitionName: string, groupId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SetListItemsForUserGroup(request: carriers.List_SetListItemsForUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetListItemsForUserGroup(udListDefinitionId: number, usergroupId: number, listItemIds: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetListItemsForUserGroupFromListName(request: carriers.List_SetListItemsForUserGroupFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetListItemsForUserGroupFromListName(udListDefinitionName: string, usergroupId: number, listItemsID: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetHeadings(request: carriers.List_GetHeadingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetHeadings(udListDefinitionId: number, listItemId: number, showDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetHeadingsForListItemFromListName(request: carriers.List_GetHeadingsForListItemFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetHeadingsForListItemFromListName(udListDefinitionName: string, listItemId: number, showDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SaveHeadingsForListItemFromListDefinition(request: carriers.List_SaveHeadingsForListItemFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SaveHeadingsForListItemFromListDefinition(udListDefinitionId: number, listItemId: number, headings: carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SaveHeadingsForListItemFromListName(request: carriers.List_SaveHeadingsForListItemFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SaveHeadingsForListItemFromListName(udListDefinitionName: string, listItemId: number, headings: carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetListItemsForHeading(request: carriers.List_GetListItemsForHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetListItemsForHeading(udListDefinitionId: number, headingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetListItemsForHeadingFromListName(request: carriers.List_GetListItemsForHeadingFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    GetListItemsForHeadingFromListName(udListDefinitionName: string, headingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;
    SetListItemsForHeading(request: carriers.List_SetListItemsForHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetListItemsForHeading(udListDefinitionId: number, headingId: number, listItemIds: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetListItemsForHeadingFromListName(request: carriers.List_SetListItemsForHeadingFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetListItemsForHeadingFromListName(udListDefinitionName: string, headingId: number, listItemIds: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetHeadingsForListItem(request: carriers.List_SetHeadingsForListItemRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetHeadingsForListItem(udListDefinitionId: number, listItemId: number, headingIds: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnHeadings(request: carriers.List_SetRankOnHeadingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnHeadings(udListDefinitionId: number, headingIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnSaleActivity(request: carriers.List_SetRankOnSaleActivityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnSaleActivity(saleTypeStageLinkId: number, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnSaleDocument(request: carriers.List_SetRankOnSaleDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnSaleDocument(saleTypeStageLinkId: number, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnProjectActivity(request: carriers.List_SetRankOnProjectActivityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnProjectActivity(projectTypeStatusLinkId: number, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnProjectDocument(request: carriers.List_SetRankOnProjectDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRankOnProjectDocument(projectTypeStatusLinkId: number, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetAllFromListDefinition(request: carriers.List_GetAllFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;
    GetAllFromListDefinition(udListDefinitionId: number, includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;
    GetAllFromListName(request: carriers.List_GetAllFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;
    GetAllFromListName(udListDefinitionName: string, includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;
    SaveAllFromListDefinition(request: carriers.List_SaveAllFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;
    SaveAllFromListDefinition(udListDefinitionId: number, items: carriers.ListItemEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;
    SaveAllFromListName(request: carriers.List_SaveAllFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;
    SaveAllFromListName(udListDefinitionName: string, items: carriers.ListItemEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;
    AddFromListDefinition(request: carriers.List_AddFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    AddFromListDefinition(udListDefinitionId: number, item: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    AddFromListName(request: carriers.List_AddFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    AddFromListName(udListDefinitionName: string, item: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    DeleteAllFromListDefinition(request: carriers.List_DeleteAllFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteAllFromListDefinition(udListDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteAllFromListName(request: carriers.List_DeleteAllFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteAllFromListName(udListDefinitionName: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetFromListDefinition(request: carriers.List_GetFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    GetFromListDefinition(id: number, udListDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    GetFromListName(request: carriers.List_GetFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    GetFromListName(id: number, udListDefinitionName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    SaveFromListDefinition(request: carriers.List_SaveFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    SaveFromListDefinition(id: number, udListDefinitionId: number, item: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    SaveFromListName(request: carriers.List_SaveFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    SaveFromListName(id: number, udListDefinitionName: string, item: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;
    DeleteFromListDefinition(request: carriers.List_DeleteFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteFromListDefinition(id: number, udListDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteFromListName(request: carriers.List_DeleteFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteFromListName(id: number, udListDefinitionName: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetHeadingsFromName(request: carriers.List_GetHeadingsFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;
    GetHeadingsFromName(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;
    GetHeadingsFromListDefinition(request: carriers.List_GetHeadingsFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;
    GetHeadingsFromListDefinition(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;
    SaveHeadingsFromName(request: carriers.List_SaveHeadingsFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;
    SaveHeadingsFromName(name: string, entities: carriers.HeadingEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;
    SaveHeadingsFromListDefinition(request: carriers.List_SaveHeadingsFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;
    SaveHeadingsFromListDefinition(id: number, entities: carriers.HeadingEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;
    SaveHeadingFromName(request: carriers.List_SaveHeadingFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;
    SaveHeadingFromName(name: string, entity: carriers.HeadingEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;
    SaveHeadingFromListDefinition(request: carriers.List_SaveHeadingFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;
    SaveHeadingFromListDefinition(id: number, entity: carriers.HeadingEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;
    DeleteAllHeadingsFromName(request: carriers.List_DeleteAllHeadingsFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteAllHeadingsFromName(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteAllHeadingsFromListDefinition(request: carriers.List_DeleteAllHeadingsFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteAllHeadingsFromListDefinition(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetLocalizedText(localizedTextId: number) :  Promise< carriers.LocalizedText >;
    GetLocalizedTextByType(request: carriers.List_GetLocalizedTextByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText >;
    GetLocalizedTextByType(textType: enums.LocalizedTextType, resourceId: number, languageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText >;
    GetLocalizedTextList(localizedTextIds: number[]) :  Promise< carriers.LocalizedText[] >;
    GetLocalizedTexts(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >;
    GetLocalizedTextsByLanguageId(request: carriers.List_GetLocalizedTextsByLanguageIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >;
    GetLocalizedTextsByLanguageId(languageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >;
    GetLocalizedTextsByType(request: carriers.List_GetLocalizedTextsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >;
    GetLocalizedTextsByType(textTypes: enums.LocalizedTextType[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >;
    GetMrMrs(mrMrsId: number) :  Promise< carriers.MrMrs >;
    GetMrMrsList(mrMrsIds: number[]) :  Promise< carriers.MrMrs[] >;
    GetMrMrses(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MrMrs[] >;
    GetPaymentTerm(paymentTermId: number) :  Promise< carriers.PaymentTerm >;
    GetPaymentTerms(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PaymentTerm[] >;
    GetPaymentType(paymentTypeId: number) :  Promise< carriers.PaymentType >;
    GetPaymentTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PaymentType[] >;
    GetPosition(positionId: number) :  Promise< carriers.Position >;
    GetPositionList(positionIds: number[]) :  Promise< carriers.Position[] >;
    GetPositions(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Position[] >;
    GetPriority(priorityId: number) :  Promise< carriers.Priority >;
    GetPriorityList(priorityIds: number[]) :  Promise< carriers.Priority[] >;
    GetPriorities(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Priority[] >;
    GetProductCategory(productCategoryId: number) :  Promise< carriers.ProductCategory >;
    GetProductCategories(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductCategory[] >;
    GetProductFamily(productFamilyId: number) :  Promise< carriers.ProductFamily >;
    GetProductFamilies(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductFamily[] >;
    GetProductType(productTypeId: number) :  Promise< carriers.ProductType >;
    GetProductTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductType[] >;
    GetProjectStatus(projectStatusId: number) :  Promise< carriers.ProjectStatus >;
    DeleteProjectStatus(request: carriers.List_DeleteProjectStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteProjectStatus(projectStatusId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetProjectStatusList(projectStatusIds: number[]) :  Promise< carriers.ProjectStatus[] >;
    GetProjectStatuses(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectStatus[] >;
    GetProjectType(projectTypeId: number) :  Promise< carriers.ProjectType >;
    GetProjectTypeEntity(projectTypeEntityId: number) :  Promise< carriers.ProjectTypeEntity >;
    GetProjectTypeList(projectTypeIds: number[]) :  Promise< carriers.ProjectType[] >;
    GetProjectTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectType[] >;
    SaveQuickReplies(request: carriers.List_SaveQuickRepliesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveQuickReplies(quickReplies: carriers.QuickReply[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetQuickReplies(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuickReply[] >;
    GetRating(ratingId: number) :  Promise< carriers.Rating >;
    GetRatingList(ratingIds: number[]) :  Promise< carriers.Rating[] >;
    GetRatings(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Rating[] >;
    GetAllSaleStages(request: carriers.List_GetAllSaleStagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStageEntity[] >;
    GetAllSaleStages(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStageEntity[] >;
    GetReason(reasonId: number) :  Promise< carriers.Reason >;
    GetReasonList(reasonIds: number[]) :  Promise< carriers.Reason[] >;
    GetReasons(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Reason[] >;
    GetQuoteApproveReason(quoteApproveReasonId: number) :  Promise< carriers.QuoteApproveReason >;
    GetQuoteApproveReasonList(quoteApproveReasonIds: number[]) :  Promise< carriers.QuoteApproveReason[] >;
    GetQuoteApproveReasons(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteApproveReason[] >;
    GetQuoteDenyReason(quoteDenyReasonId: number) :  Promise< carriers.QuoteDenyReason >;
    GetQuoteDenyReasonList(quoteDenyReasonIds: number[]) :  Promise< carriers.QuoteDenyReason[] >;
    GetQuoteDenyReasons(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteDenyReason[] >;
    GetReasonSold(reasonSoldId: number) :  Promise< carriers.ReasonSold >;
    GetReasonSoldList(reasonSoldIds: number[]) :  Promise< carriers.ReasonSold[] >;
    GetReasonStalled(reasonStalledId: number) :  Promise< carriers.ReasonStalled >;
    GetReasonStalledList(reasonStalledIds: number[]) :  Promise< carriers.ReasonStalled[] >;
    GetRelationDefinitionEntity(relationDefinitionEntityId: number) :  Promise< carriers.RelationDefinitionEntity >;
    GetResourceEntity(resourceEntityId: number) :  Promise< carriers.ResourceEntity >;
    GetSaleStageEntity(saleStageEntityId: number) :  Promise< carriers.SaleStageEntity >;
    GetSaleType(saleTypeId: number) :  Promise< carriers.SaleType >;
    GetSaleTypeEntity(saleTypeEntityId: number) :  Promise< carriers.SaleTypeEntity >;
    GetSaleTypeList(saleTypeIds: number[]) :  Promise< carriers.SaleType[] >;
    GetAllSaleType(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleType[] >;
    GetAllSaleTypeEntities(request: carriers.List_GetAllSaleTypeEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleTypeEntity[] >;
    GetAllSaleTypeEntities(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleTypeEntity[] >;
    GetSelectionCategory(selectionCategoryId: number) :  Promise< carriers.SelectionCategory >;
    GetSelectionCategoryList(selectionCategoryIds: number[]) :  Promise< carriers.SelectionCategory[] >;
    GetSource(sourceId: number) :  Promise< carriers.Source >;
    GetSourceList(sourceIds: number[]) :  Promise< carriers.Source[] >;
    GetSources(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Source[] >;
    GetTask(taskId: number) :  Promise< carriers.Task >;
    GetDocumentTemplateTask(request: carriers.List_GetDocumentTemplateTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Task >;
    GetDocumentTemplateTask(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Task >;
    GetTaskList(taskIds: number[]) :  Promise< carriers.Task[] >;
    GetTasks(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Task[] >;
    GetDocumentTemplatesTasks(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Task[] >;
    GetAllTasks(request: carriers.List_GetAllTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] >;
    GetAllTasks(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] >;
    GetTicketCategory(ticketCategoryId: number) :  Promise< carriers.TicketCategory >;
    GetTicketCategoryEntity(ticketCategoryEntityId: number) :  Promise< carriers.TicketCategoryEntity >;
    MoveAllTickets(request: carriers.List_MoveAllTicketsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveAllTickets(fromTicketCategoryId: number, toTicketCategoryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RebuildFullnames(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetTicketCategoryList(ticketCategoryEntityIds: number[]) :  Promise< carriers.TicketCategoryEntity[] >;
    GetTicketCategories(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketCategoryEntity[] >;
    GetTicketCategoriesForUserGroups(request: carriers.List_GetTicketCategoriesForUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    GetTicketCategoriesForUserGroups(userGroupIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    SetTicketCategoriesForUserGroup(request: carriers.List_SetTicketCategoriesForUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetTicketCategoriesForUserGroup(userGroupId: number, categoryIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    UpdateCategoryMemberships(request: carriers.List_UpdateCategoryMembershipsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    UpdateCategoryMemberships(ticketCategoryId: number, membershipsToAdd: carriers.TicketCategoryMembershipEntity[], membershipsToUpdate: carriers.TicketCategoryMembershipEntity[], membershipsToDelete: carriers.TicketCategoryMembershipEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetTicketPriority(ticketPriorityId: number) :  Promise< carriers.TicketPriority >;
    GetTicketPriorityEntity(ticketPriorityEntityId: number) :  Promise< carriers.TicketPriorityEntity >;
    SetTicketPrioritySortOrder(request: carriers.List_SetTicketPrioritySortOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetTicketPrioritySortOrder(ticketPriorityId: number, sortOrder: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetTicketPriorityList(ticketPriorityIds: number[]) :  Promise< carriers.TicketPriority[] >;
    GetTicketPriorities(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriority[] >;
    GetAllTicketPriorities(request: carriers.List_GetAllTicketPrioritiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriorityEntity[] >;
    GetAllTicketPriorities(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriorityEntity[] >;
    GetTicketStatusEntity(ticketStatusEntityId: number) :  Promise< carriers.TicketStatusEntity >;
    GlobalChangeTicketStatus(request: carriers.List_GlobalChangeTicketStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GlobalChangeTicketStatus(fromTicketStatusId: number, toTicketStatusId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetTicketStatusSortOrder(request: carriers.List_SetTicketStatusSortOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetTicketStatusSortOrder(ticketStatusId: number, sortOrder: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetTicketStatusList(ticketStatusEntityIds: number[]) :  Promise< carriers.TicketStatusEntity[] >;
    GetTicketStatuses(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketStatusEntity[] >;
    GetWebPanelEntity(webPanelEntityId: number) :  Promise< carriers.WebPanelEntity >;
    GenerateNavigationUrl(request: carriers.List_GenerateNavigationUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GenerateNavigationUrl(visibleIn: enums.Navigation, windowName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetWebPanelList(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity[] >;
    DeleteWebPanel(request: carriers.List_DeleteWebPanelRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteWebPanel(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetAppWebPanels(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity[] >;
    DeleteAppWebPanels(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetWebPanelByProgId(request: carriers.List_GetWebPanelByProgIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity >;
    GetWebPanelByProgId(progId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity >;
} // interface IListAgent




/**
 * Collection of all services that works with Lists. These are typical lists of data shown in dropdown list, checkbox lists, etc.
 */
export class ListAgent extends base.WebApiBase implements IListAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/List/";
        super(options);
    }



    /**
     * Set default values into a new AmountClassEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultAmountClassEntity(options?:base.WebApiRequestOptions) : Promise< carriers.AmountClassEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AmountClassEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultAmountClassEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AmountClassEntity = converters.Create_AmountClassEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing AmountClassEntity or creates a new AmountClassEntity if the id parameter is empty
     * @param entity - The AmountClassEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated AmountClassEntity
     */
    public async SaveAmountClassEntity(entity: carriers.AmountClassEntity, options?:base.WebApiRequestOptions) : Promise< carriers.AmountClassEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AmountClassEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveAmountClassEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AmountClassEntity = converters.Create_AmountClassEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new TaskMenu.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultTaskMenu(options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskMenu >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTaskMenu", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TaskMenu = converters.Create_TaskMenu_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TaskMenu or creates a new TaskMenu if the id parameter is empty
     * @param entity - The TaskMenu to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TaskMenu
     */
    public async SaveTaskMenu(entity: carriers.TaskMenu, options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskMenu >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTaskMenu", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TaskMenu = converters.Create_TaskMenu_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the TaskMenu
     * @param TaskMenuId - The id of the TaskMenu to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteTaskMenu(TaskMenuId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTaskMenu?TaskMenuId=" + TaskMenuId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new CurrencyEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultCurrencyEntity(options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CurrencyEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultCurrencyEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CurrencyEntity = converters.Create_CurrencyEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing CurrencyEntity or creates a new CurrencyEntity if the id parameter is empty
     * @param entity - The CurrencyEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated CurrencyEntity
     */
    public async SaveCurrencyEntity(entity: carriers.CurrencyEntity, options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CurrencyEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveCurrencyEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CurrencyEntity = converters.Create_CurrencyEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new DocumentTemplateEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDocumentTemplateEntity(options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplateEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDocumentTemplateEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentTemplateEntity = converters.Create_DocumentTemplateEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DocumentTemplateEntity or creates a new DocumentTemplateEntity if the id parameter is empty
     * @param entity - The DocumentTemplateEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DocumentTemplateEntity
     */
    public async SaveDocumentTemplateEntity(entity: carriers.DocumentTemplateEntity, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplateEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDocumentTemplateEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentTemplateEntity = converters.Create_DocumentTemplateEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ExtAppEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultExtAppEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ExtAppEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ExtAppEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultExtAppEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ExtAppEntity = converters.Create_ExtAppEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ExtAppEntity or creates a new ExtAppEntity if the id parameter is empty
     * @param entity - The ExtAppEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ExtAppEntity
     */
    public async SaveExtAppEntity(entity: carriers.ExtAppEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ExtAppEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ExtAppEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveExtAppEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ExtAppEntity = converters.Create_ExtAppEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new HeadingEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultHeadingEntity(options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultHeadingEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HeadingEntity = converters.Create_HeadingEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing HeadingEntity or creates a new HeadingEntity if the id parameter is empty
     * @param entity - The HeadingEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated HeadingEntity
     */
    public async SaveHeadingEntity(entity: carriers.HeadingEntity, options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveHeadingEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HeadingEntity = converters.Create_HeadingEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new HierarchyEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultHierarchyEntity(options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HierarchyEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultHierarchyEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HierarchyEntity = converters.Create_HierarchyEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing HierarchyEntity or creates a new HierarchyEntity if the id parameter is empty
     * @param entity - The HierarchyEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated HierarchyEntity
     */
    public async SaveHierarchyEntity(entity: carriers.HierarchyEntity, options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HierarchyEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveHierarchyEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HierarchyEntity = converters.Create_HierarchyEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the HierarchyEntity
     * @param HierarchyEntityId - The id of the HierarchyEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteHierarchyEntity(HierarchyEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteHierarchyEntity?HierarchyEntityId=" + HierarchyEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ListEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultListEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultListEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListEntity = converters.Create_ListEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ListEntity or creates a new ListEntity if the id parameter is empty
     * @param entity - The ListEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ListEntity
     */
    public async SaveListEntity(entity: carriers.ListEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveListEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListEntity = converters.Create_ListEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ListEntity
     * @param ListEntityId - The id of the ListEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteListEntity(ListEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteListEntity?ListEntityId=" + ListEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ListItemEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultListItemEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultListItemEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity = converters.Create_ListItemEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ProjectTypeEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultProjectTypeEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ProjectTypeEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectTypeEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProjectTypeEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectTypeEntity = converters.Create_ProjectTypeEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ProjectTypeEntity or creates a new ProjectTypeEntity if the id parameter is empty
     * @param entity - The ProjectTypeEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ProjectTypeEntity
     */
    public async SaveProjectTypeEntity(entity: carriers.ProjectTypeEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectTypeEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectTypeEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProjectTypeEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectTypeEntity = converters.Create_ProjectTypeEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new RelationDefinitionEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultRelationDefinitionEntity(options?:base.WebApiRequestOptions) : Promise< carriers.RelationDefinitionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RelationDefinitionEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultRelationDefinitionEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RelationDefinitionEntity = converters.Create_RelationDefinitionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing RelationDefinitionEntity or creates a new RelationDefinitionEntity if the id parameter is empty
     * @param entity - The RelationDefinitionEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated RelationDefinitionEntity
     */
    public async SaveRelationDefinitionEntity(entity: carriers.RelationDefinitionEntity, options?:base.WebApiRequestOptions) : Promise< carriers.RelationDefinitionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RelationDefinitionEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveRelationDefinitionEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RelationDefinitionEntity = converters.Create_RelationDefinitionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ResourceEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultResourceEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ResourceEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ResourceEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultResourceEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ResourceEntity = converters.Create_ResourceEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ResourceEntity or creates a new ResourceEntity if the id parameter is empty
     * @param entity - The ResourceEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ResourceEntity
     */
    public async SaveResourceEntity(entity: carriers.ResourceEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ResourceEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ResourceEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveResourceEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ResourceEntity = converters.Create_ResourceEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ResourceEntity
     * @param ResourceEntityId - The id of the ResourceEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteResourceEntity(ResourceEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteResourceEntity?ResourceEntityId=" + ResourceEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new SaleStageEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSaleStageEntity(options?:base.WebApiRequestOptions) : Promise< carriers.SaleStageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStageEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleStageEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleStageEntity = converters.Create_SaleStageEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SaleStageEntity or creates a new SaleStageEntity if the id parameter is empty
     * @param entity - The SaleStageEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SaleStageEntity
     */
    public async SaveSaleStageEntity(entity: carriers.SaleStageEntity, options?:base.WebApiRequestOptions) : Promise< carriers.SaleStageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStageEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSaleStageEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleStageEntity = converters.Create_SaleStageEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new SaleTypeEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSaleTypeEntity(options?:base.WebApiRequestOptions) : Promise< carriers.SaleTypeEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleTypeEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleTypeEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleTypeEntity = converters.Create_SaleTypeEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SaleTypeEntity or creates a new SaleTypeEntity if the id parameter is empty
     * @param entity - The SaleTypeEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SaleTypeEntity
     */
    public async SaveSaleTypeEntity(entity: carriers.SaleTypeEntity, options?:base.WebApiRequestOptions) : Promise< carriers.SaleTypeEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleTypeEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSaleTypeEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleTypeEntity = converters.Create_SaleTypeEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new TicketCategoryEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultTicketCategoryEntity(options?:base.WebApiRequestOptions) : Promise< carriers.TicketCategoryEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketCategoryEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketCategoryEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketCategoryEntity = converters.Create_TicketCategoryEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketCategoryEntity or creates a new TicketCategoryEntity if the id parameter is empty
     * @param entity - The TicketCategoryEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketCategoryEntity
     */
    public async SaveTicketCategoryEntity(entity: carriers.TicketCategoryEntity, options?:base.WebApiRequestOptions) : Promise< carriers.TicketCategoryEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketCategoryEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketCategoryEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketCategoryEntity = converters.Create_TicketCategoryEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the TicketCategoryEntity
     * @param TicketCategoryEntityId - The id of the TicketCategoryEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteTicketCategoryEntity(TicketCategoryEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTicketCategoryEntity?TicketCategoryEntityId=" + TicketCategoryEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new TicketPriorityEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultTicketPriorityEntity(options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriorityEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketPriorityEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketPriorityEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketPriorityEntity = converters.Create_TicketPriorityEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketPriorityEntity or creates a new TicketPriorityEntity if the id parameter is empty
     * @param entity - The TicketPriorityEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketPriorityEntity
     */
    public async SaveTicketPriorityEntity(entity: carriers.TicketPriorityEntity, options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriorityEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketPriorityEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketPriorityEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketPriorityEntity = converters.Create_TicketPriorityEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the TicketPriorityEntity
     * @param TicketPriorityEntityId - The id of the TicketPriorityEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteTicketPriorityEntity(TicketPriorityEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTicketPriorityEntity?TicketPriorityEntityId=" + TicketPriorityEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new TicketStatusEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultTicketStatusEntity(options?:base.WebApiRequestOptions) : Promise< carriers.TicketStatusEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketStatusEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketStatusEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketStatusEntity = converters.Create_TicketStatusEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketStatusEntity or creates a new TicketStatusEntity if the id parameter is empty
     * @param entity - The TicketStatusEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketStatusEntity
     */
    public async SaveTicketStatusEntity(entity: carriers.TicketStatusEntity, options?:base.WebApiRequestOptions) : Promise< carriers.TicketStatusEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketStatusEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketStatusEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketStatusEntity = converters.Create_TicketStatusEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the TicketStatusEntity
     * @param TicketStatusEntityId - The id of the TicketStatusEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteTicketStatusEntity(TicketStatusEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTicketStatusEntity?TicketStatusEntityId=" + TicketStatusEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new WebPanelEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultWebPanelEntity(options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WebPanelEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultWebPanelEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WebPanelEntity = converters.Create_WebPanelEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing WebPanelEntity or creates a new WebPanelEntity if the id parameter is empty
     * @param entity - The WebPanelEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated WebPanelEntity
     */
    public async SaveWebPanelEntity(entity: carriers.WebPanelEntity, options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WebPanelEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveWebPanelEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WebPanelEntity = converters.Create_WebPanelEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a AmountClassEntity object.
     * @param amountClassEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single AmountClassEntity
     */
    public async GetAmountClassEntity(amountClassEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.AmountClassEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AmountClassEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAmountClassEntity?amountClassEntityId=" + amountClassEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AmountClassEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a Business object.
     * @param businessId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Business
     */
    public async GetBusiness(businessId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Business > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Business >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetBusiness?businessId=" + businessId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Business_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Business objects.
     * @param businessIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Business
     */
    public async GetBusinessList(businessIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Business[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Business[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetBusinessList", businessIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BusinessArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetBusinesses( options?:base.WebApiRequestOptions) : Promise< carriers.Business[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Business[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBusinesses", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Business[] = converters.Create_BusinessArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all available businesses that a contact could have.
     * @returns An array of all available businesses
     */
    public async GetBusinesses(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Business[] >
    {
        return this._GetBusinesses(webapi_options);
    }

    /*
     * Gets a Category object.
     * @param categoryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Category
     */
    public async GetCategory(categoryId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Category > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Category >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCategory?categoryId=" + categoryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Category_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Category objects.
     * @param categoryIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Category
     */
    public async GetCategoryList(categoryIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Category[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Category[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCategoryList", categoryIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CategoryArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetCategories( options?:base.WebApiRequestOptions) : Promise< carriers.Category[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Category[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCategories", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Category[] = converters.Create_CategoryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all categories a contact could belong to
     * @returns An array of all available categories
     */
    public async GetCategories(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Category[] >
    {
        return this._GetCategories(webapi_options);
    }

    /*
     * Gets a Competitor object.
     * @param competitorId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Competitor
     */
    public async GetCompetitor(competitorId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Competitor > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Competitor >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCompetitor?competitorId=" + competitorId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Competitor_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Competitor objects.
     * @param competitorIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Competitor
     */
    public async GetCompetitorList(competitorIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Competitor[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Competitor[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCompetitorList", competitorIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CompetitorArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetCompetitors( options?:base.WebApiRequestOptions) : Promise< carriers.Competitor[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Competitor[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCompetitors", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Competitor[] = converters.Create_CompetitorArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all competitors
     * @returns 
     */
    public async GetCompetitors(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Competitor[] >
    {
        return this._GetCompetitors(webapi_options);
    }

    /*
     * Gets a TaskMenu object.
     * @param taskMenuId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TaskMenu
     */
    public async GetTaskMenu(taskMenuId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskMenu >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTaskMenu?taskMenuId=" + taskMenuId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskMenu_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetAppTaskMenus( options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskMenu[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppTaskMenus", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TaskMenu[] = converters.Create_TaskMenuArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get all task menus owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken
     * @returns List of all task menus owned by the current App
     */
    public async GetAppTaskMenus(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu[] >
    {
        return this._GetAppTaskMenus(webapi_options);
    }


    private async _DeleteAppTaskMenus( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAppTaskMenus", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Permanentely delete all task menus owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken; otherwise nothing happens
     * @returns This method has no return value
     */
    public async DeleteAppTaskMenus(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._DeleteAppTaskMenus(webapi_options);
    }


    private async _GetTaskMenuByProgId(request: carriers.List_GetTaskMenuByProgIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskMenu >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTaskMenuByProgId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TaskMenu = converters.Create_TaskMenu_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a task menu using the ProgId key that was specified when it was created
     * @param request - ProgId
     * @returns The task menu
     */
    public async GetTaskMenuByProgId(request: carriers.List_GetTaskMenuByProgIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu >;

    /**
     * Get a task menu using the ProgId key that was specified when it was created
     * @param progId - String key that can be used to uniquely retrieve the taskmenu, set in the TaskMenu when saving
     * @returns The task menu
     */
    public async GetTaskMenuByProgId(progId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu >;

    public async GetTaskMenuByProgId(progId:string|carriers.List_GetTaskMenuByProgIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskMenu > {
        let _request : carriers.List_GetTaskMenuByProgIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = progId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProgId)!='undefined' ) )
        {
            _request = progId as carriers.List_GetTaskMenuByProgIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProgId: progId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetTaskMenuByProgId( _request, _options );
    }

    /*
     * Gets a ConsentPurpose object.
     * @param consentPurposeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ConsentPurpose
     */
    public async GetConsentPurpose(consentPurposeId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentPurpose >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentPurpose?consentPurposeId=" + consentPurposeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPurpose_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SaveConsentPurpose(request: carriers.List_SaveConsentPurposeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentPurpose >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConsentPurpose", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConsentPurpose = converters.Create_ConsentPurpose_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a ConsentPurpose object
     * @param request - ConsentPurpose
     * @returns The saved ConsentPurpose object, updated with the ConsentPurposeId if it is a new database entry
     */
    public async SaveConsentPurpose(request: carriers.List_SaveConsentPurposeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose >;

    /**
     * Save a ConsentPurpose object
     * @param consentPurpose - The ConsentPurpose object to save
     * @returns The saved ConsentPurpose object, updated with the ConsentPurposeId if it is a new database entry
     */
    public async SaveConsentPurpose(consentPurpose: carriers.ConsentPurpose, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose >;

    public async SaveConsentPurpose(consentPurpose:carriers.ConsentPurpose|carriers.List_SaveConsentPurposeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose > {
        let _request : carriers.List_SaveConsentPurposeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = consentPurpose;
        if( typeof( first ) === "object" && first && ( typeof(first.ConsentPurpose)!='undefined' ) )
        {
            _request = consentPurpose as carriers.List_SaveConsentPurposeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConsentPurpose: consentPurpose as carriers.ConsentPurpose,
                       };   
            _options = webapi_options;
        }
        return this._SaveConsentPurpose( _request, _options );
    }


    private async _SetEmarketingStrictMode(request: carriers.List_SetEmarketingStrictModeRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetEmarketingStrictMode", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Turn on the Emarketing strict mode, which will enable full GDPR rules concerning Emarketing consents and subscriptions
     * @param request - Enable
     * @returns A void return
     */
    public async SetEmarketingStrictMode(request: carriers.List_SetEmarketingStrictModeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Turn on the Emarketing strict mode, which will enable full GDPR rules concerning Emarketing consents and subscriptions
     * @param enable - Set to true to enable strict mode
     * @returns A void return
     */
    public async SetEmarketingStrictMode(enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetEmarketingStrictMode(enable:boolean|carriers.List_SetEmarketingStrictModeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetEmarketingStrictModeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = enable;
        if( typeof( first ) === "object" && first && ( typeof(first.Enable)!='undefined' ) )
        {
            _request = enable as carriers.List_SetEmarketingStrictModeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Enable: enable as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetEmarketingStrictMode( _request, _options );
    }


    private async _GetEmarketingStrictMode( options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmarketingStrictMode", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the value of the Emarketing strict mode setting
     * @returns Returns true if Emarkerint strict mode is set, false otherwise
     */
    public async GetEmarketingStrictMode(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >
    {
        return this._GetEmarketingStrictMode(webapi_options);
    }

    /*
     * Gets an array of ConsentPurpose objects.
     * @param consentPurposeIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ConsentPurpose
     */
    public async GetConsentPurposeList(consentPurposeIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentPurpose[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentPurposeList", consentPurposeIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPurposeArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetConsentPurposes( options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentPurpose[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConsentPurposes", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConsentPurpose[] = converters.Create_ConsentPurposeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all defined purposes.
     * @returns An array of all defined purposes
     */
    public async GetConsentPurposes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPurpose[] >
    {
        return this._GetConsentPurposes(webapi_options);
    }

    /*
     * Gets a ConsentSource object.
     * @param consentSourceId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ConsentSource
     */
    public async GetConsentSource(consentSourceId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentSource >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentSource?consentSourceId=" + consentSourceId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentSource_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SaveConsentSource(request: carriers.List_SaveConsentSourceRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentSource >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConsentSource", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConsentSource = converters.Create_ConsentSource_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ConsentSource
     * @returns 
     */
    public async SaveConsentSource(request: carriers.List_SaveConsentSourceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource >;

    /**
     * 
     * @param consentSource - 
     * @returns 
     */
    public async SaveConsentSource(consentSource: carriers.ConsentSource, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource >;

    public async SaveConsentSource(consentSource:carriers.ConsentSource|carriers.List_SaveConsentSourceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource > {
        let _request : carriers.List_SaveConsentSourceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = consentSource;
        if( typeof( first ) === "object" && first && ( typeof(first.ConsentSource)!='undefined' ) )
        {
            _request = consentSource as carriers.List_SaveConsentSourceRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConsentSource: consentSource as carriers.ConsentSource,
                       };   
            _options = webapi_options;
        }
        return this._SaveConsentSource( _request, _options );
    }

    /*
     * Gets an array of ConsentSource objects.
     * @param consentSourceIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ConsentSource
     */
    public async GetConsentSourceList(consentSourceIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentSource[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentSourceList", consentSourceIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentSourceArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetConsentSources( options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentSource[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConsentSources", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConsentSource[] = converters.Create_ConsentSourceArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all defined Sources.
     * @returns An array of all defined Sources
     */
    public async GetConsentSources(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentSource[] >
    {
        return this._GetConsentSources(webapi_options);
    }

    /*
     * Gets a Country object.
     * @param countryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Country
     */
    public async GetCountry(countryId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Country > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Country >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCountry?countryId=" + countryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Country_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SaveCountry(request: carriers.List_SaveCountryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Country > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Country >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveCountry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Country = converters.Create_Country_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a country
     * @param request - Country
     * @returns The country that is saved
     */
    public async SaveCountry(request: carriers.List_SaveCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country >;

    /**
     * Saves a country
     * @param country - The country to save
     * @returns The country that is saved
     */
    public async SaveCountry(country: carriers.Country, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country >;

    public async SaveCountry(country:carriers.Country|carriers.List_SaveCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country > {
        let _request : carriers.List_SaveCountryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = country;
        if( typeof( first ) === "object" && first && ( typeof(first.Country)!='undefined' ) )
        {
            _request = country as carriers.List_SaveCountryRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Country: country as carriers.Country,
                       };   
            _options = webapi_options;
        }
        return this._SaveCountry( _request, _options );
    }


    private async _CreateDefaultCountry( options?:base.WebApiRequestOptions) : Promise< carriers.Country > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Country >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultCountry", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Country = converters.Create_Country_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets a new country
     * @returns A new country with default values
     */
    public async CreateDefaultCountry(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country >
    {
        return this._CreateDefaultCountry(webapi_options);
    }

    /*
     * Gets an array of Country objects.
     * @param countryIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Country
     */
    public async GetCountryList(countryIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Country[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Country[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCountryList", countryIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CountryArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetCountries( options?:base.WebApiRequestOptions) : Promise< carriers.Country[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Country[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCountries", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Country[] = converters.Create_CountryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all available countries a contact or person could belong to.
     * @returns An array of all available countries
     */
    public async GetCountries(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country[] >
    {
        return this._GetCountries(webapi_options);
    }


    private async _GetAllCountries(request: carriers.List_GetAllCountriesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Country[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Country[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllCountries", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Country[] = converters.Create_CountryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all available countries a contact or person could belong to.
     * @param request - IncludeDeleted
     * @returns An array of all available countries
     */
    public async GetAllCountries(request: carriers.List_GetAllCountriesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country[] >;

    /**
     * Returns all available countries a contact or person could belong to.
     * @param includeDeleted - Include deleted items in result?
     * @returns An array of all available countries
     */
    public async GetAllCountries(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country[] >;

    public async GetAllCountries(includeDeleted:boolean|carriers.List_GetAllCountriesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Country[] > {
        let _request : carriers.List_GetAllCountriesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.List_GetAllCountriesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllCountries( _request, _options );
    }

    /*
     * Gets a Credited object.
     * @param creditedId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Credited
     */
    public async GetCredited(creditedId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Credited > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Credited >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCredited?creditedId=" + creditedId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Credited_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Credited objects.
     * @param creditedIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Credited
     */
    public async GetCreditedList(creditedIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Credited[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Credited[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCreditedList", creditedIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CreditedArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetCrediteds( options?:base.WebApiRequestOptions) : Promise< carriers.Credited[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Credited[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCrediteds", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Credited[] = converters.Create_CreditedArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all credited
     * @returns 
     */
    public async GetCrediteds(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Credited[] >
    {
        return this._GetCrediteds(webapi_options);
    }

    /*
     * Gets a Currency object.
     * @param currencyId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Currency
     */
    public async GetCurrency(currencyId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Currency > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Currency >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCurrency?currencyId=" + currencyId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Currency_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetOurCurrency( options?:base.WebApiRequestOptions) : Promise< carriers.Currency > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Currency >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOurCurrency", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Currency = converters.Create_Currency_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets the Our currency object if currency is enabled
     * @returns Our currency
     */
    public async GetOurCurrency(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Currency >
    {
        return this._GetOurCurrency(webapi_options);
    }


    private async _ChangeCurrency(request: carriers.List_ChangeCurrencyRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeCurrency", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Recalculates the amount to the new currency.
     * @param request - Amount, FromCurrency, ToCurrency
     * @returns Amount in new currency
     */
    public async ChangeCurrency(request: carriers.List_ChangeCurrencyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Recalculates the amount to the new currency.
     * @param amount - The amount in the old currency
     * @param fromCurrency - The old currency name
     * @param toCurrency - The new currency name
     * @returns Amount in new currency
     */
    public async ChangeCurrency(amount: number, fromCurrency: string, toCurrency: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async ChangeCurrency(amount:number|carriers.List_ChangeCurrencyRequest, fromCurrency?:string|base.WebApiRequestOptions, toCurrency?:string, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.List_ChangeCurrencyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = amount;
        if( typeof( first ) === "object" && first && ( typeof(first.Amount)!='undefined' || typeof(first.FromCurrency)!='undefined' || typeof(first.ToCurrency)!='undefined' ) )
        {
            _request = amount as carriers.List_ChangeCurrencyRequest;
            _options = fromCurrency as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Amount: amount as number,
                       FromCurrency: fromCurrency as string,
                       ToCurrency: toCurrency as string,
                       };   
            _options = webapi_options;
        }
        return this._ChangeCurrency( _request, _options );
    }


    private async _GetOwnerCompanysCurrency( options?:base.WebApiRequestOptions) : Promise< carriers.Currency > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Currency >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOwnerCompanysCurrency", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Currency = converters.Create_Currency_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the currency of the user&apos;s owner company
     * @returns Currency of the user's owner company
     */
    public async GetOwnerCompanysCurrency(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Currency >
    {
        return this._GetOwnerCompanysCurrency(webapi_options);
    }

    /*
     * Gets a CurrencyEntity object.
     * @param currencyEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single CurrencyEntity
     */
    public async GetCurrencyEntity(currencyEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CurrencyEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCurrencyEntity?currencyEntityId=" + currencyEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CurrencyEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetBaseCurrency( options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CurrencyEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBaseCurrency", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CurrencyEntity = converters.Create_CurrencyEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the base currency, used for calculating exchange rates
     * @returns The base currency that other currencies are expressed in terms of
     */
    public async GetBaseCurrency(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity >
    {
        return this._GetBaseCurrency(webapi_options);
    }

    /*
     * Gets an array of Currency objects.
     * @param currencyIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Currency
     */
    public async GetCurrencyList(currencyIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Currency[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Currency[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCurrencyList", currencyIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CurrencyArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetCurrencies( options?:base.WebApiRequestOptions) : Promise< carriers.Currency[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Currency[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCurrencies", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Currency[] = converters.Create_CurrencyArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all currencies
     * @returns Array of currencies
     */
    public async GetCurrencies(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Currency[] >
    {
        return this._GetCurrencies(webapi_options);
    }


    private async _GetAllCurrencies(request: carriers.List_GetAllCurrenciesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CurrencyEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllCurrencies", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CurrencyEntity[] = converters.Create_CurrencyEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all currencies
     * @param request - IncludeDeleted
     * @returns Array of currencies
     */
    public async GetAllCurrencies(request: carriers.List_GetAllCurrenciesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity[] >;

    /**
     * Returns all currencies
     * @param includeDeleted - Include deleted items in result?
     * @returns Array of currencies
     */
    public async GetAllCurrencies(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity[] >;

    public async GetAllCurrencies(includeDeleted:boolean|carriers.List_GetAllCurrenciesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CurrencyEntity[] > {
        let _request : carriers.List_GetAllCurrenciesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.List_GetAllCurrenciesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllCurrencies( _request, _options );
    }

    /*
     * Gets a CustomerLanguage object.
     * @param customerLanguageId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single CustomerLanguage
     */
    public async GetCustomerLanguage(customerLanguageId: number, options?:base.WebApiRequestOptions) : Promise< carriers.CustomerLanguage > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CustomerLanguage >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCustomerLanguage?customerLanguageId=" + customerLanguageId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerLanguage_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of CustomerLanguage objects.
     * @param customerLanguageIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of CustomerLanguage
     */
    public async GetCustomerLanguageList(customerLanguageIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.CustomerLanguage[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CustomerLanguage[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCustomerLanguageList", customerLanguageIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerLanguageArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetCustomerLanguages( options?:base.WebApiRequestOptions) : Promise< carriers.CustomerLanguage[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CustomerLanguage[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCustomerLanguages", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CustomerLanguage[] = converters.Create_CustomerLanguageArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * 
     * @returns 
     */
    public async GetCustomerLanguages(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CustomerLanguage[] >
    {
        return this._GetCustomerLanguages(webapi_options);
    }

    /*
     * Gets a DeliveryTerm object.
     * @param deliveryTermId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DeliveryTerm
     */
    public async GetDeliveryTerm(deliveryTermId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DeliveryTerm > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DeliveryTerm >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDeliveryTerm?deliveryTermId=" + deliveryTermId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DeliveryTerm_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetDeliveryTerms( options?:base.WebApiRequestOptions) : Promise< carriers.DeliveryTerm[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DeliveryTerm[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDeliveryTerms", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DeliveryTerm[] = converters.Create_DeliveryTermArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all DeliveryTerms in SuperOffice db.
     * @returns An array of all available DeliveryTerms
     */
    public async GetDeliveryTerms(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DeliveryTerm[] >
    {
        return this._GetDeliveryTerms(webapi_options);
    }

    /*
     * Gets a DeliveryType object.
     * @param deliveryTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DeliveryType
     */
    public async GetDeliveryType(deliveryTypeId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DeliveryType > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DeliveryType >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDeliveryType?deliveryTypeId=" + deliveryTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DeliveryType_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetDeliveryTypes( options?:base.WebApiRequestOptions) : Promise< carriers.DeliveryType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DeliveryType[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDeliveryTypes", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DeliveryType[] = converters.Create_DeliveryTypeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all DeliveryTypes in SuperOffice db.
     * @returns An array of all available DeliveryType
     */
    public async GetDeliveryTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DeliveryType[] >
    {
        return this._GetDeliveryTypes(webapi_options);
    }

    /*
     * Gets a Department object.
     * @param departmentId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Department
     */
    public async GetDepartment(departmentId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Department > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Department >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDepartment?departmentId=" + departmentId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Department_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Department objects.
     * @param departmentIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Department
     */
    public async GetDepartmentList(departmentIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Department[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Department[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDepartmentList", departmentIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DepartmentArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetDepartments( options?:base.WebApiRequestOptions) : Promise< carriers.Department[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Department[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDepartments", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Department[] = converters.Create_DepartmentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Getting all departments/user groups for the internal phone list with the user&apos;s colleagues.
     * @returns Returns all departments.
     */
    public async GetDepartments(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Department[] >
    {
        return this._GetDepartments(webapi_options);
    }

    /*
     * Gets a DocumentTemplate object.
     * @param documentTemplateId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DocumentTemplate
     */
    public async GetDocumentTemplate(documentTemplateId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplate > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplate >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentTemplate?documentTemplateId=" + documentTemplateId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplate_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a DocumentTemplateEntity object.
     * @param documentTemplateEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DocumentTemplateEntity
     */
    public async GetDocumentTemplateEntity(documentTemplateEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplateEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentTemplateEntity?documentTemplateEntityId=" + documentTemplateEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SetDocumentTemplateStream(request: carriers.List_SetDocumentTemplateStreamRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplateEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentTemplateStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentTemplateEntity = converters.Create_DocumentTemplateEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Store a document template from its stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - DocumentTemplateEntity, Stream, LanguageCode, PluginId
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    public async SetDocumentTemplateStream(request: carriers.List_SetDocumentTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity >;

    /**
     * Store a document template from its stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param documentTemplateEntity - The document entity object that the binary data (document) should be stored to. Its file name may be amended by this call, see the return value
     * @param stream - The document as a stream.
     * @param languageCode - The language code ('en-US', 'nb-NO', etc). Use empty string if not supported or used.
     * @param pluginId - The plugin id to store the template with. 0 for SOArc
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    public async SetDocumentTemplateStream(documentTemplateEntity: carriers.DocumentTemplateEntity, stream: ArrayBuffer|string, languageCode: string, pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity >;

    public async SetDocumentTemplateStream(documentTemplateEntity:carriers.DocumentTemplateEntity|carriers.List_SetDocumentTemplateStreamRequest, stream?:ArrayBuffer|string|base.WebApiRequestOptions, languageCode?:string, pluginId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity > {
        let _request : carriers.List_SetDocumentTemplateStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateEntity)!='undefined' || typeof(first.Stream)!='undefined' || typeof(first.LanguageCode)!='undefined' || typeof(first.PluginId)!='undefined' ) )
        {
            _request = documentTemplateEntity as carriers.List_SetDocumentTemplateStreamRequest;
            _options = stream as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateEntity: documentTemplateEntity as carriers.DocumentTemplateEntity,
                       Stream: stream as ArrayBuffer|string,
                       LanguageCode: languageCode as string,
                       PluginId: pluginId as number,
                       };   
            _options = webapi_options;
        }
         _request.Stream = ToBase64(_request.Stream);
        return this._SetDocumentTemplateStream( _request, _options );
    }


    private async _GetDocumentTemplateUsedInSalesStage(request: carriers.List_GetDocumentTemplateUsedInSalesStageRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateUsedInSalesStage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a String array of names in sales guide that this template is used in
     * @param request - DocumentTemplateId
     * @returns The name of the salesguides that use this template
     */
    public async GetDocumentTemplateUsedInSalesStage(request: carriers.List_GetDocumentTemplateUsedInSalesStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Get a String array of names in sales guide that this template is used in
     * @param documentTemplateId - The id of the template
     * @returns The name of the salesguides that use this template
     */
    public async GetDocumentTemplateUsedInSalesStage(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetDocumentTemplateUsedInSalesStage(documentTemplateId:number|carriers.List_GetDocumentTemplateUsedInSalesStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.List_GetDocumentTemplateUsedInSalesStageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_GetDocumentTemplateUsedInSalesStageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentTemplateUsedInSalesStage( _request, _options );
    }


    private async _GetDocumentTemplateUsedInProjectStage(request: carriers.List_GetDocumentTemplateUsedInProjectStageRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateUsedInProjectStage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a String array of names in project guide that this template is used in
     * @param request - DocumentTemplateId
     * @returns The name of the projectguides that use this template
     */
    public async GetDocumentTemplateUsedInProjectStage(request: carriers.List_GetDocumentTemplateUsedInProjectStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Get a String array of names in project guide that this template is used in
     * @param documentTemplateId - The id of the template
     * @returns The name of the projectguides that use this template
     */
    public async GetDocumentTemplateUsedInProjectStage(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetDocumentTemplateUsedInProjectStage(documentTemplateId:number|carriers.List_GetDocumentTemplateUsedInProjectStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.List_GetDocumentTemplateUsedInProjectStageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_GetDocumentTemplateUsedInProjectStageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentTemplateUsedInProjectStage( _request, _options );
    }


    private async _GetDocumentTemplateUrl(request: carriers.List_GetDocumentTemplateUrlRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a url to the document template
     * @param request - DocumentTemplateId, WritableUrl, LanguageCode
     * @returns The URL to the document template
     */
    public async GetDocumentTemplateUrl(request: carriers.List_GetDocumentTemplateUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get a url to the document template
     * @param documentTemplateId - The id of the template
     * @param writableUrl - Get a writeable url to the document template?
     * @param languageCode - The language code ('en-US', 'nb-NO', etc). Use empty string if not supported or used.
     * @returns The URL to the document template
     */
    public async GetDocumentTemplateUrl(documentTemplateId: number, writableUrl: boolean, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetDocumentTemplateUrl(documentTemplateId:number|carriers.List_GetDocumentTemplateUrlRequest, writableUrl?:boolean|base.WebApiRequestOptions, languageCode?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.List_GetDocumentTemplateUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' || typeof(first.WritableUrl)!='undefined' || typeof(first.LanguageCode)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_GetDocumentTemplateUrlRequest;
            _options = writableUrl as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       WritableUrl: writableUrl as boolean,
                       LanguageCode: languageCode as string,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentTemplateUrl( _request, _options );
    }


    private async _GetDocumentTemplateProperties(request: carriers.List_GetDocumentTemplatePropertiesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateProperties", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get document template properties
     * @param request - DocumentTemplateId, RequestedProperties
     * @returns Dictionary of key=value pairs of requested properties
     */
    public async GetDocumentTemplateProperties(request: carriers.List_GetDocumentTemplatePropertiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Get document template properties
     * @param documentTemplateId - The primary key id of the document template
     * @param requestedProperties - An array of properties to get the values for
     * @returns Dictionary of key=value pairs of requested properties
     */
    public async GetDocumentTemplateProperties(documentTemplateId: number, requestedProperties: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async GetDocumentTemplateProperties(documentTemplateId:number|carriers.List_GetDocumentTemplatePropertiesRequest, requestedProperties?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.List_GetDocumentTemplatePropertiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' || typeof(first.RequestedProperties)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_GetDocumentTemplatePropertiesRequest;
            _options = requestedProperties as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       RequestedProperties: requestedProperties as string[],
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentTemplateProperties( _request, _options );
    }


    private async _GetDocumentTemplateLanguages(request: carriers.List_GetDocumentTemplateLanguagesRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateLanguages", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the supported language variations for a document template
     * @param request - DocumentTemplateId
     * @returns Returns the list of languages as ISO cultures (en-US, no, sv, etc)
     */
    public async GetDocumentTemplateLanguages(request: carriers.List_GetDocumentTemplateLanguagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Get the supported language variations for a document template
     * @param documentTemplateId - The id of the document template
     * @returns Returns the list of languages as ISO cultures (en-US, no, sv, etc)
     */
    public async GetDocumentTemplateLanguages(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetDocumentTemplateLanguages(documentTemplateId:number|carriers.List_GetDocumentTemplateLanguagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.List_GetDocumentTemplateLanguagesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_GetDocumentTemplateLanguagesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentTemplateLanguages( _request, _options );
    }


    private async _CreateDefaultDocumentTemplateLanguage(request: carriers.List_CreateDefaultDocumentTemplateLanguageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultDocumentTemplateLanguage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new document template language based on an existing template
     * @param request - DocumentTemplateId, LanguageCode
     * @returns Returns nothing - throws on error
     */
    public async CreateDefaultDocumentTemplateLanguage(request: carriers.List_CreateDefaultDocumentTemplateLanguageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Create a new document template language based on an existing template
     * @param documentTemplateId - The id of the document template
     * @param languageCode - The language code ('en-US, 'nb-NO', etc)
     * @returns Returns nothing - throws on error
     */
    public async CreateDefaultDocumentTemplateLanguage(documentTemplateId: number, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async CreateDefaultDocumentTemplateLanguage(documentTemplateId:number|carriers.List_CreateDefaultDocumentTemplateLanguageRequest, languageCode?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_CreateDefaultDocumentTemplateLanguageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' || typeof(first.LanguageCode)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_CreateDefaultDocumentTemplateLanguageRequest;
            _options = languageCode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       LanguageCode: languageCode as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultDocumentTemplateLanguage( _request, _options );
    }


    private async _DeleteDocumentTemplateLanguage(request: carriers.List_DeleteDocumentTemplateLanguageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteDocumentTemplateLanguage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes language variant of the document template
     * @param request - DocumentTemplateId, LanguageCode
     * @returns This method has no return value
     */
    public async DeleteDocumentTemplateLanguage(request: carriers.List_DeleteDocumentTemplateLanguageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes language variant of the document template
     * @param documentTemplateId - The id of the document template
     * @param languageCode - The language code ('en-US, 'nb-NO', etc)
     * @returns This method has no return value
     */
    public async DeleteDocumentTemplateLanguage(documentTemplateId: number, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteDocumentTemplateLanguage(documentTemplateId:number|carriers.List_DeleteDocumentTemplateLanguageRequest, languageCode?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteDocumentTemplateLanguageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' || typeof(first.LanguageCode)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_DeleteDocumentTemplateLanguageRequest;
            _options = languageCode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       LanguageCode: languageCode as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteDocumentTemplateLanguage( _request, _options );
    }


    private async _GetDocumentTemplateExtension(request: carriers.List_GetDocumentTemplateExtensionRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateExtension", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the file extension for the document template
     * @param request - DocumentTemplateId
     * @returns File name extension including '.': '.doc' or '.xlsx'
     */
    public async GetDocumentTemplateExtension(request: carriers.List_GetDocumentTemplateExtensionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the file extension for the document template
     * @param documentTemplateId - The primary key of the document template
     * @returns File name extension including '.': '.doc' or '.xlsx'
     */
    public async GetDocumentTemplateExtension(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetDocumentTemplateExtension(documentTemplateId:number|carriers.List_GetDocumentTemplateExtensionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.List_GetDocumentTemplateExtensionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_GetDocumentTemplateExtensionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentTemplateExtension( _request, _options );
    }


    private async _SetDocumentTemplateFromDocumentTemplate(request: carriers.List_SetDocumentTemplateFromDocumentTemplateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplateEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentTemplateFromDocumentTemplate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentTemplateEntity = converters.Create_DocumentTemplateEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new document template based on another template
     * @param request - SourceDocumentTemplateId, DocumentTemplateEntity
     * @returns The new document template entity
     */
    public async SetDocumentTemplateFromDocumentTemplate(request: carriers.List_SetDocumentTemplateFromDocumentTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity >;

    /**
     * Create a new document template based on another template
     * @param sourceDocumentTemplateId - The document template to copy contents from.
     * @param documentTemplateEntity - The new document template entity
     * @returns The new document template entity
     */
    public async SetDocumentTemplateFromDocumentTemplate(sourceDocumentTemplateId: number, documentTemplateEntity: carriers.DocumentTemplateEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity >;

    public async SetDocumentTemplateFromDocumentTemplate(sourceDocumentTemplateId:number|carriers.List_SetDocumentTemplateFromDocumentTemplateRequest, documentTemplateEntity?:carriers.DocumentTemplateEntity|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity > {
        let _request : carriers.List_SetDocumentTemplateFromDocumentTemplateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceDocumentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceDocumentTemplateId)!='undefined' || typeof(first.DocumentTemplateEntity)!='undefined' ) )
        {
            _request = sourceDocumentTemplateId as carriers.List_SetDocumentTemplateFromDocumentTemplateRequest;
            _options = documentTemplateEntity as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceDocumentTemplateId: sourceDocumentTemplateId as number,
                       DocumentTemplateEntity: documentTemplateEntity as carriers.DocumentTemplateEntity,
                       };   
            _options = webapi_options;
        }
        return this._SetDocumentTemplateFromDocumentTemplate( _request, _options );
    }


    private async _GetDocumentTemplateStreamFromId(request: carriers.List_GetDocumentTemplateStreamFromIdRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateStreamFromId", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve a stream to a document template based on its id
     * @param request - DocumentTemplateId, LanguageCode
     * @returns Open stream to the template content
     */
    public async GetDocumentTemplateStreamFromId(request: carriers.List_GetDocumentTemplateStreamFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Retrieve a stream to a document template based on its id
     * @param documentTemplateId - Id of template to retrieve
     * @param languageCode - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns Open stream to the template content
     */
    public async GetDocumentTemplateStreamFromId(documentTemplateId: number, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetDocumentTemplateStreamFromId(documentTemplateId:number|carriers.List_GetDocumentTemplateStreamFromIdRequest, languageCode?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.List_GetDocumentTemplateStreamFromIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' || typeof(first.LanguageCode)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_GetDocumentTemplateStreamFromIdRequest;
            _options = languageCode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       LanguageCode: languageCode as string,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentTemplateStreamFromId( _request, _options );
    }


    private async _SaveDocumentTemplateStream(request: carriers.List_SaveDocumentTemplateStreamRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TemplateInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDocumentTemplateStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TemplateInfo = converters.Create_TemplateInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Writes content in stream to document template file
     * @param request - DocumentTemplateId, Content, LanguageCode, PluginId
     * @returns Template info
     */
    public async SaveDocumentTemplateStream(request: carriers.List_SaveDocumentTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo >;

    /**
     * Writes content in stream to document template file
     * @param documentTemplateId - Identifier for document template
     * @param content - Stream containing content to be saved to document template file
     * @param languageCode - Language variation of template to update. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @param pluginId - Plugin to use for storing document content. 0 = SOARC. Use -1 to use the plugin specified in the template.
     * @returns Template info
     */
    public async SaveDocumentTemplateStream(documentTemplateId: number, content: ArrayBuffer|string, languageCode: string, pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo >;

    public async SaveDocumentTemplateStream(documentTemplateId:number|carriers.List_SaveDocumentTemplateStreamRequest, content?:ArrayBuffer|string|base.WebApiRequestOptions, languageCode?:string, pluginId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo > {
        let _request : carriers.List_SaveDocumentTemplateStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' || typeof(first.Content)!='undefined' || typeof(first.LanguageCode)!='undefined' || typeof(first.PluginId)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_SaveDocumentTemplateStreamRequest;
            _options = content as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       Content: content as ArrayBuffer|string,
                       LanguageCode: languageCode as string,
                       PluginId: pluginId as number,
                       };   
            _options = webapi_options;
        }
         _request.Content = ToBase64(_request.Content);
        return this._SaveDocumentTemplateStream( _request, _options );
    }


    private async _GetPluginList( options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPluginList", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get a list of installed document plugins
     * @returns Dictionary mapping plugin id=plugin name
     */
    public async GetPluginList(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >
    {
        return this._GetPluginList(webapi_options);
    }


    private async _GetPluginCapabilities(request: carriers.List_GetPluginCapabilitiesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPluginCapabilities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list of plugin-dependent capabilities for a given document archive plugin.&lt;br/&gt;A standard set of properties is defined in SuperOffice.CRM.Documents.Constants.Capabilities.
     * @param request - PluginId
     * @returns Dictionary mapping capability names=values
     */
    public async GetPluginCapabilities(request: carriers.List_GetPluginCapabilitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Get a list of plugin-dependent capabilities for a given document archive plugin.&lt;br/&gt;A standard set of properties is defined in SuperOffice.CRM.Documents.Constants.Capabilities.
     * @param pluginId - Numeric document plugin id, corresponding to the document.archiveProvider id or doctmpl.AutoeventId.
     * @returns Dictionary mapping capability names=values
     */
    public async GetPluginCapabilities(pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async GetPluginCapabilities(pluginId:number|carriers.List_GetPluginCapabilitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.List_GetPluginCapabilitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = pluginId;
        if( typeof( first ) === "object" && first && ( typeof(first.PluginId)!='undefined' ) )
        {
            _request = pluginId as carriers.List_GetPluginCapabilitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PluginId: pluginId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPluginCapabilities( _request, _options );
    }


    private async _GetDocumentTypesForPlugin(request: carriers.List_GetDocumentTypesForPluginRequest, options?:base.WebApiRequestOptions) : Promise< carriers.IntStringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.IntStringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTypesForPlugin", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.IntStringDictionary = converters.Create_IntStringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list of document types supported by a given document plugin. Use the document template type when creating a new template.
     * @param request - PluginId
     * @returns Dictionary mapping document type id=name
     */
    public async GetDocumentTypesForPlugin(request: carriers.List_GetDocumentTypesForPluginRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.IntStringDictionary >;

    /**
     * Get a list of document types supported by a given document plugin. Use the document template type when creating a new template.
     * @param pluginId - Numeric document plugin id, corresponding to the doctmpl.AutoeventId, doctmpl.LoadTemplateFromPlugin.
     * @returns Dictionary mapping document type id=name
     */
    public async GetDocumentTypesForPlugin(pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.IntStringDictionary >;

    public async GetDocumentTypesForPlugin(pluginId:number|carriers.List_GetDocumentTypesForPluginRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.IntStringDictionary > {
        let _request : carriers.List_GetDocumentTypesForPluginRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = pluginId;
        if( typeof( first ) === "object" && first && ( typeof(first.PluginId)!='undefined' ) )
        {
            _request = pluginId as carriers.List_GetDocumentTypesForPluginRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PluginId: pluginId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentTypesForPlugin( _request, _options );
    }

    /*
     * Gets an array of DocumentTemplate objects.
     * @param documentTemplateIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of DocumentTemplate
     */
    public async GetDocumentTemplateList(documentTemplateIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplate[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplate[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentTemplateList", documentTemplateIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetDocumentTemplates( options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplate[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplate[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplates", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentTemplate[] = converters.Create_DocumentTemplateArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all available document templates
     * @returns Array of DocumentTemplates
     */
    public async GetDocumentTemplates(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplate[] >
    {
        return this._GetDocumentTemplates(webapi_options);
    }


    private async _GetAllDocumentTemplates(request: carriers.List_GetAllDocumentTemplatesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentTemplateEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllDocumentTemplates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentTemplateEntity[] = converters.Create_DocumentTemplateEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all templates
     * @param request - IncludeDeleted
     * @returns Array of all template items
     */
    public async GetAllDocumentTemplates(request: carriers.List_GetAllDocumentTemplatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity[] >;

    /**
     * Returns all templates
     * @param includeDeleted - Include deleted items in result?
     * @returns Array of all template items
     */
    public async GetAllDocumentTemplates(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity[] >;

    public async GetAllDocumentTemplates(includeDeleted:boolean|carriers.List_GetAllDocumentTemplatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentTemplateEntity[] > {
        let _request : carriers.List_GetAllDocumentTemplatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.List_GetAllDocumentTemplatesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllDocumentTemplates( _request, _options );
    }


    private async _SetDocumentPluginForAllDocumentTemplates(request: carriers.List_SetDocumentPluginForAllDocumentTemplatesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentPluginForAllDocumentTemplates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets the document-plugin to be used for all templates of type &apos;document&apos;.
     * @param request - DocumentPluginId
     * @returns This method has no return value
     */
    public async SetDocumentPluginForAllDocumentTemplates(request: carriers.List_SetDocumentPluginForAllDocumentTemplatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sets the document-plugin to be used for all templates of type &apos;document&apos;.
     * @param documentPluginId - The numerical ID of the document-plugin to use.
     * @returns This method has no return value
     */
    public async SetDocumentPluginForAllDocumentTemplates(documentPluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetDocumentPluginForAllDocumentTemplates(documentPluginId:number|carriers.List_SetDocumentPluginForAllDocumentTemplatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetDocumentPluginForAllDocumentTemplatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentPluginId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentPluginId)!='undefined' ) )
        {
            _request = documentPluginId as carriers.List_SetDocumentPluginForAllDocumentTemplatesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentPluginId: documentPluginId as number,
                       };   
            _options = webapi_options;
        }
        return this._SetDocumentPluginForAllDocumentTemplates( _request, _options );
    }

    /*
     * Gets a ExtAppEntity object.
     * @param extAppEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ExtAppEntity
     */
    public async GetExtAppEntity(extAppEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ExtAppEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ExtAppEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetExtAppEntity?extAppEntityId=" + extAppEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ExtAppEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a HeadingEntity object.
     * @param headingEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single HeadingEntity
     */
    public async GetHeadingEntity(headingEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetHeadingEntity?headingEntityId=" + headingEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _CreateDefaultHeadingFromListDefinition(request: carriers.List_CreateDefaultHeadingFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultHeadingFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HeadingEntity = converters.Create_HeadingEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a heading for the specified list defintion
     * @param request - UdListDefinitionId
     * @returns The loaded heading
     */
    public async CreateDefaultHeadingFromListDefinition(request: carriers.List_CreateDefaultHeadingFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;

    /**
     * Get a heading for the specified list defintion
     * @param udListDefinitionId - The id of the list definition, indicating which list to get the item from
     * @returns The loaded heading
     */
    public async CreateDefaultHeadingFromListDefinition(udListDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;

    public async CreateDefaultHeadingFromListDefinition(udListDefinitionId:number|carriers.List_CreateDefaultHeadingFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity > {
        let _request : carriers.List_CreateDefaultHeadingFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_CreateDefaultHeadingFromListDefinitionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultHeadingFromListDefinition( _request, _options );
    }

    /*
     * Gets a HierarchyEntity object.
     * @param hierarchyEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single HierarchyEntity
     */
    public async GetHierarchyEntity(hierarchyEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HierarchyEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetHierarchyEntity?hierarchyEntityId=" + hierarchyEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HierarchyEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetAllDomains( options?:base.WebApiRequestOptions) : Promise< enums.Domain[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< enums.Domain[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllDomains", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : enums.Domain[] = response.data as enums.Domain[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get list of all domains
     * @returns Domain types (scripts, extra tables, etc)
     */
    public async GetAllDomains(webapi_options?:base.WebApiRequestOptions) : Promise< enums.Domain[] >
    {
        return this._GetAllDomains(webapi_options);
    }


    private async _GetAllInDomain(request: carriers.List_GetAllInDomainRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HierarchyEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllInDomain", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HierarchyEntity[] = converters.Create_HierarchyEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all items in a domain
     * @param request - Domain, Children
     * @returns All items and child items within a domain
     */
    public async GetAllInDomain(request: carriers.List_GetAllInDomainRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity[] >;

    /**
     * Get all items in a domain
     * @param domain - Type of items to get (scripts, extra tables, etc)
     * @param children - Include sub-items?
     * @returns All items and child items within a domain
     */
    public async GetAllInDomain(domain: enums.Domain, children: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity[] >;

    public async GetAllInDomain(domain:enums.Domain|carriers.List_GetAllInDomainRequest, children?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity[] > {
        let _request : carriers.List_GetAllInDomainRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = domain;
        if( typeof( first ) === "object" && first && ( typeof(first.Domain)!='undefined' || typeof(first.Children)!='undefined' ) )
        {
            _request = domain as carriers.List_GetAllInDomainRequest;
            _options = children as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Domain: domain as enums.Domain,
                       Children: children as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllInDomain( _request, _options );
    }


    private async _GetHierarchyFromPath(request: carriers.List_GetHierarchyFromPathRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HierarchyEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHierarchyFromPath", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HierarchyEntity = converters.Create_HierarchyEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a hierarchy item from a path
     * @param request - Domain, Path, Children
     * @returns The hierarchy node at the path
     */
    public async GetHierarchyFromPath(request: carriers.List_GetHierarchyFromPathRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;

    /**
     * Get a hierarchy item from a path
     * @param domain - Type of items to get
     * @param path - Hierarchy path to item
     * @param children - Include sub-items?
     * @returns The hierarchy node at the path
     */
    public async GetHierarchyFromPath(domain: enums.Domain, path: string, children: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;

    public async GetHierarchyFromPath(domain:enums.Domain|carriers.List_GetHierarchyFromPathRequest, path?:string|base.WebApiRequestOptions, children?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity > {
        let _request : carriers.List_GetHierarchyFromPathRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = domain;
        if( typeof( first ) === "object" && first && ( typeof(first.Domain)!='undefined' || typeof(first.Path)!='undefined' || typeof(first.Children)!='undefined' ) )
        {
            _request = domain as carriers.List_GetHierarchyFromPathRequest;
            _options = path as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Domain: domain as enums.Domain,
                       Path: path as string,
                       Children: children as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetHierarchyFromPath( _request, _options );
    }


    private async _AddHierarchyToPath(request: carriers.List_AddHierarchyToPathRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HierarchyEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddHierarchyToPath", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HierarchyEntity = converters.Create_HierarchyEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add a hierarchy item to a path
     * @param request - Domain, Path, Name
     * @returns The hierarchy node added to the path
     */
    public async AddHierarchyToPath(request: carriers.List_AddHierarchyToPathRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;

    /**
     * Add a hierarchy item to a path
     * @param domain - Type of items to get
     * @param path - Hierarchy path to parent item
     * @param name - Name of node to add
     * @returns The hierarchy node added to the path
     */
    public async AddHierarchyToPath(domain: enums.Domain, path: string, name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;

    public async AddHierarchyToPath(domain:enums.Domain|carriers.List_AddHierarchyToPathRequest, path?:string|base.WebApiRequestOptions, name?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity > {
        let _request : carriers.List_AddHierarchyToPathRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = domain;
        if( typeof( first ) === "object" && first && ( typeof(first.Domain)!='undefined' || typeof(first.Path)!='undefined' || typeof(first.Name)!='undefined' ) )
        {
            _request = domain as carriers.List_AddHierarchyToPathRequest;
            _options = path as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Domain: domain as enums.Domain,
                       Path: path as string,
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._AddHierarchyToPath( _request, _options );
    }


    private async _UpdateHierarchyFromPath(request: carriers.List_UpdateHierarchyFromPathRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HierarchyEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateHierarchyFromPath", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HierarchyEntity = converters.Create_HierarchyEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update a hierarchy item from a path
     * @param request - Domain, Path, Entity
     * @returns The hierarchy node updated to the path
     */
    public async UpdateHierarchyFromPath(request: carriers.List_UpdateHierarchyFromPathRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;

    /**
     * Update a hierarchy item from a path
     * @param domain - Type of items to get
     * @param path - Hierarchy path to item
     * @param entity - The hierarchy node to update.
     * @returns The hierarchy node updated to the path
     */
    public async UpdateHierarchyFromPath(domain: enums.Domain, path: string, entity: carriers.HierarchyEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity >;

    public async UpdateHierarchyFromPath(domain:enums.Domain|carriers.List_UpdateHierarchyFromPathRequest, path?:string|base.WebApiRequestOptions, entity?:carriers.HierarchyEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HierarchyEntity > {
        let _request : carriers.List_UpdateHierarchyFromPathRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = domain;
        if( typeof( first ) === "object" && first && ( typeof(first.Domain)!='undefined' || typeof(first.Path)!='undefined' || typeof(first.Entity)!='undefined' ) )
        {
            _request = domain as carriers.List_UpdateHierarchyFromPathRequest;
            _options = path as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Domain: domain as enums.Domain,
                       Path: path as string,
                       Entity: entity as carriers.HierarchyEntity,
                       };   
            _options = webapi_options;
        }
        return this._UpdateHierarchyFromPath( _request, _options );
    }


    private async _DeleteHierarchyFromPath(request: carriers.List_DeleteHierarchyFromPathRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteHierarchyFromPath", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove a hierarchy item and its children from a path
     * @param request - Domain, Path
     * @returns This method has no return value
     */
    public async DeleteHierarchyFromPath(request: carriers.List_DeleteHierarchyFromPathRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Remove a hierarchy item and its children from a path
     * @param domain - Type of items to get
     * @param path - Hierarchy path to item to delete
     * @returns This method has no return value
     */
    public async DeleteHierarchyFromPath(domain: enums.Domain, path: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteHierarchyFromPath(domain:enums.Domain|carriers.List_DeleteHierarchyFromPathRequest, path?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteHierarchyFromPathRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = domain;
        if( typeof( first ) === "object" && first && ( typeof(first.Domain)!='undefined' || typeof(first.Path)!='undefined' ) )
        {
            _request = domain as carriers.List_DeleteHierarchyFromPathRequest;
            _options = path as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Domain: domain as enums.Domain,
                       Path: path as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteHierarchyFromPath( _request, _options );
    }

    /*
     * Gets a LanguageInfo object.
     * @param languageInfoId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single LanguageInfo
     */
    public async GetLanguageInfo(languageInfoId: number, options?:base.WebApiRequestOptions) : Promise< carriers.LanguageInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LanguageInfo >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLanguageInfo?languageInfoId=" + languageInfoId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LanguageInfo_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of LanguageInfo objects.
     * @param languageInfoIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of LanguageInfo
     */
    public async GetLanguageInfoList(languageInfoIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.LanguageInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LanguageInfo[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLanguageInfoList", languageInfoIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LanguageInfoArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetInstalledLanguages( options?:base.WebApiRequestOptions) : Promise< carriers.LanguageInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LanguageInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetInstalledLanguages", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.LanguageInfo[] = converters.Create_LanguageInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns the list of all languages installed in this database.
     * @returns Array of installed languages
     */
    public async GetInstalledLanguages(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LanguageInfo[] >
    {
        return this._GetInstalledLanguages(webapi_options);
    }

    /*
     * Gets a LegalBase object.
     * @param legalBaseId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single LegalBase
     */
    public async GetLegalBase(legalBaseId: number, options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LegalBase >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLegalBase?legalBaseId=" + legalBaseId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LegalBase_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SaveLegalBase(request: carriers.List_SaveLegalBaseRequest, options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LegalBase >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveLegalBase", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.LegalBase = converters.Create_LegalBase_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - LegalBase
     * @returns 
     */
    public async SaveLegalBase(request: carriers.List_SaveLegalBaseRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase >;

    /**
     * 
     * @param legalBase - 
     * @returns 
     */
    public async SaveLegalBase(legalBase: carriers.LegalBase, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase >;

    public async SaveLegalBase(legalBase:carriers.LegalBase|carriers.List_SaveLegalBaseRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase > {
        let _request : carriers.List_SaveLegalBaseRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = legalBase;
        if( typeof( first ) === "object" && first && ( typeof(first.LegalBase)!='undefined' ) )
        {
            _request = legalBase as carriers.List_SaveLegalBaseRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       LegalBase: legalBase as carriers.LegalBase,
                       };   
            _options = webapi_options;
        }
        return this._SaveLegalBase( _request, _options );
    }

    /*
     * Gets an array of LegalBase objects.
     * @param legalBaseIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of LegalBase
     */
    public async GetLegalBaseList(legalBaseIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LegalBase[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLegalBaseList", legalBaseIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LegalBaseArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetLegalBases( options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LegalBase[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLegalBases", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.LegalBase[] = converters.Create_LegalBaseArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all defined bases.
     * @returns An array of all defined bases
     */
    public async GetLegalBases(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LegalBase[] >
    {
        return this._GetLegalBases(webapi_options);
    }

    /*
     * Gets a Link object.
     * @param linkId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Link
     */
    public async GetLink(linkId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Link > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Link >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLink?linkId=" + linkId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Link_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Link objects.
     * @param linkIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Link
     */
    public async GetLinkList(linkIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Link[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Link[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLinkList", linkIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LinkArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a ListEntity object.
     * @param listEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ListEntity
     */
    public async GetListEntity(listEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetListEntity?listEntityId=" + listEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetListDefinitions(request: carriers.List_GetListDefinitionsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListDefinitions", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListEntity[] = converters.Create_ListEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list of the lists - built-in and user-defined.
     * @param request - IncludeDeleted
     * @returns The list definitions
     */
    public async GetListDefinitions(request: carriers.List_GetListDefinitionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity[] >;

    /**
     * Get a list of the lists - built-in and user-defined.
     * @param includeDeleted - Include deleted items in result?
     * @returns The list definitions
     */
    public async GetListDefinitions(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity[] >;

    public async GetListDefinitions(includeDeleted:boolean|carriers.List_GetListDefinitionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity[] > {
        let _request : carriers.List_GetListDefinitionsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.List_GetListDefinitionsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetListDefinitions( _request, _options );
    }


    private async _GetListEntityByName(request: carriers.List_GetListEntityByNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListEntityByName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListEntity = converters.Create_ListEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a ListEntity resolved by the provided name.
     * @param request - Name
     * @returns A ListEntity or null.
     */
    public async GetListEntityByName(request: carriers.List_GetListEntityByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity >;

    /**
     * Gets a ListEntity resolved by the provided name.
     * @param name - The name of the list to look up.
     * @returns A ListEntity or null.
     */
    public async GetListEntityByName(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity >;

    public async GetListEntityByName(name:string|carriers.List_GetListEntityByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity > {
        let _request : carriers.List_GetListEntityByNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' ) )
        {
            _request = name as carriers.List_GetListEntityByNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._GetListEntityByName( _request, _options );
    }


    private async _SaveListEntityByName(request: carriers.List_SaveListEntityByNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveListEntityByName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListEntity = converters.Create_ListEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a ListEntity resolved by the provided name.
     * @param request - Name, ListEntity
     * @returns A ListEntity or null.
     */
    public async SaveListEntityByName(request: carriers.List_SaveListEntityByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity >;

    /**
     * Save a ListEntity resolved by the provided name.
     * @param name - The name of the list to save.
     * @param listEntity - The ListEntity to save.
     * @returns A ListEntity or null.
     */
    public async SaveListEntityByName(name: string, listEntity: carriers.ListEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity >;

    public async SaveListEntityByName(name:string|carriers.List_SaveListEntityByNameRequest, listEntity?:carriers.ListEntity|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListEntity > {
        let _request : carriers.List_SaveListEntityByNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' || typeof(first.ListEntity)!='undefined' ) )
        {
            _request = name as carriers.List_SaveListEntityByNameRequest;
            _options = listEntity as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       ListEntity: listEntity as carriers.ListEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveListEntityByName( _request, _options );
    }


    private async _DeleteListEntityByName(request: carriers.List_DeleteListEntityByNameRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteListEntityByName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a ListEntity resolved by the provided name.
     * @param request - Name
     * @returns This method has no return value
     */
    public async DeleteListEntityByName(request: carriers.List_DeleteListEntityByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a ListEntity resolved by the provided name.
     * @param name - The name of the list to delete.
     * @returns This method has no return value
     */
    public async DeleteListEntityByName(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteListEntityByName(name:string|carriers.List_DeleteListEntityByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteListEntityByNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' ) )
        {
            _request = name as carriers.List_DeleteListEntityByNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteListEntityByName( _request, _options );
    }


    private async _SaveListItemEntity(request: carriers.List_SaveListItemEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveListItemEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity = converters.Create_ListItemEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save the ListItemEntity.
     * @param request - ListItemEntity
     * @returns The saved ListItemEntity.
     */
    public async SaveListItemEntity(request: carriers.List_SaveListItemEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    /**
     * Save the ListItemEntity.
     * @param listItemEntity - The ListItemEntity to save.
     * @returns The saved ListItemEntity.
     */
    public async SaveListItemEntity(listItemEntity: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    public async SaveListItemEntity(listItemEntity:carriers.ListItemEntity|carriers.List_SaveListItemEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        let _request : carriers.List_SaveListItemEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = listItemEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.ListItemEntity)!='undefined' ) )
        {
            _request = listItemEntity as carriers.List_SaveListItemEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ListItemEntity: listItemEntity as carriers.ListItemEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveListItemEntity( _request, _options );
    }


    private async _SortListItems(request: carriers.List_SortListItemsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SortListItems", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sort the list items in a given list alphabetically
     * @param request - UdListDefinitionId, CultureName
     * @returns 
     */
    public async SortListItems(request: carriers.List_SortListItemsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sort the list items in a given list alphabetically
     * @param udListDefinitionId - Id of the list you want to sort. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param cultureName - Sort list in this language
     * @returns 
     */
    public async SortListItems(udListDefinitionId: number, cultureName: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SortListItems(udListDefinitionId:number|carriers.List_SortListItemsRequest, cultureName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SortListItemsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.CultureName)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_SortListItemsRequest;
            _options = cultureName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       CultureName: cultureName as string,
                       };   
            _options = webapi_options;
        }
        return this._SortListItems( _request, _options );
    }


    private async _MoveListItem(request: carriers.List_MoveListItemRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveListItem", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Move a list item up or down in the list based on rank
     * @param request - UdListDefinitionId, ListItemId, Direction
     * @returns 
     */
    public async MoveListItem(request: carriers.List_MoveListItemRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Move a list item up or down in the list based on rank
     * @param udListDefinitionId - Id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param listItemId - Id of the list item
     * @param direction - -1 moves the item up one position, 1 moves the item down one position
     * @returns 
     */
    public async MoveListItem(udListDefinitionId: number, listItemId: number, direction: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MoveListItem(udListDefinitionId:number|carriers.List_MoveListItemRequest, listItemId?:number|base.WebApiRequestOptions, direction?:number, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_MoveListItemRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.ListItemId)!='undefined' || typeof(first.Direction)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_MoveListItemRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       ListItemId: listItemId as number,
                       Direction: direction as number,
                       };   
            _options = webapi_options;
        }
        return this._MoveListItem( _request, _options );
    }


    private async _GetVisibleForUserGroups(request: carriers.List_GetVisibleForUserGroupsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetVisibleForUserGroups", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * List of User groups that this list item is visible for
     * @param request - UdListDefinitionId, ListItemId
     * @returns Array of selectable user groups
     */
    public async GetVisibleForUserGroups(request: carriers.List_GetVisibleForUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * List of User groups that this list item is visible for
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param listItemId - The id of the list item
     * @returns Array of selectable user groups
     */
    public async GetVisibleForUserGroups(udListDefinitionId: number, listItemId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetVisibleForUserGroups(udListDefinitionId:number|carriers.List_GetVisibleForUserGroupsRequest, listItemId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_GetVisibleForUserGroupsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.ListItemId)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_GetVisibleForUserGroupsRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       ListItemId: listItemId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetVisibleForUserGroups( _request, _options );
    }


    private async _GetVisibleForUserGroupsFromListName(request: carriers.List_GetVisibleForUserGroupsFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetVisibleForUserGroupsFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * List of User groups that this list item is visible for
     * @param request - UdListDefinitionName, ListItemId
     * @returns Array of selectable user groups
     */
    public async GetVisibleForUserGroupsFromListName(request: carriers.List_GetVisibleForUserGroupsFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * List of User groups that this list item is visible for
     * @param udListDefinitionName - The name of the list definition.
     * @param listItemId - The id of the list item
     * @returns Array of selectable user groups
     */
    public async GetVisibleForUserGroupsFromListName(udListDefinitionName: string, listItemId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetVisibleForUserGroupsFromListName(udListDefinitionName:string|carriers.List_GetVisibleForUserGroupsFromListNameRequest, listItemId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_GetVisibleForUserGroupsFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.ListItemId)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_GetVisibleForUserGroupsFromListNameRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       ListItemId: listItemId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetVisibleForUserGroupsFromListName( _request, _options );
    }


    private async _SetVisibleForUserGroups(request: carriers.List_SetVisibleForUserGroupsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetVisibleForUserGroups", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update User groups that this list item is visible for
     * @param request - UdListDefinitionId, ListItemId, UserGroups
     * @returns Array of selectable user groups
     */
    public async SetVisibleForUserGroups(request: carriers.List_SetVisibleForUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * Update User groups that this list item is visible for
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param listItemId - The id of the list item
     * @param userGroups - The selectable user groups.
     * @returns Array of selectable user groups
     */
    public async SetVisibleForUserGroups(udListDefinitionId: number, listItemId: number, userGroups: carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async SetVisibleForUserGroups(udListDefinitionId:number|carriers.List_SetVisibleForUserGroupsRequest, listItemId?:number|base.WebApiRequestOptions, userGroups?:carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_SetVisibleForUserGroupsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.ListItemId)!='undefined' || typeof(first.UserGroups)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_SetVisibleForUserGroupsRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       ListItemId: listItemId as number,
                       UserGroups: userGroups as carriers.SelectableMDOListItem[],
                       };   
            _options = webapi_options;
        }
        return this._SetVisibleForUserGroups( _request, _options );
    }


    private async _SetVisibleForUserGroupsFromListName(request: carriers.List_SetVisibleForUserGroupsFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetVisibleForUserGroupsFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update User groups that this list item is visible for
     * @param request - UdListDefinitionName, ListItemId, UserGroups
     * @returns Array of selectable user groups
     */
    public async SetVisibleForUserGroupsFromListName(request: carriers.List_SetVisibleForUserGroupsFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * Update User groups that this list item is visible for
     * @param udListDefinitionName - The name of the list definition, indicating which list to update the items from.
     * @param listItemId - The id of the list item
     * @param userGroups - The selectable user groups.
     * @returns Array of selectable user groups
     */
    public async SetVisibleForUserGroupsFromListName(udListDefinitionName: string, listItemId: number, userGroups: carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async SetVisibleForUserGroupsFromListName(udListDefinitionName:string|carriers.List_SetVisibleForUserGroupsFromListNameRequest, listItemId?:number|base.WebApiRequestOptions, userGroups?:carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_SetVisibleForUserGroupsFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.ListItemId)!='undefined' || typeof(first.UserGroups)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_SetVisibleForUserGroupsFromListNameRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       ListItemId: listItemId as number,
                       UserGroups: userGroups as carriers.SelectableMDOListItem[],
                       };   
            _options = webapi_options;
        }
        return this._SetVisibleForUserGroupsFromListName( _request, _options );
    }


    private async _SetVisibleForUserGroup(request: carriers.List_SetVisibleForUserGroupRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetVisibleForUserGroup", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set a group which this list item should be visible for
     * @param request - UdListDefinitionId, ListItemId, UserGroupId, Enable
     * @returns 
     */
    public async SetVisibleForUserGroup(request: carriers.List_SetVisibleForUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set a group which this list item should be visible for
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param listItemId - The id of the list item
     * @param userGroupId - The id of the user groups to set for this list item
     * @param enable - Set to true to enable, false to disable
     * @returns 
     */
    public async SetVisibleForUserGroup(udListDefinitionId: number, listItemId: number, userGroupId: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetVisibleForUserGroup(udListDefinitionId:number|carriers.List_SetVisibleForUserGroupRequest, listItemId?:number|base.WebApiRequestOptions, userGroupId?:number[], enable?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetVisibleForUserGroupRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.ListItemId)!='undefined' || typeof(first.UserGroupId)!='undefined' || typeof(first.Enable)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_SetVisibleForUserGroupRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       ListItemId: listItemId as number,
                       UserGroupId: userGroupId as number[],
                       Enable: enable as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetVisibleForUserGroup( _request, _options );
    }


    private async _GetListItemsForUserGroup(request: carriers.List_GetListItemsForUserGroupRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListItemsForUserGroup", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * List of list items that is visible in the usergroup
     * @param request - UdListDefinitionId, GroupId
     * @returns Array of selectable list items
     */
    public async GetListItemsForUserGroup(request: carriers.List_GetListItemsForUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * List of list items that is visible in the usergroup
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param groupId - The id of the usergroup
     * @returns Array of selectable list items
     */
    public async GetListItemsForUserGroup(udListDefinitionId: number, groupId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetListItemsForUserGroup(udListDefinitionId:number|carriers.List_GetListItemsForUserGroupRequest, groupId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_GetListItemsForUserGroupRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.GroupId)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_GetListItemsForUserGroupRequest;
            _options = groupId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       GroupId: groupId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetListItemsForUserGroup( _request, _options );
    }


    private async _GetListItemsForUserGroupFromListName(request: carriers.List_GetListItemsForUserGroupFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListItemsForUserGroupFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * List of list items that is visible in the usergroup
     * @param request - UdListDefinitionName, GroupId
     * @returns Array of selectable list items
     */
    public async GetListItemsForUserGroupFromListName(request: carriers.List_GetListItemsForUserGroupFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * List of list items that is visible in the usergroup
     * @param udListDefinitionName - The name of the list definition.
     * @param groupId - The id of the usergroup
     * @returns Array of selectable list items
     */
    public async GetListItemsForUserGroupFromListName(udListDefinitionName: string, groupId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetListItemsForUserGroupFromListName(udListDefinitionName:string|carriers.List_GetListItemsForUserGroupFromListNameRequest, groupId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_GetListItemsForUserGroupFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.GroupId)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_GetListItemsForUserGroupFromListNameRequest;
            _options = groupId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       GroupId: groupId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetListItemsForUserGroupFromListName( _request, _options );
    }


    private async _SetListItemsForUserGroup(request: carriers.List_SetListItemsForUserGroupRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetListItemsForUserGroup", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update listItems that will be visible for this usergroup
     * @param request - UdListDefinitionId, UsergroupId, ListItemIds, Enable
     * @returns 
     */
    public async SetListItemsForUserGroup(request: carriers.List_SetListItemsForUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Update listItems that will be visible for this usergroup
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param usergroupId - The id of the userGroup
     * @param listItemIds - The id of the list items.
     * @param enable - True to enable, false to disable
     * @returns 
     */
    public async SetListItemsForUserGroup(udListDefinitionId: number, usergroupId: number, listItemIds: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetListItemsForUserGroup(udListDefinitionId:number|carriers.List_SetListItemsForUserGroupRequest, usergroupId?:number|base.WebApiRequestOptions, listItemIds?:number[], enable?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetListItemsForUserGroupRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.UsergroupId)!='undefined' || typeof(first.ListItemIds)!='undefined' || typeof(first.Enable)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_SetListItemsForUserGroupRequest;
            _options = usergroupId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       UsergroupId: usergroupId as number,
                       ListItemIds: listItemIds as number[],
                       Enable: enable as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetListItemsForUserGroup( _request, _options );
    }


    private async _SetListItemsForUserGroupFromListName(request: carriers.List_SetListItemsForUserGroupFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetListItemsForUserGroupFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update listItems that will be visible for this usergroup
     * @param request - UdListDefinitionName, UsergroupId, ListItemsID, Enable
     * @returns 
     */
    public async SetListItemsForUserGroupFromListName(request: carriers.List_SetListItemsForUserGroupFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Update listItems that will be visible for this usergroup
     * @param udListDefinitionName - The name of the list definition.
     * @param usergroupId - The id of the userGroup
     * @param listItemsID - The id of the list items.
     * @param enable - True to enable, false to disable
     * @returns 
     */
    public async SetListItemsForUserGroupFromListName(udListDefinitionName: string, usergroupId: number, listItemsID: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetListItemsForUserGroupFromListName(udListDefinitionName:string|carriers.List_SetListItemsForUserGroupFromListNameRequest, usergroupId?:number|base.WebApiRequestOptions, listItemsID?:number[], enable?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetListItemsForUserGroupFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.UsergroupId)!='undefined' || typeof(first.ListItemsID)!='undefined' || typeof(first.Enable)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_SetListItemsForUserGroupFromListNameRequest;
            _options = usergroupId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       UsergroupId: usergroupId as number,
                       ListItemsID: listItemsID as number[],
                       Enable: enable as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetListItemsForUserGroupFromListName( _request, _options );
    }


    private async _GetHeadings(request: carriers.List_GetHeadingsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHeadings", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a selectable MDO list of the headings for this list item
     * @param request - UdListDefinitionId, ListItemId, ShowDeleted
     * @returns Array of headings
     */
    public async GetHeadings(request: carriers.List_GetHeadingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * Gets a selectable MDO list of the headings for this list item
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param listItemId - The id of the list item
     * @param showDeleted - Set to true if you want deleted headings
     * @returns Array of headings
     */
    public async GetHeadings(udListDefinitionId: number, listItemId: number, showDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetHeadings(udListDefinitionId:number|carriers.List_GetHeadingsRequest, listItemId?:number|base.WebApiRequestOptions, showDeleted?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_GetHeadingsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.ListItemId)!='undefined' || typeof(first.ShowDeleted)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_GetHeadingsRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       ListItemId: listItemId as number,
                       ShowDeleted: showDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetHeadings( _request, _options );
    }


    private async _GetHeadingsForListItemFromListName(request: carriers.List_GetHeadingsForListItemFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHeadingsForListItemFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a selectable MDO list of the headings for this list item
     * @param request - UdListDefinitionName, ListItemId, ShowDeleted
     * @returns Array of headings
     */
    public async GetHeadingsForListItemFromListName(request: carriers.List_GetHeadingsForListItemFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * Gets a selectable MDO list of the headings for this list item
     * @param udListDefinitionName - The name of the list definition, indicating which list to delete the items from.
     * @param listItemId - The id of the list item
     * @param showDeleted - Set to true if you want deleted headings
     * @returns Array of headings
     */
    public async GetHeadingsForListItemFromListName(udListDefinitionName: string, listItemId: number, showDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetHeadingsForListItemFromListName(udListDefinitionName:string|carriers.List_GetHeadingsForListItemFromListNameRequest, listItemId?:number|base.WebApiRequestOptions, showDeleted?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_GetHeadingsForListItemFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.ListItemId)!='undefined' || typeof(first.ShowDeleted)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_GetHeadingsForListItemFromListNameRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       ListItemId: listItemId as number,
                       ShowDeleted: showDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetHeadingsForListItemFromListName( _request, _options );
    }


    private async _SaveHeadingsForListItemFromListDefinition(request: carriers.List_SaveHeadingsForListItemFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingsForListItemFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the active headings for the list item.
     * @param request - UdListDefinitionId, ListItemId, Headings
     * @returns Array of headings
     */
    public async SaveHeadingsForListItemFromListDefinition(request: carriers.List_SaveHeadingsForListItemFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * Saves the active headings for the list item.
     * @param udListDefinitionId - The id of the list definition, indicating which list to delete the items from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param listItemId - The identity of the list item to delete
     * @param headings - The headings to save.
     * @returns Array of headings
     */
    public async SaveHeadingsForListItemFromListDefinition(udListDefinitionId: number, listItemId: number, headings: carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async SaveHeadingsForListItemFromListDefinition(udListDefinitionId:number|carriers.List_SaveHeadingsForListItemFromListDefinitionRequest, listItemId?:number|base.WebApiRequestOptions, headings?:carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_SaveHeadingsForListItemFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.ListItemId)!='undefined' || typeof(first.Headings)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_SaveHeadingsForListItemFromListDefinitionRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       ListItemId: listItemId as number,
                       Headings: headings as carriers.SelectableMDOListItem[],
                       };   
            _options = webapi_options;
        }
        return this._SaveHeadingsForListItemFromListDefinition( _request, _options );
    }


    private async _SaveHeadingsForListItemFromListName(request: carriers.List_SaveHeadingsForListItemFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingsForListItemFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the headings for the list item.
     * @param request - UdListDefinitionName, ListItemId, Headings
     * @returns Array of selectable headings 
     */
    public async SaveHeadingsForListItemFromListName(request: carriers.List_SaveHeadingsForListItemFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * Saves the headings for the list item.
     * @param udListDefinitionName - The name of the list definition, indicating which list to update.
     * @param listItemId - The identity of the list item
     * @param headings - The headings to save.
     * @returns Array of selectable headings 
     */
    public async SaveHeadingsForListItemFromListName(udListDefinitionName: string, listItemId: number, headings: carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async SaveHeadingsForListItemFromListName(udListDefinitionName:string|carriers.List_SaveHeadingsForListItemFromListNameRequest, listItemId?:number|base.WebApiRequestOptions, headings?:carriers.SelectableMDOListItem[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_SaveHeadingsForListItemFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.ListItemId)!='undefined' || typeof(first.Headings)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_SaveHeadingsForListItemFromListNameRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       ListItemId: listItemId as number,
                       Headings: headings as carriers.SelectableMDOListItem[],
                       };   
            _options = webapi_options;
        }
        return this._SaveHeadingsForListItemFromListName( _request, _options );
    }


    private async _GetListItemsForHeading(request: carriers.List_GetListItemsForHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListItemsForHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * List of list items that is selected if under this heading
     * @param request - UdListDefinitionId, HeadingId
     * @returns Array of selectable list items
     */
    public async GetListItemsForHeading(request: carriers.List_GetListItemsForHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * List of list items that is selected if under this heading
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param headingId - The id of the heading
     * @returns Array of selectable list items
     */
    public async GetListItemsForHeading(udListDefinitionId: number, headingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetListItemsForHeading(udListDefinitionId:number|carriers.List_GetListItemsForHeadingRequest, headingId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_GetListItemsForHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.HeadingId)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_GetListItemsForHeadingRequest;
            _options = headingId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       HeadingId: headingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetListItemsForHeading( _request, _options );
    }


    private async _GetListItemsForHeadingFromListName(request: carriers.List_GetListItemsForHeadingFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectableMDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListItemsForHeadingFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectableMDOListItem[] = converters.Create_SelectableMDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * List of list items that is selected if under this heading
     * @param request - UdListDefinitionName, HeadingId
     * @returns Array of selectable list items
     */
    public async GetListItemsForHeadingFromListName(request: carriers.List_GetListItemsForHeadingFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    /**
     * List of list items that is selected if under this heading
     * @param udListDefinitionName - The name of the list definition.
     * @param headingId - The id of the heading
     * @returns Array of selectable list items
     */
    public async GetListItemsForHeadingFromListName(udListDefinitionName: string, headingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] >;

    public async GetListItemsForHeadingFromListName(udListDefinitionName:string|carriers.List_GetListItemsForHeadingFromListNameRequest, headingId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectableMDOListItem[] > {
        let _request : carriers.List_GetListItemsForHeadingFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.HeadingId)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_GetListItemsForHeadingFromListNameRequest;
            _options = headingId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       HeadingId: headingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetListItemsForHeadingFromListName( _request, _options );
    }


    private async _SetListItemsForHeading(request: carriers.List_SetListItemsForHeadingRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetListItemsForHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update listItems that will be visible for this usergroup
     * @param request - UdListDefinitionId, HeadingId, ListItemIds, Enable
     * @returns 
     */
    public async SetListItemsForHeading(request: carriers.List_SetListItemsForHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Update listItems that will be visible for this usergroup
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param headingId - The id of the heading
     * @param listItemIds - The ids of the list items.
     * @param enable - True to enable, false to disable
     * @returns 
     */
    public async SetListItemsForHeading(udListDefinitionId: number, headingId: number, listItemIds: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetListItemsForHeading(udListDefinitionId:number|carriers.List_SetListItemsForHeadingRequest, headingId?:number|base.WebApiRequestOptions, listItemIds?:number[], enable?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetListItemsForHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.HeadingId)!='undefined' || typeof(first.ListItemIds)!='undefined' || typeof(first.Enable)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_SetListItemsForHeadingRequest;
            _options = headingId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       HeadingId: headingId as number,
                       ListItemIds: listItemIds as number[],
                       Enable: enable as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetListItemsForHeading( _request, _options );
    }


    private async _SetListItemsForHeadingFromListName(request: carriers.List_SetListItemsForHeadingFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetListItemsForHeadingFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update listItems under this heading
     * @param request - UdListDefinitionName, HeadingId, ListItemIds, Enable
     * @returns 
     */
    public async SetListItemsForHeadingFromListName(request: carriers.List_SetListItemsForHeadingFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Update listItems under this heading
     * @param udListDefinitionName - The name of the list definition.
     * @param headingId - The id of the heading
     * @param listItemIds - The ids of the list items.
     * @param enable - True to enable, false to disable
     * @returns 
     */
    public async SetListItemsForHeadingFromListName(udListDefinitionName: string, headingId: number, listItemIds: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetListItemsForHeadingFromListName(udListDefinitionName:string|carriers.List_SetListItemsForHeadingFromListNameRequest, headingId?:number|base.WebApiRequestOptions, listItemIds?:number[], enable?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetListItemsForHeadingFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.HeadingId)!='undefined' || typeof(first.ListItemIds)!='undefined' || typeof(first.Enable)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_SetListItemsForHeadingFromListNameRequest;
            _options = headingId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       HeadingId: headingId as number,
                       ListItemIds: listItemIds as number[],
                       Enable: enable as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetListItemsForHeadingFromListName( _request, _options );
    }


    private async _SetHeadingsForListItem(request: carriers.List_SetHeadingsForListItemRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetHeadingsForListItem", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set headings which this list item should be listed under
     * @param request - UdListDefinitionId, ListItemId, HeadingIds, Enable
     * @returns 
     */
    public async SetHeadingsForListItem(request: carriers.List_SetHeadingsForListItemRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set headings which this list item should be listed under
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param listItemId - The id of the list item
     * @param headingIds - The ids of the headings to set for this list item
     * @param enable - Set to true to enable, false to disable
     * @returns 
     */
    public async SetHeadingsForListItem(udListDefinitionId: number, listItemId: number, headingIds: number[], enable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetHeadingsForListItem(udListDefinitionId:number|carriers.List_SetHeadingsForListItemRequest, listItemId?:number|base.WebApiRequestOptions, headingIds?:number[], enable?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetHeadingsForListItemRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.ListItemId)!='undefined' || typeof(first.HeadingIds)!='undefined' || typeof(first.Enable)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_SetHeadingsForListItemRequest;
            _options = listItemId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       ListItemId: listItemId as number,
                       HeadingIds: headingIds as number[],
                       Enable: enable as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetHeadingsForListItem( _request, _options );
    }


    private async _SetRankOnHeadings(request: carriers.List_SetRankOnHeadingsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnHeadings", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set rank order on headings
     * @param request - UdListDefinitionId, HeadingIds
     * @returns 
     */
    public async SetRankOnHeadings(request: carriers.List_SetRankOnHeadingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set rank order on headings
     * @param udListDefinitionId - The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param headingIds - The ids of the headings in the order you want
     * @returns 
     */
    public async SetRankOnHeadings(udListDefinitionId: number, headingIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetRankOnHeadings(udListDefinitionId:number|carriers.List_SetRankOnHeadingsRequest, headingIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetRankOnHeadingsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.HeadingIds)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_SetRankOnHeadingsRequest;
            _options = headingIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       HeadingIds: headingIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetRankOnHeadings( _request, _options );
    }


    private async _SetRankOnSaleActivity(request: carriers.List_SetRankOnSaleActivityRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnSaleActivity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set rank order on sale activity
     * @param request - SaleTypeStageLinkId, ItemsIds
     * @returns 
     */
    public async SetRankOnSaleActivity(request: carriers.List_SetRankOnSaleActivityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set rank order on sale activity
     * @param saleTypeStageLinkId - The id of the list
     * @param itemsIds - The ids of the items in the order you want
     * @returns 
     */
    public async SetRankOnSaleActivity(saleTypeStageLinkId: number, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetRankOnSaleActivity(saleTypeStageLinkId:number|carriers.List_SetRankOnSaleActivityRequest, itemsIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetRankOnSaleActivityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleTypeStageLinkId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleTypeStageLinkId)!='undefined' || typeof(first.ItemsIds)!='undefined' ) )
        {
            _request = saleTypeStageLinkId as carriers.List_SetRankOnSaleActivityRequest;
            _options = itemsIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleTypeStageLinkId: saleTypeStageLinkId as number,
                       ItemsIds: itemsIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetRankOnSaleActivity( _request, _options );
    }


    private async _SetRankOnSaleDocument(request: carriers.List_SetRankOnSaleDocumentRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnSaleDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set rank order on project document
     * @param request - SaleTypeStageLinkId, ItemsIds
     * @returns 
     */
    public async SetRankOnSaleDocument(request: carriers.List_SetRankOnSaleDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set rank order on project document
     * @param saleTypeStageLinkId - The id of the list
     * @param itemsIds - The ids of the items in the order you want
     * @returns 
     */
    public async SetRankOnSaleDocument(saleTypeStageLinkId: number, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetRankOnSaleDocument(saleTypeStageLinkId:number|carriers.List_SetRankOnSaleDocumentRequest, itemsIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetRankOnSaleDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleTypeStageLinkId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleTypeStageLinkId)!='undefined' || typeof(first.ItemsIds)!='undefined' ) )
        {
            _request = saleTypeStageLinkId as carriers.List_SetRankOnSaleDocumentRequest;
            _options = itemsIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleTypeStageLinkId: saleTypeStageLinkId as number,
                       ItemsIds: itemsIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetRankOnSaleDocument( _request, _options );
    }


    private async _SetRankOnProjectActivity(request: carriers.List_SetRankOnProjectActivityRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnProjectActivity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set rank order on project activity
     * @param request - ProjectTypeStatusLinkId, ItemsIds
     * @returns 
     */
    public async SetRankOnProjectActivity(request: carriers.List_SetRankOnProjectActivityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set rank order on project activity
     * @param projectTypeStatusLinkId - The id of the list
     * @param itemsIds - The ids of the items in the order you want
     * @returns 
     */
    public async SetRankOnProjectActivity(projectTypeStatusLinkId: number, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetRankOnProjectActivity(projectTypeStatusLinkId:number|carriers.List_SetRankOnProjectActivityRequest, itemsIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetRankOnProjectActivityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectTypeStatusLinkId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectTypeStatusLinkId)!='undefined' || typeof(first.ItemsIds)!='undefined' ) )
        {
            _request = projectTypeStatusLinkId as carriers.List_SetRankOnProjectActivityRequest;
            _options = itemsIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectTypeStatusLinkId: projectTypeStatusLinkId as number,
                       ItemsIds: itemsIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetRankOnProjectActivity( _request, _options );
    }


    private async _SetRankOnProjectDocument(request: carriers.List_SetRankOnProjectDocumentRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnProjectDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set rank order on project document
     * @param request - ProjectTypeStatusLinkId, ItemsIds
     * @returns 
     */
    public async SetRankOnProjectDocument(request: carriers.List_SetRankOnProjectDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set rank order on project document
     * @param projectTypeStatusLinkId - The id of the list
     * @param itemsIds - The ids of the items in the order you want
     * @returns 
     */
    public async SetRankOnProjectDocument(projectTypeStatusLinkId: number, itemsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetRankOnProjectDocument(projectTypeStatusLinkId:number|carriers.List_SetRankOnProjectDocumentRequest, itemsIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetRankOnProjectDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectTypeStatusLinkId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectTypeStatusLinkId)!='undefined' || typeof(first.ItemsIds)!='undefined' ) )
        {
            _request = projectTypeStatusLinkId as carriers.List_SetRankOnProjectDocumentRequest;
            _options = itemsIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectTypeStatusLinkId: projectTypeStatusLinkId as number,
                       ItemsIds: itemsIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetRankOnProjectDocument( _request, _options );
    }


    private async _GetAllFromListDefinition(request: carriers.List_GetAllFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity[] = converters.Create_ListItemEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all list items for the specified list defintion
     * @param request - UdListDefinitionId, IncludeDeleted
     * @returns The list items
     */
    public async GetAllFromListDefinition(request: carriers.List_GetAllFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;

    /**
     * Get all list items for the specified list defintion
     * @param udListDefinitionId - The id of the list definition, indicating which list to get the item from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param includeDeleted - Include deleted items in result?
     * @returns The list items
     */
    public async GetAllFromListDefinition(udListDefinitionId: number, includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;

    public async GetAllFromListDefinition(udListDefinitionId:number|carriers.List_GetAllFromListDefinitionRequest, includeDeleted?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] > {
        let _request : carriers.List_GetAllFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_GetAllFromListDefinitionRequest;
            _options = includeDeleted as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllFromListDefinition( _request, _options );
    }


    private async _GetAllFromListName(request: carriers.List_GetAllFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity[] = converters.Create_ListItemEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all list items for the specified list defintion
     * @param request - UdListDefinitionName, IncludeDeleted
     * @returns The list items
     */
    public async GetAllFromListName(request: carriers.List_GetAllFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;

    /**
     * Get all list items for the specified list defintion
     * @param udListDefinitionName - The name of the list definition, indicating which list to get the item from.
     * @param includeDeleted - Include deleted items in result?
     * @returns The list items
     */
    public async GetAllFromListName(udListDefinitionName: string, includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;

    public async GetAllFromListName(udListDefinitionName:string|carriers.List_GetAllFromListNameRequest, includeDeleted?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] > {
        let _request : carriers.List_GetAllFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_GetAllFromListNameRequest;
            _options = includeDeleted as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllFromListName( _request, _options );
    }


    private async _SaveAllFromListDefinition(request: carriers.List_SaveAllFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveAllFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity[] = converters.Create_ListItemEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save all list items for the specified list defintion
     * @param request - UdListDefinitionId, Items
     * @returns The list items
     */
    public async SaveAllFromListDefinition(request: carriers.List_SaveAllFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;

    /**
     * Save all list items for the specified list defintion
     * @param udListDefinitionId - The id of the list definition, indicating which list to save the items to. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param items - The list items
     * @returns The list items
     */
    public async SaveAllFromListDefinition(udListDefinitionId: number, items: carriers.ListItemEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;

    public async SaveAllFromListDefinition(udListDefinitionId:number|carriers.List_SaveAllFromListDefinitionRequest, items?:carriers.ListItemEntity[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] > {
        let _request : carriers.List_SaveAllFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.Items)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_SaveAllFromListDefinitionRequest;
            _options = items as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       Items: items as carriers.ListItemEntity[],
                       };   
            _options = webapi_options;
        }
        return this._SaveAllFromListDefinition( _request, _options );
    }


    private async _SaveAllFromListName(request: carriers.List_SaveAllFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveAllFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity[] = converters.Create_ListItemEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save all list items for the specified list defintion
     * @param request - UdListDefinitionName, Items
     * @returns The list items
     */
    public async SaveAllFromListName(request: carriers.List_SaveAllFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;

    /**
     * Save all list items for the specified list defintion
     * @param udListDefinitionName - The name of the list definition, indicating which list to save the items to.
     * @param items - The list items
     * @returns The list items
     */
    public async SaveAllFromListName(udListDefinitionName: string, items: carriers.ListItemEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] >;

    public async SaveAllFromListName(udListDefinitionName:string|carriers.List_SaveAllFromListNameRequest, items?:carriers.ListItemEntity[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity[] > {
        let _request : carriers.List_SaveAllFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.Items)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_SaveAllFromListNameRequest;
            _options = items as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       Items: items as carriers.ListItemEntity[],
                       };   
            _options = webapi_options;
        }
        return this._SaveAllFromListName( _request, _options );
    }


    private async _AddFromListDefinition(request: carriers.List_AddFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity = converters.Create_ListItemEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a new list item for the specified list defintion
     * @param request - UdListDefinitionId, Item
     * @returns The saved list item
     */
    public async AddFromListDefinition(request: carriers.List_AddFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    /**
     * Save a new list item for the specified list defintion
     * @param udListDefinitionId - The name of the list definition, indicating which list to save the item to.
     * @param item - The item to save
     * @returns The saved list item
     */
    public async AddFromListDefinition(udListDefinitionId: number, item: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    public async AddFromListDefinition(udListDefinitionId:number|carriers.List_AddFromListDefinitionRequest, item?:carriers.ListItemEntity|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        let _request : carriers.List_AddFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' || typeof(first.Item)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_AddFromListDefinitionRequest;
            _options = item as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       Item: item as carriers.ListItemEntity,
                       };   
            _options = webapi_options;
        }
        return this._AddFromListDefinition( _request, _options );
    }


    private async _AddFromListName(request: carriers.List_AddFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity = converters.Create_ListItemEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a new list item for the specified list defintion
     * @param request - UdListDefinitionName, Item
     * @returns The saved list item
     */
    public async AddFromListName(request: carriers.List_AddFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    /**
     * Save a new list item for the specified list defintion
     * @param udListDefinitionName - The name of the list definition, indicating which list to save the item to.
     * @param item - The item to save
     * @returns The saved list item
     */
    public async AddFromListName(udListDefinitionName: string, item: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    public async AddFromListName(udListDefinitionName:string|carriers.List_AddFromListNameRequest, item?:carriers.ListItemEntity|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        let _request : carriers.List_AddFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' || typeof(first.Item)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_AddFromListNameRequest;
            _options = item as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       Item: item as carriers.ListItemEntity,
                       };   
            _options = webapi_options;
        }
        return this._AddFromListName( _request, _options );
    }


    private async _DeleteAllFromListDefinition(request: carriers.List_DeleteAllFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAllFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Marks all items in the list deleted
     * @param request - UdListDefinitionId
     * @returns This method has no return value
     */
    public async DeleteAllFromListDefinition(request: carriers.List_DeleteAllFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Marks all items in the list deleted
     * @param udListDefinitionId - The id of the list definition, indicating which list to delete the items from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @returns This method has no return value
     */
    public async DeleteAllFromListDefinition(udListDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteAllFromListDefinition(udListDefinitionId:number|carriers.List_DeleteAllFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteAllFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionId)!='undefined' ) )
        {
            _request = udListDefinitionId as carriers.List_DeleteAllFromListDefinitionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionId: udListDefinitionId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteAllFromListDefinition( _request, _options );
    }


    private async _DeleteAllFromListName(request: carriers.List_DeleteAllFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAllFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Marks all items in the list deleted
     * @param request - UdListDefinitionName
     * @returns This method has no return value
     */
    public async DeleteAllFromListName(request: carriers.List_DeleteAllFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Marks all items in the list deleted
     * @param udListDefinitionName - The name of the list definition, indicating which list to delete the items from.
     * @returns This method has no return value
     */
    public async DeleteAllFromListName(udListDefinitionName: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteAllFromListName(udListDefinitionName:string|carriers.List_DeleteAllFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteAllFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = udListDefinitionName;
        if( typeof( first ) === "object" && first && ( typeof(first.UdListDefinitionName)!='undefined' ) )
        {
            _request = udListDefinitionName as carriers.List_DeleteAllFromListNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UdListDefinitionName: udListDefinitionName as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteAllFromListName( _request, _options );
    }


    private async _GetFromListDefinition(request: carriers.List_GetFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity = converters.Create_ListItemEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list item for the specified list defintion
     * @param request - Id, UdListDefinitionId
     * @returns The loaded list item
     */
    public async GetFromListDefinition(request: carriers.List_GetFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    /**
     * Get a list item for the specified list defintion
     * @param id - The identity of the list item to load
     * @param udListDefinitionId - The id of the list definition, indicating which list to get the item from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @returns The loaded list item
     */
    public async GetFromListDefinition(id: number, udListDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    public async GetFromListDefinition(id:number|carriers.List_GetFromListDefinitionRequest, udListDefinitionId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        let _request : carriers.List_GetFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.UdListDefinitionId)!='undefined' ) )
        {
            _request = id as carriers.List_GetFromListDefinitionRequest;
            _options = udListDefinitionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       UdListDefinitionId: udListDefinitionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetFromListDefinition( _request, _options );
    }


    private async _GetFromListName(request: carriers.List_GetFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity = converters.Create_ListItemEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list item for the specified list defintion
     * @param request - Id, UdListDefinitionName
     * @returns The loaded list item
     */
    public async GetFromListName(request: carriers.List_GetFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    /**
     * Get a list item for the specified list defintion
     * @param id - The identity of the list item to load
     * @param udListDefinitionName - The name of the list definition, indicating which list to get the item from.
     * @returns The loaded list item
     */
    public async GetFromListName(id: number, udListDefinitionName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    public async GetFromListName(id:number|carriers.List_GetFromListNameRequest, udListDefinitionName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        let _request : carriers.List_GetFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.UdListDefinitionName)!='undefined' ) )
        {
            _request = id as carriers.List_GetFromListNameRequest;
            _options = udListDefinitionName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       UdListDefinitionName: udListDefinitionName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetFromListName( _request, _options );
    }


    private async _SaveFromListDefinition(request: carriers.List_SaveFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity = converters.Create_ListItemEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a list item for the specified list defintion
     * @param request - Id, UdListDefinitionId, Item
     * @returns The saved list item
     */
    public async SaveFromListDefinition(request: carriers.List_SaveFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    /**
     * Save a list item for the specified list defintion
     * @param id - The identity of the list item to load
     * @param udListDefinitionId - The id of the list definition, indicating which list to save the item to. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @param item - The item to save
     * @returns The saved list item
     */
    public async SaveFromListDefinition(id: number, udListDefinitionId: number, item: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    public async SaveFromListDefinition(id:number|carriers.List_SaveFromListDefinitionRequest, udListDefinitionId?:number|base.WebApiRequestOptions, item?:carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        let _request : carriers.List_SaveFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.UdListDefinitionId)!='undefined' || typeof(first.Item)!='undefined' ) )
        {
            _request = id as carriers.List_SaveFromListDefinitionRequest;
            _options = udListDefinitionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       UdListDefinitionId: udListDefinitionId as number,
                       Item: item as carriers.ListItemEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveFromListDefinition( _request, _options );
    }


    private async _SaveFromListName(request: carriers.List_SaveFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ListItemEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ListItemEntity = converters.Create_ListItemEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a list item for the specified list defintion
     * @param request - Id, UdListDefinitionName, Item
     * @returns The saved list item
     */
    public async SaveFromListName(request: carriers.List_SaveFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    /**
     * Save a list item for the specified list defintion
     * @param id - The identity of the list item to load
     * @param udListDefinitionName - The name of the list definition, indicating which list to save the item to.
     * @param item - The item to save
     * @returns The saved list item
     */
    public async SaveFromListName(id: number, udListDefinitionName: string, item: carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity >;

    public async SaveFromListName(id:number|carriers.List_SaveFromListNameRequest, udListDefinitionName?:string|base.WebApiRequestOptions, item?:carriers.ListItemEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ListItemEntity > {
        let _request : carriers.List_SaveFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.UdListDefinitionName)!='undefined' || typeof(first.Item)!='undefined' ) )
        {
            _request = id as carriers.List_SaveFromListNameRequest;
            _options = udListDefinitionName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       UdListDefinitionName: udListDefinitionName as string,
                       Item: item as carriers.ListItemEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveFromListName( _request, _options );
    }


    private async _DeleteFromListDefinition(request: carriers.List_DeleteFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a list item from the specified list defintion
     * @param request - Id, UdListDefinitionId
     * @returns This method has no return value
     */
    public async DeleteFromListDefinition(request: carriers.List_DeleteFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a list item from the specified list defintion
     * @param id - The identity of the list item to delete
     * @param udListDefinitionId - The id of the list definition, indicating which list to delete the items from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     * @returns This method has no return value
     */
    public async DeleteFromListDefinition(id: number, udListDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteFromListDefinition(id:number|carriers.List_DeleteFromListDefinitionRequest, udListDefinitionId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.UdListDefinitionId)!='undefined' ) )
        {
            _request = id as carriers.List_DeleteFromListDefinitionRequest;
            _options = udListDefinitionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       UdListDefinitionId: udListDefinitionId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteFromListDefinition( _request, _options );
    }


    private async _DeleteFromListName(request: carriers.List_DeleteFromListNameRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteFromListName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a list item from the specified list defintion
     * @param request - Id, UdListDefinitionName
     * @returns This method has no return value
     */
    public async DeleteFromListName(request: carriers.List_DeleteFromListNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a list item from the specified list defintion
     * @param id - The identity of the list item to delete
     * @param udListDefinitionName - The name of the list definition, indicating which list to delete the items from.
     * @returns This method has no return value
     */
    public async DeleteFromListName(id: number, udListDefinitionName: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteFromListName(id:number|carriers.List_DeleteFromListNameRequest, udListDefinitionName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteFromListNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.UdListDefinitionName)!='undefined' ) )
        {
            _request = id as carriers.List_DeleteFromListNameRequest;
            _options = udListDefinitionName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       UdListDefinitionName: udListDefinitionName as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteFromListName( _request, _options );
    }


    private async _GetHeadingsFromName(request: carriers.List_GetHeadingsFromNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHeadingsFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HeadingEntity[] = converters.Create_HeadingEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets headings for list resolved by the provided name.
     * @param request - Name
     * @returns List of headings
     */
    public async GetHeadingsFromName(request: carriers.List_GetHeadingsFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;

    /**
     * Gets headings for list resolved by the provided name.
     * @param name - The name of the list to look up.
     * @returns List of headings
     */
    public async GetHeadingsFromName(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;

    public async GetHeadingsFromName(name:string|carriers.List_GetHeadingsFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] > {
        let _request : carriers.List_GetHeadingsFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' ) )
        {
            _request = name as carriers.List_GetHeadingsFromNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._GetHeadingsFromName( _request, _options );
    }


    private async _GetHeadingsFromListDefinition(request: carriers.List_GetHeadingsFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHeadingsFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HeadingEntity[] = converters.Create_HeadingEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets headings for list resolved by the provided id.
     * @param request - Id
     * @returns List of headings
     */
    public async GetHeadingsFromListDefinition(request: carriers.List_GetHeadingsFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;

    /**
     * Gets headings for list resolved by the provided id.
     * @param id - The id of the list to look up.
     * @returns List of headings
     */
    public async GetHeadingsFromListDefinition(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;

    public async GetHeadingsFromListDefinition(id:number|carriers.List_GetHeadingsFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] > {
        let _request : carriers.List_GetHeadingsFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.List_GetHeadingsFromListDefinitionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._GetHeadingsFromListDefinition( _request, _options );
    }


    private async _SaveHeadingsFromName(request: carriers.List_SaveHeadingsFromNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingsFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HeadingEntity[] = converters.Create_HeadingEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save headings for list resolved by the provided name.
     * @param request - Name, Entities
     * @returns List of headings
     */
    public async SaveHeadingsFromName(request: carriers.List_SaveHeadingsFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;

    /**
     * Save headings for list resolved by the provided name.
     * @param name - The name of the list to look up.
     * @param entities - The headings to save
     * @returns List of headings
     */
    public async SaveHeadingsFromName(name: string, entities: carriers.HeadingEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;

    public async SaveHeadingsFromName(name:string|carriers.List_SaveHeadingsFromNameRequest, entities?:carriers.HeadingEntity[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] > {
        let _request : carriers.List_SaveHeadingsFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' || typeof(first.Entities)!='undefined' ) )
        {
            _request = name as carriers.List_SaveHeadingsFromNameRequest;
            _options = entities as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       Entities: entities as carriers.HeadingEntity[],
                       };   
            _options = webapi_options;
        }
        return this._SaveHeadingsFromName( _request, _options );
    }


    private async _SaveHeadingsFromListDefinition(request: carriers.List_SaveHeadingsFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingsFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HeadingEntity[] = converters.Create_HeadingEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save headings for list resolved by the provided id.
     * @param request - Id, Entities
     * @returns List of headings
     */
    public async SaveHeadingsFromListDefinition(request: carriers.List_SaveHeadingsFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;

    /**
     * Save headings for list resolved by the provided id.
     * @param id - The id of the list to look up.
     * @param entities - The headings to save
     * @returns List of headings
     */
    public async SaveHeadingsFromListDefinition(id: number, entities: carriers.HeadingEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] >;

    public async SaveHeadingsFromListDefinition(id:number|carriers.List_SaveHeadingsFromListDefinitionRequest, entities?:carriers.HeadingEntity[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity[] > {
        let _request : carriers.List_SaveHeadingsFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.Entities)!='undefined' ) )
        {
            _request = id as carriers.List_SaveHeadingsFromListDefinitionRequest;
            _options = entities as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       Entities: entities as carriers.HeadingEntity[],
                       };   
            _options = webapi_options;
        }
        return this._SaveHeadingsFromListDefinition( _request, _options );
    }


    private async _SaveHeadingFromName(request: carriers.List_SaveHeadingFromNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HeadingEntity = converters.Create_HeadingEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save new heading for list resolved by the provided name.
     * @param request - Name, Entity
     * @returns The saved entity.
     */
    public async SaveHeadingFromName(request: carriers.List_SaveHeadingFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;

    /**
     * Save new heading for list resolved by the provided name.
     * @param name - The name of the list to look up.
     * @param entity - The new heading to save
     * @returns The saved entity.
     */
    public async SaveHeadingFromName(name: string, entity: carriers.HeadingEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;

    public async SaveHeadingFromName(name:string|carriers.List_SaveHeadingFromNameRequest, entity?:carriers.HeadingEntity|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity > {
        let _request : carriers.List_SaveHeadingFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' || typeof(first.Entity)!='undefined' ) )
        {
            _request = name as carriers.List_SaveHeadingFromNameRequest;
            _options = entity as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       Entity: entity as carriers.HeadingEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveHeadingFromName( _request, _options );
    }


    private async _SaveHeadingFromListDefinition(request: carriers.List_SaveHeadingFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.HeadingEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.HeadingEntity = converters.Create_HeadingEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save new heading for list resolved by the provided id.
     * @param request - Id, Entity
     * @returns The saved entity.
     */
    public async SaveHeadingFromListDefinition(request: carriers.List_SaveHeadingFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;

    /**
     * Save new heading for list resolved by the provided id.
     * @param id - The id of the list to look up.
     * @param entity - The new heading to save
     * @returns The saved entity.
     */
    public async SaveHeadingFromListDefinition(id: number, entity: carriers.HeadingEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity >;

    public async SaveHeadingFromListDefinition(id:number|carriers.List_SaveHeadingFromListDefinitionRequest, entity?:carriers.HeadingEntity|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.HeadingEntity > {
        let _request : carriers.List_SaveHeadingFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.Entity)!='undefined' ) )
        {
            _request = id as carriers.List_SaveHeadingFromListDefinitionRequest;
            _options = entity as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       Entity: entity as carriers.HeadingEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveHeadingFromListDefinition( _request, _options );
    }


    private async _DeleteAllHeadingsFromName(request: carriers.List_DeleteAllHeadingsFromNameRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAllHeadingsFromName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete all headings for list resolved by the provided name.
     * @param request - Name
     * @returns This method has no return value
     */
    public async DeleteAllHeadingsFromName(request: carriers.List_DeleteAllHeadingsFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete all headings for list resolved by the provided name.
     * @param name - The name of the list to look up.
     * @returns This method has no return value
     */
    public async DeleteAllHeadingsFromName(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteAllHeadingsFromName(name:string|carriers.List_DeleteAllHeadingsFromNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteAllHeadingsFromNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' ) )
        {
            _request = name as carriers.List_DeleteAllHeadingsFromNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteAllHeadingsFromName( _request, _options );
    }


    private async _DeleteAllHeadingsFromListDefinition(request: carriers.List_DeleteAllHeadingsFromListDefinitionRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAllHeadingsFromListDefinition", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete all headings for list resolved by the provided id.
     * @param request - Id
     * @returns This method has no return value
     */
    public async DeleteAllHeadingsFromListDefinition(request: carriers.List_DeleteAllHeadingsFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete all headings for list resolved by the provided id.
     * @param id - The id of the list to look up.
     * @returns This method has no return value
     */
    public async DeleteAllHeadingsFromListDefinition(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteAllHeadingsFromListDefinition(id:number|carriers.List_DeleteAllHeadingsFromListDefinitionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteAllHeadingsFromListDefinitionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.List_DeleteAllHeadingsFromListDefinitionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteAllHeadingsFromListDefinition( _request, _options );
    }

    /*
     * Gets a LocalizedText object.
     * @param localizedTextId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single LocalizedText
     */
    public async GetLocalizedText(localizedTextId: number, options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LocalizedText >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLocalizedText?localizedTextId=" + localizedTextId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LocalizedText_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetLocalizedTextByType(request: carriers.List_GetLocalizedTextByTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LocalizedText >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLocalizedTextByType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.LocalizedText = converters.Create_LocalizedText_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns a localized text based on the resource id for the selected language.
     * @param request - TextType, ResourceId, LanguageId
     * @returns A LocalizedText carrier.
     */
    public async GetLocalizedTextByType(request: carriers.List_GetLocalizedTextByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText >;

    /**
     * Returns a localized text based on the resource id for the selected language.
     * @param textType - Type of the localized text
     * @param resourceId - The resource id. This id has different meaning based on the LocalizedTextType.
     * @param languageId - The LCID number of the language.
     * @returns A LocalizedText carrier.
     */
    public async GetLocalizedTextByType(textType: enums.LocalizedTextType, resourceId: number, languageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText >;

    public async GetLocalizedTextByType(textType:enums.LocalizedTextType|carriers.List_GetLocalizedTextByTypeRequest, resourceId?:number|base.WebApiRequestOptions, languageId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText > {
        let _request : carriers.List_GetLocalizedTextByTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = textType;
        if( typeof( first ) === "object" && first && ( typeof(first.TextType)!='undefined' || typeof(first.ResourceId)!='undefined' || typeof(first.LanguageId)!='undefined' ) )
        {
            _request = textType as carriers.List_GetLocalizedTextByTypeRequest;
            _options = resourceId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TextType: textType as enums.LocalizedTextType,
                       ResourceId: resourceId as number,
                       LanguageId: languageId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetLocalizedTextByType( _request, _options );
    }

    /*
     * Gets an array of LocalizedText objects.
     * @param localizedTextIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of LocalizedText
     */
    public async GetLocalizedTextList(localizedTextIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LocalizedText[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLocalizedTextList", localizedTextIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LocalizedTextArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetLocalizedTexts( options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LocalizedText[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLocalizedTexts", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.LocalizedText[] = converters.Create_LocalizedTextArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets all localized texts in the CRM database.
     * @returns Array of LocalizedText objects
     */
    public async GetLocalizedTexts(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >
    {
        return this._GetLocalizedTexts(webapi_options);
    }


    private async _GetLocalizedTextsByLanguageId(request: carriers.List_GetLocalizedTextsByLanguageIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LocalizedText[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLocalizedTextsByLanguageId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.LocalizedText[] = converters.Create_LocalizedTextArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets all localized text belonging to a specific language.
     * @param request - LanguageId
     * @returns Array of LocalizedText objects
     */
    public async GetLocalizedTextsByLanguageId(request: carriers.List_GetLocalizedTextsByLanguageIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >;

    /**
     * Gets all localized text belonging to a specific language.
     * @param languageId - The LCID number of the language.
     * @returns Array of LocalizedText objects
     */
    public async GetLocalizedTextsByLanguageId(languageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >;

    public async GetLocalizedTextsByLanguageId(languageId:number|carriers.List_GetLocalizedTextsByLanguageIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] > {
        let _request : carriers.List_GetLocalizedTextsByLanguageIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = languageId;
        if( typeof( first ) === "object" && first && ( typeof(first.LanguageId)!='undefined' ) )
        {
            _request = languageId as carriers.List_GetLocalizedTextsByLanguageIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       LanguageId: languageId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetLocalizedTextsByLanguageId( _request, _options );
    }


    private async _GetLocalizedTextsByType(request: carriers.List_GetLocalizedTextsByTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LocalizedText[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLocalizedTextsByType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.LocalizedText[] = converters.Create_LocalizedTextArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets localized text by their type
     * @param request - TextTypes
     * @returns Array of LocalizedText objects
     */
    public async GetLocalizedTextsByType(request: carriers.List_GetLocalizedTextsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >;

    /**
     * Gets localized text by their type
     * @param textTypes - Array of LocalizedTextTypes. If null all texts are returned.
     * @returns Array of LocalizedText objects
     */
    public async GetLocalizedTextsByType(textTypes: enums.LocalizedTextType[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] >;

    public async GetLocalizedTextsByType(textTypes:enums.LocalizedTextType[]|carriers.List_GetLocalizedTextsByTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LocalizedText[] > {
        let _request : carriers.List_GetLocalizedTextsByTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = textTypes;
        if( typeof( first ) === "object" && first && ( typeof(first.TextTypes)!='undefined' ) )
        {
            _request = textTypes as carriers.List_GetLocalizedTextsByTypeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TextTypes: textTypes as enums.LocalizedTextType[],
                       };   
            _options = webapi_options;
        }
        return this._GetLocalizedTextsByType( _request, _options );
    }

    /*
     * Gets a MrMrs object.
     * @param mrMrsId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single MrMrs
     */
    public async GetMrMrs(mrMrsId: number, options?:base.WebApiRequestOptions) : Promise< carriers.MrMrs > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MrMrs >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetMrMrs?mrMrsId=" + mrMrsId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MrMrs_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of MrMrs objects.
     * @param mrMrsIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of MrMrs
     */
    public async GetMrMrsList(mrMrsIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.MrMrs[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MrMrs[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetMrMrsList", mrMrsIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MrMrsArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetMrMrses( options?:base.WebApiRequestOptions) : Promise< carriers.MrMrs[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MrMrs[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMrMrses", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MrMrs[] = converters.Create_MrMrsArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all Items from the MrMrs table sorted by their value.
     * @returns All items from the MrMrs table sorted by their value
     */
    public async GetMrMrses(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MrMrs[] >
    {
        return this._GetMrMrses(webapi_options);
    }

    /*
     * Gets a PaymentTerm object.
     * @param paymentTermId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PaymentTerm
     */
    public async GetPaymentTerm(paymentTermId: number, options?:base.WebApiRequestOptions) : Promise< carriers.PaymentTerm > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PaymentTerm >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPaymentTerm?paymentTermId=" + paymentTermId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PaymentTerm_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetPaymentTerms( options?:base.WebApiRequestOptions) : Promise< carriers.PaymentTerm[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PaymentTerm[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPaymentTerms", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PaymentTerm[] = converters.Create_PaymentTermArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all PaymentTerms in SuperOffice db.
     * @returns An array of all available PaymentTerms
     */
    public async GetPaymentTerms(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PaymentTerm[] >
    {
        return this._GetPaymentTerms(webapi_options);
    }

    /*
     * Gets a PaymentType object.
     * @param paymentTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PaymentType
     */
    public async GetPaymentType(paymentTypeId: number, options?:base.WebApiRequestOptions) : Promise< carriers.PaymentType > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PaymentType >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPaymentType?paymentTypeId=" + paymentTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PaymentType_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetPaymentTypes( options?:base.WebApiRequestOptions) : Promise< carriers.PaymentType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PaymentType[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPaymentTypes", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PaymentType[] = converters.Create_PaymentTypeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all PaymentTypes in SuperOffice db.
     * @returns An array of all available PaymentTypes
     */
    public async GetPaymentTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PaymentType[] >
    {
        return this._GetPaymentTypes(webapi_options);
    }

    /*
     * Gets a Position object.
     * @param positionId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Position
     */
    public async GetPosition(positionId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Position > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Position >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPosition?positionId=" + positionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Position_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Position objects.
     * @param positionIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Position
     */
    public async GetPositionList(positionIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Position[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Position[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPositionList", positionIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PositionArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetPositions( options?:base.WebApiRequestOptions) : Promise< carriers.Position[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Position[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPositions", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Position[] = converters.Create_PositionArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all the positions a person could have.
     * @returns An array of all available positions
     */
    public async GetPositions(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Position[] >
    {
        return this._GetPositions(webapi_options);
    }

    /*
     * Gets a Priority object.
     * @param priorityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Priority
     */
    public async GetPriority(priorityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Priority > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Priority >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPriority?priorityId=" + priorityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Priority_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Priority objects.
     * @param priorityIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Priority
     */
    public async GetPriorityList(priorityIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Priority[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Priority[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPriorityList", priorityIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriorityArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetPriorities( options?:base.WebApiRequestOptions) : Promise< carriers.Priority[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Priority[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPriorities", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Priority[] = converters.Create_PriorityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all priorities an appointment could have.
     * @returns An array of all available priorities
     */
    public async GetPriorities(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Priority[] >
    {
        return this._GetPriorities(webapi_options);
    }

    /*
     * Gets a ProductCategory object.
     * @param productCategoryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProductCategory
     */
    public async GetProductCategory(productCategoryId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProductCategory > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProductCategory >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProductCategory?productCategoryId=" + productCategoryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductCategory_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetProductCategories( options?:base.WebApiRequestOptions) : Promise< carriers.ProductCategory[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProductCategory[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductCategories", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProductCategory[] = converters.Create_ProductCategoryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all ProductCategories in SuperOffice list.
     * @returns An array of all available ProductCategory
     */
    public async GetProductCategories(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductCategory[] >
    {
        return this._GetProductCategories(webapi_options);
    }

    /*
     * Gets a ProductFamily object.
     * @param productFamilyId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProductFamily
     */
    public async GetProductFamily(productFamilyId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProductFamily > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProductFamily >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProductFamily?productFamilyId=" + productFamilyId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductFamily_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetProductFamilies( options?:base.WebApiRequestOptions) : Promise< carriers.ProductFamily[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProductFamily[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductFamilies", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProductFamily[] = converters.Create_ProductFamilyArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all ProductFamily in SuperOffice list.
     * @returns An array of all available ProductFamilies
     */
    public async GetProductFamilies(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductFamily[] >
    {
        return this._GetProductFamilies(webapi_options);
    }

    /*
     * Gets a ProductType object.
     * @param productTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProductType
     */
    public async GetProductType(productTypeId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProductType > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProductType >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProductType?productTypeId=" + productTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductType_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetProductTypes( options?:base.WebApiRequestOptions) : Promise< carriers.ProductType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProductType[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductTypes", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProductType[] = converters.Create_ProductTypeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all ProductTypes in SuperOffice list.
     * @returns An array of all available ProductTypes
     */
    public async GetProductTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProductType[] >
    {
        return this._GetProductTypes(webapi_options);
    }

    /*
     * Gets a ProjectStatus object.
     * @param projectStatusId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectStatus
     */
    public async GetProjectStatus(projectStatusId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectStatus > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectStatus >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectStatus?projectStatusId=" + projectStatusId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectStatus_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _DeleteProjectStatus(request: carriers.List_DeleteProjectStatusRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteProjectStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes a project status
     * @param request - ProjectStatusId
     * @returns No return
     */
    public async DeleteProjectStatus(request: carriers.List_DeleteProjectStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes a project status
     * @param projectStatusId - The project status id to delete
     * @returns No return
     */
    public async DeleteProjectStatus(projectStatusId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteProjectStatus(projectStatusId:number|carriers.List_DeleteProjectStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteProjectStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectStatusId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectStatusId)!='undefined' ) )
        {
            _request = projectStatusId as carriers.List_DeleteProjectStatusRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectStatusId: projectStatusId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteProjectStatus( _request, _options );
    }

    /*
     * Gets an array of ProjectStatus objects.
     * @param projectStatusIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ProjectStatus
     */
    public async GetProjectStatusList(projectStatusIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.ProjectStatus[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectStatus[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectStatusList", projectStatusIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectStatusArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetProjectStatuses( options?:base.WebApiRequestOptions) : Promise< carriers.ProjectStatus[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectStatus[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectStatuses", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectStatus[] = converters.Create_ProjectStatusArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets all items from the Project Status (ProjStatus) table.
     * @returns List of all Project statuses.
     */
    public async GetProjectStatuses(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectStatus[] >
    {
        return this._GetProjectStatuses(webapi_options);
    }

    /*
     * Gets a ProjectType object.
     * @param projectTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectType
     */
    public async GetProjectType(projectTypeId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectType > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectType >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectType?projectTypeId=" + projectTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectType_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a ProjectTypeEntity object.
     * @param projectTypeEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectTypeEntity
     */
    public async GetProjectTypeEntity(projectTypeEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectTypeEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectTypeEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectTypeEntity?projectTypeEntityId=" + projectTypeEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectTypeEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of ProjectType objects.
     * @param projectTypeIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ProjectType
     */
    public async GetProjectTypeList(projectTypeIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.ProjectType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectType[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectTypeList", projectTypeIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectTypeArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetProjectTypes( options?:base.WebApiRequestOptions) : Promise< carriers.ProjectType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectType[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectTypes", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectType[] = converters.Create_ProjectTypeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets all items from the Project Type (ProjType) table.
     * @returns List of all project types.
     */
    public async GetProjectTypes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectType[] >
    {
        return this._GetProjectTypes(webapi_options);
    }


    private async _SaveQuickReplies(request: carriers.List_SaveQuickRepliesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuickReplies", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method to save all quick replies for a given associate
     * @param request - QuickReplies
     * @returns 
     */
    public async SaveQuickReplies(request: carriers.List_SaveQuickRepliesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Method to save all quick replies for a given associate
     * @param quickReplies - Array of quick replies
     * @returns 
     */
    public async SaveQuickReplies(quickReplies: carriers.QuickReply[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveQuickReplies(quickReplies:carriers.QuickReply[]|carriers.List_SaveQuickRepliesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SaveQuickRepliesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quickReplies;
        if( typeof( first ) === "object" && first && ( typeof(first.QuickReplies)!='undefined' ) )
        {
            _request = quickReplies as carriers.List_SaveQuickRepliesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuickReplies: quickReplies as carriers.QuickReply[],
                       };   
            _options = webapi_options;
        }
        return this._SaveQuickReplies( _request, _options );
    }


    private async _GetQuickReplies( options?:base.WebApiRequestOptions) : Promise< carriers.QuickReply[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuickReply[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuickReplies", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuickReply[] = converters.Create_QuickReplyArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Method to return all quick replies for a given associate
     * @returns Array of quick replies
     */
    public async GetQuickReplies(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuickReply[] >
    {
        return this._GetQuickReplies(webapi_options);
    }

    /*
     * Gets a Rating object.
     * @param ratingId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Rating
     */
    public async GetRating(ratingId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Rating > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Rating >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRating?ratingId=" + ratingId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Rating_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Rating objects.
     * @param ratingIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Rating
     */
    public async GetRatingList(ratingIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Rating[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Rating[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRatingList", ratingIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RatingArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetRatings( options?:base.WebApiRequestOptions) : Promise< carriers.Rating[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Rating[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRatings", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Rating[] = converters.Create_RatingArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all ratings
     * @returns Array of ratings
     */
    public async GetRatings(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Rating[] >
    {
        return this._GetRatings(webapi_options);
    }


    private async _GetAllSaleStages(request: carriers.List_GetAllSaleStagesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SaleStageEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStageEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllSaleStages", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleStageEntity[] = converters.Create_SaleStageEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all ratings
     * @param request - IncludeDeleted
     * @returns Array of sale stage ratings
     */
    public async GetAllSaleStages(request: carriers.List_GetAllSaleStagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStageEntity[] >;

    /**
     * Returns all ratings
     * @param includeDeleted - Include deleted items in result?
     * @returns Array of sale stage ratings
     */
    public async GetAllSaleStages(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStageEntity[] >;

    public async GetAllSaleStages(includeDeleted:boolean|carriers.List_GetAllSaleStagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStageEntity[] > {
        let _request : carriers.List_GetAllSaleStagesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.List_GetAllSaleStagesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllSaleStages( _request, _options );
    }

    /*
     * Gets a Reason object.
     * @param reasonId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Reason
     */
    public async GetReason(reasonId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Reason > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Reason >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReason?reasonId=" + reasonId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Reason_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Reason objects.
     * @param reasonIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Reason
     */
    public async GetReasonList(reasonIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Reason[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Reason[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonList", reasonIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetReasons( options?:base.WebApiRequestOptions) : Promise< carriers.Reason[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Reason[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetReasons", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Reason[] = converters.Create_ReasonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all reasons
     * @returns Array of reasons
     */
    public async GetReasons(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Reason[] >
    {
        return this._GetReasons(webapi_options);
    }

    /*
     * Gets a QuoteApproveReason object.
     * @param quoteApproveReasonId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single QuoteApproveReason
     */
    public async GetQuoteApproveReason(quoteApproveReasonId: number, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteApproveReason > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteApproveReason >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteApproveReason?quoteApproveReasonId=" + quoteApproveReasonId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteApproveReason_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of QuoteApproveReason objects.
     * @param quoteApproveReasonIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of QuoteApproveReason
     */
    public async GetQuoteApproveReasonList(quoteApproveReasonIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.QuoteApproveReason[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteApproveReason[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteApproveReasonList", quoteApproveReasonIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteApproveReasonArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetQuoteApproveReasons( options?:base.WebApiRequestOptions) : Promise< carriers.QuoteApproveReason[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteApproveReason[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteApproveReasons", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteApproveReason[] = converters.Create_QuoteApproveReasonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all available QuoteApproveReasons.
     * @returns An array of all non-deleted QuoteApproveReason
     */
    public async GetQuoteApproveReasons(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteApproveReason[] >
    {
        return this._GetQuoteApproveReasons(webapi_options);
    }

    /*
     * Gets a QuoteDenyReason object.
     * @param quoteDenyReasonId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single QuoteDenyReason
     */
    public async GetQuoteDenyReason(quoteDenyReasonId: number, options?:base.WebApiRequestOptions) : Promise< carriers.QuoteDenyReason > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteDenyReason >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteDenyReason?quoteDenyReasonId=" + quoteDenyReasonId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteDenyReason_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of QuoteDenyReason objects.
     * @param quoteDenyReasonIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of QuoteDenyReason
     */
    public async GetQuoteDenyReasonList(quoteDenyReasonIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.QuoteDenyReason[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteDenyReason[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteDenyReasonList", quoteDenyReasonIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteDenyReasonArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetQuoteDenyReasons( options?:base.WebApiRequestOptions) : Promise< carriers.QuoteDenyReason[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.QuoteDenyReason[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteDenyReasons", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.QuoteDenyReason[] = converters.Create_QuoteDenyReasonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all available QuoteDenyReasons.
     * @returns An array of all non-deleted QuoteDenyReason
     */
    public async GetQuoteDenyReasons(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.QuoteDenyReason[] >
    {
        return this._GetQuoteDenyReasons(webapi_options);
    }

    /*
     * Gets a ReasonSold object.
     * @param reasonSoldId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ReasonSold
     */
    public async GetReasonSold(reasonSoldId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ReasonSold > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReasonSold >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonSold?reasonSoldId=" + reasonSoldId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonSold_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of ReasonSold objects.
     * @param reasonSoldIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ReasonSold
     */
    public async GetReasonSoldList(reasonSoldIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.ReasonSold[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReasonSold[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonSoldList", reasonSoldIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonSoldArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a ReasonStalled object.
     * @param reasonStalledId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ReasonStalled
     */
    public async GetReasonStalled(reasonStalledId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ReasonStalled > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReasonStalled >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonStalled?reasonStalledId=" + reasonStalledId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonStalled_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of ReasonStalled objects.
     * @param reasonStalledIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ReasonStalled
     */
    public async GetReasonStalledList(reasonStalledIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.ReasonStalled[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReasonStalled[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonStalledList", reasonStalledIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonStalledArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a RelationDefinitionEntity object.
     * @param relationDefinitionEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single RelationDefinitionEntity
     */
    public async GetRelationDefinitionEntity(relationDefinitionEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.RelationDefinitionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RelationDefinitionEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRelationDefinitionEntity?relationDefinitionEntityId=" + relationDefinitionEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RelationDefinitionEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a ResourceEntity object.
     * @param resourceEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ResourceEntity
     */
    public async GetResourceEntity(resourceEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ResourceEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ResourceEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetResourceEntity?resourceEntityId=" + resourceEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ResourceEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a SaleStageEntity object.
     * @param saleStageEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleStageEntity
     */
    public async GetSaleStageEntity(saleStageEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SaleStageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStageEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleStageEntity?saleStageEntityId=" + saleStageEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStageEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a SaleType object.
     * @param saleTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleType
     */
    public async GetSaleType(saleTypeId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SaleType > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleType >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleType?saleTypeId=" + saleTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleType_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a SaleTypeEntity object.
     * @param saleTypeEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleTypeEntity
     */
    public async GetSaleTypeEntity(saleTypeEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SaleTypeEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleTypeEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleTypeEntity?saleTypeEntityId=" + saleTypeEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleTypeEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of SaleType objects.
     * @param saleTypeIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of SaleType
     */
    public async GetSaleTypeList(saleTypeIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.SaleType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleType[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleTypeList", saleTypeIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleTypeArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetAllSaleType( options?:base.WebApiRequestOptions) : Promise< carriers.SaleType[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleType[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllSaleType", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleType[] = converters.Create_SaleTypeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all sale types as simple list items
     * @returns Array of simple sale type list items
     */
    public async GetAllSaleType(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleType[] >
    {
        return this._GetAllSaleType(webapi_options);
    }


    private async _GetAllSaleTypeEntities(request: carriers.List_GetAllSaleTypeEntitiesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SaleTypeEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleTypeEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllSaleTypeEntities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleTypeEntity[] = converters.Create_SaleTypeEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all sale types as entities with stakeholders, guide and quote properties
     * @param request - IncludeDeleted
     * @returns Array of sale type entities with stakeholders, guide and quote properties
     */
    public async GetAllSaleTypeEntities(request: carriers.List_GetAllSaleTypeEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleTypeEntity[] >;

    /**
     * Returns all sale types as entities with stakeholders, guide and quote properties
     * @param includeDeleted - Include deleted items in result?
     * @returns Array of sale type entities with stakeholders, guide and quote properties
     */
    public async GetAllSaleTypeEntities(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleTypeEntity[] >;

    public async GetAllSaleTypeEntities(includeDeleted:boolean|carriers.List_GetAllSaleTypeEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleTypeEntity[] > {
        let _request : carriers.List_GetAllSaleTypeEntitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.List_GetAllSaleTypeEntitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllSaleTypeEntities( _request, _options );
    }

    /*
     * Gets a SelectionCategory object.
     * @param selectionCategoryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SelectionCategory
     */
    public async GetSelectionCategory(selectionCategoryId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionCategory > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionCategory >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSelectionCategory?selectionCategoryId=" + selectionCategoryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionCategory_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of SelectionCategory objects.
     * @param selectionCategoryIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of SelectionCategory
     */
    public async GetSelectionCategoryList(selectionCategoryIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.SelectionCategory[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionCategory[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSelectionCategoryList", selectionCategoryIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionCategoryArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a Source object.
     * @param sourceId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Source
     */
    public async GetSource(sourceId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Source > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Source >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSource?sourceId=" + sourceId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Source_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of Source objects.
     * @param sourceIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Source
     */
    public async GetSourceList(sourceIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Source[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Source[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSourceList", sourceIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SourceArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetSources( options?:base.WebApiRequestOptions) : Promise< carriers.Source[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Source[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSources", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Source[] = converters.Create_SourceArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all sources
     * @returns Array of sources
     */
    public async GetSources(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Source[] >
    {
        return this._GetSources(webapi_options);
    }

    /*
     * Gets a Task object.
     * @param taskId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Task
     */
    public async GetTask(taskId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Task > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Task >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTask?taskId=" + taskId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Task_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetDocumentTemplateTask(request: carriers.List_GetDocumentTemplateTaskRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Task > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Task >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateTask", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Task = converters.Create_Task_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns a Document Template list item as a TaskListItem. The appointment&apos;s task is a Document template item when the appointment is a document.
     * @param request - DocumentTemplateId
     * @returns Document Template item as TaskListItem.
     */
    public async GetDocumentTemplateTask(request: carriers.List_GetDocumentTemplateTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Task >;

    /**
     * Returns a Document Template list item as a TaskListItem. The appointment&apos;s task is a Document template item when the appointment is a document.
     * @param documentTemplateId - Id of the document template, i.e. the Appointment.TaskIdx
     * @returns Document Template item as TaskListItem.
     */
    public async GetDocumentTemplateTask(documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Task >;

    public async GetDocumentTemplateTask(documentTemplateId:number|carriers.List_GetDocumentTemplateTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Task > {
        let _request : carriers.List_GetDocumentTemplateTaskRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.List_GetDocumentTemplateTaskRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentTemplateTask( _request, _options );
    }

    /*
     * Gets an array of Task objects.
     * @param taskIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Task
     */
    public async GetTaskList(taskIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Task[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Task[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTaskList", taskIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetTasks( options?:base.WebApiRequestOptions) : Promise< carriers.Task[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Task[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTasks", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Task[] = converters.Create_TaskArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all appointment tasks
     * @returns An array of all available tasks
     */
    public async GetTasks(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Task[] >
    {
        return this._GetTasks(webapi_options);
    }


    private async _GetDocumentTemplatesTasks( options?:base.WebApiRequestOptions) : Promise< carriers.Task[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Task[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplatesTasks", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Task[] = converters.Create_TaskArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * The appointment&apos;s task is a Document template item when the appointment is a document.
     * @returns Document Template list as a array of Tasks
     */
    public async GetDocumentTemplatesTasks(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Task[] >
    {
        return this._GetDocumentTemplatesTasks(webapi_options);
    }


    private async _GetAllTasks(request: carriers.List_GetAllTasksRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TaskListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllTasks", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TaskListItem[] = converters.Create_TaskListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all appointment tasks
     * @param request - IncludeDeleted
     * @returns An array of all available tasks
     */
    public async GetAllTasks(request: carriers.List_GetAllTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] >;

    /**
     * Returns all appointment tasks
     * @param includeDeleted - Include deleted items in result?
     * @returns An array of all available tasks
     */
    public async GetAllTasks(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] >;

    public async GetAllTasks(includeDeleted:boolean|carriers.List_GetAllTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TaskListItem[] > {
        let _request : carriers.List_GetAllTasksRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.List_GetAllTasksRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllTasks( _request, _options );
    }

    /*
     * Gets a TicketCategory object.
     * @param ticketCategoryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketCategory
     */
    public async GetTicketCategory(ticketCategoryId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TicketCategory > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketCategory >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketCategory?ticketCategoryId=" + ticketCategoryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketCategory_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a TicketCategoryEntity object.
     * @param ticketCategoryEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketCategoryEntity
     */
    public async GetTicketCategoryEntity(ticketCategoryEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TicketCategoryEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketCategoryEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketCategoryEntity?ticketCategoryEntityId=" + ticketCategoryEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketCategoryEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _MoveAllTickets(request: carriers.List_MoveAllTicketsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveAllTickets", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Move all tickets from one ticket category to another
     * @param request - FromTicketCategoryId, ToTicketCategoryId
     * @returns This method has no return value
     */
    public async MoveAllTickets(request: carriers.List_MoveAllTicketsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Move all tickets from one ticket category to another
     * @param fromTicketCategoryId - The id of the category we want to move tickets from
     * @param toTicketCategoryId - The id of the category we want to move the tickets to
     * @returns This method has no return value
     */
    public async MoveAllTickets(fromTicketCategoryId: number, toTicketCategoryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MoveAllTickets(fromTicketCategoryId:number|carriers.List_MoveAllTicketsRequest, toTicketCategoryId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_MoveAllTicketsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = fromTicketCategoryId;
        if( typeof( first ) === "object" && first && ( typeof(first.FromTicketCategoryId)!='undefined' || typeof(first.ToTicketCategoryId)!='undefined' ) )
        {
            _request = fromTicketCategoryId as carriers.List_MoveAllTicketsRequest;
            _options = toTicketCategoryId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FromTicketCategoryId: fromTicketCategoryId as number,
                       ToTicketCategoryId: toTicketCategoryId as number,
                       };   
            _options = webapi_options;
        }
        return this._MoveAllTickets( _request, _options );
    }


    private async _RebuildFullnames( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RebuildFullnames", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Update the fullname field of all categories. Use this e.g. when changing parentId or renaming a category with children.
     * @returns This method has no return value
     */
    public async RebuildFullnames(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._RebuildFullnames(webapi_options);
    }

    /*
     * Gets an array of TicketCategoryEntity objects.
     * @param ticketCategoryEntityIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of TicketCategoryEntity
     */
    public async GetTicketCategoryList(ticketCategoryEntityIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.TicketCategoryEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketCategoryEntity[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketCategoryList", ticketCategoryEntityIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketCategoryEntityArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetTicketCategories( options?:base.WebApiRequestOptions) : Promise< carriers.TicketCategoryEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketCategoryEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketCategories", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketCategoryEntity[] = converters.Create_TicketCategoryEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * 
     * @returns 
     */
    public async GetTicketCategories(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketCategoryEntity[] >
    {
        return this._GetTicketCategories(webapi_options);
    }


    private async _GetTicketCategoriesForUserGroups(request: carriers.List_GetTicketCategoriesForUserGroupsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketCategoriesForUserGroups", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MDOListItem[] = converters.Create_MDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Ticket categories for user groups
     * @param request - UserGroupIds
     * @returns 
     */
    public async GetTicketCategoriesForUserGroups(request: carriers.List_GetTicketCategoriesForUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    /**
     * Ticket categories for user groups
     * @param userGroupIds - The ids of the user groups we want tickets categories from
     * @returns 
     */
    public async GetTicketCategoriesForUserGroups(userGroupIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    public async GetTicketCategoriesForUserGroups(userGroupIds:number[]|carriers.List_GetTicketCategoriesForUserGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        let _request : carriers.List_GetTicketCategoriesForUserGroupsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userGroupIds;
        if( typeof( first ) === "object" && first && ( typeof(first.UserGroupIds)!='undefined' ) )
        {
            _request = userGroupIds as carriers.List_GetTicketCategoriesForUserGroupsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserGroupIds: userGroupIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetTicketCategoriesForUserGroups( _request, _options );
    }


    private async _SetTicketCategoriesForUserGroup(request: carriers.List_SetTicketCategoriesForUserGroupRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketCategoriesForUserGroup", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set ticket categories for one user group
     * @param request - UserGroupId, CategoryIds
     * @returns This method has no return value
     */
    public async SetTicketCategoriesForUserGroup(request: carriers.List_SetTicketCategoriesForUserGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set ticket categories for one user group
     * @param userGroupId - The ids of the user groups we want tickets categories from
     * @param categoryIds - The ids of the user groups we want tickets categories from
     * @returns This method has no return value
     */
    public async SetTicketCategoriesForUserGroup(userGroupId: number, categoryIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetTicketCategoriesForUserGroup(userGroupId:number|carriers.List_SetTicketCategoriesForUserGroupRequest, categoryIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetTicketCategoriesForUserGroupRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = userGroupId;
        if( typeof( first ) === "object" && first && ( typeof(first.UserGroupId)!='undefined' || typeof(first.CategoryIds)!='undefined' ) )
        {
            _request = userGroupId as carriers.List_SetTicketCategoriesForUserGroupRequest;
            _options = categoryIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       UserGroupId: userGroupId as number,
                       CategoryIds: categoryIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetTicketCategoriesForUserGroup( _request, _options );
    }


    private async _UpdateCategoryMemberships(request: carriers.List_UpdateCategoryMembershipsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateCategoryMemberships", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Updates category memberships
     * @param request - TicketCategoryId, MembershipsToAdd, MembershipsToUpdate, MembershipsToDelete
     * @returns This method has no return value
     */
    public async UpdateCategoryMemberships(request: carriers.List_UpdateCategoryMembershipsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Updates category memberships
     * @param ticketCategoryId - Id of ticket category to update memberships for
     * @param membershipsToAdd - List of memberships to add
     * @param membershipsToUpdate - List of memberships to update
     * @param membershipsToDelete - List of memberships to delete
     * @returns This method has no return value
     */
    public async UpdateCategoryMemberships(ticketCategoryId: number, membershipsToAdd: carriers.TicketCategoryMembershipEntity[], membershipsToUpdate: carriers.TicketCategoryMembershipEntity[], membershipsToDelete: carriers.TicketCategoryMembershipEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async UpdateCategoryMemberships(ticketCategoryId:number|carriers.List_UpdateCategoryMembershipsRequest, membershipsToAdd?:carriers.TicketCategoryMembershipEntity[]|base.WebApiRequestOptions, membershipsToUpdate?:carriers.TicketCategoryMembershipEntity[], membershipsToDelete?:carriers.TicketCategoryMembershipEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_UpdateCategoryMembershipsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketCategoryId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketCategoryId)!='undefined' || typeof(first.MembershipsToAdd)!='undefined' || typeof(first.MembershipsToUpdate)!='undefined' || typeof(first.MembershipsToDelete)!='undefined' ) )
        {
            _request = ticketCategoryId as carriers.List_UpdateCategoryMembershipsRequest;
            _options = membershipsToAdd as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketCategoryId: ticketCategoryId as number,
                       MembershipsToAdd: membershipsToAdd as carriers.TicketCategoryMembershipEntity[],
                       MembershipsToUpdate: membershipsToUpdate as carriers.TicketCategoryMembershipEntity[],
                       MembershipsToDelete: membershipsToDelete as carriers.TicketCategoryMembershipEntity[],
                       };   
            _options = webapi_options;
        }
        return this._UpdateCategoryMemberships( _request, _options );
    }

    /*
     * Gets a TicketPriority object.
     * @param ticketPriorityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketPriority
     */
    public async GetTicketPriority(ticketPriorityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriority > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketPriority >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketPriority?ticketPriorityId=" + ticketPriorityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriority_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a TicketPriorityEntity object.
     * @param ticketPriorityEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketPriorityEntity
     */
    public async GetTicketPriorityEntity(ticketPriorityEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriorityEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketPriorityEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketPriorityEntity?ticketPriorityEntityId=" + ticketPriorityEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriorityEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SetTicketPrioritySortOrder(request: carriers.List_SetTicketPrioritySortOrderRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketPrioritySortOrder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will set sort order of ticket priority in a list
     * @param request - TicketPriorityId, SortOrder
     * @returns This method has no return value
     */
    public async SetTicketPrioritySortOrder(request: carriers.List_SetTicketPrioritySortOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * This method will set sort order of ticket priority in a list
     * @param ticketPriorityId - Id of ticket priority
     * @param sortOrder - Indicates the sort order for this priority. 1 is first. Any records following this one will be renumbered automatically
     * @returns This method has no return value
     */
    public async SetTicketPrioritySortOrder(ticketPriorityId: number, sortOrder: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetTicketPrioritySortOrder(ticketPriorityId:number|carriers.List_SetTicketPrioritySortOrderRequest, sortOrder?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetTicketPrioritySortOrderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketPriorityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketPriorityId)!='undefined' || typeof(first.SortOrder)!='undefined' ) )
        {
            _request = ticketPriorityId as carriers.List_SetTicketPrioritySortOrderRequest;
            _options = sortOrder as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketPriorityId: ticketPriorityId as number,
                       SortOrder: sortOrder as number,
                       };   
            _options = webapi_options;
        }
        return this._SetTicketPrioritySortOrder( _request, _options );
    }

    /*
     * Gets an array of TicketPriority objects.
     * @param ticketPriorityIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of TicketPriority
     */
    public async GetTicketPriorityList(ticketPriorityIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriority[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketPriority[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketPriorityList", ticketPriorityIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriorityArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetTicketPriorities( options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriority[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketPriority[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketPriorities", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketPriority[] = converters.Create_TicketPriorityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * 
     * @returns 
     */
    public async GetTicketPriorities(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriority[] >
    {
        return this._GetTicketPriorities(webapi_options);
    }


    private async _GetAllTicketPriorities(request: carriers.List_GetAllTicketPrioritiesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriorityEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketPriorityEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllTicketPriorities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketPriorityEntity[] = converters.Create_TicketPriorityEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all available ticket priorities.
     * @param request - IncludeDeleted
     * @returns An array of all available ticket priorities
     */
    public async GetAllTicketPriorities(request: carriers.List_GetAllTicketPrioritiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriorityEntity[] >;

    /**
     * Returns all available ticket priorities.
     * @param includeDeleted - Include deleted items in result?
     * @returns An array of all available ticket priorities
     */
    public async GetAllTicketPriorities(includeDeleted: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriorityEntity[] >;

    public async GetAllTicketPriorities(includeDeleted:boolean|carriers.List_GetAllTicketPrioritiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketPriorityEntity[] > {
        let _request : carriers.List_GetAllTicketPrioritiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeDeleted;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeDeleted)!='undefined' ) )
        {
            _request = includeDeleted as carriers.List_GetAllTicketPrioritiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeDeleted: includeDeleted as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetAllTicketPriorities( _request, _options );
    }

    /*
     * Gets a TicketStatusEntity object.
     * @param ticketStatusEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketStatusEntity
     */
    public async GetTicketStatusEntity(ticketStatusEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TicketStatusEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketStatusEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketStatusEntity?ticketStatusEntityId=" + ticketStatusEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketStatusEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GlobalChangeTicketStatus(request: carriers.List_GlobalChangeTicketStatusRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GlobalChangeTicketStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will change all references from one ticket status to another. Typically used in conjuction with delete
     * @param request - FromTicketStatusId, ToTicketStatusId
     * @returns Does not return anything
     */
    public async GlobalChangeTicketStatus(request: carriers.List_GlobalChangeTicketStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * This method will change all references from one ticket status to another. Typically used in conjuction with delete
     * @param fromTicketStatusId - The id of the ticket status to change from
     * @param toTicketStatusId - The id of the ticket status to change to
     * @returns Does not return anything
     */
    public async GlobalChangeTicketStatus(fromTicketStatusId: number, toTicketStatusId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async GlobalChangeTicketStatus(fromTicketStatusId:number|carriers.List_GlobalChangeTicketStatusRequest, toTicketStatusId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_GlobalChangeTicketStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = fromTicketStatusId;
        if( typeof( first ) === "object" && first && ( typeof(first.FromTicketStatusId)!='undefined' || typeof(first.ToTicketStatusId)!='undefined' ) )
        {
            _request = fromTicketStatusId as carriers.List_GlobalChangeTicketStatusRequest;
            _options = toTicketStatusId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FromTicketStatusId: fromTicketStatusId as number,
                       ToTicketStatusId: toTicketStatusId as number,
                       };   
            _options = webapi_options;
        }
        return this._GlobalChangeTicketStatus( _request, _options );
    }


    private async _SetTicketStatusSortOrder(request: carriers.List_SetTicketStatusSortOrderRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketStatusSortOrder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will set sort order of ticket status in a list
     * @param request - TicketStatusId, SortOrder
     * @returns This method has no return value
     */
    public async SetTicketStatusSortOrder(request: carriers.List_SetTicketStatusSortOrderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * This method will set sort order of ticket status in a list
     * @param ticketStatusId - Id of ticket status
     * @param sortOrder - Indicates the sort order for this status. 1 is first. Any records following this one will be renumbered automatically
     * @returns This method has no return value
     */
    public async SetTicketStatusSortOrder(ticketStatusId: number, sortOrder: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetTicketStatusSortOrder(ticketStatusId:number|carriers.List_SetTicketStatusSortOrderRequest, sortOrder?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_SetTicketStatusSortOrderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketStatusId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketStatusId)!='undefined' || typeof(first.SortOrder)!='undefined' ) )
        {
            _request = ticketStatusId as carriers.List_SetTicketStatusSortOrderRequest;
            _options = sortOrder as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketStatusId: ticketStatusId as number,
                       SortOrder: sortOrder as number,
                       };   
            _options = webapi_options;
        }
        return this._SetTicketStatusSortOrder( _request, _options );
    }

    /*
     * Gets an array of TicketStatusEntity objects.
     * @param ticketStatusEntityIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of TicketStatusEntity
     */
    public async GetTicketStatusList(ticketStatusEntityIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.TicketStatusEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketStatusEntity[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketStatusList", ticketStatusEntityIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketStatusEntityArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetTicketStatuses( options?:base.WebApiRequestOptions) : Promise< carriers.TicketStatusEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketStatusEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketStatuses", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketStatusEntity[] = converters.Create_TicketStatusEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * 
     * @returns 
     */
    public async GetTicketStatuses(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketStatusEntity[] >
    {
        return this._GetTicketStatuses(webapi_options);
    }

    /*
     * Gets a WebPanelEntity object.
     * @param webPanelEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single WebPanelEntity
     */
    public async GetWebPanelEntity(webPanelEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WebPanelEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetWebPanelEntity?webPanelEntityId=" + webPanelEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WebPanelEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GenerateNavigationUrl(request: carriers.List_GenerateNavigationUrlRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateNavigationUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This methods generates the navigation URL to be used to navigate to the panel
     * @param request - VisibleIn, WindowName
     * @returns The navigation url
     */
    public async GenerateNavigationUrl(request: carriers.List_GenerateNavigationUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * This methods generates the navigation URL to be used to navigate to the panel
     * @param visibleIn - The visble in/navigation to generate for
     * @param windowName - The name of the web panel window
     * @returns The navigation url
     */
    public async GenerateNavigationUrl(visibleIn: enums.Navigation, windowName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GenerateNavigationUrl(visibleIn:enums.Navigation|carriers.List_GenerateNavigationUrlRequest, windowName?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.List_GenerateNavigationUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = visibleIn;
        if( typeof( first ) === "object" && first && ( typeof(first.VisibleIn)!='undefined' || typeof(first.WindowName)!='undefined' ) )
        {
            _request = visibleIn as carriers.List_GenerateNavigationUrlRequest;
            _options = windowName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       VisibleIn: visibleIn as enums.Navigation,
                       WindowName: windowName as string,
                       };   
            _options = webapi_options;
        }
        return this._GenerateNavigationUrl( _request, _options );
    }


    private async _GetWebPanelList( options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WebPanelEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWebPanelList", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WebPanelEntity[] = converters.Create_WebPanelEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Return a list of all web panels. 
     * @returns List of all web panels
     */
    public async GetWebPanelList(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity[] >
    {
        return this._GetWebPanelList(webapi_options);
    }


    private async _DeleteWebPanel(request: carriers.List_DeleteWebPanelRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteWebPanel", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Hard-delete (real, permanent DELETE in the database) the given web panel. Use with care!
     * @param request - Id
     * @returns This method has no return value
     */
    public async DeleteWebPanel(request: carriers.List_DeleteWebPanelRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Hard-delete (real, permanent DELETE in the database) the given web panel. Use with care!
     * @param id - Database id of web panel to delete
     * @returns This method has no return value
     */
    public async DeleteWebPanel(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteWebPanel(id:number|carriers.List_DeleteWebPanelRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.List_DeleteWebPanelRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.List_DeleteWebPanelRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteWebPanel( _request, _options );
    }


    private async _GetAppWebPanels( options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WebPanelEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppWebPanels", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WebPanelEntity[] = converters.Create_WebPanelEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get all web panels owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken
     * @returns List of all web panels owned by the current App
     */
    public async GetAppWebPanels(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity[] >
    {
        return this._GetAppWebPanels(webapi_options);
    }


    private async _DeleteAppWebPanels( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAppWebPanels", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Permanentely delete all web panels owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken; otherwise nothing happens
     * @returns This method has no return value
     */
    public async DeleteAppWebPanels(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._DeleteAppWebPanels(webapi_options);
    }


    private async _GetWebPanelByProgId(request: carriers.List_GetWebPanelByProgIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WebPanelEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWebPanelByProgId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WebPanelEntity = converters.Create_WebPanelEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a web panel using the ProgId key that was specified when it was created
     * @param request - ProgId
     * @returns The Web panel information
     */
    public async GetWebPanelByProgId(request: carriers.List_GetWebPanelByProgIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity >;

    /**
     * Get a web panel using the ProgId key that was specified when it was created
     * @param progId - String key that can be used to uniquely retrieve the panel, set in the WebPanelEntity when saving
     * @returns The Web panel information
     */
    public async GetWebPanelByProgId(progId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity >;

    public async GetWebPanelByProgId(progId:string|carriers.List_GetWebPanelByProgIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebPanelEntity > {
        let _request : carriers.List_GetWebPanelByProgIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = progId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProgId)!='undefined' ) )
        {
            _request = progId as carriers.List_GetWebPanelByProgIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProgId: progId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetWebPanelByProgId( _request, _options );
    }

    } // class v1ListAgentController 



// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/ConfigurationAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * User interface configuration - XMLs and other elements such as inter-client URLs
 */
export interface IConfigurationAgent {
    CreateDefaultConfigurableScreenDelta(): Promise< carriers.ConfigurableScreenDelta >;
    SaveConfigurableScreenDelta(entity: carriers.ConfigurableScreenDelta) : Promise< carriers.ConfigurableScreenDelta >;
    DeleteConfigurableScreenDelta(ConfigurableScreenDeltaId: number) : Promise<void>;
    CreateDefaultDiaryViewEntity(): Promise< carriers.DiaryViewEntity >;
    SaveDiaryViewEntity(entity: carriers.DiaryViewEntity) : Promise< carriers.DiaryViewEntity >;
    DeleteDiaryViewEntity(DiaryViewEntityId: number) : Promise<void>;
    CreateDefaultSystemEventEntity(): Promise< carriers.SystemEventEntity >;
    SaveSystemEventEntity(entity: carriers.SystemEventEntity) : Promise< carriers.SystemEventEntity >;
    DeleteSystemEventEntity(SystemEventEntityId: number) : Promise<void>;
    GetConfigurableScreenDelta(configurableScreenDeltaId: number) :  Promise< carriers.ConfigurableScreenDelta >;
    GetScreenConfigurationDeltas(webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetScreenConfigurationDelta(request: carriers.Configuration_GetScreenConfigurationDeltaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetScreenConfigurationDelta(deltaType: enums.DeltaType, deltaState: enums.DeltaState, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetConfigurableScreenDeltasByDelta(request: carriers.Configuration_GetConfigurableScreenDeltasByDeltaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] >;
    GetConfigurableScreenDeltasByDelta(configurableScreenDelta: carriers.ConfigurableScreenDelta, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] >;
    GetConfigurableScreenDeltasByQuery(request: carriers.Configuration_GetConfigurableScreenDeltasByQueryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] >;
    GetConfigurableScreenDeltasByQuery(deltaQuery: carriers.DeltaQuery, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] >;
    RebuildUdefDeltas(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RebuildWebpanelDeltas(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveAndPublish(request: carriers.Configuration_SaveAndPublishRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta >;
    SaveAndPublish(configurableScreenDelta: carriers.ConfigurableScreenDelta, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta >;
    SetAppliesToKey(request: carriers.Configuration_SetAppliesToKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetAppliesToKey(recipeId: string, appliesToKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetRecipeAppliesToMappings(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetApplicationConfiguration(request: carriers.Configuration_GetApplicationConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetApplicationConfiguration(application: string, instance: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetPageConfiguration(request: carriers.Configuration_GetPageConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetPageConfiguration(application: string, instance: string, page: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetObjectMapping(request: carriers.Configuration_GetObjectMappingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetObjectMapping(application: string, instance: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetFilterList(request: carriers.Configuration_GetFilterListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetFilterList(application: string, instance: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    ClearConfigurationCache(request: carriers.Configuration_ClearConfigurationCacheRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ClearConfigurationCache(application: string, instance: string, forAllAssociates: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetAnyConfiguration(request: carriers.Configuration_GetAnyConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetAnyConfiguration(application: string, instance: string, item: string, type: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetEMarketingUrl(request: carriers.Configuration_GetEMarketingUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetEMarketingUrl(language: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCsProgramUrl(request: carriers.Configuration_GetCsProgramUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCsProgramUrl(language: string, programName: string, action: string, extraParameters: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCSAuthUrl(request: carriers.Configuration_GetCSAuthUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCSAuthUrl(language: string, programName: string, action: string, extraParameters: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCSRegistryValue(request: carriers.Configuration_GetCSRegistryValueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCSRegistryValue(entry: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCSWwwFolder(webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetRefreshedPageConfiguration(request: carriers.Configuration_GetRefreshedPageConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetRefreshedPageConfiguration(application: string, instance: string, page: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetWwwUrl(request: carriers.Configuration_GetWwwUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetWwwUrl(client: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetHelpDispatcherUrl(webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetWwwUrlForSMWeb(webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCsCgiUrlInternal(webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCRMUrl(request: carriers.Configuration_GetCRMUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCRMUrl(soProtocol: string, currents: string, frameless: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetEmailNumberOfDays(webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetCustomerUrl(webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetSpfDomain(webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDiaryViewEntity(diaryViewEntityId: number) :  Promise< carriers.DiaryViewEntity >;
    GetSystemEventEntity(systemEventEntityId: number) :  Promise< carriers.SystemEventEntity >;
    ExistsSystemEvent(request: carriers.Configuration_ExistsSystemEventRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ExistsSystemEvent(key: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetWindowPosSize(windowPosSizeId: number) :  Promise< carriers.WindowPosSize >;
    SaveWindowPosSize(request: carriers.Configuration_SaveWindowPosSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize >;
    SaveWindowPosSize(windowPosSize: carriers.WindowPosSize, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize >;
    DeleteWindowPosSize(request: carriers.Configuration_DeleteWindowPosSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteWindowPosSize(windowPosSizeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetWindowPosSizeList(windowPosSizeIds: number[]) :  Promise< carriers.WindowPosSize[] >;
    GetMyWindowPosSizes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;
    GetWindowPosSizesOnPersonId(request: carriers.Configuration_GetWindowPosSizesOnPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;
    GetWindowPosSizesOnPersonId(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;
    GetWindowPosSizesOnAssociateId(request: carriers.Configuration_GetWindowPosSizesOnAssociateIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;
    GetWindowPosSizesOnAssociateId(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;
    SaveWindowPosSizes(request: carriers.Configuration_SaveWindowPosSizesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;
    SaveWindowPosSizes(windowPosSizes: carriers.WindowPosSize[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;
} // interface IConfigurationAgent




/**
 * User interface configuration - XMLs and other elements such as inter-client URLs
 */
export class ConfigurationAgent extends base.WebApiBase implements IConfigurationAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Configuration/";
        super(options);
    }



    /**
     * Set default values into a new ConfigurableScreenDelta.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultConfigurableScreenDelta(options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConfigurableScreenDelta >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultConfigurableScreenDelta", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConfigurableScreenDelta = converters.Create_ConfigurableScreenDelta_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ConfigurableScreenDelta or creates a new ConfigurableScreenDelta if the id parameter is empty
     * @param entity - The ConfigurableScreenDelta to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ConfigurableScreenDelta
     */
    public async SaveConfigurableScreenDelta(entity: carriers.ConfigurableScreenDelta, options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConfigurableScreenDelta >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveConfigurableScreenDelta", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConfigurableScreenDelta = converters.Create_ConfigurableScreenDelta_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ConfigurableScreenDelta
     * @param ConfigurableScreenDeltaId - The id of the ConfigurableScreenDelta to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteConfigurableScreenDelta(ConfigurableScreenDeltaId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteConfigurableScreenDelta?ConfigurableScreenDeltaId=" + ConfigurableScreenDeltaId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new DiaryViewEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDiaryViewEntity(options?:base.WebApiRequestOptions) : Promise< carriers.DiaryViewEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DiaryViewEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDiaryViewEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DiaryViewEntity = converters.Create_DiaryViewEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DiaryViewEntity or creates a new DiaryViewEntity if the id parameter is empty
     * @param entity - The DiaryViewEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DiaryViewEntity
     */
    public async SaveDiaryViewEntity(entity: carriers.DiaryViewEntity, options?:base.WebApiRequestOptions) : Promise< carriers.DiaryViewEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DiaryViewEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDiaryViewEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DiaryViewEntity = converters.Create_DiaryViewEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the DiaryViewEntity
     * @param DiaryViewEntityId - The id of the DiaryViewEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteDiaryViewEntity(DiaryViewEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDiaryViewEntity?DiaryViewEntityId=" + DiaryViewEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new SystemEventEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSystemEventEntity(options?:base.WebApiRequestOptions) : Promise< carriers.SystemEventEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SystemEventEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSystemEventEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SystemEventEntity = converters.Create_SystemEventEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SystemEventEntity or creates a new SystemEventEntity if the id parameter is empty
     * @param entity - The SystemEventEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SystemEventEntity
     */
    public async SaveSystemEventEntity(entity: carriers.SystemEventEntity, options?:base.WebApiRequestOptions) : Promise< carriers.SystemEventEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SystemEventEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSystemEventEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SystemEventEntity = converters.Create_SystemEventEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the SystemEventEntity
     * @param SystemEventEntityId - The id of the SystemEventEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteSystemEventEntity(SystemEventEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteSystemEventEntity?SystemEventEntityId=" + SystemEventEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ConfigurableScreenDelta object.
     * @param configurableScreenDeltaId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ConfigurableScreenDelta
     */
    public async GetConfigurableScreenDelta(configurableScreenDeltaId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConfigurableScreenDelta >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConfigurableScreenDelta?configurableScreenDeltaId=" + configurableScreenDeltaId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConfigurableScreenDelta_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetScreenConfigurationDeltas( options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetScreenConfigurationDeltas", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * This method will return a json with all deltas for screen
     * @returns A string with all recipe deltas in json for logged in associate
     */
    public async GetScreenConfigurationDeltas(webapi_options?:base.WebApiRequestOptions) : Promise< string >
    {
        return this._GetScreenConfigurationDeltas(webapi_options);
    }


    private async _GetScreenConfigurationDelta(request: carriers.Configuration_GetScreenConfigurationDeltaRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetScreenConfigurationDelta", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will return a json with all deltas for screen
     * @param request - DeltaType, DeltaState
     * @returns A string with recipe delta in json for logged in associate of given deltatype
     */
    public async GetScreenConfigurationDelta(request: carriers.Configuration_GetScreenConfigurationDeltaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * This method will return a json with all deltas for screen
     * @param deltaType - The recipe in json for this DeltaType: System, WebPanel, CustomFields, Custom...
     * @param deltaState - Draft or published or None
     * @returns A string with recipe delta in json for logged in associate of given deltatype
     */
    public async GetScreenConfigurationDelta(deltaType: enums.DeltaType, deltaState: enums.DeltaState, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetScreenConfigurationDelta(deltaType:enums.DeltaType|carriers.Configuration_GetScreenConfigurationDeltaRequest, deltaState?:enums.DeltaState|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetScreenConfigurationDeltaRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = deltaType;
        if( typeof( first ) === "object" && first && ( typeof(first.DeltaType)!='undefined' || typeof(first.DeltaState)!='undefined' ) )
        {
            _request = deltaType as carriers.Configuration_GetScreenConfigurationDeltaRequest;
            _options = deltaState as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DeltaType: deltaType as enums.DeltaType,
                       DeltaState: deltaState as enums.DeltaState,
                       };   
            _options = webapi_options;
        }
        return this._GetScreenConfigurationDelta( _request, _options );
    }


    private async _GetConfigurableScreenDeltasByDelta(request: carriers.Configuration_GetConfigurableScreenDeltasByDeltaRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConfigurableScreenDelta[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConfigurableScreenDeltasByDelta", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConfigurableScreenDelta[] = converters.Create_ConfigurableScreenDeltaArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will return a configurablescreen delta matching the properties received from the incomming delta
     * @param request - ConfigurableScreenDelta
     * @returns An array of deltas matching the values of the incomming parameter-delta
     */
    public async GetConfigurableScreenDeltasByDelta(request: carriers.Configuration_GetConfigurableScreenDeltasByDeltaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] >;

    /**
     * This method will return a configurablescreen delta matching the properties received from the incomming delta
     * @param configurableScreenDelta - A delta populated with wanted properties
     * @returns An array of deltas matching the values of the incomming parameter-delta
     */
    public async GetConfigurableScreenDeltasByDelta(configurableScreenDelta: carriers.ConfigurableScreenDelta, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] >;

    public async GetConfigurableScreenDeltasByDelta(configurableScreenDelta:carriers.ConfigurableScreenDelta|carriers.Configuration_GetConfigurableScreenDeltasByDeltaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] > {
        let _request : carriers.Configuration_GetConfigurableScreenDeltasByDeltaRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = configurableScreenDelta;
        if( typeof( first ) === "object" && first && ( typeof(first.ConfigurableScreenDelta)!='undefined' ) )
        {
            _request = configurableScreenDelta as carriers.Configuration_GetConfigurableScreenDeltasByDeltaRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConfigurableScreenDelta: configurableScreenDelta as carriers.ConfigurableScreenDelta,
                       };   
            _options = webapi_options;
        }
        return this._GetConfigurableScreenDeltasByDelta( _request, _options );
    }


    private async _GetConfigurableScreenDeltasByQuery(request: carriers.Configuration_GetConfigurableScreenDeltasByQueryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConfigurableScreenDelta[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConfigurableScreenDeltasByQuery", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConfigurableScreenDelta[] = converters.Create_ConfigurableScreenDeltaArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will return a configurablescreen delta matching the properties received from the incomming query
     * @param request - DeltaQuery
     * @returns An array of deltas matching the values of the incomming query
     */
    public async GetConfigurableScreenDeltasByQuery(request: carriers.Configuration_GetConfigurableScreenDeltasByQueryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] >;

    /**
     * This method will return a configurablescreen delta matching the properties received from the incomming query
     * @param deltaQuery - An object populated with wanted properties for the deltas to return
     * @returns An array of deltas matching the values of the incomming query
     */
    public async GetConfigurableScreenDeltasByQuery(deltaQuery: carriers.DeltaQuery, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] >;

    public async GetConfigurableScreenDeltasByQuery(deltaQuery:carriers.DeltaQuery|carriers.Configuration_GetConfigurableScreenDeltasByQueryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta[] > {
        let _request : carriers.Configuration_GetConfigurableScreenDeltasByQueryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = deltaQuery;
        if( typeof( first ) === "object" && first && ( typeof(first.DeltaQuery)!='undefined' ) )
        {
            _request = deltaQuery as carriers.Configuration_GetConfigurableScreenDeltasByQueryRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DeltaQuery: deltaQuery as carriers.DeltaQuery,
                       };   
            _options = webapi_options;
        }
        return this._GetConfigurableScreenDeltasByQuery( _request, _options );
    }


    private async _RebuildUdefDeltas( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RebuildUdefDeltas", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Flush and rebuild userdefined field deltas. Mostly used after publishing udefs or adding/editing Customer Service extrafields
     * @returns No return value
     */
    public async RebuildUdefDeltas(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._RebuildUdefDeltas(webapi_options);
    }


    private async _RebuildWebpanelDeltas( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RebuildWebpanelDeltas", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Flush and rebuild webpanel deltas. Mostly used after adding/editing webpanels or change group visibility of them
     * @returns No return value
     */
    public async RebuildWebpanelDeltas(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._RebuildWebpanelDeltas(webapi_options);
    }


    private async _SaveAndPublish(request: carriers.Configuration_SaveAndPublishRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConfigurableScreenDelta >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveAndPublish", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConfigurableScreenDelta = converters.Create_ConfigurableScreenDelta_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save the incomming draft and publish
     * @param request - ConfigurableScreenDelta
     * @returns The newly published version of the ConfigurbleScreenDelta
     */
    public async SaveAndPublish(request: carriers.Configuration_SaveAndPublishRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta >;

    /**
     * Save the incomming draft and publish
     * @param configurableScreenDelta - The ConfigurableScreenDelta draft that is going to be published
     * @returns The newly published version of the ConfigurbleScreenDelta
     */
    public async SaveAndPublish(configurableScreenDelta: carriers.ConfigurableScreenDelta, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta >;

    public async SaveAndPublish(configurableScreenDelta:carriers.ConfigurableScreenDelta|carriers.Configuration_SaveAndPublishRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConfigurableScreenDelta > {
        let _request : carriers.Configuration_SaveAndPublishRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = configurableScreenDelta;
        if( typeof( first ) === "object" && first && ( typeof(first.ConfigurableScreenDelta)!='undefined' ) )
        {
            _request = configurableScreenDelta as carriers.Configuration_SaveAndPublishRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConfigurableScreenDelta: configurableScreenDelta as carriers.ConfigurableScreenDelta,
                       };   
            _options = webapi_options;
        }
        return this._SaveAndPublish( _request, _options );
    }


    private async _SetAppliesToKey(request: carriers.Configuration_SetAppliesToKeyRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetAppliesToKey", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the type of assignTo the deltas of the given recipe should have
     * @param request - RecipeId, AppliesToKey
     * @returns Returns nothing
     */
    public async SetAppliesToKey(request: carriers.Configuration_SetAppliesToKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the type of assignTo the deltas of the given recipe should have
     * @param recipeId - The recipeId that will use this apply to type
     * @param appliesToKey - The type we should use for differencing between delta layout. Like usergroup or project type. Saved in table ConfigurableScreenAppliesTo
     * @returns Returns nothing
     */
    public async SetAppliesToKey(recipeId: string, appliesToKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetAppliesToKey(recipeId:string|carriers.Configuration_SetAppliesToKeyRequest, appliesToKey?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Configuration_SetAppliesToKeyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = recipeId;
        if( typeof( first ) === "object" && first && ( typeof(first.RecipeId)!='undefined' || typeof(first.AppliesToKey)!='undefined' ) )
        {
            _request = recipeId as carriers.Configuration_SetAppliesToKeyRequest;
            _options = appliesToKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RecipeId: recipeId as string,
                       AppliesToKey: appliesToKey as string,
                       };   
            _options = webapi_options;
        }
        return this._SetAppliesToKey( _request, _options );
    }


    private async _GetRecipeAppliesToMappings( options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecipeAppliesToMappings", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Return the a  dictionary with recipeId as key, and chosen appliesTo for that recipe, Like projecttype for projectcardrecipe
     * @returns Mapping of recipeId and selected appliesToKey
     */
    public async GetRecipeAppliesToMappings(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >
    {
        return this._GetRecipeAppliesToMappings(webapi_options);
    }


    private async _GetApplicationConfiguration(request: carriers.Configuration_GetApplicationConfigurationRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetApplicationConfiguration", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Return the application configuration. This is a list of pages, with information about the name, main panel and preference mappings of each page.
     * @param request - Application, Instance
     * @returns XML structure containing the application configuration
     */
    public async GetApplicationConfiguration(request: carriers.Configuration_GetApplicationConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Return the application configuration. This is a list of pages, with information about the name, main panel and preference mappings of each page.
     * @param application - The application name, for instance 'SixWeb'
     * @param instance - The instance name for the application, like 'MainInstance'
     * @returns XML structure containing the application configuration
     */
    public async GetApplicationConfiguration(application: string, instance: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetApplicationConfiguration(application:string|carriers.Configuration_GetApplicationConfigurationRequest, instance?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetApplicationConfigurationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = application;
        if( typeof( first ) === "object" && first && ( typeof(first.Application)!='undefined' || typeof(first.Instance)!='undefined' ) )
        {
            _request = application as carriers.Configuration_GetApplicationConfigurationRequest;
            _options = instance as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Application: application as string,
                       Instance: instance as string,
                       };   
            _options = webapi_options;
        }
        return this._GetApplicationConfiguration( _request, _options );
    }


    private async _GetPageConfiguration(request: carriers.Configuration_GetPageConfigurationRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPageConfiguration", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the configuration for one whole web page, including all its panels etc.  totally asynchronous items like menus are not included, but all references are resolved and all special processing is applied.
     * @param request - Application, Instance, Page
     * @returns XML containing the configuration for the given page, from the page down to the control level.
     */
    public async GetPageConfiguration(request: carriers.Configuration_GetPageConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the configuration for one whole web page, including all its panels etc.  totally asynchronous items like menus are not included, but all references are resolved and all special processing is applied.
     * @param application - The application name, for instance 'SixWeb
     * @param instance - The instance name for the application, like 'MainInstance'
     * @param page - Page name, must correspond to one of the pages in the Application Configuration
     * @returns XML containing the configuration for the given page, from the page down to the control level.
     */
    public async GetPageConfiguration(application: string, instance: string, page: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetPageConfiguration(application:string|carriers.Configuration_GetPageConfigurationRequest, instance?:string|base.WebApiRequestOptions, page?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetPageConfigurationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = application;
        if( typeof( first ) === "object" && first && ( typeof(first.Application)!='undefined' || typeof(first.Instance)!='undefined' || typeof(first.Page)!='undefined' ) )
        {
            _request = application as carriers.Configuration_GetPageConfigurationRequest;
            _options = instance as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Application: application as string,
                       Instance: instance as string,
                       Page: page as string,
                       };   
            _options = webapi_options;
        }
        return this._GetPageConfiguration( _request, _options );
    }


    private async _GetObjectMapping(request: carriers.Configuration_GetObjectMappingRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetObjectMapping", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the object mappings, i.e., the what code objects should be instantiated to handle the entities of the client configuration.
     * @param request - Application, Instance
     * @returns XML containing the object mappings, including assembly and class names
     */
    public async GetObjectMapping(request: carriers.Configuration_GetObjectMappingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the object mappings, i.e., the what code objects should be instantiated to handle the entities of the client configuration.
     * @param application - The application name, for instance 'SixWeb'
     * @param instance - The instance name for the application, like 'MainInstance'
     * @returns XML containing the object mappings, including assembly and class names
     */
    public async GetObjectMapping(application: string, instance: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetObjectMapping(application:string|carriers.Configuration_GetObjectMappingRequest, instance?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetObjectMappingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = application;
        if( typeof( first ) === "object" && first && ( typeof(first.Application)!='undefined' || typeof(first.Instance)!='undefined' ) )
        {
            _request = application as carriers.Configuration_GetObjectMappingRequest;
            _options = instance as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Application: application as string,
                       Instance: instance as string,
                       };   
            _options = webapi_options;
        }
        return this._GetObjectMapping( _request, _options );
    }


    private async _GetFilterList(request: carriers.Configuration_GetFilterListRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFilterList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the list of filters to be used for processing the configuration data for this application.
     * @param request - Application, Instance
     * @returns XML representing the list of filters and any configuration data they may need.
     */
    public async GetFilterList(request: carriers.Configuration_GetFilterListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the list of filters to be used for processing the configuration data for this application.
     * @param application - The application name, for instance 'SixWeb'
     * @param instance - The instance name for the application, like 'MainInstance'
     * @returns XML representing the list of filters and any configuration data they may need.
     */
    public async GetFilterList(application: string, instance: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetFilterList(application:string|carriers.Configuration_GetFilterListRequest, instance?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetFilterListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = application;
        if( typeof( first ) === "object" && first && ( typeof(first.Application)!='undefined' || typeof(first.Instance)!='undefined' ) )
        {
            _request = application as carriers.Configuration_GetFilterListRequest;
            _options = instance as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Application: application as string,
                       Instance: instance as string,
                       };   
            _options = webapi_options;
        }
        return this._GetFilterList( _request, _options );
    }


    private async _ClearConfigurationCache(request: carriers.Configuration_ClearConfigurationCacheRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ClearConfigurationCache", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Configuration XML&apos;s may be expensive to build and parse, and are therefore cached to the database. &lt;para/&gt;Cahcing is per application/instance/associate, and can be turned off through the config file. &lt;para/&gt;If caching is on, and the configuration is changed, it is necessary to clear the cached configurations from the database, through this call.&lt;para/&gt;Note that changes to the externalapplication table require cache invalidation. SoAdmin will do so automatically.
     * @param request - Application, Instance, ForAllAssociates
     * @returns There is no return value.
     */
    public async ClearConfigurationCache(request: carriers.Configuration_ClearConfigurationCacheRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Configuration XML&apos;s may be expensive to build and parse, and are therefore cached to the database. &lt;para/&gt;Cahcing is per application/instance/associate, and can be turned off through the config file. &lt;para/&gt;If caching is on, and the configuration is changed, it is necessary to clear the cached configurations from the database, through this call.&lt;para/&gt;Note that changes to the externalapplication table require cache invalidation. SoAdmin will do so automatically.
     * @param application - The application name, for instance 'SixWeb'
     * @param instance - The instance name for the application, like 'MainInstance'
     * @param forAllAssociates - If false, only the current associate's configuration is cleared. If true, configurations are cleared for all associates.
     * @returns There is no return value.
     */
    public async ClearConfigurationCache(application: string, instance: string, forAllAssociates: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ClearConfigurationCache(application:string|carriers.Configuration_ClearConfigurationCacheRequest, instance?:string|base.WebApiRequestOptions, forAllAssociates?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Configuration_ClearConfigurationCacheRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = application;
        if( typeof( first ) === "object" && first && ( typeof(first.Application)!='undefined' || typeof(first.Instance)!='undefined' || typeof(first.ForAllAssociates)!='undefined' ) )
        {
            _request = application as carriers.Configuration_ClearConfigurationCacheRequest;
            _options = instance as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Application: application as string,
                       Instance: instance as string,
                       ForAllAssociates: forAllAssociates as boolean,
                       };   
            _options = webapi_options;
        }
        return this._ClearConfigurationCache( _request, _options );
    }


    private async _GetAnyConfiguration(request: carriers.Configuration_GetAnyConfigurationRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAnyConfiguration", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get one defined configuration fragment, with full reference resolution and parsing applied. This is essentially the same service as the GetPageConfiguration, except that this service is not locked to objects of type Page.
     * @param request - Application, Instance, Item, Type
     * @returns Fully resolved and parsed configuration XML, as string.
     */
    public async GetAnyConfiguration(request: carriers.Configuration_GetAnyConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get one defined configuration fragment, with full reference resolution and parsing applied. This is essentially the same service as the GetPageConfiguration, except that this service is not locked to objects of type Page.
     * @param application - The application name, for instance Six.Web
     * @param instance - The instance name, for instance Main
     * @param item - The configuration item name (first component of file name)
     * @param type - The configuration item type (second component of file name)
     * @returns Fully resolved and parsed configuration XML, as string.
     */
    public async GetAnyConfiguration(application: string, instance: string, item: string, type: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetAnyConfiguration(application:string|carriers.Configuration_GetAnyConfigurationRequest, instance?:string|base.WebApiRequestOptions, item?:string, type?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetAnyConfigurationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = application;
        if( typeof( first ) === "object" && first && ( typeof(first.Application)!='undefined' || typeof(first.Instance)!='undefined' || typeof(first.Item)!='undefined' || typeof(first.Type)!='undefined' ) )
        {
            _request = application as carriers.Configuration_GetAnyConfigurationRequest;
            _options = instance as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Application: application as string,
                       Instance: instance as string,
                       Item: item as string,
                       Type: type as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAnyConfiguration( _request, _options );
    }


    private async _GetEMarketingUrl(request: carriers.Configuration_GetEMarketingUrlRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMarketingUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - Language
     * @returns 
     */
    public async GetEMarketingUrl(request: carriers.Configuration_GetEMarketingUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * 
     * @param language - 
     * @returns 
     */
    public async GetEMarketingUrl(language: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetEMarketingUrl(language:string|carriers.Configuration_GetEMarketingUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetEMarketingUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = language;
        if( typeof( first ) === "object" && first && ( typeof(first.Language)!='undefined' ) )
        {
            _request = language as carriers.Configuration_GetEMarketingUrlRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Language: language as string,
                       };   
            _options = webapi_options;
        }
        return this._GetEMarketingUrl( _request, _options );
    }


    private async _GetCsProgramUrl(request: carriers.Configuration_GetCsProgramUrlRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCsProgramUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will convert a module name into a CS URL.
     * @param request - Language, ProgramName, Action, ExtraParameters
     * @returns Returns a valid CS URL composed of the give parameters.
     */
    public async GetCsProgramUrl(request: carriers.Configuration_GetCsProgramUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * This method will convert a module name into a CS URL.
     * @param language - By setting this parameter, you can change the CS language for the current user.
     * @param programName - In this parameter you must specify which CS program you want to create an URL for. Valid examples are "ticket", "rms", "spm" etc.
     * @param action - Here you can optionally specify the action for the current program. This will enable you to go to a specific screen.
     * @param extraParameters - If an action is specified, you can specify extra parameters here. This can be used to set specific behaviour for the chosen screen/action. If an empty action is supplied, this parameter will be ignored.
     * @returns Returns a valid CS URL composed of the give parameters.
     */
    public async GetCsProgramUrl(language: string, programName: string, action: string, extraParameters: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetCsProgramUrl(language:string|carriers.Configuration_GetCsProgramUrlRequest, programName?:string|base.WebApiRequestOptions, action?:string, extraParameters?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetCsProgramUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = language;
        if( typeof( first ) === "object" && first && ( typeof(first.Language)!='undefined' || typeof(first.ProgramName)!='undefined' || typeof(first.Action)!='undefined' || typeof(first.ExtraParameters)!='undefined' ) )
        {
            _request = language as carriers.Configuration_GetCsProgramUrlRequest;
            _options = programName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Language: language as string,
                       ProgramName: programName as string,
                       Action: action as string,
                       ExtraParameters: extraParameters as string,
                       };   
            _options = webapi_options;
        }
        return this._GetCsProgramUrl( _request, _options );
    }


    private async _GetCSAuthUrl(request: carriers.Configuration_GetCSAuthUrlRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCSAuthUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Will generate an url to the emarketing module
     * @param request - Language, ProgramName, Action, ExtraParameters
     * @returns Returns a valid CS URL composed of the give parameters.
     */
    public async GetCSAuthUrl(request: carriers.Configuration_GetCSAuthUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Will generate an url to the emarketing module
     * @param language - By setting this parameter, you can change the CS language for the current user.
     * @param programName - In this parameter you must specify which CS program you want to create an URL for. Valid examples are "ticket", "rms", "spm" etc.
     * @param action - Here you can optionally specify the action for the current program. This will enable you to go to a specific screen.
     * @param extraParameters - If an action is specified, you can specify extra parameters here. This can be used to set specific behaviour for the chosen screen/action. If an empty action is supplied, this parameter will be ignored.
     * @returns Returns a valid CS URL composed of the give parameters.
     */
    public async GetCSAuthUrl(language: string, programName: string, action: string, extraParameters: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetCSAuthUrl(language:string|carriers.Configuration_GetCSAuthUrlRequest, programName?:string|base.WebApiRequestOptions, action?:string, extraParameters?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetCSAuthUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = language;
        if( typeof( first ) === "object" && first && ( typeof(first.Language)!='undefined' || typeof(first.ProgramName)!='undefined' || typeof(first.Action)!='undefined' || typeof(first.ExtraParameters)!='undefined' ) )
        {
            _request = language as carriers.Configuration_GetCSAuthUrlRequest;
            _options = programName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Language: language as string,
                       ProgramName: programName as string,
                       Action: action as string,
                       ExtraParameters: extraParameters as string,
                       };   
            _options = webapi_options;
        }
        return this._GetCSAuthUrl( _request, _options );
    }


    private async _GetCSRegistryValue(request: carriers.Configuration_GetCSRegistryValueRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCSRegistryValue", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will get a value from the CS Registry table.
     * @param request - Entry
     * @returns The value of the specified Registry entry
     */
    public async GetCSRegistryValue(request: carriers.Configuration_GetCSRegistryValueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * This method will get a value from the CS Registry table.
     * @param entry - The Registry entry to get
     * @returns The value of the specified Registry entry
     */
    public async GetCSRegistryValue(entry: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetCSRegistryValue(entry:number|carriers.Configuration_GetCSRegistryValueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetCSRegistryValueRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = entry;
        if( typeof( first ) === "object" && first && ( typeof(first.Entry)!='undefined' ) )
        {
            _request = entry as carriers.Configuration_GetCSRegistryValueRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Entry: entry as number,
                       };   
            _options = webapi_options;
        }
        return this._GetCSRegistryValue( _request, _options );
    }


    private async _GetCSWwwFolder( options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCSWwwFolder", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * This method will get the www folder for CS
     * @returns The www folder for CS
     */
    public async GetCSWwwFolder(webapi_options?:base.WebApiRequestOptions) : Promise< string >
    {
        return this._GetCSWwwFolder(webapi_options);
    }


    private async _GetRefreshedPageConfiguration(request: carriers.Configuration_GetRefreshedPageConfigurationRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRefreshedPageConfiguration", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the configuration for one whole web page, including all its panels etc.  totally asynchronous items like menus are not included, but all references are resolved and all special processing is applied. Does not use cache for fetching, but updates the cache with refreshed configuration.
     * @param request - Application, Instance, Page
     * @returns XML containing the configuration for the given page, from the page down to the control level.
     */
    public async GetRefreshedPageConfiguration(request: carriers.Configuration_GetRefreshedPageConfigurationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the configuration for one whole web page, including all its panels etc.  totally asynchronous items like menus are not included, but all references are resolved and all special processing is applied. Does not use cache for fetching, but updates the cache with refreshed configuration.
     * @param application - The application name, for instance 'SixWeb
     * @param instance - The instance name for the application, like 'MainInstance'
     * @param page - Page name, must correspond to one of the pages in the Application Configuration
     * @returns XML containing the configuration for the given page, from the page down to the control level.
     */
    public async GetRefreshedPageConfiguration(application: string, instance: string, page: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetRefreshedPageConfiguration(application:string|carriers.Configuration_GetRefreshedPageConfigurationRequest, instance?:string|base.WebApiRequestOptions, page?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetRefreshedPageConfigurationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = application;
        if( typeof( first ) === "object" && first && ( typeof(first.Application)!='undefined' || typeof(first.Instance)!='undefined' || typeof(first.Page)!='undefined' ) )
        {
            _request = application as carriers.Configuration_GetRefreshedPageConfigurationRequest;
            _options = instance as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Application: application as string,
                       Instance: instance as string,
                       Page: page as string,
                       };   
            _options = webapi_options;
        }
        return this._GetRefreshedPageConfiguration( _request, _options );
    }


    private async _GetWwwUrl(request: carriers.Configuration_GetWwwUrlRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWwwUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Will get the default URL used for the logo, from the [NetServices] PageUrl preferencec, with tags substituted.
     * @param request - Client
     * @returns URL to be used when clicking the logo
     */
    public async GetWwwUrl(request: carriers.Configuration_GetWwwUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Will get the default URL used for the logo, from the [NetServices] PageUrl preferencec, with tags substituted.
     * @param client - The name for the client application, like 'CS' or 'SM.web', used for the <clie> variable
     * @returns URL to be used when clicking the logo
     */
    public async GetWwwUrl(client: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetWwwUrl(client:string|carriers.Configuration_GetWwwUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetWwwUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = client;
        if( typeof( first ) === "object" && first && ( typeof(first.Client)!='undefined' ) )
        {
            _request = client as carriers.Configuration_GetWwwUrlRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Client: client as string,
                       };   
            _options = webapi_options;
        }
        return this._GetWwwUrl( _request, _options );
    }


    private async _GetHelpDispatcherUrl( options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHelpDispatcherUrl", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Will get the GetHelpDispatcherUrl used by the help system
     * @returns URL to be used by the help system
     */
    public async GetHelpDispatcherUrl(webapi_options?:base.WebApiRequestOptions) : Promise< string >
    {
        return this._GetHelpDispatcherUrl(webapi_options);
    }


    private async _GetWwwUrlForSMWeb( options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWwwUrlForSMWeb", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns the URL used for the logo by the SM.web client. Uses urldispatch.aspx
     * @returns Link to urldispatch.aspx tagged with [SOSITEURL]
     */
    public async GetWwwUrlForSMWeb(webapi_options?:base.WebApiRequestOptions) : Promise< string >
    {
        return this._GetWwwUrlForSMWeb(webapi_options);
    }


    private async _GetCsCgiUrlInternal( options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCsCgiUrlInternal", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * This method will get the host name for CS
     * @returns Will get the host name for where CS is installed
     */
    public async GetCsCgiUrlInternal(webapi_options?:base.WebApiRequestOptions) : Promise< string >
    {
        return this._GetCsCgiUrlInternal(webapi_options);
    }


    private async _GetCRMUrl(request: carriers.Configuration_GetCRMUrlRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCRMUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns a valid url based in the soprotocol provided
     * @param request - SoProtocol, Currents, Frameless
     * @returns Url with soprotocol
     */
    public async GetCRMUrl(request: carriers.Configuration_GetCRMUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Returns a valid url based in the soprotocol provided
     * @param soProtocol - SoProtocol to display. Eg. contact.activityarchive.minipreview
     * @param currents - currents to set. Eg. contact_id=100&person_id=299
     * @param frameless - If true frame is not rendered( Navigationbar, buttonbar and menu )
     * @returns Url with soprotocol
     */
    public async GetCRMUrl(soProtocol: string, currents: string, frameless: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetCRMUrl(soProtocol:string|carriers.Configuration_GetCRMUrlRequest, currents?:string|base.WebApiRequestOptions, frameless?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Configuration_GetCRMUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = soProtocol;
        if( typeof( first ) === "object" && first && ( typeof(first.SoProtocol)!='undefined' || typeof(first.Currents)!='undefined' || typeof(first.Frameless)!='undefined' ) )
        {
            _request = soProtocol as carriers.Configuration_GetCRMUrlRequest;
            _options = currents as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SoProtocol: soProtocol as string,
                       Currents: currents as string,
                       Frameless: frameless as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetCRMUrl( _request, _options );
    }


    private async _GetEmailNumberOfDays( options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailNumberOfDays", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * 
     * @returns Number of days in the past for which we are fetching email
     */
    public async GetEmailNumberOfDays(webapi_options?:base.WebApiRequestOptions) : Promise< number >
    {
        return this._GetEmailNumberOfDays(webapi_options);
    }


    private async _GetCustomerUrl( options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCustomerUrl", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * This method will get the URL for the external access to the customer center
     * @returns The URL to the customer center, without any actions
     */
    public async GetCustomerUrl(webapi_options?:base.WebApiRequestOptions) : Promise< string >
    {
        return this._GetCustomerUrl(webapi_options);
    }


    private async _GetSpfDomain( options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSpfDomain", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the SPF domain defined for the mail cluster for this tenant (Online only)
     * @returns The configured SPF domain. Will return empty for Onsite installations or tenants in Online using custom SMTP
     */
    public async GetSpfDomain(webapi_options?:base.WebApiRequestOptions) : Promise< string >
    {
        return this._GetSpfDomain(webapi_options);
    }

    /*
     * Gets a DiaryViewEntity object.
     * @param diaryViewEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DiaryViewEntity
     */
    public async GetDiaryViewEntity(diaryViewEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DiaryViewEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DiaryViewEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDiaryViewEntity?diaryViewEntityId=" + diaryViewEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DiaryViewEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a SystemEventEntity object.
     * @param systemEventEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SystemEventEntity
     */
    public async GetSystemEventEntity(systemEventEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SystemEventEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SystemEventEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSystemEventEntity?systemEventEntityId=" + systemEventEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SystemEventEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _ExistsSystemEvent(request: carriers.Configuration_ExistsSystemEventRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExistsSystemEvent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Is there a system event with the given key?
     * @param request - Key
     * @returns The system event
     */
    public async ExistsSystemEvent(request: carriers.Configuration_ExistsSystemEventRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Is there a system event with the given key?
     * @param key - The key to match on
     * @returns The system event
     */
    public async ExistsSystemEvent(key: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async ExistsSystemEvent(key:string|carriers.Configuration_ExistsSystemEventRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Configuration_ExistsSystemEventRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = key;
        if( typeof( first ) === "object" && first && ( typeof(first.Key)!='undefined' ) )
        {
            _request = key as carriers.Configuration_ExistsSystemEventRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Key: key as string,
                       };   
            _options = webapi_options;
        }
        return this._ExistsSystemEvent( _request, _options );
    }

    /*
     * Gets a WindowPosSize object.
     * @param windowPosSizeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single WindowPosSize
     */
    public async GetWindowPosSize(windowPosSizeId: number, options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WindowPosSize >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetWindowPosSize?windowPosSizeId=" + windowPosSizeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WindowPosSize_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _SaveWindowPosSize(request: carriers.Configuration_SaveWindowPosSizeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WindowPosSize >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveWindowPosSize", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WindowPosSize = converters.Create_WindowPosSize_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a window and dialog position and size setting.
     * @param request - WindowPosSize
     * @returns The saved item
     */
    public async SaveWindowPosSize(request: carriers.Configuration_SaveWindowPosSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize >;

    /**
     * Saves a window and dialog position and size setting.
     * @param windowPosSize - The item that is saved
     * @returns The saved item
     */
    public async SaveWindowPosSize(windowPosSize: carriers.WindowPosSize, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize >;

    public async SaveWindowPosSize(windowPosSize:carriers.WindowPosSize|carriers.Configuration_SaveWindowPosSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize > {
        let _request : carriers.Configuration_SaveWindowPosSizeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = windowPosSize;
        if( typeof( first ) === "object" && first && ( typeof(first.WindowPosSize)!='undefined' ) )
        {
            _request = windowPosSize as carriers.Configuration_SaveWindowPosSizeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       WindowPosSize: windowPosSize as carriers.WindowPosSize,
                       };   
            _options = webapi_options;
        }
        return this._SaveWindowPosSize( _request, _options );
    }


    private async _DeleteWindowPosSize(request: carriers.Configuration_DeleteWindowPosSizeRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteWindowPosSize", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes a window and dialog position and size setting.
     * @param request - WindowPosSizeId
     * @returns 
     */
    public async DeleteWindowPosSize(request: carriers.Configuration_DeleteWindowPosSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes a window and dialog position and size setting.
     * @param windowPosSizeId - Id of the window and dialog position and size settings item.
     * @returns 
     */
    public async DeleteWindowPosSize(windowPosSizeId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteWindowPosSize(windowPosSizeId:number|carriers.Configuration_DeleteWindowPosSizeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Configuration_DeleteWindowPosSizeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = windowPosSizeId;
        if( typeof( first ) === "object" && first && ( typeof(first.WindowPosSizeId)!='undefined' ) )
        {
            _request = windowPosSizeId as carriers.Configuration_DeleteWindowPosSizeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       WindowPosSizeId: windowPosSizeId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteWindowPosSize( _request, _options );
    }

    /*
     * Gets an array of WindowPosSize objects.
     * @param windowPosSizeIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of WindowPosSize
     */
    public async GetWindowPosSizeList(windowPosSizeIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WindowPosSize[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetWindowPosSizeList", windowPosSizeIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WindowPosSizeArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetMyWindowPosSizes( options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WindowPosSize[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyWindowPosSizes", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WindowPosSize[] = converters.Create_WindowPosSizeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets the window and dialog position and size settings belonging to the currently logged on user
     * @returns Array of window and dialog position and size settings
     */
    public async GetMyWindowPosSizes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >
    {
        return this._GetMyWindowPosSizes(webapi_options);
    }


    private async _GetWindowPosSizesOnPersonId(request: carriers.Configuration_GetWindowPosSizesOnPersonIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WindowPosSize[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWindowPosSizesOnPersonId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WindowPosSize[] = converters.Create_WindowPosSizeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the window and dialog position and size settings belonging to the specified person
     * @param request - PersonId
     * @returns Array of window and dialog position and size settings
     */
    public async GetWindowPosSizesOnPersonId(request: carriers.Configuration_GetWindowPosSizesOnPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;

    /**
     * Gets the window and dialog position and size settings belonging to the specified person
     * @param personId - Person id of the associate owning these window settings
     * @returns Array of window and dialog position and size settings
     */
    public async GetWindowPosSizesOnPersonId(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;

    public async GetWindowPosSizesOnPersonId(personId:number|carriers.Configuration_GetWindowPosSizesOnPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] > {
        let _request : carriers.Configuration_GetWindowPosSizesOnPersonIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Configuration_GetWindowPosSizesOnPersonIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetWindowPosSizesOnPersonId( _request, _options );
    }


    private async _GetWindowPosSizesOnAssociateId(request: carriers.Configuration_GetWindowPosSizesOnAssociateIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WindowPosSize[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWindowPosSizesOnAssociateId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WindowPosSize[] = converters.Create_WindowPosSizeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the window and dialog position and size settings belonging to the specified associate
     * @param request - AssociateId
     * @returns Array of window and dialog position and size settings
     */
    public async GetWindowPosSizesOnAssociateId(request: carriers.Configuration_GetWindowPosSizesOnAssociateIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;

    /**
     * Gets the window and dialog position and size settings belonging to the specified associate
     * @param associateId - Associate id of the Associate/Person owning these window settings
     * @returns Array of window and dialog position and size settings
     */
    public async GetWindowPosSizesOnAssociateId(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;

    public async GetWindowPosSizesOnAssociateId(associateId:number|carriers.Configuration_GetWindowPosSizesOnAssociateIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] > {
        let _request : carriers.Configuration_GetWindowPosSizesOnAssociateIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.Configuration_GetWindowPosSizesOnAssociateIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetWindowPosSizesOnAssociateId( _request, _options );
    }


    private async _SaveWindowPosSizes(request: carriers.Configuration_SaveWindowPosSizesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WindowPosSize[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveWindowPosSizes", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WindowPosSize[] = converters.Create_WindowPosSizeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a set of window and dialog position and size settings.
     * @param request - WindowPosSizes
     * @returns The saved items
     */
    public async SaveWindowPosSizes(request: carriers.Configuration_SaveWindowPosSizesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;

    /**
     * Saves a set of window and dialog position and size settings.
     * @param windowPosSizes - The items that are saved
     * @returns The saved items
     */
    public async SaveWindowPosSizes(windowPosSizes: carriers.WindowPosSize[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] >;

    public async SaveWindowPosSizes(windowPosSizes:carriers.WindowPosSize[]|carriers.Configuration_SaveWindowPosSizesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WindowPosSize[] > {
        let _request : carriers.Configuration_SaveWindowPosSizesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = windowPosSizes;
        if( typeof( first ) === "object" && first && ( typeof(first.WindowPosSizes)!='undefined' ) )
        {
            _request = windowPosSizes as carriers.Configuration_SaveWindowPosSizesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       WindowPosSizes: windowPosSizes as carriers.WindowPosSize[],
                       };   
            _options = webapi_options;
        }
        return this._SaveWindowPosSizes( _request, _options );
    }

    } // class v1ConfigurationAgentController 



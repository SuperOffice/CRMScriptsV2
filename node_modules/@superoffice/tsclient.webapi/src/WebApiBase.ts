import axios, {
	AxiosInstance,
	AxiosRequestConfig,
	AxiosResponse,
	CancelTokenSource,
	InternalAxiosRequestConfig
} from "axios";
import { AxiosCache } from "./AxiosCacheHandler";
import {
	HEADER_NAME_ACCEPT_LANGUAGE,
	HEADER_NAME_BROWSER_TZ_OFFSET,
	HEADER_NAME_CULTURE,
	HEADER_NAME_LANGUAGE,
	HEADER_NAME_TIMEZONE
} from "./SoApiConstants";

/** HTTP Request status on options object. Negative values indicate failure or cancellation. */
export enum WebApiStatus {
	Unknown = 0,
	Pending = 1,
	Completed = 10,
	Failed = -1,
	Cancelled = -4
}

/** How should Blob objects be returned? */
export enum ReturnBlobType {
	/** Return blob as ArrayBuffer */
	AsArrayBuffer = 0,
	/** Return Base64 string */
	AsBase64 = 1,
	/** Return blob as string */
	AsString = 2
}
/**
 * customize a single request: override language, monitor request state, cancel request using cancelToken.
 */
export interface WebApiRequestOptions {
	/** ISO 2 letter language code ('en', 'sv' etc) or '' to disable language parsing. */
	languageCode?: string;
	/** ISO 2 letter language code ('en', 'sv' etc) or '' to disable language parsing. */
	cultureCode?: string;
	/** SuperOffice Timezone ID or name ('UTC', 'AU-WA', 'FR', etc). Blank means the user's current timezone is used; see the SO-TIMEZONE reponse header. */
	timezone?: string;
	/** Include the timezone info on datetimes in the response? This may trigger conversions. e.g. Datetimes are returned with "Z" or "+2:00" suffix. See the SO-TIMEZONE reponse header. */
	timezoneInclude?: boolean;
	/** AbortController object - provides a method to abort the request */
	abortController?: AbortController;
	/** @deprecated cancel token object - provides a cancel(msg) method to abortbort the request */
	cancelToken?: CancelTokenSource;
	/** Has the HTTP request completed?. Negative values = failure/cancel. Completed OK = 10 */
	requestStatus?: WebApiStatus;
	/** How should BLOBs be returned: Base64, string or ArrayBuffer. */
	returnBlobAs?: ReturnBlobType;

	threshold?: IThreshold;
}

/**
 * Set a threshold on the request. When timeout is reached, callback will be executed. If request finished within timeout a successCallback is called
 */
export interface IThreshold {
	//Called when timeout is reached
	callback?: () => void;
	//Called when timeout is not reached
	successCallback?: () => void;
	//Called when thr request failed
	errorCallback?: () => void;
	//Threashold time
	timeout: number;
	//setTimeout handler
	timeoutHandler?: any;
}

/**
 * GET requests for the REST API
 */
export interface WebApiGetRequestOptions extends WebApiRequestOptions {
	/** Return entity only if it has been modified after the date, otherwise return HTTP 304 NotModified */
	ifModifiedSince?: Date;

	/** Return entity only if it has not been modified after the date, otherwise return HTTP 412 PreconditionFailed */
	ifUnmodifiedSince?: Date;

	/** Should HTTP 304 NotModified response throw error or return NULL? Default = return NULL */
	ifNotModifiedThrowError?: boolean;
}

/**
 * PUT and PATCH and DELETE requests for the REST API
 */
export interface WebApiPutRequestOptions extends WebApiRequestOptions {
	/** Return entity only if it has not been modified after the date, otherwise return HTTP 412 PreconditionFailed */
	ifUnmodifiedSince?: Date;
}

/** RFC6902 patch operations */
export enum WebApiPatchOp {
	add = "add",
	remove = "remove",
	replace = "replace",
	test = "test"
}

/** RFC6902 patch operation description. */
export interface WebApiPatchOperation {
	/** "add", "remove", "replace", or "test" */
	op: WebApiPatchOp;
	/** Path to property to apply op to: "/Department" - case insensitive. */
	path: string;
	/** Value to replace/add to the property identified by path. Not used by "remove" op. */
	value?: any;
}

/**
 * Configure the agent with a default URL, language values, whether to parse resource strings.
 * Can be overriden on individual requests using WebApiRequestOptions
 */
export interface WebApiOptions {
	/** The URL to API endpoint. 'https://crm.example.com/api' */
	baseUrl?: string;
	/** Additional path to add to the baseUrl. For internal use */
	basePath?: string;
	/** Should we send a language/culture header? */
	resourceParsing?: ResourceParsing;
	/** Language ISO code to parse responses to. Sends to server using Accept-Language header. e.g. 'en' or 'sv' */
	languageCode?: string;
	/** Language ISO code to parse values to. Sends to server using SO-CULTURE header. e.g. 'en' or 'sv'. Defaults to same as languageCode. */
	cultureCode?: string;
	/** SuperOffice Timezone ID ('UTC', 'AU-WA', 'FR', etc) or '' to disable timezone conversions */
	timezone?: string;
	/** Include the timezone info on the response? This may trigger conversions into local timezone by the runtime */
	timezoneInclude?: boolean;
	axios?: AxiosInstance;
	/** Default axios configuration. Overridden by languageCode/cultureCode. */
	axiosConfig?: AxiosRequestConfig;
	resourceManager?: any;
	cache?: cacheOptions;
	errorHandler?: (error: any) => Promise<any>;
}

export interface cacheOptions {
	refresh?: boolean;
	duration?: number;
}

/** Should WebAPI decode resource and multilang strings? Sets HTTP Language and Culture request headers to blank. */
export enum ResourceParsing {
	/** Enables string substitution in responses. Sends the culture/language header. */
	Parse = 0,
	/** Disables string substitution. Does not send culture/language header. */
	DoNotParse = 1
}

/** Base class for /api/v1/Agents/ clients */
export class WebApiBase {
	public static _global_options: WebApiOptions;
	protected _options: WebApiOptions;
	protected _axios: AxiosInstance;

	constructor(options: WebApiOptions, createAxios: boolean = true) {
		const nodejs = typeof process !== "undefined" && process.versions && process.versions.node;
		const isBrowser = !nodejs && (typeof window !== "undefined" || typeof self !== "undefined");
		if (!isBrowser && !options.baseUrl) throw new Error("WebAPI: BaseURL is not defined.");

		if (!WebApiBase._global_options) WebApiBase._global_options = WebApiBase.CloneOptions(options);

		this.SetBaseUrl(options);

		if (options.resourceManager && options.resourceManager.getCurrentLangCode) {
			options.languageCode = options.resourceManager.getCurrentLangCode();
		}
		if (options.resourceManager && options.resourceManager.getCurrentFormatCode) {
			options.cultureCode = options.resourceManager.getCurrentFormatCode();
		}
		if (!options.axios && createAxios) {
			options.axios = axios.create(options.axiosConfig);
			// Set UserAgent if not in browser
			if (!isBrowser) options.axios.defaults.headers["User-Agent"] = "SO-TS-WebApi/1.0";
			options.axios.defaults.headers["Content-Type"] = "application/json";
			options.axios.defaults.headers[HEADER_NAME_BROWSER_TZ_OFFSET] =
				-new Date().getTimezoneOffset();

			if (options.languageCode)
				options.axios.defaults.headers[HEADER_NAME_LANGUAGE] = options.languageCode;
			if (options.cultureCode)
				options.axios.defaults.headers[HEADER_NAME_CULTURE] = options.cultureCode;
			if (options.timezone) options.axios.defaults.headers[HEADER_NAME_TIMEZONE] = options.timezone;
			if (options.timezoneInclude) {
				options.axios.defaults.headers[HEADER_NAME_TIMEZONE] =
					options.axios.defaults.headers[HEADER_NAME_TIMEZONE] ?? "";
				if (options.axios.defaults.headers[HEADER_NAME_TIMEZONE])
					options.axios.defaults.headers[HEADER_NAME_TIMEZONE] += ",";
				options.axios.defaults.headers[HEADER_NAME_TIMEZONE] += "includeTZOffset";
			}

			if (options.resourceParsing === ResourceParsing.DoNotParse) {
				options.axios.defaults.headers[HEADER_NAME_ACCEPT_LANGUAGE] = "";
				options.axios.defaults.headers[HEADER_NAME_LANGUAGE] = "";
				options.axios.defaults.headers[HEADER_NAME_CULTURE] = "";
				delete options.axios.defaults.headers[HEADER_NAME_LANGUAGE];
				delete options.axios.defaults.headers[HEADER_NAME_CULTURE];
			}
			if (options.cache) {
				options.axios.interceptors.request.use(request =>
					this.requestHandler(request, options.cache)
				);
				options.axios.interceptors.response.use(
					response => this.responseHandler(response, options.cache),
					error => this.errorHandler(error)
				);
			} else {
				options.axios.interceptors.response.use(undefined, options.errorHandler);
			}
		}
		this._options = options;
		this._axios = options.axios;
	}
	private responseHandler(response: AxiosResponse<any>, cache: cacheOptions): AxiosResponse<any> {
		if (response.config.url) {
			AxiosCache.store(response.config["cachekey"], response.data, cache.duration);
		}
		return response;
	}

	//Handler when cache hits in requestHandler
	private errorHandler(error: any) {
		if (error && error.headers && error.headers.cached === "true") {
			return Promise.resolve(error);
		}
		if (this._options.errorHandler) {
			return this._options.errorHandler(error);
		}
		return Promise.reject(error);
	}

	private requestHandler(request: InternalAxiosRequestConfig, cache?: cacheOptions) {
		//if refresh we do nothing
		if (cache.refresh) {
			return request;
		}

		request["cachekey"] =
			this.hashValue(request.url + JSON.stringify(request.data)) +
			(request.headers.get(HEADER_NAME_LANGUAGE) ? request.headers.get(HEADER_NAME_LANGUAGE) : "");

		const checkIsValidResponse = AxiosCache.isValid(request["cachekey"] || "");
		if (checkIsValidResponse.isValid) {
			request.headers.set("cached", "true");
			request.data = checkIsValidResponse.value || "{}";
			// we 'fail' the request and let the error handler take care of the promise
			return Promise.reject(request);
		}

		return request;
	}

	protected SetBaseUrl(options: WebApiOptions): void {
		if (options.baseUrl === "") options.baseUrl = "/api/";
		if (options.baseUrl.lastIndexOf("/") < options.baseUrl.length - 1) options.baseUrl += "/";
		// Move BasePath onto BaseUrl
		if (options.basePath) {
			if (options.baseUrl.lastIndexOf("api/") < options.baseUrl.length - 4)
				options.baseUrl += "api/";
			options.baseUrl += options.basePath;
			options.basePath = undefined;
		}
	}
	private hashValue(s) {
		if (!s) return "";
		return (
			"_" +
			s.split("").reduce(function (a, b) {
				a = (a << 5) - a + b.charCodeAt(0);
				return a & a;
			}, 0)
		);
	}
	protected static CloneOptions(options: WebApiOptions): WebApiOptions {
		const clone: WebApiOptions = {
			baseUrl: options.baseUrl,
			resourceParsing: options.resourceParsing,
			languageCode: options.languageCode,
			cultureCode: options.cultureCode,
			timezone: options.timezone,
			timezoneInclude: options.timezoneInclude,
			axios: options.axios,
			axiosConfig: options.axiosConfig,
			resourceManager: options.resourceManager,
			cache: options.cache,
			errorHandler: options.errorHandler
		};
		return clone;
	}

	public static GetAxiosRequestConfig(
		options?: WebApiRequestOptions,
		baseOptions?: WebApiOptions
	): AxiosRequestConfig {
		let config: AxiosRequestConfig = null;
		if (baseOptions) {
			if (baseOptions.axiosConfig) config = { ...baseOptions.axiosConfig }; // clone axios config
			config = config || {};
			if (baseOptions.baseUrl) config.baseURL = baseOptions.baseUrl;
		}
		config = config || {};
		config.params = config.params || {};
		config.headers = config.headers || {};
		config.headers["Accept"] = "application/json";

		if (options) {
			options.requestStatus = WebApiStatus.Pending;
			if (typeof options.languageCode == "string") {
				config.headers[HEADER_NAME_ACCEPT_LANGUAGE] = options.languageCode;
				config.headers[HEADER_NAME_LANGUAGE] = options.languageCode;
			}
			if (typeof options.cultureCode == "string") {
				config.headers[HEADER_NAME_CULTURE] = options.cultureCode;
			}
			if (typeof options.timezone == "string") {
				config.headers[HEADER_NAME_TIMEZONE] = options.timezone;
			}
			if (options.timezoneInclude) {
				config.headers[HEADER_NAME_TIMEZONE] = config.headers[HEADER_NAME_TIMEZONE] ?? "";
				if (config.headers[HEADER_NAME_TIMEZONE]) config.headers[HEADER_NAME_TIMEZONE] += ",";
				config.headers[HEADER_NAME_TIMEZONE] += "includeTZOffset";
			}
			// If we have abortController, do not use cancel token
			if (options.abortController) {
				config.signal = options.abortController.signal;
			} else if (options.cancelToken) {
				config.cancelToken = options.cancelToken.token;
			}
			if (options.abortController) {
				config.signal = options.abortController.signal;
			}
			const getOptions = options as WebApiGetRequestOptions;
			if (getOptions && getOptions.ifModifiedSince) {
				if (typeof getOptions.ifModifiedSince == "object")
					config.headers["If-Modified-Since"] = getOptions.ifModifiedSince.toUTCString();
				if (typeof getOptions.ifModifiedSince == "string")
					config.headers["If-Modified-Since"] = getOptions.ifModifiedSince;
				if (!getOptions.ifNotModifiedThrowError)
					config.validateStatus = WebApiBase.validateModifiedStatus;
				else config.validateStatus = WebApiBase.validate200Status; // 304 throws error
			}
			if (getOptions && getOptions.ifUnmodifiedSince) {
				if (typeof getOptions.ifUnmodifiedSince == "object")
					config.headers["If-Unmodified-Since"] = getOptions.ifUnmodifiedSince.toUTCString();
				if (typeof getOptions.ifUnmodifiedSince == "string")
					config.headers["If-Unmodified-Since"] = getOptions.ifUnmodifiedSince;
			}
			const putOptions = options as WebApiPutRequestOptions;
			if (putOptions && putOptions.ifUnmodifiedSince) {
				if (typeof putOptions.ifUnmodifiedSince == "object")
					config.headers["If-Unmodified-Since"] = putOptions.ifUnmodifiedSince.toUTCString();
				if (typeof putOptions.ifUnmodifiedSince == "string")
					config.headers["If-Unmodified-Since"] = putOptions.ifUnmodifiedSince;
			}
		}
		WebApiBase.SetXSRFTokenFromHiddenField();
		return config;
	}

	public static SetXSRFTokenFromHiddenField() {
		// don't do this if we are not in browser context
		if (typeof window != "undefined" && document && document.cookie) {
			if (document.cookie.indexOf("XSRF-TOKEN") < 0) {
				// no XSRF-TOKEN cookie - see if we can add one from the hidden form field
				let xsrfToken = undefined;
				let msg = undefined;
				const xsrfInput = document.getElementById("XSRF_TOKEN") as HTMLInputElement;
				if (xsrfInput) {
					xsrfToken = xsrfInput.value;
					msg = "Setting XSRF cookie from INPUT field";
				}
				if (!xsrfToken) {
					// still no XSRF-TOKEN value
					msg = "No XSRF cookie found.";
					if (console) console.log(msg);
				}
				if (xsrfToken) {
					// Normalize path:
					// "/crm.web/admin/default.aspx" --> "/crm.web/"
					// '/crm.web/cs/scripts/ticket.exe' --> '/crm.web/cs/"
					let path = window.location.pathname;
					let lowpath = path.toLowerCase();
					if (lowpath.endsWith("default.aspx")) path = path.substring(0, path.length - 12);
					lowpath = path.toLowerCase();
					if (lowpath.endsWith("/")) path = path.substring(0, path.length - 1);
					lowpath = path.toLowerCase();
					if (lowpath.endsWith("/admin")) path = path.substring(0, path.length - 6);
					lowpath = path.toLowerCase();
					let scriptsPos = lowpath.indexOf("/scripts/");
					let exePos = lowpath.indexOf(".fcgi");
					if (exePos < 0) exePos = lowpath.indexOf(".exe");
					if (scriptsPos > 0 && exePos > 0) {
						path = path.substring(0, scriptsPos); // /crm.web/cs/scripts/ticket.exe' --> '/crm.web/cs'
						let slashPos = path.lastIndexOf("/");
						if (slashPos > 1) path = path.substring(0, slashPos); // '/crm.web/cs' --> ''/crm.web'
					}
					document.cookie = "XSRF-TOKEN=" + xsrfToken + ";SameSite=Lax;Secure;path=" + path;
					if (console) console.log(msg);
					document.cookie = "XSRF-FROM-INPUT=" + path + ";SameSite=Lax;Secure;"; // path defaults to document location
				}
			}
		}
	}

	// `validateStatus` defines whether to resolve or reject the promise for a given
	// HTTP response status code. If `validateStatus` returns `true` (or is set to `null`
	// or `undefined`), the promise will be resolved; otherwise, the promise will be
	// rejected.
	// validate 304 Unmodified as ok
	private static validateModifiedStatus(status: number): boolean {
		const validate: boolean = (status >= 200 && status < 300) || status === 304;
		return validate;
	}
	private static validate200Status(status: number): boolean {
		const validate: boolean = status >= 200 && status < 300;
		return validate;
	}

	public static FigureOutOptions(
		baseUrlOrOptions: string | WebApiOptions | undefined,
		langOrconfigOrRMOrParse?: string | ResourceParsing | AxiosRequestConfig | any,
		langOrResourceOrRM?: string | ResourceParsing | any,
		cultureCode?: string
	): WebApiOptions {
		let options: WebApiOptions = {};

		if (typeof baseUrlOrOptions == "object") {
			// Make a copy so we don't mess up caller's copy of options object
			options = baseUrlOrOptions as WebApiOptions;
			options = WebApiBase.CloneOptions(options);
		} else if (typeof baseUrlOrOptions == "string") {
			options = {
				baseUrl: baseUrlOrOptions as string
			};
		}

		if (typeof langOrconfigOrRMOrParse == "string") {
			options.languageCode = langOrconfigOrRMOrParse as string;
		} else if (typeof langOrconfigOrRMOrParse == "object") {
			if (langOrconfigOrRMOrParse.getCurrentLangCode && langOrconfigOrRMOrParse.getCurrentLangCode)
				options.resourceManager = langOrconfigOrRMOrParse;
			if (
				langOrconfigOrRMOrParse.auth ||
				langOrconfigOrRMOrParse.baseURL ||
				langOrconfigOrRMOrParse.url ||
				langOrconfigOrRMOrParse.headers ||
				langOrconfigOrRMOrParse.timeout
			)
				options.axiosConfig = langOrconfigOrRMOrParse as AxiosRequestConfig;
		} else if (typeof langOrconfigOrRMOrParse == "number") {
			options.resourceParsing = langOrconfigOrRMOrParse as ResourceParsing;
		}

		if (typeof langOrResourceOrRM == "string") {
			options.languageCode = langOrResourceOrRM as string;
		} else if (typeof langOrResourceOrRM == "number") {
			options.resourceParsing = langOrResourceOrRM as ResourceParsing;
		} else if (typeof langOrResourceOrRM == "object") {
			if (langOrResourceOrRM.getCurrentLangCode && langOrResourceOrRM.getCurrentLangCode)
				options.resourceManager = langOrResourceOrRM;
			if (
				langOrResourceOrRM.auth ||
				langOrResourceOrRM.baseURL ||
				langOrResourceOrRM.url ||
				langOrResourceOrRM.headers ||
				langOrResourceOrRM.timeout
			)
				options.axiosConfig = langOrResourceOrRM as AxiosRequestConfig;
		}

		if (cultureCode) options.cultureCode = cultureCode;

		// Check for global defaults for missing properties
		if (WebApiBase._global_options) {
			if (!options.baseUrl) options.baseUrl = WebApiBase._global_options.baseUrl;
			if (!options.axios) options.axios = WebApiBase._global_options.axios;
			if (!options.axiosConfig) options.axiosConfig = WebApiBase._global_options.axiosConfig;
			if (!options.cultureCode) options.cultureCode = WebApiBase._global_options.cultureCode;
			if (!options.languageCode) options.languageCode = WebApiBase._global_options.languageCode;
			if (!options.timezone) options.timezone = WebApiBase._global_options.timezone;
			if (options.timezoneInclude === undefined)
				options.timezoneInclude = WebApiBase._global_options.timezoneInclude;
			if (!options.resourceManager)
				options.resourceManager = WebApiBase._global_options.resourceManager;
			if (!options.errorHandler) options.errorHandler = WebApiBase._global_options.errorHandler;
		}

		return options;
	}

	/** @deprecated Make a new cancel token that can be placed in an WebApiRequestOptions object. */
	public MakeCancelToken(): CancelTokenSource {
		return axios.CancelToken.source();
	}

	/** Make a new AbortController that can be placed in an  WebApiRequestOptions object */
	public MakeAbortController(): AbortController {
		return new AbortController();
	}

	/** @deprecated Make a new options object with an cancelToken on it. */
	public MakeOptions(): WebApiRequestOptions {
		const opts: WebApiRequestOptions = {};
		opts.requestStatus = WebApiStatus.Unknown;
		opts.cancelToken = this.MakeCancelToken();
		return opts;
	}

	/** Make a new options object with an abortController on it */
	public MakeAbortableOptions(): WebApiRequestOptions {
		const opts: WebApiRequestOptions = {};
		opts.requestStatus = WebApiStatus.Unknown;
		opts.abortController = this.MakeAbortController();
		return opts;
	}

	public static SetPending(options: WebApiRequestOptions) {
		if (options) options.requestStatus = WebApiStatus.Pending;

		if (options && options.threshold) {
			options.threshold.timeoutHandler = setTimeout(() => {
				//We do not want successCallback to be call if the threshold is reached
				if (options.threshold.timeout > 0) options.threshold.successCallback = null;
				options.threshold.callback();
			}, options.threshold.timeout);
		}
		if (options?.cancelToken?.token.reason) options.requestStatus = WebApiStatus.Cancelled;
	}

	public static SetCompleted(options: WebApiRequestOptions) {
		if (options) {
			if (options?.threshold) {
				clearTimeout(options.threshold.timeoutHandler);
				if (options.threshold.successCallback) options.threshold.successCallback();
			}
			if (options.cancelToken?.token?.reason) options.requestStatus = WebApiStatus.Cancelled;
			else options.requestStatus = WebApiStatus.Completed;
		}
	}

	public static HandleError(options: WebApiRequestOptions, config: AxiosRequestConfig, err: any) {
		if (options) {
			if (options && options.threshold) {
				clearTimeout(options.threshold.timeoutHandler);
				if (options.threshold.errorCallback) options.threshold.errorCallback();
			}

			if ((config?.signal || config?.cancelToken) && axios.isCancel(err)) {
				options.requestStatus = WebApiStatus.Cancelled;
			} else {
				options.requestStatus = WebApiStatus.Failed;
			}
		}
	}
}

// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/DocumentAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Collection of all services that works with Document data. This is services for the document information, not the physical document themselves. These are handled by the BLOB service methods.
 */
export interface IDocumentAgent {
    CreateDefaultDocumentEntity(): Promise< carriers.DocumentEntity >;
    SaveDocumentEntity(entity: carriers.DocumentEntity) : Promise< carriers.DocumentEntity >;
    DeleteDocumentEntity(DocumentEntityId: number) : Promise<void>;
    CreateDefaultDocumentPreview(): Promise< carriers.DocumentPreview >;
    CreateDefaultSuggestedDocumentEntity(): Promise< carriers.SuggestedDocumentEntity >;
    SaveSuggestedDocumentEntity(entity: carriers.SuggestedDocumentEntity) : Promise< carriers.SuggestedDocumentEntity >;
    CreateDefaultTemplateVariablesParameters(): Promise< carriers.TemplateVariablesParameters >;
    GetDocument(documentId: number) :  Promise< carriers.Document >;
    GetDocumentEntity(documentEntityId: number) :  Promise< carriers.DocumentEntity >;
    GetDocumentStreamFromEntity(request: carriers.Document_GetDocumentStreamFromEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetDocumentStreamFromEntity(documentEntity: carriers.DocumentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SetDocumentStream(request: carriers.Document_SetDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    SetDocumentStream(documentEntity: carriers.DocumentEntity, stream: ArrayBuffer|string, overwriteExistingData: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    CreateDocumentStream(request: carriers.Document_CreateDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    CreateDocumentStream(documentEntity: carriers.DocumentEntity, overwriteExistingData: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetTemplateStream(request: carriers.Document_GetTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetTemplateStream(templateName: string, allowPersonal: boolean, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetSanitizedTemplateStream(request: carriers.Document_GetSanitizedTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetSanitizedTemplateStream(templateName: string, allowPersonal: boolean, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetTemplateStreamFromId(request: carriers.Document_GetTemplateStreamFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetTemplateStreamFromId(templateId: number, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetSanitizedTemplateStreamFromId(request: carriers.Document_GetSanitizedTemplateStreamFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetSanitizedTemplateStreamFromId(templateId: number, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetDocumentStream(request: carriers.Document_GetDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetSanitizedDocumentStream(request: carriers.Document_GetSanitizedDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetSanitizedDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetPreviewDocumentStream(request: carriers.Document_GetPreviewDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;
    GetPreviewDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;
    GetUnsanitizedPreviewDocumentStream(request: carriers.Document_GetUnsanitizedPreviewDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;
    GetUnsanitizedPreviewDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;
    CreateNewPhysicalMailMergeDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalMailMergeDocumentFromTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    CreateNewPhysicalMailMergeDocumentFromTemplate(documentId: number, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    CreateNewPhysicalDocumentFromTemplateWithCustomTags(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTagsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    CreateNewPhysicalDocumentFromTemplateWithCustomTags(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, customTags: string[], customValues: string[], uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    CreateNewPhysicalDocumentFromTemplateWithCustomTags2(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTags2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    CreateNewPhysicalDocumentFromTemplateWithCustomTags2(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, customTags: carriers.StringDictionary, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    SubstituteTemplateVariables(request: carriers.Document_SubstituteTemplateVariablesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SubstituteTemplateVariables(source: string, generatorEncoding: enums.GeneratorEncoding, contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SubstituteTemplateVariablesWithCustomTags(request: carriers.Document_SubstituteTemplateVariablesWithCustomTagsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SubstituteTemplateVariablesWithCustomTags(source: string, generatorEncoding: enums.GeneratorEncoding, customTags: string[], customValues: string[], contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SubstituteTemplateVariablesWithCustomTags2(request: carriers.Document_SubstituteTemplateVariablesWithCustomTags2Request, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SubstituteTemplateVariablesWithCustomTags2(source: string, generatorEncoding: enums.GeneratorEncoding, customTags: carriers.StringDictionary, contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    CreateTempFile(request: carriers.Document_CreateTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    CreateTempFile(filename: string, dataStream: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetTempFile(request: carriers.Document_GetTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetTempFile(filename: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    DeleteTempFile(request: carriers.Document_DeleteTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteTempFile(filename: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetTemplateStream(request: carriers.Document_SetTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetTemplateStream(filename: string, personal: boolean, stream: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateNewPhysicalDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    CreateNewPhysicalDocumentFromTemplate(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    SubstituteMergeDocumentTemplateVariables(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SubstituteMergeDocumentTemplateVariables(documentId: number, associateId: number, customTags: string[], customValues: string[], webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SubstituteMergeDocumentTemplateVariables2(request: carriers.Document_SubstituteMergeDocumentTemplateVariables2Request, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SubstituteMergeDocumentTemplateVariables2(documentId: number, associateId: number, customTags: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SubstituteTemplateVariablesEx(request: carriers.Document_SubstituteTemplateVariablesExRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SubstituteTemplateVariablesEx(parameters: carriers.TemplateVariablesParameters, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    VerifyGetDocumentStream(request: carriers.Document_VerifyGetDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    VerifyGetDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SubstituteMergeDocumentTemplateVariablesEx(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesExRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SubstituteMergeDocumentTemplateVariablesEx(mergeDocumentId: number, contactId: number, personId: number, projectId: number, selectionId: number, appointmentId: number, documentId: number, saleId: number, customTags: string[], customValues: string[], webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SubstituteMergeDocumentTemplateVariablesEx2(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesEx2Request, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SubstituteMergeDocumentTemplateVariablesEx2(mergeDocumentId: number, contactId: number, personId: number, projectId: number, selectionId: number, appointmentId: number, documentId: number, saleId: number, customTags: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetDocumentUrl(request: carriers.Document_GetDocumentUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDocumentUrl(documentId: number, versionId: string, writeableUrl: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    DeletePhysicalDocument(request: carriers.Document_DeletePhysicalDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    DeletePhysicalDocument(documentId: number, allowedReturnType: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    RenameDocument(request: carriers.Document_RenameDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    RenameDocument(documentId: number, newFilename: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCheckoutState(request: carriers.Document_GetCheckoutStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CheckoutInfo >;
    GetCheckoutState(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CheckoutInfo >;
    CheckoutDocument(request: carriers.Document_CheckoutDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    CheckoutDocument(documentId: number, allowedReturnTypes: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    CheckinDocument(request: carriers.Document_CheckinDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    CheckinDocument(documentId: number, allowedReturnTypes: string[], versionDescription: string, versionExtraFields: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    UndoCheckoutDocument(request: carriers.Document_UndoCheckoutDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    UndoCheckoutDocument(documentId: number, allowedReturnTypes: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    GetVersionList(request: carriers.Document_GetVersionListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.VersionInfo[] >;
    GetVersionList(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.VersionInfo[] >;
    GetPluginList(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetPluginCapabilities(request: carriers.Document_GetPluginCapabilitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetPluginCapabilities(pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetDocumentProperties(request: carriers.Document_GetDocumentPropertiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetDocumentProperties(documentId: number, requestedProperties: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetDocumentCommands(request: carriers.Document_GetDocumentCommandsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CommandInfo[] >;
    GetDocumentCommands(documentId: number, allowedReturnTypes: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CommandInfo[] >;
    ExecuteDocumentCommand(request: carriers.Document_ExecuteDocumentCommandRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    ExecuteDocumentCommand(documentId: number, versionId: string, allowedReturnTypes: string[], command: string, additionalData: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;
    CreateDefaultDocumentEntityFromSuggestion(request: carriers.Document_CreateDefaultDocumentEntityFromSuggestionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    CreateDefaultDocumentEntityFromSuggestion(suggestedDocumentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    SaveDocumentTemplateStream(request: carriers.Document_SaveDocumentTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo >;
    SaveDocumentTemplateStream(documentTemplateId: number, content: ArrayBuffer|string, languageCode: string, pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo >;
    SetDocumentStreamFromId(request: carriers.Document_SetDocumentStreamFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    SetDocumentStreamFromId(documentId: number, stream: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;
    SavePrivacyReport(request: carriers.Document_SavePrivacyReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    SavePrivacyReport(htmlReport: string, title: string, personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    ValidateDocumentEntity(request: carriers.Document_ValidateDocumentEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    ValidateDocumentEntity(documentEntity: carriers.DocumentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetDocumentLength(request: carriers.Document_GetDocumentLengthRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetDocumentLength(documentId: number, versionId: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetDocumentList(documentIds: number[]) :  Promise< carriers.Document[] >;
    GetAppointmentDocuments(request: carriers.Document_GetAppointmentDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetAppointmentDocuments(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetSaleDocuments(request: carriers.Document_GetSaleDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetSaleDocuments(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocuments(request: carriers.Document_GetPersonDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocuments(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPublishedDocument(request: carriers.Document_GetPublishedDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document >;
    GetPublishedDocument(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document >;
    GetPublishedDocuments(request: carriers.Document_GetPublishedDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPublishedDocuments(documentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetMyPublishedDocuments(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPublishedDocumentsByDate(request: carriers.Document_GetPublishedDocumentsByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPublishedDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetContactDocumentsByTemplateTypes(request: carriers.Document_GetContactDocumentsByTemplateTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetContactDocumentsByTemplateTypes(contactId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetContactDocumentsByTemplateType(request: carriers.Document_GetContactDocumentsByTemplateTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetContactDocumentsByTemplateType(contactId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetContactDocumentsByTemplateHeading(request: carriers.Document_GetContactDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetContactDocumentsByTemplateHeading(contactId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetContactDocuments(request: carriers.Document_GetContactDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetContactDocuments(contactId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPublishedPersonDocumentsByDate(request: carriers.Document_GetPublishedPersonDocumentsByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPublishedPersonDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPublishedProjectDocuments(request: carriers.Document_GetPublishedProjectDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPublishedProjectDocuments(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectMemberDocumentsByTemplateTypes(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectMemberDocumentsByTemplateTypes(personId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectMemberDocumentsByTemplateType(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectMemberDocumentsByTemplateType(personId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectMemberDocumentsByTemplateHeading(request: carriers.Document_GetProjectMemberDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectMemberDocumentsByTemplateHeading(personId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectMemberDocuments(request: carriers.Document_GetProjectMemberDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectMemberDocuments(personId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectDocumentsByTemplateTypes(request: carriers.Document_GetProjectDocumentsByTemplateTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectDocumentsByTemplateTypes(projectId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectDocumentsByTemplateType(request: carriers.Document_GetProjectDocumentsByTemplateTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectDocumentsByTemplateType(projectId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectDocumentsByTemplateHeading(request: carriers.Document_GetProjectDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectDocumentsByTemplateHeading(projectId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectDocuments(request: carriers.Document_GetProjectDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetProjectDocuments(projectId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocumentsByTemplateTypes(request: carriers.Document_GetPersonDocumentsByTemplateTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocumentsByTemplateTypes(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocumentsByTemplateType(request: carriers.Document_GetPersonDocumentsByTemplateTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocumentsByTemplateType(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocumentsByTemplateHeading(request: carriers.Document_GetPersonDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocumentsByTemplateHeading(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocumentsByDate(request: carriers.Document_GetPersonDocumentsByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetPersonDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetDocumentsByTemplateHeading(request: carriers.Document_GetDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetDocumentsByTemplateHeading(templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;
    GetSuggestedDocumentEntity(suggestedDocumentEntityId: number) :  Promise< carriers.SuggestedDocumentEntity >;
} // interface IDocumentAgent




/**
 * Collection of all services that works with Document data. This is services for the document information, not the physical document themselves. These are handled by the BLOB service methods.
 */
export class DocumentAgent extends base.WebApiBase implements IDocumentAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Document/";
        super(options);
    }



    /**
     * Set default values into a new DocumentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDocumentEntity(options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDocumentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentEntity = converters.Create_DocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DocumentEntity or creates a new DocumentEntity if the id parameter is empty
     * @param entity - The DocumentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DocumentEntity
     */
    public async SaveDocumentEntity(entity: carriers.DocumentEntity, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDocumentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentEntity = converters.Create_DocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the DocumentEntity
     * @param DocumentEntityId - The id of the DocumentEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteDocumentEntity(DocumentEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDocumentEntity?DocumentEntityId=" + DocumentEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new DocumentPreview.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDocumentPreview(options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentPreview >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDocumentPreview", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentPreview = converters.Create_DocumentPreview_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new SuggestedDocumentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSuggestedDocumentEntity(options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedDocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SuggestedDocumentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSuggestedDocumentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SuggestedDocumentEntity = converters.Create_SuggestedDocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SuggestedDocumentEntity or creates a new SuggestedDocumentEntity if the id parameter is empty
     * @param entity - The SuggestedDocumentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SuggestedDocumentEntity
     */
    public async SaveSuggestedDocumentEntity(entity: carriers.SuggestedDocumentEntity, options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedDocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SuggestedDocumentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSuggestedDocumentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SuggestedDocumentEntity = converters.Create_SuggestedDocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new TemplateVariablesParameters.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultTemplateVariablesParameters(options?:base.WebApiRequestOptions) : Promise< carriers.TemplateVariablesParameters > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TemplateVariablesParameters >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTemplateVariablesParameters", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TemplateVariablesParameters = converters.Create_TemplateVariablesParameters_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Document object.
     * @param documentId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Document
     */
    public async GetDocument(documentId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Document > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocument?documentId=" + documentId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Document_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a DocumentEntity object.
     * @param documentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DocumentEntity
     */
    public async GetDocumentEntity(documentEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentEntity?documentEntityId=" + documentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetDocumentStreamFromEntity(request: carriers.Document_GetDocumentStreamFromEntityRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentStreamFromEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the document as a stream
     * @param request - DocumentEntity
     * @returns The document as a Stream
     */
    public async GetDocumentStreamFromEntity(request: carriers.Document_GetDocumentStreamFromEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Get the document as a stream
     * @param documentEntity - The document entity object that refers to the binary data (document)
     * @returns The document as a Stream
     */
    public async GetDocumentStreamFromEntity(documentEntity: carriers.DocumentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetDocumentStreamFromEntity(documentEntity:carriers.DocumentEntity|carriers.Document_GetDocumentStreamFromEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_GetDocumentStreamFromEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentEntity)!='undefined' ) )
        {
            _request = documentEntity as carriers.Document_GetDocumentStreamFromEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentEntity: documentEntity as carriers.DocumentEntity,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentStreamFromEntity( _request, _options );
    }


    private async _SetDocumentStream(request: carriers.Document_SetDocumentStreamRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentEntity = converters.Create_DocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Store a document&apos;s contents from its stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - DocumentEntity, Stream, OverwriteExistingData
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    public async SetDocumentStream(request: carriers.Document_SetDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    /**
     * Store a document&apos;s contents from its stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param documentEntity - The document entity object that the binary data (document) should be stored to. Its file name may be amended by this call, see the return value
     * @param stream - The document as a stream.
     * @param overwriteExistingData - If true, the stream will overwrite existing data stored for this record in the document archive; this works only for documents that already have a physical document in existence. If false, the call will only work for a document that has no physical document in the archive, and such a physical document will be created.
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    public async SetDocumentStream(documentEntity: carriers.DocumentEntity, stream: ArrayBuffer|string, overwriteExistingData: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    public async SetDocumentStream(documentEntity:carriers.DocumentEntity|carriers.Document_SetDocumentStreamRequest, stream?:ArrayBuffer|string|base.WebApiRequestOptions, overwriteExistingData?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        let _request : carriers.Document_SetDocumentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentEntity)!='undefined' || typeof(first.Stream)!='undefined' || typeof(first.OverwriteExistingData)!='undefined' ) )
        {
            _request = documentEntity as carriers.Document_SetDocumentStreamRequest;
            _options = stream as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentEntity: documentEntity as carriers.DocumentEntity,
                       Stream: stream as ArrayBuffer|string,
                       OverwriteExistingData: overwriteExistingData as boolean,
                       };   
            _options = webapi_options;
        }
         _request.Stream = ToBase64(_request.Stream);
        return this._SetDocumentStream( _request, _options );
    }


    private async _CreateDocumentStream(request: carriers.Document_CreateDocumentStreamRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDocumentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a new Stream that can be used to store the document in the file archive.
     * @param request - DocumentEntity, OverwriteExistingData
     * @returns A writeable stream. When written and closed, the stream will become the new document content, subject to locking and versioning constraints.
     */
    public async CreateDocumentStream(request: carriers.Document_CreateDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Creates a new Stream that can be used to store the document in the file archive.
     * @param documentEntity - The document the stream belongs to
     * @param overwriteExistingData - If true, the stream will overwrite existing data stored for this record in the document archive
     * @returns A writeable stream. When written and closed, the stream will become the new document content, subject to locking and versioning constraints.
     */
    public async CreateDocumentStream(documentEntity: carriers.DocumentEntity, overwriteExistingData: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async CreateDocumentStream(documentEntity:carriers.DocumentEntity|carriers.Document_CreateDocumentStreamRequest, overwriteExistingData?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_CreateDocumentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentEntity)!='undefined' || typeof(first.OverwriteExistingData)!='undefined' ) )
        {
            _request = documentEntity as carriers.Document_CreateDocumentStreamRequest;
            _options = overwriteExistingData as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentEntity: documentEntity as carriers.DocumentEntity,
                       OverwriteExistingData: overwriteExistingData as boolean,
                       };   
            _options = webapi_options;
        }
        return this._CreateDocumentStream( _request, _options );
    }


    private async _GetTemplateStream(request: carriers.Document_GetTemplateStreamRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTemplateStream", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve a stream to a mail template based on its name
     * @param request - TemplateName, AllowPersonal, UiCulture
     * @returns Open stream to the mail template
     */
    public async GetTemplateStream(request: carriers.Document_GetTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Retrieve a stream to a mail template based on its name
     * @param templateName - Filename of mail template to retrieve
     * @param allowPersonal - If true, try looking up template in personal area before looking in shared document template area
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns Open stream to the mail template
     */
    public async GetTemplateStream(templateName: string, allowPersonal: boolean, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetTemplateStream(templateName:string|carriers.Document_GetTemplateStreamRequest, allowPersonal?:boolean|base.WebApiRequestOptions, uiCulture?:string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_GetTemplateStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = templateName;
        if( typeof( first ) === "object" && first && ( typeof(first.TemplateName)!='undefined' || typeof(first.AllowPersonal)!='undefined' || typeof(first.UiCulture)!='undefined' ) )
        {
            _request = templateName as carriers.Document_GetTemplateStreamRequest;
            _options = allowPersonal as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TemplateName: templateName as string,
                       AllowPersonal: allowPersonal as boolean,
                       UiCulture: uiCulture as string,
                       };   
            _options = webapi_options;
        }
        return this._GetTemplateStream( _request, _options );
    }


    private async _GetSanitizedTemplateStream(request: carriers.Document_GetSanitizedTemplateStreamRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSanitizedTemplateStream", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve a stream to a mail template based on its name. Sanitizes the contents if possible.
     * @param request - TemplateName, AllowPersonal, UiCulture
     * @returns Open stream to the mail template
     */
    public async GetSanitizedTemplateStream(request: carriers.Document_GetSanitizedTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Retrieve a stream to a mail template based on its name. Sanitizes the contents if possible.
     * @param templateName - Filename of mail template to retrieve
     * @param allowPersonal - If true, try looking up template in personal area before looking in shared document template area
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns Open stream to the mail template
     */
    public async GetSanitizedTemplateStream(templateName: string, allowPersonal: boolean, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetSanitizedTemplateStream(templateName:string|carriers.Document_GetSanitizedTemplateStreamRequest, allowPersonal?:boolean|base.WebApiRequestOptions, uiCulture?:string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_GetSanitizedTemplateStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = templateName;
        if( typeof( first ) === "object" && first && ( typeof(first.TemplateName)!='undefined' || typeof(first.AllowPersonal)!='undefined' || typeof(first.UiCulture)!='undefined' ) )
        {
            _request = templateName as carriers.Document_GetSanitizedTemplateStreamRequest;
            _options = allowPersonal as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TemplateName: templateName as string,
                       AllowPersonal: allowPersonal as boolean,
                       UiCulture: uiCulture as string,
                       };   
            _options = webapi_options;
        }
        return this._GetSanitizedTemplateStream( _request, _options );
    }


    private async _GetTemplateStreamFromId(request: carriers.Document_GetTemplateStreamFromIdRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTemplateStreamFromId", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve a stream to a document template based on its id
     * @param request - TemplateId, UiCulture
     * @returns Open stream to the template
     */
    public async GetTemplateStreamFromId(request: carriers.Document_GetTemplateStreamFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Retrieve a stream to a document template based on its id
     * @param templateId - Id of template to retrieve
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns Open stream to the template
     */
    public async GetTemplateStreamFromId(templateId: number, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetTemplateStreamFromId(templateId:number|carriers.Document_GetTemplateStreamFromIdRequest, uiCulture?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_GetTemplateStreamFromIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = templateId;
        if( typeof( first ) === "object" && first && ( typeof(first.TemplateId)!='undefined' || typeof(first.UiCulture)!='undefined' ) )
        {
            _request = templateId as carriers.Document_GetTemplateStreamFromIdRequest;
            _options = uiCulture as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TemplateId: templateId as number,
                       UiCulture: uiCulture as string,
                       };   
            _options = webapi_options;
        }
        return this._GetTemplateStreamFromId( _request, _options );
    }


    private async _GetSanitizedTemplateStreamFromId(request: carriers.Document_GetSanitizedTemplateStreamFromIdRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSanitizedTemplateStreamFromId", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve a stream to a document template based on its id. Sanitizes the contents if possible.
     * @param request - TemplateId, UiCulture
     * @returns Open stream to the template
     */
    public async GetSanitizedTemplateStreamFromId(request: carriers.Document_GetSanitizedTemplateStreamFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Retrieve a stream to a document template based on its id. Sanitizes the contents if possible.
     * @param templateId - Id of template to retrieve
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns Open stream to the template
     */
    public async GetSanitizedTemplateStreamFromId(templateId: number, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetSanitizedTemplateStreamFromId(templateId:number|carriers.Document_GetSanitizedTemplateStreamFromIdRequest, uiCulture?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_GetSanitizedTemplateStreamFromIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = templateId;
        if( typeof( first ) === "object" && first && ( typeof(first.TemplateId)!='undefined' || typeof(first.UiCulture)!='undefined' ) )
        {
            _request = templateId as carriers.Document_GetSanitizedTemplateStreamFromIdRequest;
            _options = uiCulture as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TemplateId: templateId as number,
                       UiCulture: uiCulture as string,
                       };   
            _options = webapi_options;
        }
        return this._GetSanitizedTemplateStreamFromId( _request, _options );
    }


    private async _GetDocumentStream(request: carriers.Document_GetDocumentStreamRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the document content as a stream
     * @param request - DocumentId
     * @returns The document as a Stream. This stream can be read once and clients should not assume it remains valid after a ReadToEnd or Close.
     */
    public async GetDocumentStream(request: carriers.Document_GetDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Get the document content as a stream
     * @param documentId - SuperOffice document id
     * @returns The document as a Stream. This stream can be read once and clients should not assume it remains valid after a ReadToEnd or Close.
     */
    public async GetDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetDocumentStream(documentId:number|carriers.Document_GetDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_GetDocumentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetDocumentStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentStream( _request, _options );
    }


    private async _GetSanitizedDocumentStream(request: carriers.Document_GetSanitizedDocumentStreamRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSanitizedDocumentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the document content as a stream. Retrieves a sanitized version if possible
     * @param request - DocumentId
     * @returns The document as a Stream. This stream can be read once and clients should not assume it remains valid after a ReadToEnd or Close.
     */
    public async GetSanitizedDocumentStream(request: carriers.Document_GetSanitizedDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Get the document content as a stream. Retrieves a sanitized version if possible
     * @param documentId - SuperOffice document id
     * @returns The document as a Stream. This stream can be read once and clients should not assume it remains valid after a ReadToEnd or Close.
     */
    public async GetSanitizedDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetSanitizedDocumentStream(documentId:number|carriers.Document_GetSanitizedDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_GetSanitizedDocumentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetSanitizedDocumentStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetSanitizedDocumentStream( _request, _options );
    }


    private async _GetPreviewDocumentStream(request: carriers.Document_GetPreviewDocumentStreamRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentPreview >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewDocumentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentPreview = converters.Create_DocumentPreview_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the preview version of the document content as a stream. Retrieves a sanitized version if possible
     * @param request - DocumentId
     * @returns Preview version of the document
     */
    public async GetPreviewDocumentStream(request: carriers.Document_GetPreviewDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;

    /**
     * Get the preview version of the document content as a stream. Retrieves a sanitized version if possible
     * @param documentId - SuperOffice document id
     * @returns Preview version of the document
     */
    public async GetPreviewDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;

    public async GetPreviewDocumentStream(documentId:number|carriers.Document_GetPreviewDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview > {
        let _request : carriers.Document_GetPreviewDocumentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetPreviewDocumentStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviewDocumentStream( _request, _options );
    }


    private async _GetUnsanitizedPreviewDocumentStream(request: carriers.Document_GetUnsanitizedPreviewDocumentStreamRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentPreview >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedPreviewDocumentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentPreview = converters.Create_DocumentPreview_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the preview version of the document content as a stream. Retrieves an unsanitized version. This has less CPU impact but the caller must sanitize the content before presenting it to the user.
     * @param request - DocumentId
     * @returns Unsanitized preview version of the document
     */
    public async GetUnsanitizedPreviewDocumentStream(request: carriers.Document_GetUnsanitizedPreviewDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;

    /**
     * Get the preview version of the document content as a stream. Retrieves an unsanitized version. This has less CPU impact but the caller must sanitize the content before presenting it to the user.
     * @param documentId - SuperOffice document id
     * @returns Unsanitized preview version of the document
     */
    public async GetUnsanitizedPreviewDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;

    public async GetUnsanitizedPreviewDocumentStream(documentId:number|carriers.Document_GetUnsanitizedPreviewDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview > {
        let _request : carriers.Document_GetUnsanitizedPreviewDocumentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetUnsanitizedPreviewDocumentStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetUnsanitizedPreviewDocumentStream( _request, _options );
    }


    private async _CreateNewPhysicalMailMergeDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalMailMergeDocumentFromTemplateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewPhysicalMailMergeDocumentFromTemplate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentEntity = converters.Create_DocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new physical document based on the documents template. Do not replace template tags, as the document is going to be used as a mail merge source. Use GetDocumentStream to obtain the created documents. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - DocumentId, UiCulture
     * @returns The document object with updated info after creating the document.
     */
    public async CreateNewPhysicalMailMergeDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalMailMergeDocumentFromTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    /**
     * Create a new physical document based on the documents template. Do not replace template tags, as the document is going to be used as a mail merge source. Use GetDocumentStream to obtain the created documents. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param documentId - Identifier for a document. The template to use is stored in the document entity.
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns The document object with updated info after creating the document.
     */
    public async CreateNewPhysicalMailMergeDocumentFromTemplate(documentId: number, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    public async CreateNewPhysicalMailMergeDocumentFromTemplate(documentId:number|carriers.Document_CreateNewPhysicalMailMergeDocumentFromTemplateRequest, uiCulture?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        let _request : carriers.Document_CreateNewPhysicalMailMergeDocumentFromTemplateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.UiCulture)!='undefined' ) )
        {
            _request = documentId as carriers.Document_CreateNewPhysicalMailMergeDocumentFromTemplateRequest;
            _options = uiCulture as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       UiCulture: uiCulture as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateNewPhysicalMailMergeDocumentFromTemplate( _request, _options );
    }


    private async _CreateNewPhysicalDocumentFromTemplateWithCustomTags(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTagsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewPhysicalDocumentFromTemplateWithCustomTags", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentEntity = converters.Create_DocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CustomTags, CustomValues, UiCulture
     * @returns The document object with updated info after creating the document
     */
    public async CreateNewPhysicalDocumentFromTemplateWithCustomTags(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTagsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    /**
     * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param contactId - Identifier for a contact. Defaults to document's contact if 0
     * @param personId - Identifier for a person. Defaults to document's person if 0
     * @param appointmentId - identifier for an appointment. Defaults to document if 0
     * @param documentId - Identifier for the document
     * @param saleId - Identifier for sale. Defaults to document's sale if 0.
     * @param selectionId - identifier for selection.
     * @param projectId - identifier for project. Defaults to document's project if 0
     * @param customTags - Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param customValues - Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param uiCulture - Language variation of template to use when creating document. (ISO code - "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns The document object with updated info after creating the document
     */
    public async CreateNewPhysicalDocumentFromTemplateWithCustomTags(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, customTags: string[], customValues: string[], uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    public async CreateNewPhysicalDocumentFromTemplateWithCustomTags(contactId:number|carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTagsRequest, personId?:number|base.WebApiRequestOptions, appointmentId?:number, documentId?:number, saleId?:number, selectionId?:number, projectId?:number, customTags?:string[], customValues?:string[], uiCulture?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        let _request : carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTagsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.AppointmentId)!='undefined' || typeof(first.DocumentId)!='undefined' || typeof(first.SaleId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.ProjectId)!='undefined' || typeof(first.CustomTags)!='undefined' || typeof(first.CustomValues)!='undefined' || typeof(first.UiCulture)!='undefined' ) )
        {
            _request = contactId as carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTagsRequest;
            _options = personId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       PersonId: personId as number,
                       AppointmentId: appointmentId as number,
                       DocumentId: documentId as number,
                       SaleId: saleId as number,
                       SelectionId: selectionId as number,
                       ProjectId: projectId as number,
                       CustomTags: customTags as string[],
                       CustomValues: customValues as string[],
                       UiCulture: uiCulture as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateNewPhysicalDocumentFromTemplateWithCustomTags( _request, _options );
    }


    private async _CreateNewPhysicalDocumentFromTemplateWithCustomTags2(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTags2Request, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewPhysicalDocumentFromTemplateWithCustomTags2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentEntity = converters.Create_DocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CustomTags, UiCulture
     * @returns The document object with updated info after creating the document
     */
    public async CreateNewPhysicalDocumentFromTemplateWithCustomTags2(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTags2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    /**
     * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param contactId - Identifier for a contact. Defaults to document's contact if 0
     * @param personId - Identifier for a person. Defaults to document's person if 0
     * @param appointmentId - identifier for an appointment. Defaults to document if 0
     * @param documentId - Identifier for the document
     * @param saleId - Identifier for sale. Defaults to document's sale if 0.
     * @param selectionId - identifier for selection.
     * @param projectId - identifier for project. Defaults to document's project if 0
     * @param customTags - Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag.
     * @param uiCulture - Language variation of template to use when creating document. (ISO code - "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns The document object with updated info after creating the document
     */
    public async CreateNewPhysicalDocumentFromTemplateWithCustomTags2(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, customTags: carriers.StringDictionary, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    public async CreateNewPhysicalDocumentFromTemplateWithCustomTags2(contactId:number|carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTags2Request, personId?:number|base.WebApiRequestOptions, appointmentId?:number, documentId?:number, saleId?:number, selectionId?:number, projectId?:number, customTags?:carriers.StringDictionary, uiCulture?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        let _request : carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTags2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.AppointmentId)!='undefined' || typeof(first.DocumentId)!='undefined' || typeof(first.SaleId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.ProjectId)!='undefined' || typeof(first.CustomTags)!='undefined' || typeof(first.UiCulture)!='undefined' ) )
        {
            _request = contactId as carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTags2Request;
            _options = personId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       PersonId: personId as number,
                       AppointmentId: appointmentId as number,
                       DocumentId: documentId as number,
                       SaleId: saleId as number,
                       SelectionId: selectionId as number,
                       ProjectId: projectId as number,
                       CustomTags: customTags as carriers.StringDictionary,
                       UiCulture: uiCulture as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateNewPhysicalDocumentFromTemplateWithCustomTags2( _request, _options );
    }


    private async _SubstituteTemplateVariables(request: carriers.Document_SubstituteTemplateVariablesRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteTemplateVariables", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.
     * @param request - Source, GeneratorEncoding, ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CultureName
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    public async SubstituteTemplateVariables(request: carriers.Document_SubstituteTemplateVariablesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.
     * @param source - Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.<p/>Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     * @param generatorEncoding - Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     * @param contactId - Identifier for a contact
     * @param personId - Identifier for a person
     * @param appointmentId - Identifier for an appointment
     * @param documentId - Identifier for a document
     * @param saleId - Identifier for a sale
     * @param selectionId - Identifier for a selection
     * @param projectId - Identifier for a project
     * @param cultureName - Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    public async SubstituteTemplateVariables(source: string, generatorEncoding: enums.GeneratorEncoding, contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SubstituteTemplateVariables(source:string|carriers.Document_SubstituteTemplateVariablesRequest, generatorEncoding?:enums.GeneratorEncoding|base.WebApiRequestOptions, contactId?:number, personId?:number, appointmentId?:number, documentId?:number, saleId?:number, selectionId?:number, projectId?:number, cultureName?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Document_SubstituteTemplateVariablesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = source;
        if( typeof( first ) === "object" && first && ( typeof(first.Source)!='undefined' || typeof(first.GeneratorEncoding)!='undefined' || typeof(first.ContactId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.AppointmentId)!='undefined' || typeof(first.DocumentId)!='undefined' || typeof(first.SaleId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.ProjectId)!='undefined' || typeof(first.CultureName)!='undefined' ) )
        {
            _request = source as carriers.Document_SubstituteTemplateVariablesRequest;
            _options = generatorEncoding as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Source: source as string,
                       GeneratorEncoding: generatorEncoding as enums.GeneratorEncoding,
                       ContactId: contactId as number,
                       PersonId: personId as number,
                       AppointmentId: appointmentId as number,
                       DocumentId: documentId as number,
                       SaleId: saleId as number,
                       SelectionId: selectionId as number,
                       ProjectId: projectId as number,
                       CultureName: cultureName as string,
                       };   
            _options = webapi_options;
        }
        return this._SubstituteTemplateVariables( _request, _options );
    }


    private async _SubstituteTemplateVariablesWithCustomTags(request: carriers.Document_SubstituteTemplateVariablesWithCustomTagsRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteTemplateVariablesWithCustomTags", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.&lt;p/&gt;This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - Source, GeneratorEncoding, CustomTags, CustomValues, ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CultureName
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    public async SubstituteTemplateVariablesWithCustomTags(request: carriers.Document_SubstituteTemplateVariablesWithCustomTagsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.&lt;p/&gt;This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param source - Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.<p/>Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     * @param generatorEncoding - Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     * @param customTags - Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param customValues - Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param contactId - Identifier for a contact
     * @param personId - Identifier for a person
     * @param appointmentId - Identifier for an appointment
     * @param documentId - Identifier for a document
     * @param saleId - Identifier for a sale
     * @param selectionId - Identifier for a selection
     * @param projectId - Identifier for a project
     * @param cultureName - Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    public async SubstituteTemplateVariablesWithCustomTags(source: string, generatorEncoding: enums.GeneratorEncoding, customTags: string[], customValues: string[], contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SubstituteTemplateVariablesWithCustomTags(source:string|carriers.Document_SubstituteTemplateVariablesWithCustomTagsRequest, generatorEncoding?:enums.GeneratorEncoding|base.WebApiRequestOptions, customTags?:string[], customValues?:string[], contactId?:number, personId?:number, appointmentId?:number, documentId?:number, saleId?:number, selectionId?:number, projectId?:number, cultureName?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Document_SubstituteTemplateVariablesWithCustomTagsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = source;
        if( typeof( first ) === "object" && first && ( typeof(first.Source)!='undefined' || typeof(first.GeneratorEncoding)!='undefined' || typeof(first.CustomTags)!='undefined' || typeof(first.CustomValues)!='undefined' || typeof(first.ContactId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.AppointmentId)!='undefined' || typeof(first.DocumentId)!='undefined' || typeof(first.SaleId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.ProjectId)!='undefined' || typeof(first.CultureName)!='undefined' ) )
        {
            _request = source as carriers.Document_SubstituteTemplateVariablesWithCustomTagsRequest;
            _options = generatorEncoding as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Source: source as string,
                       GeneratorEncoding: generatorEncoding as enums.GeneratorEncoding,
                       CustomTags: customTags as string[],
                       CustomValues: customValues as string[],
                       ContactId: contactId as number,
                       PersonId: personId as number,
                       AppointmentId: appointmentId as number,
                       DocumentId: documentId as number,
                       SaleId: saleId as number,
                       SelectionId: selectionId as number,
                       ProjectId: projectId as number,
                       CultureName: cultureName as string,
                       };   
            _options = webapi_options;
        }
        return this._SubstituteTemplateVariablesWithCustomTags( _request, _options );
    }


    private async _SubstituteTemplateVariablesWithCustomTags2(request: carriers.Document_SubstituteTemplateVariablesWithCustomTags2Request, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteTemplateVariablesWithCustomTags2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.&lt;p/&gt;This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - Source, GeneratorEncoding, CustomTags, ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CultureName
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    public async SubstituteTemplateVariablesWithCustomTags2(request: carriers.Document_SubstituteTemplateVariablesWithCustomTags2Request, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.&lt;p/&gt;This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param source - Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.<p/>Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     * @param generatorEncoding - Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     * @param customTags - Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag.
     * @param contactId - Identifier for a contact
     * @param personId - Identifier for a person
     * @param appointmentId - Identifier for an appointment
     * @param documentId - Identifier for a document
     * @param saleId - Identifier for a sale
     * @param selectionId - Identifier for a selection
     * @param projectId - Identifier for a project
     * @param cultureName - Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    public async SubstituteTemplateVariablesWithCustomTags2(source: string, generatorEncoding: enums.GeneratorEncoding, customTags: carriers.StringDictionary, contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SubstituteTemplateVariablesWithCustomTags2(source:string|carriers.Document_SubstituteTemplateVariablesWithCustomTags2Request, generatorEncoding?:enums.GeneratorEncoding|base.WebApiRequestOptions, customTags?:carriers.StringDictionary, contactId?:number, personId?:number, appointmentId?:number, documentId?:number, saleId?:number, selectionId?:number, projectId?:number, cultureName?:string, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Document_SubstituteTemplateVariablesWithCustomTags2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = source;
        if( typeof( first ) === "object" && first && ( typeof(first.Source)!='undefined' || typeof(first.GeneratorEncoding)!='undefined' || typeof(first.CustomTags)!='undefined' || typeof(first.ContactId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.AppointmentId)!='undefined' || typeof(first.DocumentId)!='undefined' || typeof(first.SaleId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.ProjectId)!='undefined' || typeof(first.CultureName)!='undefined' ) )
        {
            _request = source as carriers.Document_SubstituteTemplateVariablesWithCustomTags2Request;
            _options = generatorEncoding as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Source: source as string,
                       GeneratorEncoding: generatorEncoding as enums.GeneratorEncoding,
                       CustomTags: customTags as carriers.StringDictionary,
                       ContactId: contactId as number,
                       PersonId: personId as number,
                       AppointmentId: appointmentId as number,
                       DocumentId: documentId as number,
                       SaleId: saleId as number,
                       SelectionId: selectionId as number,
                       ProjectId: projectId as number,
                       CultureName: cultureName as string,
                       };   
            _options = webapi_options;
        }
        return this._SubstituteTemplateVariablesWithCustomTags2( _request, _options );
    }


    private async _CreateTempFile(request: carriers.Document_CreateTempFileRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTempFile", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new temporary file based on the provided stream.  Specified filename may be overridden, and actual name is returned.
     * @param request - Filename, DataStream
     * @returns Actual used filename.
     */
    public async CreateTempFile(request: carriers.Document_CreateTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Create a new temporary file based on the provided stream.  Specified filename may be overridden, and actual name is returned.
     * @param filename - Wanted name of file.
     * @param dataStream - Data to be added to the file.
     * @returns Actual used filename.
     */
    public async CreateTempFile(filename: string, dataStream: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async CreateTempFile(filename:string|carriers.Document_CreateTempFileRequest, dataStream?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Document_CreateTempFileRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = filename;
        if( typeof( first ) === "object" && first && ( typeof(first.Filename)!='undefined' || typeof(first.DataStream)!='undefined' ) )
        {
            _request = filename as carriers.Document_CreateTempFileRequest;
            _options = dataStream as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Filename: filename as string,
                       DataStream: dataStream as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.DataStream = ToBase64(_request.DataStream);
        return this._CreateTempFile( _request, _options );
    }


    private async _GetTempFile(request: carriers.Document_GetTempFileRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTempFile", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get data stream for temporary file created with CreateTempFile.
     * @param request - Filename
     * @returns The document as a Stream
     */
    public async GetTempFile(request: carriers.Document_GetTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Get data stream for temporary file created with CreateTempFile.
     * @param filename - Name of temporary file to retrieve.
     * @returns The document as a Stream
     */
    public async GetTempFile(filename: string, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetTempFile(filename:string|carriers.Document_GetTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_GetTempFileRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = filename;
        if( typeof( first ) === "object" && first && ( typeof(first.Filename)!='undefined' ) )
        {
            _request = filename as carriers.Document_GetTempFileRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Filename: filename as string,
                       };   
            _options = webapi_options;
        }
        return this._GetTempFile( _request, _options );
    }


    private async _DeleteTempFile(request: carriers.Document_DeleteTempFileRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteTempFile", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a temporary file created with CreateTempFile.
     * @param request - Filename
     * @returns 
     */
    public async DeleteTempFile(request: carriers.Document_DeleteTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a temporary file created with CreateTempFile.
     * @param filename - Name of temporary file to delete.
     * @returns 
     */
    public async DeleteTempFile(filename: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteTempFile(filename:string|carriers.Document_DeleteTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Document_DeleteTempFileRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = filename;
        if( typeof( first ) === "object" && first && ( typeof(first.Filename)!='undefined' ) )
        {
            _request = filename as carriers.Document_DeleteTempFileRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Filename: filename as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteTempFile( _request, _options );
    }


    private async _SetTemplateStream(request: carriers.Document_SetTemplateStreamRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTemplateStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a mail signature template to the document archive
     * @param request - Filename, Personal, Stream
     * @returns This method has no return value
     */
    public async SetTemplateStream(request: carriers.Document_SetTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Save a mail signature template to the document archive
     * @param filename - Filename of template.
     * @param personal - If true, save the template in the user area, instead of in shared template area.
     * @param stream - The signature template content as a stream.
     * @returns This method has no return value
     */
    public async SetTemplateStream(filename: string, personal: boolean, stream: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetTemplateStream(filename:string|carriers.Document_SetTemplateStreamRequest, personal?:boolean|base.WebApiRequestOptions, stream?:ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Document_SetTemplateStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = filename;
        if( typeof( first ) === "object" && first && ( typeof(first.Filename)!='undefined' || typeof(first.Personal)!='undefined' || typeof(first.Stream)!='undefined' ) )
        {
            _request = filename as carriers.Document_SetTemplateStreamRequest;
            _options = personal as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Filename: filename as string,
                       Personal: personal as boolean,
                       Stream: stream as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Stream = ToBase64(_request.Stream);
        return this._SetTemplateStream( _request, _options );
    }


    private async _CreateNewPhysicalDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewPhysicalDocumentFromTemplate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentEntity = converters.Create_DocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new document content based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, UiCulture
     * @returns The updated document entity, after creating the document content from the template.
     */
    public async CreateNewPhysicalDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    /**
     * Create a new document content based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param contactId - Identifier for a contact. Defaults to document's contact if 0
     * @param personId - Identifier for a person. Defaults to document's person if 0
     * @param appointmentId - identifier for an appointment. Defaults to document if 0
     * @param documentId - Identifier for a document. The document defines the template to use.
     * @param saleId - Identifier for sale. Defaults to document's sale if 0.
     * @param selectionId - identifier for selection.
     * @param projectId - identifier for project. Defaults to document's project if 0
     * @param uiCulture - Language variation of template to use when creating document content. (ISO code "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns The updated document entity, after creating the document content from the template.
     */
    public async CreateNewPhysicalDocumentFromTemplate(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, uiCulture: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    public async CreateNewPhysicalDocumentFromTemplate(contactId:number|carriers.Document_CreateNewPhysicalDocumentFromTemplateRequest, personId?:number|base.WebApiRequestOptions, appointmentId?:number, documentId?:number, saleId?:number, selectionId?:number, projectId?:number, uiCulture?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        let _request : carriers.Document_CreateNewPhysicalDocumentFromTemplateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.AppointmentId)!='undefined' || typeof(first.DocumentId)!='undefined' || typeof(first.SaleId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.ProjectId)!='undefined' || typeof(first.UiCulture)!='undefined' ) )
        {
            _request = contactId as carriers.Document_CreateNewPhysicalDocumentFromTemplateRequest;
            _options = personId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       PersonId: personId as number,
                       AppointmentId: appointmentId as number,
                       DocumentId: documentId as number,
                       SaleId: saleId as number,
                       SelectionId: selectionId as number,
                       ProjectId: projectId as number,
                       UiCulture: uiCulture as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateNewPhysicalDocumentFromTemplate( _request, _options );
    }


    private async _SubstituteMergeDocumentTemplateVariables(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteMergeDocumentTemplateVariables", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Parse the source document, and replace any template variable tags with their values, based on the associate Id.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - DocumentId, AssociateId, CustomTags, CustomValues
     * @returns The document as a Stream
     */
    public async SubstituteMergeDocumentTemplateVariables(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Parse the source document, and replace any template variable tags with their values, based on the associate Id.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param documentId - The document id that refers to the binary data (document)
     * @param associateId - The associateId used to subsitute tags in the document.
     * @param customTags - Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param customValues - Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @returns The document as a Stream
     */
    public async SubstituteMergeDocumentTemplateVariables(documentId: number, associateId: number, customTags: string[], customValues: string[], webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async SubstituteMergeDocumentTemplateVariables(documentId:number|carriers.Document_SubstituteMergeDocumentTemplateVariablesRequest, associateId?:number|base.WebApiRequestOptions, customTags?:string[], customValues?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_SubstituteMergeDocumentTemplateVariablesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.AssociateId)!='undefined' || typeof(first.CustomTags)!='undefined' || typeof(first.CustomValues)!='undefined' ) )
        {
            _request = documentId as carriers.Document_SubstituteMergeDocumentTemplateVariablesRequest;
            _options = associateId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       AssociateId: associateId as number,
                       CustomTags: customTags as string[],
                       CustomValues: customValues as string[],
                       };   
            _options = webapi_options;
        }
        return this._SubstituteMergeDocumentTemplateVariables( _request, _options );
    }


    private async _SubstituteMergeDocumentTemplateVariables2(request: carriers.Document_SubstituteMergeDocumentTemplateVariables2Request, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteMergeDocumentTemplateVariables2", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Parse the source document, and replace any template variable tags with their values, based on the associate Id.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - DocumentId, AssociateId, CustomTags
     * @returns The document as a Stream
     */
    public async SubstituteMergeDocumentTemplateVariables2(request: carriers.Document_SubstituteMergeDocumentTemplateVariables2Request, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Parse the source document, and replace any template variable tags with their values, based on the associate Id.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param documentId - The document id that refers to the binary data (document)
     * @param associateId - The associateId used to subsitute tags in the document.
     * @param customTags - Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag.
     * @returns The document as a Stream
     */
    public async SubstituteMergeDocumentTemplateVariables2(documentId: number, associateId: number, customTags: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async SubstituteMergeDocumentTemplateVariables2(documentId:number|carriers.Document_SubstituteMergeDocumentTemplateVariables2Request, associateId?:number|base.WebApiRequestOptions, customTags?:carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_SubstituteMergeDocumentTemplateVariables2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.AssociateId)!='undefined' || typeof(first.CustomTags)!='undefined' ) )
        {
            _request = documentId as carriers.Document_SubstituteMergeDocumentTemplateVariables2Request;
            _options = associateId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       AssociateId: associateId as number,
                       CustomTags: customTags as carriers.StringDictionary,
                       };   
            _options = webapi_options;
        }
        return this._SubstituteMergeDocumentTemplateVariables2( _request, _options );
    }


    private async _SubstituteTemplateVariablesEx(request: carriers.Document_SubstituteTemplateVariablesExRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteTemplateVariablesEx", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Parse the source string, and replace any template variable tags with their values, based on the identities, custom values and entities specified in the other parameters.
     * @param request - Parameters
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    public async SubstituteTemplateVariablesEx(request: carriers.Document_SubstituteTemplateVariablesExRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Parse the source string, and replace any template variable tags with their values, based on the identities, custom values and entities specified in the other parameters.
     * @param parameters - Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    public async SubstituteTemplateVariablesEx(parameters: carriers.TemplateVariablesParameters, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SubstituteTemplateVariablesEx(parameters:carriers.TemplateVariablesParameters|carriers.Document_SubstituteTemplateVariablesExRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Document_SubstituteTemplateVariablesExRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = parameters;
        if( typeof( first ) === "object" && first && ( typeof(first.Parameters)!='undefined' ) )
        {
            _request = parameters as carriers.Document_SubstituteTemplateVariablesExRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Parameters: parameters as carriers.TemplateVariablesParameters,
                       };   
            _options = webapi_options;
        }
        return this._SubstituteTemplateVariablesEx( _request, _options );
    }


    private async _VerifyGetDocumentStream(request: carriers.Document_VerifyGetDocumentStreamRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("VerifyGetDocumentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Verify that the requested document stream exists, and that we can access it, without actually getting the stream.
     * @param request - DocumentId
     * @returns 
     */
    public async VerifyGetDocumentStream(request: carriers.Document_VerifyGetDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Verify that the requested document stream exists, and that we can access it, without actually getting the stream.
     * @param documentId - The document id that refers to the binary data (document)
     * @returns 
     */
    public async VerifyGetDocumentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async VerifyGetDocumentStream(documentId:number|carriers.Document_VerifyGetDocumentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Document_VerifyGetDocumentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.Document_VerifyGetDocumentStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._VerifyGetDocumentStream( _request, _options );
    }


    private async _SubstituteMergeDocumentTemplateVariablesEx(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesExRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteMergeDocumentTemplateVariablesEx", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - MergeDocumentId, ContactId, PersonId, ProjectId, SelectionId, AppointmentId, DocumentId, SaleId, CustomTags, CustomValues
     * @returns The document as a Stream
     */
    public async SubstituteMergeDocumentTemplateVariablesEx(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesExRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param mergeDocumentId - The document id that refers to the binary data (document)
     * @param contactId - The contact identifier to use for template substitution
     * @param personId - The person identifier to use for template substitution
     * @param projectId - The project identifier to use for template substitution
     * @param selectionId - The selection identifier to use for template substitution
     * @param appointmentId - The appointment identifier to use for template substitution
     * @param documentId - The document identifier to use for template substitution
     * @param saleId - The sale identifier to use for template substitution
     * @param customTags - Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param customValues - Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @returns The document as a Stream
     */
    public async SubstituteMergeDocumentTemplateVariablesEx(mergeDocumentId: number, contactId: number, personId: number, projectId: number, selectionId: number, appointmentId: number, documentId: number, saleId: number, customTags: string[], customValues: string[], webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async SubstituteMergeDocumentTemplateVariablesEx(mergeDocumentId:number|carriers.Document_SubstituteMergeDocumentTemplateVariablesExRequest, contactId?:number|base.WebApiRequestOptions, personId?:number, projectId?:number, selectionId?:number, appointmentId?:number, documentId?:number, saleId?:number, customTags?:string[], customValues?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_SubstituteMergeDocumentTemplateVariablesExRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mergeDocumentId;
        if( typeof( first ) === "object" && first && ( typeof(first.MergeDocumentId)!='undefined' || typeof(first.ContactId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.ProjectId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.AppointmentId)!='undefined' || typeof(first.DocumentId)!='undefined' || typeof(first.SaleId)!='undefined' || typeof(first.CustomTags)!='undefined' || typeof(first.CustomValues)!='undefined' ) )
        {
            _request = mergeDocumentId as carriers.Document_SubstituteMergeDocumentTemplateVariablesExRequest;
            _options = contactId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MergeDocumentId: mergeDocumentId as number,
                       ContactId: contactId as number,
                       PersonId: personId as number,
                       ProjectId: projectId as number,
                       SelectionId: selectionId as number,
                       AppointmentId: appointmentId as number,
                       DocumentId: documentId as number,
                       SaleId: saleId as number,
                       CustomTags: customTags as string[],
                       CustomValues: customValues as string[],
                       };   
            _options = webapi_options;
        }
        return this._SubstituteMergeDocumentTemplateVariablesEx( _request, _options );
    }


    private async _SubstituteMergeDocumentTemplateVariablesEx2(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesEx2Request, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteMergeDocumentTemplateVariablesEx2", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - MergeDocumentId, ContactId, PersonId, ProjectId, SelectionId, AppointmentId, DocumentId, SaleId, CustomTags
     * @returns The document as a Stream
     */
    public async SubstituteMergeDocumentTemplateVariablesEx2(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesEx2Request, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param mergeDocumentId - The document id that refers to the binary data (document)
     * @param contactId - The contact identifier to use for template substitution
     * @param personId - The person identifier to use for template substitution
     * @param projectId - The project identifier to use for template substitution
     * @param selectionId - The selection identifier to use for template substitution
     * @param appointmentId - The appointment identifier to use for template substitution
     * @param documentId - The document identifier to use for template substitution
     * @param saleId - The sale identifier to use for template substitution
     * @param customTags - Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag
     * @returns The document as a Stream
     */
    public async SubstituteMergeDocumentTemplateVariablesEx2(mergeDocumentId: number, contactId: number, personId: number, projectId: number, selectionId: number, appointmentId: number, documentId: number, saleId: number, customTags: carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async SubstituteMergeDocumentTemplateVariablesEx2(mergeDocumentId:number|carriers.Document_SubstituteMergeDocumentTemplateVariablesEx2Request, contactId?:number|base.WebApiRequestOptions, personId?:number, projectId?:number, selectionId?:number, appointmentId?:number, documentId?:number, saleId?:number, customTags?:carriers.StringDictionary, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Document_SubstituteMergeDocumentTemplateVariablesEx2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mergeDocumentId;
        if( typeof( first ) === "object" && first && ( typeof(first.MergeDocumentId)!='undefined' || typeof(first.ContactId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.ProjectId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.AppointmentId)!='undefined' || typeof(first.DocumentId)!='undefined' || typeof(first.SaleId)!='undefined' || typeof(first.CustomTags)!='undefined' ) )
        {
            _request = mergeDocumentId as carriers.Document_SubstituteMergeDocumentTemplateVariablesEx2Request;
            _options = contactId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MergeDocumentId: mergeDocumentId as number,
                       ContactId: contactId as number,
                       PersonId: personId as number,
                       ProjectId: projectId as number,
                       SelectionId: selectionId as number,
                       AppointmentId: appointmentId as number,
                       DocumentId: documentId as number,
                       SaleId: saleId as number,
                       CustomTags: customTags as carriers.StringDictionary,
                       };   
            _options = webapi_options;
        }
        return this._SubstituteMergeDocumentTemplateVariablesEx2( _request, _options );
    }


    private async _GetDocumentUrl(request: carriers.Document_GetDocumentUrlRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a URL referring to the given document content.&lt;para/&gt;This URL may be passed to the ultimate client (text editor of some kind?), which is then responsible for all further operations.&lt;para/&gt;The returned string is a fully qualified URL.&lt;para/&gt;Not all documents and document plugins support this feature.
     * @param request - DocumentId, VersionId, WriteableUrl
     * @returns Fully resolved URL referring to the document. May be NULL or blank if plugin does not support URLs.
     */
    public async GetDocumentUrl(request: carriers.Document_GetDocumentUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get a URL referring to the given document content.&lt;para/&gt;This URL may be passed to the ultimate client (text editor of some kind?), which is then responsible for all further operations.&lt;para/&gt;The returned string is a fully qualified URL.&lt;para/&gt;Not all documents and document plugins support this feature.
     * @param documentId - SuperOffice document primary key
     * @param versionId - Version ID if applicable/desired; a blank value implies "latest" version and is always acceptable.
     * @param writeableUrl - If true, then a URL that supports saving is requested. Som edocument plugins may not support read-only URLs, so there is no guarantee that a False value will actually yield a read-only URL, and vice versa.
     * @returns Fully resolved URL referring to the document. May be NULL or blank if plugin does not support URLs.
     */
    public async GetDocumentUrl(documentId: number, versionId: string, writeableUrl: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetDocumentUrl(documentId:number|carriers.Document_GetDocumentUrlRequest, versionId?:string|base.WebApiRequestOptions, writeableUrl?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Document_GetDocumentUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.VersionId)!='undefined' || typeof(first.WriteableUrl)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetDocumentUrlRequest;
            _options = versionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       VersionId: versionId as string,
                       WriteableUrl: writeableUrl as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentUrl( _request, _options );
    }


    private async _DeletePhysicalDocument(request: carriers.Document_DeletePhysicalDocumentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReturnInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePhysicalDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReturnInfo = converters.Create_ReturnInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete the document contents
     * @param request - DocumentId, AllowedReturnType
     * @returns Delete status - did removal succeed or not
     */
    public async DeletePhysicalDocument(request: carriers.Document_DeletePhysicalDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    /**
     * Delete the document contents
     * @param documentId - document primary key
     * @param allowedReturnType - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing. Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests
     * @returns Delete status - did removal succeed or not
     */
    public async DeletePhysicalDocument(documentId: number, allowedReturnType: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    public async DeletePhysicalDocument(documentId:number|carriers.Document_DeletePhysicalDocumentRequest, allowedReturnType?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        let _request : carriers.Document_DeletePhysicalDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.AllowedReturnType)!='undefined' ) )
        {
            _request = documentId as carriers.Document_DeletePhysicalDocumentRequest;
            _options = allowedReturnType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       AllowedReturnType: allowedReturnType as string[],
                       };   
            _options = webapi_options;
        }
        return this._DeletePhysicalDocument( _request, _options );
    }


    private async _RenameDocument(request: carriers.Document_RenameDocumentRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RenameDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Rename the physical document, i.e., change the file name or equivalent concept in the document archive.
     * @param request - DocumentId, NewFilename
     * @returns The actual, new "file" name. This will generally be derived from the suggested name, but may be amended.
     */
    public async RenameDocument(request: carriers.Document_RenameDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Rename the physical document, i.e., change the file name or equivalent concept in the document archive.
     * @param documentId - SuperOffice document ID
     * @param newFilename - Suggested new file name. The document archive may amend this to conform to uniqueness constraints, character range limitations etc.
     * @returns The actual, new "file" name. This will generally be derived from the suggested name, but may be amended.
     */
    public async RenameDocument(documentId: number, newFilename: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async RenameDocument(documentId:number|carriers.Document_RenameDocumentRequest, newFilename?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Document_RenameDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.NewFilename)!='undefined' ) )
        {
            _request = documentId as carriers.Document_RenameDocumentRequest;
            _options = newFilename as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       NewFilename: newFilename as string,
                       };   
            _options = webapi_options;
        }
        return this._RenameDocument( _request, _options );
    }


    private async _GetCheckoutState(request: carriers.Document_GetCheckoutStateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CheckoutInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CheckoutInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCheckoutState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CheckoutInfo = converters.Create_CheckoutInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the current checkout state for a document, relative to the user perforing the call.
     * @param request - DocumentId
     * @returns Current checkout state of the document
     */
    public async GetCheckoutState(request: carriers.Document_GetCheckoutStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CheckoutInfo >;

    /**
     * Get the current checkout state for a document, relative to the user perforing the call.
     * @param documentId - SuperOffice document ID
     * @returns Current checkout state of the document
     */
    public async GetCheckoutState(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CheckoutInfo >;

    public async GetCheckoutState(documentId:number|carriers.Document_GetCheckoutStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CheckoutInfo > {
        let _request : carriers.Document_GetCheckoutStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetCheckoutStateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetCheckoutState( _request, _options );
    }


    private async _CheckoutDocument(request: carriers.Document_CheckoutDocumentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReturnInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckoutDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReturnInfo = converters.Create_ReturnInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check out a document for editing by the current user.
     * @param request - DocumentId, AllowedReturnTypes
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    public async CheckoutDocument(request: carriers.Document_CheckoutDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    /**
     * Check out a document for editing by the current user.
     * @param documentId - SuperOffice document ID
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    public async CheckoutDocument(documentId: number, allowedReturnTypes: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    public async CheckoutDocument(documentId:number|carriers.Document_CheckoutDocumentRequest, allowedReturnTypes?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        let _request : carriers.Document_CheckoutDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.AllowedReturnTypes)!='undefined' ) )
        {
            _request = documentId as carriers.Document_CheckoutDocumentRequest;
            _options = allowedReturnTypes as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       AllowedReturnTypes: allowedReturnTypes as string[],
                       };   
            _options = webapi_options;
        }
        return this._CheckoutDocument( _request, _options );
    }


    private async _CheckinDocument(request: carriers.Document_CheckinDocumentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReturnInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckinDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReturnInfo = converters.Create_ReturnInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check in a currently checked-out document
     * @param request - DocumentId, AllowedReturnTypes, VersionDescription, VersionExtraFields
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    public async CheckinDocument(request: carriers.Document_CheckinDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    /**
     * Check in a currently checked-out document
     * @param documentId - SuperOffice document Id
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     * @param versionDescription - Optional textual description related to this version of the document; may be blank, and is discarded if the document/plugin do not support versioning.
     * @param versionExtraFields - Optional extra metadata related to the new version (as opposed to metadata related to the document as a whole). Discarded if the document/plugin do not support versioning.
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    public async CheckinDocument(documentId: number, allowedReturnTypes: string[], versionDescription: string, versionExtraFields: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    public async CheckinDocument(documentId:number|carriers.Document_CheckinDocumentRequest, allowedReturnTypes?:string[]|base.WebApiRequestOptions, versionDescription?:string, versionExtraFields?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        let _request : carriers.Document_CheckinDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.AllowedReturnTypes)!='undefined' || typeof(first.VersionDescription)!='undefined' || typeof(first.VersionExtraFields)!='undefined' ) )
        {
            _request = documentId as carriers.Document_CheckinDocumentRequest;
            _options = allowedReturnTypes as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       AllowedReturnTypes: allowedReturnTypes as string[],
                       VersionDescription: versionDescription as string,
                       VersionExtraFields: versionExtraFields as string[],
                       };   
            _options = webapi_options;
        }
        return this._CheckinDocument( _request, _options );
    }


    private async _UndoCheckoutDocument(request: carriers.Document_UndoCheckoutDocumentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReturnInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UndoCheckoutDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReturnInfo = converters.Create_ReturnInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Undo (abandon) a checkout
     * @param request - DocumentId, AllowedReturnTypes
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    public async UndoCheckoutDocument(request: carriers.Document_UndoCheckoutDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    /**
     * Undo (abandon) a checkout
     * @param documentId - SuperOffice document ID
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    public async UndoCheckoutDocument(documentId: number, allowedReturnTypes: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    public async UndoCheckoutDocument(documentId:number|carriers.Document_UndoCheckoutDocumentRequest, allowedReturnTypes?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        let _request : carriers.Document_UndoCheckoutDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.AllowedReturnTypes)!='undefined' ) )
        {
            _request = documentId as carriers.Document_UndoCheckoutDocumentRequest;
            _options = allowedReturnTypes as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       AllowedReturnTypes: allowedReturnTypes as string[],
                       };   
            _options = webapi_options;
        }
        return this._UndoCheckoutDocument( _request, _options );
    }


    private async _GetVersionList(request: carriers.Document_GetVersionListRequest, options?:base.WebApiRequestOptions) : Promise< carriers.VersionInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.VersionInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetVersionList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.VersionInfo[] = converters.Create_VersionInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list of existing, committed  versions for a given document
     * @param request - DocumentId
     * @returns Array of objects describing the existing, committed versions for this document
     */
    public async GetVersionList(request: carriers.Document_GetVersionListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.VersionInfo[] >;

    /**
     * Get a list of existing, committed  versions for a given document
     * @param documentId - SuperOffice document Id
     * @returns Array of objects describing the existing, committed versions for this document
     */
    public async GetVersionList(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.VersionInfo[] >;

    public async GetVersionList(documentId:number|carriers.Document_GetVersionListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.VersionInfo[] > {
        let _request : carriers.Document_GetVersionListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetVersionListRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetVersionList( _request, _options );
    }


    private async _GetPluginList( options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPluginList", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get a list of installed document plugins
     * @returns Dictionary mapping plugin id=plugin name
     */
    public async GetPluginList(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >
    {
        return this._GetPluginList(webapi_options);
    }


    private async _GetPluginCapabilities(request: carriers.Document_GetPluginCapabilitiesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPluginCapabilities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list of plugin-dependent capabilities for a given document archive plugin.&lt;br/&gt;A standard set of properties is defined in SuperOffice.CRM.Documents.Constants.Capabilities.
     * @param request - PluginId
     * @returns Dictionary mapping capability names=values
     */
    public async GetPluginCapabilities(request: carriers.Document_GetPluginCapabilitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Get a list of plugin-dependent capabilities for a given document archive plugin.&lt;br/&gt;A standard set of properties is defined in SuperOffice.CRM.Documents.Constants.Capabilities.
     * @param pluginId - Numeric document plugin id, corresponding to the document.archiveProvider id or doctmpl.autoeventid.
     * @returns Dictionary mapping capability names=values
     */
    public async GetPluginCapabilities(pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async GetPluginCapabilities(pluginId:number|carriers.Document_GetPluginCapabilitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Document_GetPluginCapabilitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = pluginId;
        if( typeof( first ) === "object" && first && ( typeof(first.PluginId)!='undefined' ) )
        {
            _request = pluginId as carriers.Document_GetPluginCapabilitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PluginId: pluginId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPluginCapabilities( _request, _options );
    }


    private async _GetDocumentProperties(request: carriers.Document_GetDocumentPropertiesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentProperties", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get plugin-dependent properties for the document. A number of standard properties that should be supported by all plugins are defined in SuperOffice.CRM.Documents.Constants.Properties.
     * @param request - DocumentId, RequestedProperties
     * @returns Dictionary of name=value pairs, corresponding to the requested properties.
     */
    public async GetDocumentProperties(request: carriers.Document_GetDocumentPropertiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Get plugin-dependent properties for the document. A number of standard properties that should be supported by all plugins are defined in SuperOffice.CRM.Documents.Constants.Properties.
     * @param documentId - SuperOffice document ID
     * @param requestedProperties - Array of property names whose values are being requested.
     * @returns Dictionary of name=value pairs, corresponding to the requested properties.
     */
    public async GetDocumentProperties(documentId: number, requestedProperties: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async GetDocumentProperties(documentId:number|carriers.Document_GetDocumentPropertiesRequest, requestedProperties?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Document_GetDocumentPropertiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.RequestedProperties)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetDocumentPropertiesRequest;
            _options = requestedProperties as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       RequestedProperties: requestedProperties as string[],
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentProperties( _request, _options );
    }


    private async _GetDocumentCommands(request: carriers.Document_GetDocumentCommandsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CommandInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CommandInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentCommands", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CommandInfo[] = converters.Create_CommandInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list of custom commands valid for the specific document at this time. This information should not be cached by clients, as it may change between documents and over time.
     * @param request - DocumentId, AllowedReturnTypes
     * @returns Array of command information items. The command list is constrained by the allowedReturnTypes parameter.
     */
    public async GetDocumentCommands(request: carriers.Document_GetDocumentCommandsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CommandInfo[] >;

    /**
     * Get a list of custom commands valid for the specific document at this time. This information should not be cached by clients, as it may change between documents and over time.
     * @param documentId - SuperOffice document ID
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.<br/>In this context the parameter is used to filter the returned command list, so that commands that require return actions not supported, will not be included by the document plugin.
     * @returns Array of command information items. The command list is constrained by the allowedReturnTypes parameter.
     */
    public async GetDocumentCommands(documentId: number, allowedReturnTypes: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CommandInfo[] >;

    public async GetDocumentCommands(documentId:number|carriers.Document_GetDocumentCommandsRequest, allowedReturnTypes?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CommandInfo[] > {
        let _request : carriers.Document_GetDocumentCommandsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.AllowedReturnTypes)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetDocumentCommandsRequest;
            _options = allowedReturnTypes as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       AllowedReturnTypes: allowedReturnTypes as string[],
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentCommands( _request, _options );
    }


    private async _ExecuteDocumentCommand(request: carriers.Document_ExecuteDocumentCommandRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReturnInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExecuteDocumentCommand", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReturnInfo = converters.Create_ReturnInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Execute a custom command on a particular document, optionally a particular version
     * @param request - DocumentId, VersionId, AllowedReturnTypes, Command, AdditionalData
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    public async ExecuteDocumentCommand(request: carriers.Document_ExecuteDocumentCommandRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    /**
     * Execute a custom command on a particular document, optionally a particular version
     * @param documentId - SuperOffice document ID
     * @param versionId - Version ID if applicable/desired; a blank value implies "latest" version and is always acceptable.
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     * @param command - Command name, generally matching one of those returned from the GetDocumentCommands service. However, it is legal for document plugins to support commands that are not declared through GetDocumentCommands, for instance if a custom GUI needs to access plugin functionality.
     * @param additionalData - Any additional data that the document command needs. This parameter can be used as a tunnel between a custom-programmed GUI and its plugin.<br/>It is suggested that the format is name=value, with one such pair per array item.
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    public async ExecuteDocumentCommand(documentId: number, versionId: string, allowedReturnTypes: string[], command: string, additionalData: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo >;

    public async ExecuteDocumentCommand(documentId:number|carriers.Document_ExecuteDocumentCommandRequest, versionId?:string|base.WebApiRequestOptions, allowedReturnTypes?:string[], command?:string, additionalData?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReturnInfo > {
        let _request : carriers.Document_ExecuteDocumentCommandRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.VersionId)!='undefined' || typeof(first.AllowedReturnTypes)!='undefined' || typeof(first.Command)!='undefined' || typeof(first.AdditionalData)!='undefined' ) )
        {
            _request = documentId as carriers.Document_ExecuteDocumentCommandRequest;
            _options = versionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       VersionId: versionId as string,
                       AllowedReturnTypes: allowedReturnTypes as string[],
                       Command: command as string,
                       AdditionalData: additionalData as string[],
                       };   
            _options = webapi_options;
        }
        return this._ExecuteDocumentCommand( _request, _options );
    }


    private async _CreateDefaultDocumentEntityFromSuggestion(request: carriers.Document_CreateDefaultDocumentEntityFromSuggestionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultDocumentEntityFromSuggestion", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentEntity = converters.Create_DocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - SuggestedDocumentId
     * @returns 
     */
    public async CreateDefaultDocumentEntityFromSuggestion(request: carriers.Document_CreateDefaultDocumentEntityFromSuggestionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    /**
     * 
     * @param suggestedDocumentId - 
     * @returns 
     */
    public async CreateDefaultDocumentEntityFromSuggestion(suggestedDocumentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    public async CreateDefaultDocumentEntityFromSuggestion(suggestedDocumentId:number|carriers.Document_CreateDefaultDocumentEntityFromSuggestionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        let _request : carriers.Document_CreateDefaultDocumentEntityFromSuggestionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = suggestedDocumentId;
        if( typeof( first ) === "object" && first && ( typeof(first.SuggestedDocumentId)!='undefined' ) )
        {
            _request = suggestedDocumentId as carriers.Document_CreateDefaultDocumentEntityFromSuggestionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SuggestedDocumentId: suggestedDocumentId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultDocumentEntityFromSuggestion( _request, _options );
    }


    private async _SaveDocumentTemplateStream(request: carriers.Document_SaveDocumentTemplateStreamRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TemplateInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDocumentTemplateStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TemplateInfo = converters.Create_TemplateInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves content in stream to document template file
     * @param request - DocumentTemplateId, Content, LanguageCode, PluginId
     * @returns Template info
     */
    public async SaveDocumentTemplateStream(request: carriers.Document_SaveDocumentTemplateStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo >;

    /**
     * Saves content in stream to document template file
     * @param documentTemplateId - Identifier for document template
     * @param content - Stream containing content to be saved to document template file
     * @param languageCode - Language variation of template to update. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @param pluginId - Plugin id. Use -1 to use the plugin specified in the template.
     * @returns Template info
     */
    public async SaveDocumentTemplateStream(documentTemplateId: number, content: ArrayBuffer|string, languageCode: string, pluginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo >;

    public async SaveDocumentTemplateStream(documentTemplateId:number|carriers.Document_SaveDocumentTemplateStreamRequest, content?:ArrayBuffer|string|base.WebApiRequestOptions, languageCode?:string, pluginId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemplateInfo > {
        let _request : carriers.Document_SaveDocumentTemplateStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentTemplateId)!='undefined' || typeof(first.Content)!='undefined' || typeof(first.LanguageCode)!='undefined' || typeof(first.PluginId)!='undefined' ) )
        {
            _request = documentTemplateId as carriers.Document_SaveDocumentTemplateStreamRequest;
            _options = content as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentTemplateId: documentTemplateId as number,
                       Content: content as ArrayBuffer|string,
                       LanguageCode: languageCode as string,
                       PluginId: pluginId as number,
                       };   
            _options = webapi_options;
        }
         _request.Content = ToBase64(_request.Content);
        return this._SaveDocumentTemplateStream( _request, _options );
    }


    private async _SetDocumentStreamFromId(request: carriers.Document_SetDocumentStreamFromIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentStreamFromId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentEntity = converters.Create_DocumentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Store document content from stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - DocumentId, Stream
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    public async SetDocumentStreamFromId(request: carriers.Document_SetDocumentStreamFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    /**
     * Store document content from stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param documentId - The document entity object that the binary data (document) should be stored to. Its file name may be amended by this call, see the return value.
     * @param stream - The document content as a stream.
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    public async SetDocumentStreamFromId(documentId: number, stream: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity >;

    public async SetDocumentStreamFromId(documentId:number|carriers.Document_SetDocumentStreamFromIdRequest, stream?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentEntity > {
        let _request : carriers.Document_SetDocumentStreamFromIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.Stream)!='undefined' ) )
        {
            _request = documentId as carriers.Document_SetDocumentStreamFromIdRequest;
            _options = stream as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       Stream: stream as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Stream = ToBase64(_request.Stream);
        return this._SetDocumentStreamFromId( _request, _options );
    }


    private async _SavePrivacyReport(request: carriers.Document_SavePrivacyReportRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePrivacyReport", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Generates a Pdf from HTML and makes a document
     * @param request - HtmlReport, Title, PersonId
     * @returns Document id of saved report
     */
    public async SavePrivacyReport(request: carriers.Document_SavePrivacyReportRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Generates a Pdf from HTML and makes a document
     * @param htmlReport - Html to convert
     * @param title - Title of report
     * @param personId - Person id associated with the report
     * @returns Document id of saved report
     */
    public async SavePrivacyReport(htmlReport: string, title: string, personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async SavePrivacyReport(htmlReport:string|carriers.Document_SavePrivacyReportRequest, title?:string|base.WebApiRequestOptions, personId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Document_SavePrivacyReportRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = htmlReport;
        if( typeof( first ) === "object" && first && ( typeof(first.HtmlReport)!='undefined' || typeof(first.Title)!='undefined' || typeof(first.PersonId)!='undefined' ) )
        {
            _request = htmlReport as carriers.Document_SavePrivacyReportRequest;
            _options = title as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       HtmlReport: htmlReport as string,
                       Title: title as string,
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._SavePrivacyReport( _request, _options );
    }


    private async _ValidateDocumentEntity(request: carriers.Document_ValidateDocumentEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateDocumentEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param request - DocumentEntity
     * @returns Error messages tagged by field.
     */
    public async ValidateDocumentEntity(request: carriers.Document_ValidateDocumentEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param documentEntity - Entity to be checked for errors.
     * @returns Error messages tagged by field.
     */
    public async ValidateDocumentEntity(documentEntity: carriers.DocumentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async ValidateDocumentEntity(documentEntity:carriers.DocumentEntity|carriers.Document_ValidateDocumentEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Document_ValidateDocumentEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentEntity)!='undefined' ) )
        {
            _request = documentEntity as carriers.Document_ValidateDocumentEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentEntity: documentEntity as carriers.DocumentEntity,
                       };   
            _options = webapi_options;
        }
        return this._ValidateDocumentEntity( _request, _options );
    }


    private async _GetDocumentLength(request: carriers.Document_GetDocumentLengthRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentLength", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get length of the document content in bytes.
     * @param request - DocumentId, VersionId
     * @returns The length of the document content in bytes.
     */
    public async GetDocumentLength(request: carriers.Document_GetDocumentLengthRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Get length of the document content in bytes.
     * @param documentId - SuperOffice document id
     * @param versionId - Version ID if applicable; a blank value implies "latest" version and is always acceptable.
     * @returns The length of the document content in bytes.
     */
    public async GetDocumentLength(documentId: number, versionId: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async GetDocumentLength(documentId:number|carriers.Document_GetDocumentLengthRequest, versionId?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Document_GetDocumentLengthRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' || typeof(first.VersionId)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetDocumentLengthRequest;
            _options = versionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       VersionId: versionId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentLength( _request, _options );
    }

    /*
     * Gets an array of Document objects.
     * @param documentIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Document
     */
    public async GetDocumentList(documentIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentList", documentIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetAppointmentDocuments(request: carriers.Document_GetAppointmentDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all documents that are linked to the appointment. I.e. the documents that are listed in the appointment dialog.
     * @param request - AppointmentId
     * @returns Array of documents
     */
    public async GetAppointmentDocuments(request: carriers.Document_GetAppointmentDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Get all documents that are linked to the appointment. I.e. the documents that are listed in the appointment dialog.
     * @param appointmentId - The appointment id.
     * @returns Array of documents
     */
    public async GetAppointmentDocuments(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetAppointmentDocuments(appointmentId:number|carriers.Document_GetAppointmentDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetAppointmentDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' ) )
        {
            _request = appointmentId as carriers.Document_GetAppointmentDocumentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAppointmentDocuments( _request, _options );
    }


    private async _GetSaleDocuments(request: carriers.Document_GetSaleDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSaleDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all documents that are linked to the sale. I.e. the documents that are listed in the sale dialog.
     * @param request - SaleId
     * @returns Array of documents
     */
    public async GetSaleDocuments(request: carriers.Document_GetSaleDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Get all documents that are linked to the sale. I.e. the documents that are listed in the sale dialog.
     * @param saleId - The sale id.
     * @returns Array of documents
     */
    public async GetSaleDocuments(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetSaleDocuments(saleId:number|carriers.Document_GetSaleDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetSaleDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' ) )
        {
            _request = saleId as carriers.Document_GetSaleDocumentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetSaleDocuments( _request, _options );
    }


    private async _GetPersonDocuments(request: carriers.Document_GetPersonDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all documents that are linked to the person. I.e. the documents that are listed in the person dialog.
     * @param request - PersonId
     * @returns Array of documents
     */
    public async GetPersonDocuments(request: carriers.Document_GetPersonDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Get all documents that are linked to the person. I.e. the documents that are listed in the person dialog.
     * @param personId - The person id.
     * @returns Array of documents
     */
    public async GetPersonDocuments(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetPersonDocuments(personId:number|carriers.Document_GetPersonDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetPersonDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetPersonDocumentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonDocuments( _request, _options );
    }


    private async _GetPublishedDocument(request: carriers.Document_GetPublishedDocumentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document = converters.Create_Document_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the document if it&apos;s published
     * @param request - DocumentId
     * @returns Document
     */
    public async GetPublishedDocument(request: carriers.Document_GetPublishedDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document >;

    /**
     * Get the document if it&apos;s published
     * @param documentId - The document id
     * @returns Document
     */
    public async GetPublishedDocument(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document >;

    public async GetPublishedDocument(documentId:number|carriers.Document_GetPublishedDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document > {
        let _request : carriers.Document_GetPublishedDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.Document_GetPublishedDocumentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedDocument( _request, _options );
    }


    private async _GetPublishedDocuments(request: carriers.Document_GetPublishedDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the published documents from an array of doucment ids.
     * @param request - DocumentIds
     * @returns Array of Document
     */
    public async GetPublishedDocuments(request: carriers.Document_GetPublishedDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Get the published documents from an array of doucment ids.
     * @param documentIds - Array of document ids.
     * @returns Array of Document
     */
    public async GetPublishedDocuments(documentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetPublishedDocuments(documentIds:number[]|carriers.Document_GetPublishedDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetPublishedDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentIds;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentIds)!='undefined' ) )
        {
            _request = documentIds as carriers.Document_GetPublishedDocumentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentIds: documentIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedDocuments( _request, _options );
    }


    private async _GetMyPublishedDocuments( options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyPublishedDocuments", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * 
     * @returns Array of documents
     */
    public async GetMyPublishedDocuments(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >
    {
        return this._GetMyPublishedDocuments(webapi_options);
    }


    private async _GetPublishedDocumentsByDate(request: carriers.Document_GetPublishedDocumentsByDateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedDocumentsByDate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of published document appointments within a time range. The document appointments is visible to the person specified or the document is in a project the person belongs to. 
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetPublishedDocumentsByDate(request: carriers.Document_GetPublishedDocumentsByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of published document appointments within a time range. The document appointments is visible to the person specified or the document is in a project the person belongs to. 
     * @param personId - The personId
     * @param includeProjectDocuments - Include projectDocuments to select documents in projects person is a member of.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetPublishedDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetPublishedDocumentsByDate(personId:number|carriers.Document_GetPublishedDocumentsByDateRequest, includeProjectDocuments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetPublishedDocumentsByDateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectDocuments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetPublishedDocumentsByDateRequest;
            _options = includeProjectDocuments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectDocuments: includeProjectDocuments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedDocumentsByDate( _request, _options );
    }


    private async _GetContactDocumentsByTemplateTypes(request: carriers.Document_GetContactDocumentsByTemplateTypesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactDocumentsByTemplateTypes", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the contact specified. 
     * @param request - ContactId, StartTime, EndTime, Count, DocumentTemplateIds
     * @returns Array of Appointments.
     */
    public async GetContactDocumentsByTemplateTypes(request: carriers.Document_GetContactDocumentsByTemplateTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the contact specified. 
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateIds - Ids of the document template types to filter on.
     * @returns Array of Appointments.
     */
    public async GetContactDocumentsByTemplateTypes(contactId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetContactDocumentsByTemplateTypes(contactId:number|carriers.Document_GetContactDocumentsByTemplateTypesRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, documentTemplateIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetContactDocumentsByTemplateTypesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.DocumentTemplateIds)!='undefined' ) )
        {
            _request = contactId as carriers.Document_GetContactDocumentsByTemplateTypesRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       DocumentTemplateIds: documentTemplateIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetContactDocumentsByTemplateTypes( _request, _options );
    }


    private async _GetContactDocumentsByTemplateType(request: carriers.Document_GetContactDocumentsByTemplateTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactDocumentsByTemplateType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the contact specified. 
     * @param request - ContactId, StartTime, EndTime, Count, DocumentTemplateId
     * @returns Array of Appointments.
     */
    public async GetContactDocumentsByTemplateType(request: carriers.Document_GetContactDocumentsByTemplateTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the contact specified. 
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateId - Id of the document template type to filter on.
     * @returns Array of Appointments.
     */
    public async GetContactDocumentsByTemplateType(contactId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetContactDocumentsByTemplateType(contactId:number|carriers.Document_GetContactDocumentsByTemplateTypeRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, documentTemplateId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetContactDocumentsByTemplateTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.DocumentTemplateId)!='undefined' ) )
        {
            _request = contactId as carriers.Document_GetContactDocumentsByTemplateTypeRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       DocumentTemplateId: documentTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactDocumentsByTemplateType( _request, _options );
    }


    private async _GetContactDocumentsByTemplateHeading(request: carriers.Document_GetContactDocumentsByTemplateHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactDocumentsByTemplateHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by the document template heading. The document appointments belong to the contact specified. The heading represents a grouping or filtering of document templates.
     * @param request - ContactId, StartTime, EndTime, Count, TemplateHeadingId
     * @returns Array of Appointments.
     */
    public async GetContactDocumentsByTemplateHeading(request: carriers.Document_GetContactDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by the document template heading. The document appointments belong to the contact specified. The heading represents a grouping or filtering of document templates.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    public async GetContactDocumentsByTemplateHeading(contactId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetContactDocumentsByTemplateHeading(contactId:number|carriers.Document_GetContactDocumentsByTemplateHeadingRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, templateHeadingId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetContactDocumentsByTemplateHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TemplateHeadingId)!='undefined' ) )
        {
            _request = contactId as carriers.Document_GetContactDocumentsByTemplateHeadingRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TemplateHeadingId: templateHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactDocumentsByTemplateHeading( _request, _options );
    }


    private async _GetContactDocuments(request: carriers.Document_GetContactDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the contact specified. 
     * @param request - ContactId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetContactDocuments(request: carriers.Document_GetContactDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the contact specified. 
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetContactDocuments(contactId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetContactDocuments(contactId:number|carriers.Document_GetContactDocumentsRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetContactDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = contactId as carriers.Document_GetContactDocumentsRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactDocuments( _request, _options );
    }


    private async _GetPublishedPersonDocumentsByDate(request: carriers.Document_GetPublishedPersonDocumentsByDateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedPersonDocumentsByDate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of published document appointments within a time range. The document appointments belong to the person specified or the document is in a project the person belongs to. 
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetPublishedPersonDocumentsByDate(request: carriers.Document_GetPublishedPersonDocumentsByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of published document appointments within a time range. The document appointments belong to the person specified or the document is in a project the person belongs to. 
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetPublishedPersonDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetPublishedPersonDocumentsByDate(personId:number|carriers.Document_GetPublishedPersonDocumentsByDateRequest, includeProjectDocuments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetPublishedPersonDocumentsByDateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectDocuments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetPublishedPersonDocumentsByDateRequest;
            _options = includeProjectDocuments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectDocuments: includeProjectDocuments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedPersonDocumentsByDate( _request, _options );
    }


    private async _GetPublishedProjectDocuments(request: carriers.Document_GetPublishedProjectDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProjectDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get published appointment documents by project id.
     * @param request - ProjectId
     * @returns Array of Appointment
     */
    public async GetPublishedProjectDocuments(request: carriers.Document_GetPublishedProjectDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Get published appointment documents by project id.
     * @param projectId - The project id
     * @returns Array of Appointment
     */
    public async GetPublishedProjectDocuments(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetPublishedProjectDocuments(projectId:number|carriers.Document_GetPublishedProjectDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetPublishedProjectDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Document_GetPublishedProjectDocumentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedProjectDocuments( _request, _options );
    }


    private async _GetProjectMemberDocumentsByTemplateTypes(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberDocumentsByTemplateTypes", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project member specified. 
     * @param request - PersonId, StartTime, EndTime, Count, DocumentTemplateIds
     * @returns Array of Appointments.
     */
    public async GetProjectMemberDocumentsByTemplateTypes(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project member specified. 
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateIds - Ids of the document template types to filter on.
     * @returns Array of Appointments.
     */
    public async GetProjectMemberDocumentsByTemplateTypes(personId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetProjectMemberDocumentsByTemplateTypes(personId:number|carriers.Document_GetProjectMemberDocumentsByTemplateTypesRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, documentTemplateIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetProjectMemberDocumentsByTemplateTypesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.DocumentTemplateIds)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetProjectMemberDocumentsByTemplateTypesRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       DocumentTemplateIds: documentTemplateIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMemberDocumentsByTemplateTypes( _request, _options );
    }


    private async _GetProjectMemberDocumentsByTemplateType(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberDocumentsByTemplateType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project member specified. 
     * @param request - PersonId, StartTime, EndTime, Count, DocumentTemplateId
     * @returns Array of Appointments.
     */
    public async GetProjectMemberDocumentsByTemplateType(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project member specified. 
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateId - Id of the document template type to filter on.
     * @returns Array of Appointments.
     */
    public async GetProjectMemberDocumentsByTemplateType(personId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetProjectMemberDocumentsByTemplateType(personId:number|carriers.Document_GetProjectMemberDocumentsByTemplateTypeRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, documentTemplateId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetProjectMemberDocumentsByTemplateTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.DocumentTemplateId)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetProjectMemberDocumentsByTemplateTypeRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       DocumentTemplateId: documentTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMemberDocumentsByTemplateType( _request, _options );
    }


    private async _GetProjectMemberDocumentsByTemplateHeading(request: carriers.Document_GetProjectMemberDocumentsByTemplateHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberDocumentsByTemplateHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project member specified. The heading represents a grouping or filtering of document templates.
     * @param request - PersonId, StartTime, EndTime, Count, TemplateHeadingId
     * @returns Array of Appointments.
     */
    public async GetProjectMemberDocumentsByTemplateHeading(request: carriers.Document_GetProjectMemberDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project member specified. The heading represents a grouping or filtering of document templates.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    public async GetProjectMemberDocumentsByTemplateHeading(personId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetProjectMemberDocumentsByTemplateHeading(personId:number|carriers.Document_GetProjectMemberDocumentsByTemplateHeadingRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, templateHeadingId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetProjectMemberDocumentsByTemplateHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TemplateHeadingId)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetProjectMemberDocumentsByTemplateHeadingRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TemplateHeadingId: templateHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMemberDocumentsByTemplateHeading( _request, _options );
    }


    private async _GetProjectMemberDocuments(request: carriers.Document_GetProjectMemberDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project member specified. 
     * @param request - PersonId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetProjectMemberDocuments(request: carriers.Document_GetProjectMemberDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project member specified. 
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetProjectMemberDocuments(personId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetProjectMemberDocuments(personId:number|carriers.Document_GetProjectMemberDocumentsRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetProjectMemberDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetProjectMemberDocumentsRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMemberDocuments( _request, _options );
    }


    private async _GetProjectDocumentsByTemplateTypes(request: carriers.Document_GetProjectDocumentsByTemplateTypesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectDocumentsByTemplateTypes", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project specified. 
     * @param request - ProjectId, StartTime, EndTime, Count, DocumentTemplateIds
     * @returns Array of Appointments.
     */
    public async GetProjectDocumentsByTemplateTypes(request: carriers.Document_GetProjectDocumentsByTemplateTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project specified. 
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateIds - Ids of the document template types to filter on.
     * @returns Array of Appointments.
     */
    public async GetProjectDocumentsByTemplateTypes(projectId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetProjectDocumentsByTemplateTypes(projectId:number|carriers.Document_GetProjectDocumentsByTemplateTypesRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, documentTemplateIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetProjectDocumentsByTemplateTypesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.DocumentTemplateIds)!='undefined' ) )
        {
            _request = projectId as carriers.Document_GetProjectDocumentsByTemplateTypesRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       DocumentTemplateIds: documentTemplateIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetProjectDocumentsByTemplateTypes( _request, _options );
    }


    private async _GetProjectDocumentsByTemplateType(request: carriers.Document_GetProjectDocumentsByTemplateTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectDocumentsByTemplateType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project specified. 
     * @param request - ProjectId, StartTime, EndTime, Count, DocumentTemplateId
     * @returns Array of Appointments.
     */
    public async GetProjectDocumentsByTemplateType(request: carriers.Document_GetProjectDocumentsByTemplateTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project specified. 
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateId - Id of the document template type to filter on.
     * @returns Array of Appointments.
     */
    public async GetProjectDocumentsByTemplateType(projectId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetProjectDocumentsByTemplateType(projectId:number|carriers.Document_GetProjectDocumentsByTemplateTypeRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, documentTemplateId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetProjectDocumentsByTemplateTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.DocumentTemplateId)!='undefined' ) )
        {
            _request = projectId as carriers.Document_GetProjectDocumentsByTemplateTypeRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       DocumentTemplateId: documentTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectDocumentsByTemplateType( _request, _options );
    }


    private async _GetProjectDocumentsByTemplateHeading(request: carriers.Document_GetProjectDocumentsByTemplateHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectDocumentsByTemplateHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project specified. The heading represents a grouping or filtering of document templates.
     * @param request - ProjectId, StartTime, EndTime, Count, TemplateHeadingId
     * @returns Array of Appointments.
     */
    public async GetProjectDocumentsByTemplateHeading(request: carriers.Document_GetProjectDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project specified. The heading represents a grouping or filtering of document templates.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    public async GetProjectDocumentsByTemplateHeading(projectId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetProjectDocumentsByTemplateHeading(projectId:number|carriers.Document_GetProjectDocumentsByTemplateHeadingRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, templateHeadingId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetProjectDocumentsByTemplateHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TemplateHeadingId)!='undefined' ) )
        {
            _request = projectId as carriers.Document_GetProjectDocumentsByTemplateHeadingRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TemplateHeadingId: templateHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectDocumentsByTemplateHeading( _request, _options );
    }


    private async _GetProjectDocuments(request: carriers.Document_GetProjectDocumentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectDocuments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project specified. 
     * @param request - ProjectId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetProjectDocuments(request: carriers.Document_GetProjectDocumentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project specified. 
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetProjectDocuments(projectId: number, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetProjectDocuments(projectId:number|carriers.Document_GetProjectDocumentsRequest, startTime?:Date|base.WebApiRequestOptions, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetProjectDocumentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = projectId as carriers.Document_GetProjectDocumentsRequest;
            _options = startTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectDocuments( _request, _options );
    }


    private async _GetPersonDocumentsByTemplateTypes(request: carriers.Document_GetPersonDocumentsByTemplateTypesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocumentsByTemplateTypes", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the person specified. 
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count, DocumentTemplateIds
     * @returns Array of Appointments.
     */
    public async GetPersonDocumentsByTemplateTypes(request: carriers.Document_GetPersonDocumentsByTemplateTypesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the person specified. 
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateIds - Ids of the document template types to filter on.
     * @returns Array of Appointments.
     */
    public async GetPersonDocumentsByTemplateTypes(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetPersonDocumentsByTemplateTypes(personId:number|carriers.Document_GetPersonDocumentsByTemplateTypesRequest, includeProjectDocuments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, documentTemplateIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetPersonDocumentsByTemplateTypesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectDocuments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.DocumentTemplateIds)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetPersonDocumentsByTemplateTypesRequest;
            _options = includeProjectDocuments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectDocuments: includeProjectDocuments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       DocumentTemplateIds: documentTemplateIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetPersonDocumentsByTemplateTypes( _request, _options );
    }


    private async _GetPersonDocumentsByTemplateType(request: carriers.Document_GetPersonDocumentsByTemplateTypeRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocumentsByTemplateType", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the person specified. 
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count, DocumentTemplateId
     * @returns Array of Appointments.
     */
    public async GetPersonDocumentsByTemplateType(request: carriers.Document_GetPersonDocumentsByTemplateTypeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the person specified. 
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateId - Id of the document template type to filter on.
     * @returns Array of Appointments.
     */
    public async GetPersonDocumentsByTemplateType(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetPersonDocumentsByTemplateType(personId:number|carriers.Document_GetPersonDocumentsByTemplateTypeRequest, includeProjectDocuments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, documentTemplateId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetPersonDocumentsByTemplateTypeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectDocuments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.DocumentTemplateId)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetPersonDocumentsByTemplateTypeRequest;
            _options = includeProjectDocuments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectDocuments: includeProjectDocuments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       DocumentTemplateId: documentTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonDocumentsByTemplateType( _request, _options );
    }


    private async _GetPersonDocumentsByTemplateHeading(request: carriers.Document_GetPersonDocumentsByTemplateHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocumentsByTemplateHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the person specified. The heading represents a grouping or filtering of document templates.
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count, TemplateHeadingId
     * @returns Array of Appointments.
     */
    public async GetPersonDocumentsByTemplateHeading(request: carriers.Document_GetPersonDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the person specified. The heading represents a grouping or filtering of document templates.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    public async GetPersonDocumentsByTemplateHeading(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetPersonDocumentsByTemplateHeading(personId:number|carriers.Document_GetPersonDocumentsByTemplateHeadingRequest, includeProjectDocuments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, templateHeadingId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetPersonDocumentsByTemplateHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectDocuments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' || typeof(first.TemplateHeadingId)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetPersonDocumentsByTemplateHeadingRequest;
            _options = includeProjectDocuments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectDocuments: includeProjectDocuments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       TemplateHeadingId: templateHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonDocumentsByTemplateHeading( _request, _options );
    }


    private async _GetPersonDocumentsByDate(request: carriers.Document_GetPersonDocumentsByDateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocumentsByDate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the person specified. 
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    public async GetPersonDocumentsByDate(request: carriers.Document_GetPersonDocumentsByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the person specified. 
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    public async GetPersonDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetPersonDocumentsByDate(personId:number|carriers.Document_GetPersonDocumentsByDateRequest, includeProjectDocuments?:boolean|base.WebApiRequestOptions, startTime?:Date, endTime?:Date, count?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetPersonDocumentsByDateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.IncludeProjectDocuments)!='undefined' || typeof(first.StartTime)!='undefined' || typeof(first.EndTime)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = personId as carriers.Document_GetPersonDocumentsByDateRequest;
            _options = includeProjectDocuments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       IncludeProjectDocuments: includeProjectDocuments as boolean,
                       StartTime: startTime as Date,
                       EndTime: endTime as Date,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonDocumentsByDate( _request, _options );
    }


    private async _GetDocumentsByTemplateHeading(request: carriers.Document_GetDocumentsByTemplateHeadingRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Document[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentsByTemplateHeading", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Document[] = converters.Create_DocumentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns document appointments, filtered by the document template heading. The heading represents a grouping or filtering of document templates.
     * @param request - TemplateHeadingId
     * @returns Array of Appointments.
     */
    public async GetDocumentsByTemplateHeading(request: carriers.Document_GetDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    /**
     * Method that returns document appointments, filtered by the document template heading. The heading represents a grouping or filtering of document templates.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    public async GetDocumentsByTemplateHeading(templateHeadingId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] >;

    public async GetDocumentsByTemplateHeading(templateHeadingId:number|carriers.Document_GetDocumentsByTemplateHeadingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Document[] > {
        let _request : carriers.Document_GetDocumentsByTemplateHeadingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = templateHeadingId;
        if( typeof( first ) === "object" && first && ( typeof(first.TemplateHeadingId)!='undefined' ) )
        {
            _request = templateHeadingId as carriers.Document_GetDocumentsByTemplateHeadingRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TemplateHeadingId: templateHeadingId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDocumentsByTemplateHeading( _request, _options );
    }

    /*
     * Gets a SuggestedDocumentEntity object.
     * @param suggestedDocumentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SuggestedDocumentEntity
     */
    public async GetSuggestedDocumentEntity(suggestedDocumentEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SuggestedDocumentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SuggestedDocumentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSuggestedDocumentEntity?suggestedDocumentEntityId=" + suggestedDocumentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedDocumentEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    } // class v1DocumentAgentController 



// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/EMailAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Email connection, reading, sending
 * 
 * **Online Restricted:** This agent is not available in Online by default. Access must be requested specifically when app is registered.
 */
export interface IEMailAgent {
    CreateDefaultEMailAccount(): Promise< carriers.EMailAccount >;
    SaveEMailAccount(entity: carriers.EMailAccount) : Promise< carriers.EMailAccount >;
    DeleteEMailAccount(EMailAccountId: number) : Promise<void>;
    CreateDefaultEMailAddress(): Promise< carriers.EMailAddress >;
    CreateDefaultEMailAppointment(): Promise< carriers.EMailAppointment >;
    CreateDefaultEMailAttachment(): Promise< carriers.EMailAttachment >;
    CreateDefaultEMailConnectionInfo(): Promise< carriers.EMailConnectionInfo >;
    CreateDefaultEMailConnectionInfoExtended(): Promise< carriers.EMailConnectionInfoExtended >;
    CreateDefaultEMailCustomHeader(): Promise< carriers.EMailCustomHeader >;
    CreateDefaultEMailEntity(): Promise< carriers.EMailEntity >;
    CreateDefaultEMailEnvelope(): Promise< carriers.EMailEnvelope >;
    CreateDefaultEMailFolder(): Promise< carriers.EMailFolder >;
    CreateDefaultEMailSOInfo(): Promise< carriers.EMailSOInfo >;
    GetEMailAccount(eMailAccountId: number) :  Promise< carriers.EMailAccount >;
    GetEMailAccountFromEMailAddress(request: carriers.EMail_GetEMailAccountFromEMailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount >;
    GetEMailAccountFromEMailAddress(fromAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount >;
    GetCurrentAccountId(webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetCurrentAccount(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount >;
    GetPersonEntitiesFromEmailAddress(request: carriers.EMail_GetPersonEntitiesFromEmailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity[] >;
    GetPersonEntitiesFromEmailAddress(emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity[] >;
    GetPersonsFromEmailAddress(request: carriers.EMail_GetPersonsFromEmailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetPersonsFromEmailAddress(emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    HasMXRecord(request: carriers.EMail_HasMXRecordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasMXRecord(mailDomain: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasSPFRecord(request: carriers.EMail_HasSPFRecordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasSPFRecord(sourceSpf: string, targetDomain: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ResolveEMailRecipients(request: carriers.EMail_ResolveEMailRecipientsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;
    ResolveEMailRecipients(emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;
    GetEMailFromId(request: carriers.EMail_GetEMailFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMailFromId(connectionInfo: carriers.EMailConnectionInfo, messageServerId: number, lookupAddresses: boolean, flags: enums.EMailFlags, includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    SendEMails(request: carriers.EMail_SendEMailsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] >;
    SendEMails(outgoingConnectionInfo: carriers.EMailConnectionInfo, emails: carriers.EMailEntity[], sentItemsConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] >;
    SaveEMail(request: carriers.EMail_SaveEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    SaveEMail(connectionInfo: carriers.EMailConnectionInfo, email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    AuthenticateIncoming(request: carriers.EMail_AuthenticateIncomingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    AuthenticateIncoming(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    AuthenticateOutgoing(request: carriers.EMail_AuthenticateOutgoingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    AuthenticateOutgoing(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetFolderList(request: carriers.EMail_GetFolderListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetFolderList(connectionInfo: carriers.EMailConnectionInfo, includeItemCount: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetAttachment(request: carriers.EMail_GetAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetAttachment(connectionInfo: carriers.EMailConnectionInfo, messageServerId: number, attachmentId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    MarkAsRead(request: carriers.EMail_MarkAsReadRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MarkAsRead(connectionInfo: carriers.EMailConnectionInfo, messageServerIds: number[], read: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetFolderEMailCount(request: carriers.EMail_GetFolderEMailCountRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetFolderEMailCount(connectionInfo: carriers.EMailConnectionInfo, onlyUnread: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    Delete(request: carriers.EMail_DeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Delete(connectionInfo: carriers.EMailConnectionInfo, messageServerIds: number[], moveToFolder: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveToFolder(request: carriers.EMail_MoveToFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveToFolder(connectionInfo: carriers.EMailConnectionInfo, messageServerIds: number[], targetFolder: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    EmptyFolder(request: carriers.EMail_EmptyFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    EmptyFolder(connectionInfo: carriers.EMailConnectionInfo, moveToFolder: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetEMailAsStream(request: carriers.EMail_GetEMailAsStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetEMailAsStream(connectionInfo: carriers.EMailConnectionInfo, messageServerId: number, stripAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    FindAddress(request: carriers.EMail_FindAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;
    FindAddress(address: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;
    GetEMailFromDocumentId(request: carriers.EMail_GetEMailFromDocumentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMailFromDocumentId(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMailFromDocumentId(request: carriers.EMail_GetUnsanitizedEMailFromDocumentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMailFromDocumentId(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMailFromAttachmentId(request: carriers.EMail_GetEMailFromAttachmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMailFromAttachmentId(emailId: number, attachmentIds: string[], includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMailFromAttachmentId(request: carriers.EMail_GetUnsanitizedEMailFromAttachmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMailFromAttachmentId(emailId: number, attachmentIds: string[], includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMailFromDocumentAttachmentId(request: carriers.EMail_GetEMailFromDocumentAttachmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMailFromDocumentAttachmentId(docId: number, attachmentIds: string[], includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMailFromDocumentAttachmentId(request: carriers.EMail_GetUnsanitizedEMailFromDocumentAttachmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMailFromDocumentAttachmentId(docId: number, attachmentIds: string[], includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMailEnvelopes(request: carriers.EMail_GetEMailEnvelopesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] >;
    GetEMailEnvelopes(connectionInfo: carriers.EMailConnectionInfo, messageServerIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] >;
    SetSubscription(request: carriers.EMail_SetSubscriptionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetSubscription(connectionInfo: carriers.EMailConnectionInfo, folders: carriers.EMailFolder[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateFolder(request: carriers.EMail_CreateFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateFolder(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteFolder(request: carriers.EMail_DeleteFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteFolder(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateEMailFromDocumentEntity(request: carriers.EMail_CreateEMailFromDocumentEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    CreateEMailFromDocumentEntity(documentEntity: carriers.DocumentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    CreateEMailFromMimeMessage(request: carriers.EMail_CreateEMailFromMimeMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    CreateEMailFromMimeMessage(mimeMessage: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetFolderInfo(request: carriers.EMail_GetFolderInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder[] >;
    GetFolderInfo(connectionInfo: carriers.EMailConnectionInfo, folders: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder[] >;
    GetFolderHasNewEMail(request: carriers.EMail_GetFolderHasNewEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetFolderHasNewEMail(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetEMailAddresses(request: carriers.EMail_GetEMailAddressesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;
    GetEMailAddresses(emailIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;
    RefreshFolder(request: carriers.EMail_RefreshFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    RefreshFolder(connectionInfo: carriers.EMailConnectionInfo, folders: string[], webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetEMailFromTemp(request: carriers.EMail_GetEMailFromTempRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMailFromTemp(fileName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    Authenticate(request: carriers.EMail_AuthenticateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    Authenticate(connectionInfoExtended: carriers.EMailConnectionInfoExtended, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetEmailMessageIds(request: carriers.EMail_GetEmailMessageIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetEmailMessageIds(connectionInfoExtended: carriers.EMailConnectionInfoExtended, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetExtendedEmailMessageIds(request: carriers.EMail_GetExtendedEmailMessageIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetExtendedEmailMessageIds(connectionInfoExtended: carriers.EMailConnectionInfoExtended, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetEmailsAsString(request: carriers.EMail_GetEmailsAsStringRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    GetEmailsAsString(connectionInfoExtended: carriers.EMailConnectionInfoExtended, messageIds: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    DeleteExtended(request: carriers.EMail_DeleteExtendedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteExtended(connectionInfoExtended: carriers.EMailConnectionInfoExtended, messageIds: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RelayMessage(request: carriers.EMail_RelayMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RelayMessage(connectionInfoExtended: carriers.EMailConnectionInfoExtended, rfc822: string, from: string, recipients: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetEMail(request: carriers.EMail_GetEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMail(id: number, includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMail(request: carriers.EMail_GetUnsanitizedEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMail(id: number, includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    MarkEmailsAsRead(request: carriers.EMail_MarkEmailsAsReadRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MarkEmailsAsRead(ids: number[], read: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteEmails(request: carriers.EMail_DeleteEmailsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteEmails(ids: number[], moveToFolder: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveEmailsToTrash(request: carriers.EMail_MoveEmailsToTrashRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveEmailsToTrash(ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Save(request: carriers.EMail_SaveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    Save(email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    SaveToMailServer(request: carriers.EMail_SaveToMailServerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    SaveToMailServer(email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    Send(request: carriers.EMail_SendRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] >;
    Send(emails: carriers.EMailEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] >;
    CreateForwardEmail(request: carriers.EMail_CreateForwardEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    CreateForwardEmail(email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    FindContactOrPersonByEmailName(request: carriers.EMail_FindContactOrPersonByEmailNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] >;
    FindContactOrPersonByEmailName(name: string, emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] >;
    FindContactOrPersonByEmailNameWithLimit(request: carriers.EMail_FindContactOrPersonByEmailNameWithLimitRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] >;
    FindContactOrPersonByEmailNameWithLimit(name: string, emailAddress: string, numberOfContacts: number, numberOfPersons: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] >;
    RefreshFolderForAssociate(request: carriers.EMail_RefreshFolderForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    RefreshFolderForAssociate(folders: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetNewMail(request: carriers.EMail_GetNewMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] >;
    GetNewMail(folders: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] >;
    CacheFolderList(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder[] >;
    MoveEmailsToFolder(request: carriers.EMail_MoveEmailsToFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    MoveEmailsToFolder(folderId: number, emailItemIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetMailFromMessageId(request: carriers.EMail_GetMailFromMessageIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetMailFromMessageId(messageId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetMailFromInReplyTo(request: carriers.EMail_GetMailFromInReplyToRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetMailFromInReplyTo(messageId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    SendAndSaveEmailToTmpDocument(request: carriers.EMail_SendAndSaveEmailToTmpDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SendAndSaveEmailToTmpDocument(email: carriers.EMailEntity, stripAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SaveEmailToTmpDocument(request: carriers.EMail_SaveEmailToTmpDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SaveEmailToTmpDocument(email: carriers.EMailEntity, folderId: number, stripAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SaveDraft(request: carriers.EMail_SaveDraftRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    SaveDraft(entity: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    SetRepliedAt(request: carriers.EMail_SetRepliedAtRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetRepliedAt(messageId: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetEMailFromDocumentIdWithoutAttachmentStream(request: carriers.EMail_GetEMailFromDocumentIdWithoutAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetEMailFromDocumentIdWithoutAttachmentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream(request: carriers.EMail_GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;
    GetAttachmentFromId(request: carriers.EMail_GetAttachmentFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetAttachmentFromId(mailItemId: number, attachmentId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetPreviewAttachmentFromId(request: carriers.EMail_GetPreviewAttachmentFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetPreviewAttachmentFromId(mailItemId: number, attachmentId: string, attachmentType: string, attachmentFilename: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetUnsanitizedPreviewAttachmentFromId(request: carriers.EMail_GetUnsanitizedPreviewAttachmentFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetUnsanitizedPreviewAttachmentFromId(mailItemId: number, attachmentId: string, attachmentType: string, attachmentFilename: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetPreviewAttachmentFromDocId(request: carriers.EMail_GetPreviewAttachmentFromDocIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetPreviewAttachmentFromDocId(docId: number, attachmentId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetUnsanitizedPreviewAttachmentFromDocId(request: carriers.EMail_GetUnsanitizedPreviewAttachmentFromDocIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    GetUnsanitizedPreviewAttachmentFromDocId(docId: number, attachmentId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;
    TestAuthenticate(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ToggleSubscription(request: carriers.EMail_ToggleSubscriptionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ToggleSubscription(folderId: number, subscriptionStatus: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    HasNewMail(request: carriers.EMail_HasNewMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasNewMail(mailItemId: number, folderId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    LatestItemIdByFolder(request: carriers.EMail_LatestItemIdByFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    LatestItemIdByFolder(folderId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CreateInlineHtmlHeader(request: carriers.EMail_CreateInlineHtmlHeaderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    CreateInlineHtmlHeader(email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetEmailAppointment(request: carriers.EMail_GetEmailAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAppointment >;
    GetEmailAppointment(mailItemId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAppointment >;
    GetEmailAppointmentRecurrence(request: carriers.EMail_GetEmailAppointmentRecurrenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;
    GetEmailAppointmentRecurrence(mailItemId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;
    GetParticipantInfoFromEmailAddress(request: carriers.EMail_GetParticipantInfoFromEmailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >;
    GetParticipantInfoFromEmailAddress(emailAddress: string, appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >;
    GetEmailDocumentAsMimeStream(request: carriers.EMail_GetEmailDocumentAsMimeStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetEmailDocumentAsMimeStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetEMailSOInfo(eMailSOInfoId: number) :  Promise< carriers.EMailSOInfo >;
    GetReadySyncEmailAccounts(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SyncUserAccount[] >;
    SyncEmailAccount(request: carriers.EMail_SyncEmailAccountRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SyncEmailAccount(syncUserAccount: carriers.SyncUserAccount, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SyncEmailAccounts(request: carriers.EMail_SyncEmailAccountsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SyncEmailAccounts(syncUserAccounts: carriers.SyncUserAccount[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
} // interface IEMailAgent




/**
 * Email connection, reading, sending
 */
export class EMailAgent extends base.WebApiBase implements IEMailAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/EMail/";
        super(options);
    }



    /**
     * Set default values into a new EMailAccount.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailAccount(options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAccount >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailAccount", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAccount = converters.Create_EMailAccount_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing EMailAccount or creates a new EMailAccount if the id parameter is empty
     * @param entity - The EMailAccount to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated EMailAccount
     */
    public async SaveEMailAccount(entity: carriers.EMailAccount, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAccount >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveEMailAccount", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAccount = converters.Create_EMailAccount_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the EMailAccount
     * @param EMailAccountId - The id of the EMailAccount to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteEMailAccount(EMailAccountId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteEMailAccount?EMailAccountId=" + EMailAccountId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailAddress.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailAddress(options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAddress >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailAddress", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAddress = converters.Create_EMailAddress_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailAppointment.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailAppointment(options?:base.WebApiRequestOptions) : Promise< carriers.EMailAppointment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAppointment >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailAppointment", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAppointment = converters.Create_EMailAppointment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailAttachment.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailAttachment(options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAttachment >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailAttachment", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAttachment = converters.Create_EMailAttachment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailConnectionInfo.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailConnectionInfo(options?:base.WebApiRequestOptions) : Promise< carriers.EMailConnectionInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailConnectionInfo >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailConnectionInfo", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailConnectionInfo = converters.Create_EMailConnectionInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailConnectionInfoExtended.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailConnectionInfoExtended(options?:base.WebApiRequestOptions) : Promise< carriers.EMailConnectionInfoExtended > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailConnectionInfoExtended >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailConnectionInfoExtended", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailConnectionInfoExtended = converters.Create_EMailConnectionInfoExtended_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailCustomHeader.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailCustomHeader(options?:base.WebApiRequestOptions) : Promise< carriers.EMailCustomHeader > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailCustomHeader >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailCustomHeader", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailCustomHeader = converters.Create_EMailCustomHeader_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailEntity(options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailEnvelope.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailEnvelope(options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEnvelope >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailEnvelope", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEnvelope = converters.Create_EMailEnvelope_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailFolder.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailFolder(options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailFolder >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailFolder", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailFolder = converters.Create_EMailFolder_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new EMailSOInfo.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultEMailSOInfo(options?:base.WebApiRequestOptions) : Promise< carriers.EMailSOInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailSOInfo >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailSOInfo", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailSOInfo = converters.Create_EMailSOInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a EMailAccount object.
     * @param eMailAccountId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single EMailAccount
     */
    public async GetEMailAccount(eMailAccountId: number, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAccount >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetEMailAccount?eMailAccountId=" + eMailAccountId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAccount_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetEMailAccountFromEMailAddress(request: carriers.EMail_GetEMailAccountFromEMailAddressRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAccount >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailAccountFromEMailAddress", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAccount = converters.Create_EMailAccount_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the email account corresponding to this email address (for the current associate).
     * @param request - FromAddress
     * @returns Found or empty email account
     */
    public async GetEMailAccountFromEMailAddress(request: carriers.EMail_GetEMailAccountFromEMailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount >;

    /**
     * Returns the email account corresponding to this email address (for the current associate).
     * @param fromAddress - The address associated with this email account
     * @returns Found or empty email account
     */
    public async GetEMailAccountFromEMailAddress(fromAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount >;

    public async GetEMailAccountFromEMailAddress(fromAddress:string|carriers.EMail_GetEMailAccountFromEMailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount > {
        let _request : carriers.EMail_GetEMailAccountFromEMailAddressRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = fromAddress;
        if( typeof( first ) === "object" && first && ( typeof(first.FromAddress)!='undefined' ) )
        {
            _request = fromAddress as carriers.EMail_GetEMailAccountFromEMailAddressRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FromAddress: fromAddress as string,
                       };   
            _options = webapi_options;
        }
        return this._GetEMailAccountFromEMailAddress( _request, _options );
    }


    private async _GetCurrentAccountId( options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCurrentAccountId", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get current accountId (last logged into should normally be current) for logged in associate
     * @returns Id of current account
     */
    public async GetCurrentAccountId(webapi_options?:base.WebApiRequestOptions) : Promise< number >
    {
        return this._GetCurrentAccountId(webapi_options);
    }


    private async _GetCurrentAccount( options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAccount >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCurrentAccount", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAccount = converters.Create_EMailAccount_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get current account (last logged into should normally be current) for logged in associate
     * @returns Id of current account
     */
    public async GetCurrentAccount(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAccount >
    {
        return this._GetCurrentAccount(webapi_options);
    }


    private async _GetPersonEntitiesFromEmailAddress(request: carriers.EMail_GetPersonEntitiesFromEmailAddressRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonEntitiesFromEmailAddress", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonEntity[] = converters.Create_PersonEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all persons and contacts with the given email address
     * @param request - EmailAddress
     * @returns 
     */
    public async GetPersonEntitiesFromEmailAddress(request: carriers.EMail_GetPersonEntitiesFromEmailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity[] >;

    /**
     * Get all persons and contacts with the given email address
     * @param emailAddress - The emailAddress to find persons and contacts for
     * @returns 
     */
    public async GetPersonEntitiesFromEmailAddress(emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity[] >;

    public async GetPersonEntitiesFromEmailAddress(emailAddress:string|carriers.EMail_GetPersonEntitiesFromEmailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity[] > {
        let _request : carriers.EMail_GetPersonEntitiesFromEmailAddressRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailAddress;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailAddress)!='undefined' ) )
        {
            _request = emailAddress as carriers.EMail_GetPersonEntitiesFromEmailAddressRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailAddress: emailAddress as string,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonEntitiesFromEmailAddress( _request, _options );
    }


    private async _GetPersonsFromEmailAddress(request: carriers.EMail_GetPersonsFromEmailAddressRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonsFromEmailAddress", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person[] = converters.Create_PersonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all persons and contacts with the given email address
     * @param request - EmailAddress
     * @returns 
     */
    public async GetPersonsFromEmailAddress(request: carriers.EMail_GetPersonsFromEmailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    /**
     * Get all persons and contacts with the given email address
     * @param emailAddress - The emailAddress to find persons and contacts for
     * @returns 
     */
    public async GetPersonsFromEmailAddress(emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    public async GetPersonsFromEmailAddress(emailAddress:string|carriers.EMail_GetPersonsFromEmailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        let _request : carriers.EMail_GetPersonsFromEmailAddressRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailAddress;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailAddress)!='undefined' ) )
        {
            _request = emailAddress as carriers.EMail_GetPersonsFromEmailAddressRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailAddress: emailAddress as string,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonsFromEmailAddress( _request, _options );
    }


    private async _HasMXRecord(request: carriers.EMail_HasMXRecordRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasMXRecord", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Return true if there is one or more MX records in DNS for the given mail domain
     * @param request - MailDomain
     * @returns True if there is at least one MX record
     */
    public async HasMXRecord(request: carriers.EMail_HasMXRecordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Return true if there is one or more MX records in DNS for the given mail domain
     * @param mailDomain - The mail domain to check. Normally this is the part after @ in an email address
     * @returns True if there is at least one MX record
     */
    public async HasMXRecord(mailDomain: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasMXRecord(mailDomain:string|carriers.EMail_HasMXRecordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.EMail_HasMXRecordRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mailDomain;
        if( typeof( first ) === "object" && first && ( typeof(first.MailDomain)!='undefined' ) )
        {
            _request = mailDomain as carriers.EMail_HasMXRecordRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MailDomain: mailDomain as string,
                       };   
            _options = webapi_options;
        }
        return this._HasMXRecord( _request, _options );
    }


    private async _HasSPFRecord(request: carriers.EMail_HasSPFRecordRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasSPFRecord", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Return true if target domain contains a SPF record which is under the given SPF record
     * @param request - SourceSpf, TargetDomain
     * @returns True if a match is found
     */
    public async HasSPFRecord(request: carriers.EMail_HasSPFRecordRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Return true if target domain contains a SPF record which is under the given SPF record
     * @param sourceSpf - The SPF to match from
     * @param targetDomain - The domain to verify if it has at least one SPF record contained in the source SPF
     * @returns True if a match is found
     */
    public async HasSPFRecord(sourceSpf: string, targetDomain: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasSPFRecord(sourceSpf:string|carriers.EMail_HasSPFRecordRequest, targetDomain?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.EMail_HasSPFRecordRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceSpf;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceSpf)!='undefined' || typeof(first.TargetDomain)!='undefined' ) )
        {
            _request = sourceSpf as carriers.EMail_HasSPFRecordRequest;
            _options = targetDomain as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceSpf: sourceSpf as string,
                       TargetDomain: targetDomain as string,
                       };   
            _options = webapi_options;
        }
        return this._HasSPFRecord( _request, _options );
    }


    private async _ResolveEMailRecipients(request: carriers.EMail_ResolveEMailRecipientsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAddress[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResolveEMailRecipients", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAddress[] = converters.Create_EMailAddressArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Resolve separate emails from single string. Also lookup persons by emails.
     * @param request - EmailAddress
     * @returns Resolved EMail recipients
     */
    public async ResolveEMailRecipients(request: carriers.EMail_ResolveEMailRecipientsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;

    /**
     * Resolve separate emails from single string. Also lookup persons by emails.
     * @param emailAddress - The string to lookup emails from
     * @returns Resolved EMail recipients
     */
    public async ResolveEMailRecipients(emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;

    public async ResolveEMailRecipients(emailAddress:string|carriers.EMail_ResolveEMailRecipientsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] > {
        let _request : carriers.EMail_ResolveEMailRecipientsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailAddress;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailAddress)!='undefined' ) )
        {
            _request = emailAddress as carriers.EMail_ResolveEMailRecipientsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailAddress: emailAddress as string,
                       };   
            _options = webapi_options;
        }
        return this._ResolveEMailRecipients( _request, _options );
    }


    private async _GetEMailFromId(request: carriers.EMail_GetEMailFromIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get en e-mail based on its unique id
     * @param request - ConnectionInfo, MessageServerId, LookupAddresses, Flags, IncludeAttachments
     * @returns The e-mail
     */
    public async GetEMailFromId(request: carriers.EMail_GetEMailFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get en e-mail based on its unique id
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param messageServerId - Unique ID for the e-mail to retrieve
     * @param lookupAddresses - If true try to look up e-mail addresses in from/to/cc/bcc fields against superoffice contacts
     * @param flags - Any flags to apply to the fetched item. Ex: Seen/Answered
     * @param includeAttachments - Should we retrieve attachments embedded in the e-mail from the server
     * @returns The e-mail
     */
    public async GetEMailFromId(connectionInfo: carriers.EMailConnectionInfo, messageServerId: number, lookupAddresses: boolean, flags: enums.EMailFlags, includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetEMailFromId(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_GetEMailFromIdRequest, messageServerId?:number|base.WebApiRequestOptions, lookupAddresses?:boolean, flags?:enums.EMailFlags, includeAttachments?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetEMailFromIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.MessageServerId)!='undefined' || typeof(first.LookupAddresses)!='undefined' || typeof(first.Flags)!='undefined' || typeof(first.IncludeAttachments)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_GetEMailFromIdRequest;
            _options = messageServerId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       MessageServerId: messageServerId as number,
                       LookupAddresses: lookupAddresses as boolean,
                       Flags: flags as enums.EMailFlags,
                       IncludeAttachments: includeAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetEMailFromId( _request, _options );
    }


    private async _SendEMails(request: carriers.EMail_SendEMailsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendEMails", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity[] = converters.Create_EMailEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Send the provided e-mails
     * @param request - OutgoingConnectionInfo, Emails, SentItemsConnectionInfo
     * @returns The sent e-mails (updated with message id etc.)
     */
    public async SendEMails(request: carriers.EMail_SendEMailsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] >;

    /**
     * Send the provided e-mails
     * @param outgoingConnectionInfo - All information needed to connect to the mailserver
     * @param emails - The e-mails to send
     * @param sentItemsConnectionInfo - If provided, save sent item(s) in the folder specified.  May be null.
     * @returns The sent e-mails (updated with message id etc.)
     */
    public async SendEMails(outgoingConnectionInfo: carriers.EMailConnectionInfo, emails: carriers.EMailEntity[], sentItemsConnectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] >;

    public async SendEMails(outgoingConnectionInfo:carriers.EMailConnectionInfo|carriers.EMail_SendEMailsRequest, emails?:carriers.EMailEntity[]|base.WebApiRequestOptions, sentItemsConnectionInfo?:carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] > {
        let _request : carriers.EMail_SendEMailsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = outgoingConnectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.OutgoingConnectionInfo)!='undefined' || typeof(first.Emails)!='undefined' || typeof(first.SentItemsConnectionInfo)!='undefined' ) )
        {
            _request = outgoingConnectionInfo as carriers.EMail_SendEMailsRequest;
            _options = emails as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       OutgoingConnectionInfo: outgoingConnectionInfo as carriers.EMailConnectionInfo,
                       Emails: emails as carriers.EMailEntity[],
                       SentItemsConnectionInfo: sentItemsConnectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._SendEMails( _request, _options );
    }


    private async _SaveEMail(request: carriers.EMail_SaveEMailRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveEMail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save the passed e-mail back to the server
     * @param request - ConnectionInfo, Email
     * @returns The updated saved entity
     */
    public async SaveEMail(request: carriers.EMail_SaveEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Save the passed e-mail back to the server
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param email - The e-mail to save
     * @returns The updated saved entity
     */
    public async SaveEMail(connectionInfo: carriers.EMailConnectionInfo, email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async SaveEMail(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_SaveEMailRequest, email?:carriers.EMailEntity|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_SaveEMailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.Email)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_SaveEMailRequest;
            _options = email as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       Email: email as carriers.EMailEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveEMail( _request, _options );
    }


    private async _AuthenticateIncoming(request: carriers.EMail_AuthenticateIncomingRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AuthenticateIncoming", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Authenticate against a mail-server to retrieve e-mails from
     * @param request - ConnectionInfo
     * @returns True if authentication was succcesfull
     */
    public async AuthenticateIncoming(request: carriers.EMail_AuthenticateIncomingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Authenticate against a mail-server to retrieve e-mails from
     * @param connectionInfo - All information needed to connect to the mailserver
     * @returns True if authentication was succcesfull
     */
    public async AuthenticateIncoming(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async AuthenticateIncoming(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_AuthenticateIncomingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.EMail_AuthenticateIncomingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_AuthenticateIncomingRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._AuthenticateIncoming( _request, _options );
    }


    private async _AuthenticateOutgoing(request: carriers.EMail_AuthenticateOutgoingRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AuthenticateOutgoing", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Authenticate against a mail server to send items with
     * @param request - ConnectionInfo
     * @returns True if authentication was succcesfull
     */
    public async AuthenticateOutgoing(request: carriers.EMail_AuthenticateOutgoingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Authenticate against a mail server to send items with
     * @param connectionInfo - All information needed to connect to the mailserver
     * @returns True if authentication was succcesfull
     */
    public async AuthenticateOutgoing(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async AuthenticateOutgoing(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_AuthenticateOutgoingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.EMail_AuthenticateOutgoingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_AuthenticateOutgoingRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._AuthenticateOutgoing( _request, _options );
    }


    private async _GetFolderList(request: carriers.EMail_GetFolderListRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFolderList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve all folders for the mail account. String is separated in sections by the paragraph character.  First section contains the folder delimeter char. Next is folder name. Additional sections may be unread and total items.
     * @param request - ConnectionInfo, IncludeItemCount
     * @returns List of available folders as a string array
     */
    public async GetFolderList(request: carriers.EMail_GetFolderListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Retrieve all folders for the mail account. String is separated in sections by the paragraph character.  First section contains the folder delimeter char. Next is folder name. Additional sections may be unread and total items.
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param includeItemCount - If true, unread and total items are added to the foldername separated by a comma
     * @returns List of available folders as a string array
     */
    public async GetFolderList(connectionInfo: carriers.EMailConnectionInfo, includeItemCount: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetFolderList(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_GetFolderListRequest, includeItemCount?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.EMail_GetFolderListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.IncludeItemCount)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_GetFolderListRequest;
            _options = includeItemCount as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       IncludeItemCount: includeItemCount as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetFolderList( _request, _options );
    }


    private async _GetAttachment(request: carriers.EMail_GetAttachmentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAttachment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAttachment = converters.Create_EMailAttachment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve an attachment from an e-mail
     * @param request - ConnectionInfo, MessageServerId, AttachmentId
     * @returns The attachment
     */
    public async GetAttachment(request: carriers.EMail_GetAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    /**
     * Retrieve an attachment from an e-mail
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param messageServerId - Unique ID for the e-mail to retrieve the attachment from
     * @param attachmentId - Id of the attachment in the e-mail
     * @returns The attachment
     */
    public async GetAttachment(connectionInfo: carriers.EMailConnectionInfo, messageServerId: number, attachmentId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    public async GetAttachment(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_GetAttachmentRequest, messageServerId?:number|base.WebApiRequestOptions, attachmentId?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        let _request : carriers.EMail_GetAttachmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.MessageServerId)!='undefined' || typeof(first.AttachmentId)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_GetAttachmentRequest;
            _options = messageServerId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       MessageServerId: messageServerId as number,
                       AttachmentId: attachmentId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAttachment( _request, _options );
    }


    private async _MarkAsRead(request: carriers.EMail_MarkAsReadRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MarkAsRead", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Mark one or more e-mails as (un)read
     * @param request - ConnectionInfo, MessageServerIds, Read
     * @returns 
     */
    public async MarkAsRead(request: carriers.EMail_MarkAsReadRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Mark one or more e-mails as (un)read
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param messageServerIds - The e-mails to handle
     * @param read - If true mails are marked as read. If false mails are marked as unread.
     * @returns 
     */
    public async MarkAsRead(connectionInfo: carriers.EMailConnectionInfo, messageServerIds: number[], read: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MarkAsRead(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_MarkAsReadRequest, messageServerIds?:number[]|base.WebApiRequestOptions, read?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_MarkAsReadRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.MessageServerIds)!='undefined' || typeof(first.Read)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_MarkAsReadRequest;
            _options = messageServerIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       MessageServerIds: messageServerIds as number[],
                       Read: read as boolean,
                       };   
            _options = webapi_options;
        }
        return this._MarkAsRead( _request, _options );
    }


    private async _GetFolderEMailCount(request: carriers.EMail_GetFolderEMailCountRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFolderEMailCount", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve total/unread mail items in current folder
     * @param request - ConnectionInfo, OnlyUnread
     * @returns Number of mail items
     */
    public async GetFolderEMailCount(request: carriers.EMail_GetFolderEMailCountRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Retrieve total/unread mail items in current folder
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param onlyUnread - If true, only unread items are counted
     * @returns Number of mail items
     */
    public async GetFolderEMailCount(connectionInfo: carriers.EMailConnectionInfo, onlyUnread: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async GetFolderEMailCount(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_GetFolderEMailCountRequest, onlyUnread?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.EMail_GetFolderEMailCountRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.OnlyUnread)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_GetFolderEMailCountRequest;
            _options = onlyUnread as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       OnlyUnread: onlyUnread as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetFolderEMailCount( _request, _options );
    }


    private async _Delete(request: carriers.EMail_DeleteRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Delete", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete specified mail items
     * @param request - ConnectionInfo, MessageServerIds, MoveToFolder
     * @returns 
     */
    public async Delete(request: carriers.EMail_DeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete specified mail items
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param messageServerIds - The e-mails to handle
     * @param moveToFolder - If set, move deleted items to this folder
     * @returns 
     */
    public async Delete(connectionInfo: carriers.EMailConnectionInfo, messageServerIds: number[], moveToFolder: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Delete(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_DeleteRequest, messageServerIds?:number[]|base.WebApiRequestOptions, moveToFolder?:string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_DeleteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.MessageServerIds)!='undefined' || typeof(first.MoveToFolder)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_DeleteRequest;
            _options = messageServerIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       MessageServerIds: messageServerIds as number[],
                       MoveToFolder: moveToFolder as string,
                       };   
            _options = webapi_options;
        }
        return this._Delete( _request, _options );
    }


    private async _MoveToFolder(request: carriers.EMail_MoveToFolderRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveToFolder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Moved specified items from current folder to targetFolder
     * @param request - ConnectionInfo, MessageServerIds, TargetFolder
     * @returns 
     */
    public async MoveToFolder(request: carriers.EMail_MoveToFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Moved specified items from current folder to targetFolder
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param messageServerIds - The e-mails to handle
     * @param targetFolder - Name of folder to move items to
     * @returns 
     */
    public async MoveToFolder(connectionInfo: carriers.EMailConnectionInfo, messageServerIds: number[], targetFolder: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MoveToFolder(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_MoveToFolderRequest, messageServerIds?:number[]|base.WebApiRequestOptions, targetFolder?:string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_MoveToFolderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.MessageServerIds)!='undefined' || typeof(first.TargetFolder)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_MoveToFolderRequest;
            _options = messageServerIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       MessageServerIds: messageServerIds as number[],
                       TargetFolder: targetFolder as string,
                       };   
            _options = webapi_options;
        }
        return this._MoveToFolder( _request, _options );
    }


    private async _EmptyFolder(request: carriers.EMail_EmptyFolderRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("EmptyFolder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete all items in folder specified in the connection object
     * @param request - ConnectionInfo, MoveToFolder
     * @returns 
     */
    public async EmptyFolder(request: carriers.EMail_EmptyFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete all items in folder specified in the connection object
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param moveToFolder - If set, move deleted items to this folder
     * @returns 
     */
    public async EmptyFolder(connectionInfo: carriers.EMailConnectionInfo, moveToFolder: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async EmptyFolder(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_EmptyFolderRequest, moveToFolder?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_EmptyFolderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.MoveToFolder)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_EmptyFolderRequest;
            _options = moveToFolder as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       MoveToFolder: moveToFolder as string,
                       };   
            _options = webapi_options;
        }
        return this._EmptyFolder( _request, _options );
    }


    private async _GetEMailAsStream(request: carriers.EMail_GetEMailAsStreamRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailAsStream", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve an e-mail optionally stripping attachments as a stream
     * @param request - ConnectionInfo, MessageServerId, StripAttachments
     * @returns The attachment as a stream
     */
    public async GetEMailAsStream(request: carriers.EMail_GetEMailAsStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Retrieve an e-mail optionally stripping attachments as a stream
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param messageServerId - Unique ID for the e-mail to retrieve
     * @param stripAttachments - If true, do not include attachments in stream
     * @returns The attachment as a stream
     */
    public async GetEMailAsStream(connectionInfo: carriers.EMailConnectionInfo, messageServerId: number, stripAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetEMailAsStream(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_GetEMailAsStreamRequest, messageServerId?:number|base.WebApiRequestOptions, stripAttachments?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.EMail_GetEMailAsStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.MessageServerId)!='undefined' || typeof(first.StripAttachments)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_GetEMailAsStreamRequest;
            _options = messageServerId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       MessageServerId: messageServerId as number,
                       StripAttachments: stripAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetEMailAsStream( _request, _options );
    }


    private async _FindAddress(request: carriers.EMail_FindAddressRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAddress[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindAddress", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAddress[] = converters.Create_EMailAddressArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Search for contacts and persons with the specified e-mail address (exact match on the email address string required)
     * @param request - Address
     * @returns All resolved contacts/persons
     */
    public async FindAddress(request: carriers.EMail_FindAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;

    /**
     * Search for contacts and persons with the specified e-mail address (exact match on the email address string required)
     * @param address - E-mail address to look for
     * @returns All resolved contacts/persons
     */
    public async FindAddress(address: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;

    public async FindAddress(address:string|carriers.EMail_FindAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] > {
        let _request : carriers.EMail_FindAddressRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = address;
        if( typeof( first ) === "object" && first && ( typeof(first.Address)!='undefined' ) )
        {
            _request = address as carriers.EMail_FindAddressRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Address: address as string,
                       };   
            _options = webapi_options;
        }
        return this._FindAddress( _request, _options );
    }


    private async _GetEMailFromDocumentId(request: carriers.EMail_GetEMailFromDocumentIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromDocumentId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on an archived document
     * @param request - DocumentId
     * @returns The e-mail
     */
    public async GetEMailFromDocumentId(request: carriers.EMail_GetEMailFromDocumentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on an archived document
     * @param documentId - Unique id of the document
     * @returns The e-mail
     */
    public async GetEMailFromDocumentId(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetEMailFromDocumentId(documentId:number|carriers.EMail_GetEMailFromDocumentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetEMailFromDocumentIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.EMail_GetEMailFromDocumentIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetEMailFromDocumentId( _request, _options );
    }


    private async _GetUnsanitizedEMailFromDocumentId(request: carriers.EMail_GetUnsanitizedEMailFromDocumentIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMailFromDocumentId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on an archived document. The returned value is not sanitized.
     * @param request - DocumentId
     * @returns The e-mail
     */
    public async GetUnsanitizedEMailFromDocumentId(request: carriers.EMail_GetUnsanitizedEMailFromDocumentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on an archived document. The returned value is not sanitized.
     * @param documentId - Unique id of the document
     * @returns The e-mail
     */
    public async GetUnsanitizedEMailFromDocumentId(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetUnsanitizedEMailFromDocumentId(documentId:number|carriers.EMail_GetUnsanitizedEMailFromDocumentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetUnsanitizedEMailFromDocumentIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.EMail_GetUnsanitizedEMailFromDocumentIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMailFromDocumentId( _request, _options );
    }


    private async _GetEMailFromAttachmentId(request: carriers.EMail_GetEMailFromAttachmentIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromAttachmentId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on an email and attachment id
     * @param request - EmailId, AttachmentIds, IncludeAttachments
     * @returns The attachment as an e-mail
     */
    public async GetEMailFromAttachmentId(request: carriers.EMail_GetEMailFromAttachmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on an email and attachment id
     * @param emailId - The primary key of the email row in the DB
     * @param attachmentIds - Id of the attachment. If multiple elements this is treated as attachment in attachemnts, e.g. [1, 2] means attachment 2 in attachment 1 of email.
     * @param includeAttachments - Should we retrieve attachments embedded in the e-mail from the server
     * @returns The attachment as an e-mail
     */
    public async GetEMailFromAttachmentId(emailId: number, attachmentIds: string[], includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetEMailFromAttachmentId(emailId:number|carriers.EMail_GetEMailFromAttachmentIdRequest, attachmentIds?:string[]|base.WebApiRequestOptions, includeAttachments?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetEMailFromAttachmentIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailId;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailId)!='undefined' || typeof(first.AttachmentIds)!='undefined' || typeof(first.IncludeAttachments)!='undefined' ) )
        {
            _request = emailId as carriers.EMail_GetEMailFromAttachmentIdRequest;
            _options = attachmentIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailId: emailId as number,
                       AttachmentIds: attachmentIds as string[],
                       IncludeAttachments: includeAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetEMailFromAttachmentId( _request, _options );
    }


    private async _GetUnsanitizedEMailFromAttachmentId(request: carriers.EMail_GetUnsanitizedEMailFromAttachmentIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMailFromAttachmentId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on an email and attachment id. The returned value is not sanitized.
     * @param request - EmailId, AttachmentIds, IncludeAttachments
     * @returns The attachment as an e-mail
     */
    public async GetUnsanitizedEMailFromAttachmentId(request: carriers.EMail_GetUnsanitizedEMailFromAttachmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on an email and attachment id. The returned value is not sanitized.
     * @param emailId - The primary key of the email row in the DB
     * @param attachmentIds - Id of the attachment. If multiple elements this is treated as attachment in attachemnts, e.g. [1, 2] means attachment 2 in attachment 1 of email.
     * @param includeAttachments - Should we retrieve attachments embedded in the e-mail from the server
     * @returns The attachment as an e-mail
     */
    public async GetUnsanitizedEMailFromAttachmentId(emailId: number, attachmentIds: string[], includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetUnsanitizedEMailFromAttachmentId(emailId:number|carriers.EMail_GetUnsanitizedEMailFromAttachmentIdRequest, attachmentIds?:string[]|base.WebApiRequestOptions, includeAttachments?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetUnsanitizedEMailFromAttachmentIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailId;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailId)!='undefined' || typeof(first.AttachmentIds)!='undefined' || typeof(first.IncludeAttachments)!='undefined' ) )
        {
            _request = emailId as carriers.EMail_GetUnsanitizedEMailFromAttachmentIdRequest;
            _options = attachmentIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailId: emailId as number,
                       AttachmentIds: attachmentIds as string[],
                       IncludeAttachments: includeAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMailFromAttachmentId( _request, _options );
    }


    private async _GetEMailFromDocumentAttachmentId(request: carriers.EMail_GetEMailFromDocumentAttachmentIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromDocumentAttachmentId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on an email in the archive system and attachment id
     * @param request - DocId, AttachmentIds, IncludeAttachments
     * @returns The attachment as an e-mail
     */
    public async GetEMailFromDocumentAttachmentId(request: carriers.EMail_GetEMailFromDocumentAttachmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on an email in the archive system and attachment id
     * @param docId - The primary key of the document row in the DB
     * @param attachmentIds - Id of the attachment. If multiple elements this is treated as attachment in attachemnts, e.g. [1, 2] means attachment 2 in attachment 1 of email.
     * @param includeAttachments - Should we retrieve attachments embedded in the e-mail from the server
     * @returns The attachment as an e-mail
     */
    public async GetEMailFromDocumentAttachmentId(docId: number, attachmentIds: string[], includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetEMailFromDocumentAttachmentId(docId:number|carriers.EMail_GetEMailFromDocumentAttachmentIdRequest, attachmentIds?:string[]|base.WebApiRequestOptions, includeAttachments?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetEMailFromDocumentAttachmentIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = docId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocId)!='undefined' || typeof(first.AttachmentIds)!='undefined' || typeof(first.IncludeAttachments)!='undefined' ) )
        {
            _request = docId as carriers.EMail_GetEMailFromDocumentAttachmentIdRequest;
            _options = attachmentIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocId: docId as number,
                       AttachmentIds: attachmentIds as string[],
                       IncludeAttachments: includeAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetEMailFromDocumentAttachmentId( _request, _options );
    }


    private async _GetUnsanitizedEMailFromDocumentAttachmentId(request: carriers.EMail_GetUnsanitizedEMailFromDocumentAttachmentIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMailFromDocumentAttachmentId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on an email in the archive system and attachment id. The returned value is not sanitized.
     * @param request - DocId, AttachmentIds, IncludeAttachments
     * @returns The attachment as an e-mail
     */
    public async GetUnsanitizedEMailFromDocumentAttachmentId(request: carriers.EMail_GetUnsanitizedEMailFromDocumentAttachmentIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on an email in the archive system and attachment id. The returned value is not sanitized.
     * @param docId - The primary key of the document row in the DB
     * @param attachmentIds - Id of the attachment. If multiple elements this is treated as attachment in attachemnts, e.g. [1, 2] means attachment 2 in attachment 1 of email.
     * @param includeAttachments - Should we retrieve attachments embedded in the e-mail from the server
     * @returns The attachment as an e-mail
     */
    public async GetUnsanitizedEMailFromDocumentAttachmentId(docId: number, attachmentIds: string[], includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetUnsanitizedEMailFromDocumentAttachmentId(docId:number|carriers.EMail_GetUnsanitizedEMailFromDocumentAttachmentIdRequest, attachmentIds?:string[]|base.WebApiRequestOptions, includeAttachments?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetUnsanitizedEMailFromDocumentAttachmentIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = docId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocId)!='undefined' || typeof(first.AttachmentIds)!='undefined' || typeof(first.IncludeAttachments)!='undefined' ) )
        {
            _request = docId as carriers.EMail_GetUnsanitizedEMailFromDocumentAttachmentIdRequest;
            _options = attachmentIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocId: docId as number,
                       AttachmentIds: attachmentIds as string[],
                       IncludeAttachments: includeAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMailFromDocumentAttachmentId( _request, _options );
    }


    private async _GetEMailEnvelopes(request: carriers.EMail_GetEMailEnvelopesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEnvelope[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailEnvelopes", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEnvelope[] = converters.Create_EMailEnvelopeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve a set of e-mail envelopes
     * @param request - ConnectionInfo, MessageServerIds
     * @returns The e-mail envelope objects
     */
    public async GetEMailEnvelopes(request: carriers.EMail_GetEMailEnvelopesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] >;

    /**
     * Retrieve a set of e-mail envelopes
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param messageServerIds - Unique identitifiers for the e-mails to retrieve envelopes for
     * @returns The e-mail envelope objects
     */
    public async GetEMailEnvelopes(connectionInfo: carriers.EMailConnectionInfo, messageServerIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] >;

    public async GetEMailEnvelopes(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_GetEMailEnvelopesRequest, messageServerIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] > {
        let _request : carriers.EMail_GetEMailEnvelopesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.MessageServerIds)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_GetEMailEnvelopesRequest;
            _options = messageServerIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       MessageServerIds: messageServerIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetEMailEnvelopes( _request, _options );
    }


    private async _SetSubscription(request: carriers.EMail_SetSubscriptionRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetSubscription", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set subscription on or off on a set of folders
     * @param request - ConnectionInfo, Folders
     * @returns 
     */
    public async SetSubscription(request: carriers.EMail_SetSubscriptionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set subscription on or off on a set of folders
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param folders - Folders to set subscription value on
     * @returns 
     */
    public async SetSubscription(connectionInfo: carriers.EMailConnectionInfo, folders: carriers.EMailFolder[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetSubscription(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_SetSubscriptionRequest, folders?:carriers.EMailFolder[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_SetSubscriptionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.Folders)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_SetSubscriptionRequest;
            _options = folders as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       Folders: folders as carriers.EMailFolder[],
                       };   
            _options = webapi_options;
        }
        return this._SetSubscription( _request, _options );
    }


    private async _CreateFolder(request: carriers.EMail_CreateFolderRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateFolder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new folder on the server
     * @param request - ConnectionInfo
     * @returns 
     */
    public async CreateFolder(request: carriers.EMail_CreateFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Create a new folder on the server
     * @param connectionInfo - All information needed to connect to the mailserver
     * @returns 
     */
    public async CreateFolder(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async CreateFolder(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_CreateFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_CreateFolderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_CreateFolderRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._CreateFolder( _request, _options );
    }


    private async _DeleteFolder(request: carriers.EMail_DeleteFolderRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteFolder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a folder from the server
     * @param request - ConnectionInfo
     * @returns 
     */
    public async DeleteFolder(request: carriers.EMail_DeleteFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a folder from the server
     * @param connectionInfo - All information needed to connect to the mailserver
     * @returns 
     */
    public async DeleteFolder(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteFolder(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_DeleteFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_DeleteFolderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_DeleteFolderRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._DeleteFolder( _request, _options );
    }


    private async _CreateEMailFromDocumentEntity(request: carriers.EMail_CreateEMailFromDocumentEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateEMailFromDocumentEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on the provided DocumentEntity
     * @param request - DocumentEntity
     * @returns The e-mail
     */
    public async CreateEMailFromDocumentEntity(request: carriers.EMail_CreateEMailFromDocumentEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on the provided DocumentEntity
     * @param documentEntity - DocumentEntity data
     * @returns The e-mail
     */
    public async CreateEMailFromDocumentEntity(documentEntity: carriers.DocumentEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async CreateEMailFromDocumentEntity(documentEntity:carriers.DocumentEntity|carriers.EMail_CreateEMailFromDocumentEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_CreateEMailFromDocumentEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentEntity)!='undefined' ) )
        {
            _request = documentEntity as carriers.EMail_CreateEMailFromDocumentEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentEntity: documentEntity as carriers.DocumentEntity,
                       };   
            _options = webapi_options;
        }
        return this._CreateEMailFromDocumentEntity( _request, _options );
    }


    private async _CreateEMailFromMimeMessage(request: carriers.EMail_CreateEMailFromMimeMessageRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateEMailFromMimeMessage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on the provided MIME-message
     * @param request - MimeMessage
     * @returns The e-mail
     */
    public async CreateEMailFromMimeMessage(request: carriers.EMail_CreateEMailFromMimeMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on the provided MIME-message
     * @param mimeMessage - string representing a MIME-formatted message
     * @returns The e-mail
     */
    public async CreateEMailFromMimeMessage(mimeMessage: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async CreateEMailFromMimeMessage(mimeMessage:string|carriers.EMail_CreateEMailFromMimeMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_CreateEMailFromMimeMessageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mimeMessage;
        if( typeof( first ) === "object" && first && ( typeof(first.MimeMessage)!='undefined' ) )
        {
            _request = mimeMessage as carriers.EMail_CreateEMailFromMimeMessageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MimeMessage: mimeMessage as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateEMailFromMimeMessage( _request, _options );
    }


    private async _GetFolderInfo(request: carriers.EMail_GetFolderInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailFolder[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFolderInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailFolder[] = converters.Create_EMailFolderArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve information about folders.  If folders parameter is not specified(null), information about all subscribed folders will be returned.
     * @param request - ConnectionInfo, Folders
     * @returns Folder information
     */
    public async GetFolderInfo(request: carriers.EMail_GetFolderInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder[] >;

    /**
     * Retrieve information about folders.  If folders parameter is not specified(null), information about all subscribed folders will be returned.
     * @param connectionInfo - All information needed to connect to the mailserver
     * @param folders - Folders to get information about.
     * @returns Folder information
     */
    public async GetFolderInfo(connectionInfo: carriers.EMailConnectionInfo, folders: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder[] >;

    public async GetFolderInfo(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_GetFolderInfoRequest, folders?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder[] > {
        let _request : carriers.EMail_GetFolderInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.Folders)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_GetFolderInfoRequest;
            _options = folders as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       Folders: folders as string[],
                       };   
            _options = webapi_options;
        }
        return this._GetFolderInfo( _request, _options );
    }


    private async _GetFolderHasNewEMail(request: carriers.EMail_GetFolderHasNewEMailRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFolderHasNewEMail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check if folder has received new items since previous access.
     * @param request - ConnectionInfo
     * @returns True if new mail is available.
     */
    public async GetFolderHasNewEMail(request: carriers.EMail_GetFolderHasNewEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Check if folder has received new items since previous access.
     * @param connectionInfo - All information needed to connect to the mailserver
     * @returns True if new mail is available.
     */
    public async GetFolderHasNewEMail(connectionInfo: carriers.EMailConnectionInfo, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async GetFolderHasNewEMail(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_GetFolderHasNewEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.EMail_GetFolderHasNewEMailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_GetFolderHasNewEMailRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       };   
            _options = webapi_options;
        }
        return this._GetFolderHasNewEMail( _request, _options );
    }


    private async _GetEMailAddresses(request: carriers.EMail_GetEMailAddressesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAddress[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailAddresses", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAddress[] = converters.Create_EMailAddressArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get information about one or more email addresses, identified by IDs
     * @param request - EmailIds
     * @returns Array of email information objects
     */
    public async GetEMailAddresses(request: carriers.EMail_GetEMailAddressesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;

    /**
     * Get information about one or more email addresses, identified by IDs
     * @param emailIds - Array of IDs from the email table, each identifying one email address
     * @returns Array of email information objects
     */
    public async GetEMailAddresses(emailIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] >;

    public async GetEMailAddresses(emailIds:number[]|carriers.EMail_GetEMailAddressesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAddress[] > {
        let _request : carriers.EMail_GetEMailAddressesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailIds;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailIds)!='undefined' ) )
        {
            _request = emailIds as carriers.EMail_GetEMailAddressesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailIds: emailIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetEMailAddresses( _request, _options );
    }


    private async _RefreshFolder(request: carriers.EMail_RefreshFolderRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RefreshFolder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Refresh the given folders - i.e., fetch data from the mail server and update the in-database cache. This may happen synchronously or as a batch task, the return value will be 0 if the processing was synchronous, or the batch task id if a batch task is used.
     * @param request - ConnectionInfo, Folders
     * @returns Batch task id, or 0 if the processing was synchronous
     */
    public async RefreshFolder(request: carriers.EMail_RefreshFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Refresh the given folders - i.e., fetch data from the mail server and update the in-database cache. This may happen synchronously or as a batch task, the return value will be 0 if the processing was synchronous, or the batch task id if a batch task is used.
     * @param connectionInfo - Email connection info credentials
     * @param folders - List of folder names to refresh
     * @returns Batch task id, or 0 if the processing was synchronous
     */
    public async RefreshFolder(connectionInfo: carriers.EMailConnectionInfo, folders: string[], webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async RefreshFolder(connectionInfo:carriers.EMailConnectionInfo|carriers.EMail_RefreshFolderRequest, folders?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.EMail_RefreshFolderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfo)!='undefined' || typeof(first.Folders)!='undefined' ) )
        {
            _request = connectionInfo as carriers.EMail_RefreshFolderRequest;
            _options = folders as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfo: connectionInfo as carriers.EMailConnectionInfo,
                       Folders: folders as string[],
                       };   
            _options = webapi_options;
        }
        return this._RefreshFolder( _request, _options );
    }


    private async _GetEMailFromTemp(request: carriers.EMail_GetEMailFromTempRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromTemp", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - FileName
     * @returns 
     */
    public async GetEMailFromTemp(request: carriers.EMail_GetEMailFromTempRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * 
     * @param fileName - 
     * @returns 
     */
    public async GetEMailFromTemp(fileName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetEMailFromTemp(fileName:string|carriers.EMail_GetEMailFromTempRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetEMailFromTempRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = fileName;
        if( typeof( first ) === "object" && first && ( typeof(first.FileName)!='undefined' ) )
        {
            _request = fileName as carriers.EMail_GetEMailFromTempRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FileName: fileName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetEMailFromTemp( _request, _options );
    }


    private async _Authenticate(request: carriers.EMail_AuthenticateRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Authenticate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ConnectionInfoExtended
     * @returns 
     */
    public async Authenticate(request: carriers.EMail_AuthenticateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param connectionInfoExtended - 
     * @returns 
     */
    public async Authenticate(connectionInfoExtended: carriers.EMailConnectionInfoExtended, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async Authenticate(connectionInfoExtended:carriers.EMailConnectionInfoExtended|carriers.EMail_AuthenticateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.EMail_AuthenticateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfoExtended;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfoExtended)!='undefined' ) )
        {
            _request = connectionInfoExtended as carriers.EMail_AuthenticateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfoExtended: connectionInfoExtended as carriers.EMailConnectionInfoExtended,
                       };   
            _options = webapi_options;
        }
        return this._Authenticate( _request, _options );
    }


    private async _GetEmailMessageIds(request: carriers.EMail_GetEmailMessageIdsRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailMessageIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ConnectionInfoExtended
     * @returns 
     */
    public async GetEmailMessageIds(request: carriers.EMail_GetEmailMessageIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * 
     * @param connectionInfoExtended - 
     * @returns 
     */
    public async GetEmailMessageIds(connectionInfoExtended: carriers.EMailConnectionInfoExtended, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetEmailMessageIds(connectionInfoExtended:carriers.EMailConnectionInfoExtended|carriers.EMail_GetEmailMessageIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.EMail_GetEmailMessageIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfoExtended;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfoExtended)!='undefined' ) )
        {
            _request = connectionInfoExtended as carriers.EMail_GetEmailMessageIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfoExtended: connectionInfoExtended as carriers.EMailConnectionInfoExtended,
                       };   
            _options = webapi_options;
        }
        return this._GetEmailMessageIds( _request, _options );
    }


    private async _GetExtendedEmailMessageIds(request: carriers.EMail_GetExtendedEmailMessageIdsRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetExtendedEmailMessageIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets not only the Message-Id&apos;s but also the UID&apos;s and the uniquevalidity property in this format-&gt; uvalidity:uid:MsgId - and this format should be understood by GetEmailsAsString() and DeleteExtended().
     * @param request - ConnectionInfoExtended
     * @returns 
     */
    public async GetExtendedEmailMessageIds(request: carriers.EMail_GetExtendedEmailMessageIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Gets not only the Message-Id&apos;s but also the UID&apos;s and the uniquevalidity property in this format-&gt; uvalidity:uid:MsgId - and this format should be understood by GetEmailsAsString() and DeleteExtended().
     * @param connectionInfoExtended - 
     * @returns 
     */
    public async GetExtendedEmailMessageIds(connectionInfoExtended: carriers.EMailConnectionInfoExtended, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetExtendedEmailMessageIds(connectionInfoExtended:carriers.EMailConnectionInfoExtended|carriers.EMail_GetExtendedEmailMessageIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.EMail_GetExtendedEmailMessageIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfoExtended;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfoExtended)!='undefined' ) )
        {
            _request = connectionInfoExtended as carriers.EMail_GetExtendedEmailMessageIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfoExtended: connectionInfoExtended as carriers.EMailConnectionInfoExtended,
                       };   
            _options = webapi_options;
        }
        return this._GetExtendedEmailMessageIds( _request, _options );
    }


    private async _GetEmailsAsString(request: carriers.EMail_GetEmailsAsStringRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailsAsString", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ConnectionInfoExtended, MessageIds
     * @returns 
     */
    public async GetEmailsAsString(request: carriers.EMail_GetEmailsAsStringRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * 
     * @param connectionInfoExtended - 
     * @param messageIds - 
     * @returns 
     */
    public async GetEmailsAsString(connectionInfoExtended: carriers.EMailConnectionInfoExtended, messageIds: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async GetEmailsAsString(connectionInfoExtended:carriers.EMailConnectionInfoExtended|carriers.EMail_GetEmailsAsStringRequest, messageIds?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.EMail_GetEmailsAsStringRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfoExtended;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfoExtended)!='undefined' || typeof(first.MessageIds)!='undefined' ) )
        {
            _request = connectionInfoExtended as carriers.EMail_GetEmailsAsStringRequest;
            _options = messageIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfoExtended: connectionInfoExtended as carriers.EMailConnectionInfoExtended,
                       MessageIds: messageIds as string[],
                       };   
            _options = webapi_options;
        }
        return this._GetEmailsAsString( _request, _options );
    }


    private async _DeleteExtended(request: carriers.EMail_DeleteExtendedRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteExtended", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ConnectionInfoExtended, MessageIds
     * @returns 
     */
    public async DeleteExtended(request: carriers.EMail_DeleteExtendedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * 
     * @param connectionInfoExtended - 
     * @param messageIds - 
     * @returns 
     */
    public async DeleteExtended(connectionInfoExtended: carriers.EMailConnectionInfoExtended, messageIds: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteExtended(connectionInfoExtended:carriers.EMailConnectionInfoExtended|carriers.EMail_DeleteExtendedRequest, messageIds?:string[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_DeleteExtendedRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfoExtended;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfoExtended)!='undefined' || typeof(first.MessageIds)!='undefined' ) )
        {
            _request = connectionInfoExtended as carriers.EMail_DeleteExtendedRequest;
            _options = messageIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfoExtended: connectionInfoExtended as carriers.EMailConnectionInfoExtended,
                       MessageIds: messageIds as string[],
                       };   
            _options = webapi_options;
        }
        return this._DeleteExtended( _request, _options );
    }


    private async _RelayMessage(request: carriers.EMail_RelayMessageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RelayMessage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ConnectionInfoExtended, Rfc822, From, Recipients
     * @returns 
     */
    public async RelayMessage(request: carriers.EMail_RelayMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * 
     * @param connectionInfoExtended - 
     * @param rfc822 - 
     * @param from - 
     * @param recipients - 
     * @returns 
     */
    public async RelayMessage(connectionInfoExtended: carriers.EMailConnectionInfoExtended, rfc822: string, from: string, recipients: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RelayMessage(connectionInfoExtended:carriers.EMailConnectionInfoExtended|carriers.EMail_RelayMessageRequest, rfc822?:string|base.WebApiRequestOptions, from?:string, recipients?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_RelayMessageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = connectionInfoExtended;
        if( typeof( first ) === "object" && first && ( typeof(first.ConnectionInfoExtended)!='undefined' || typeof(first.Rfc822)!='undefined' || typeof(first.From)!='undefined' || typeof(first.Recipients)!='undefined' ) )
        {
            _request = connectionInfoExtended as carriers.EMail_RelayMessageRequest;
            _options = rfc822 as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ConnectionInfoExtended: connectionInfoExtended as carriers.EMailConnectionInfoExtended,
                       Rfc822: rfc822 as string,
                       From: from as string,
                       Recipients: recipients as string[],
                       };   
            _options = webapi_options;
        }
        return this._RelayMessage( _request, _options );
    }


    private async _GetEMail(request: carriers.EMail_GetEMailRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get en e-mail based on its primary key in the DB
     * @param request - Id, IncludeAttachments
     * @returns The e-mail
     */
    public async GetEMail(request: carriers.EMail_GetEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get en e-mail based on its primary key in the DB
     * @param id - The primary key of the email row in the DB
     * @param includeAttachments - Should we retrieve attachments embedded in the e-mail from the server
     * @returns The e-mail
     */
    public async GetEMail(id: number, includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetEMail(id:number|carriers.EMail_GetEMailRequest, includeAttachments?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetEMailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.IncludeAttachments)!='undefined' ) )
        {
            _request = id as carriers.EMail_GetEMailRequest;
            _options = includeAttachments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       IncludeAttachments: includeAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetEMail( _request, _options );
    }


    private async _GetUnsanitizedEMail(request: carriers.EMail_GetUnsanitizedEMailRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get en e-mail based on its primary key in the DB. The returned value is not sanitized.
     * @param request - Id, IncludeAttachments
     * @returns The e-mail
     */
    public async GetUnsanitizedEMail(request: carriers.EMail_GetUnsanitizedEMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get en e-mail based on its primary key in the DB. The returned value is not sanitized.
     * @param id - The primary key of the email row in the DB
     * @param includeAttachments - Should we retrieve attachments embedded in the e-mail from the server
     * @returns The e-mail
     */
    public async GetUnsanitizedEMail(id: number, includeAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetUnsanitizedEMail(id:number|carriers.EMail_GetUnsanitizedEMailRequest, includeAttachments?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetUnsanitizedEMailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.IncludeAttachments)!='undefined' ) )
        {
            _request = id as carriers.EMail_GetUnsanitizedEMailRequest;
            _options = includeAttachments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       IncludeAttachments: includeAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMail( _request, _options );
    }


    private async _MarkEmailsAsRead(request: carriers.EMail_MarkEmailsAsReadRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MarkEmailsAsRead", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Mark one or more e-mails as (un)read
     * @param request - Ids, Read
     * @returns 
     */
    public async MarkEmailsAsRead(request: carriers.EMail_MarkEmailsAsReadRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Mark one or more e-mails as (un)read
     * @param ids - The e-mails to handle
     * @param read - If true mails are marked as read. If false mails are marked as unread.
     * @returns 
     */
    public async MarkEmailsAsRead(ids: number[], read: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MarkEmailsAsRead(ids:number[]|carriers.EMail_MarkEmailsAsReadRequest, read?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_MarkEmailsAsReadRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ids;
        if( typeof( first ) === "object" && first && ( typeof(first.Ids)!='undefined' || typeof(first.Read)!='undefined' ) )
        {
            _request = ids as carriers.EMail_MarkEmailsAsReadRequest;
            _options = read as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Ids: ids as number[],
                       Read: read as boolean,
                       };   
            _options = webapi_options;
        }
        return this._MarkEmailsAsRead( _request, _options );
    }


    private async _DeleteEmails(request: carriers.EMail_DeleteEmailsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteEmails", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete specified mail items and optionally move to the specified folder
     * @param request - Ids, MoveToFolder
     * @returns 
     */
    public async DeleteEmails(request: carriers.EMail_DeleteEmailsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete specified mail items and optionally move to the specified folder
     * @param ids - The e-mails to handle
     * @param moveToFolder - If set, move deleted items to this folder
     * @returns 
     */
    public async DeleteEmails(ids: number[], moveToFolder: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteEmails(ids:number[]|carriers.EMail_DeleteEmailsRequest, moveToFolder?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_DeleteEmailsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ids;
        if( typeof( first ) === "object" && first && ( typeof(first.Ids)!='undefined' || typeof(first.MoveToFolder)!='undefined' ) )
        {
            _request = ids as carriers.EMail_DeleteEmailsRequest;
            _options = moveToFolder as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Ids: ids as number[],
                       MoveToFolder: moveToFolder as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteEmails( _request, _options );
    }


    private async _MoveEmailsToTrash(request: carriers.EMail_MoveEmailsToTrashRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveEmailsToTrash", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete specified mail items and move to the Trash folder
     * @param request - Ids
     * @returns 
     */
    public async MoveEmailsToTrash(request: carriers.EMail_MoveEmailsToTrashRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete specified mail items and move to the Trash folder
     * @param ids - The e-mails to handle
     * @returns 
     */
    public async MoveEmailsToTrash(ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MoveEmailsToTrash(ids:number[]|carriers.EMail_MoveEmailsToTrashRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_MoveEmailsToTrashRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ids;
        if( typeof( first ) === "object" && first && ( typeof(first.Ids)!='undefined' ) )
        {
            _request = ids as carriers.EMail_MoveEmailsToTrashRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Ids: ids as number[],
                       };   
            _options = webapi_options;
        }
        return this._MoveEmailsToTrash( _request, _options );
    }


    private async _Save(request: carriers.EMail_SaveRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Save", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save the e-mail back to the database
     * @param request - Email
     * @returns The updated saved entity
     */
    public async Save(request: carriers.EMail_SaveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Save the e-mail back to the database
     * @param email - The e-mail to save
     * @returns The updated saved entity
     */
    public async Save(email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async Save(email:carriers.EMailEntity|carriers.EMail_SaveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_SaveRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = email;
        if( typeof( first ) === "object" && first && ( typeof(first.Email)!='undefined' ) )
        {
            _request = email as carriers.EMail_SaveRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Email: email as carriers.EMailEntity,
                       };   
            _options = webapi_options;
        }
        return this._Save( _request, _options );
    }


    private async _SaveToMailServer(request: carriers.EMail_SaveToMailServerRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveToMailServer", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save the passed e-mail back to the mail server
     * @param request - Email
     * @returns The updated saved entity
     */
    public async SaveToMailServer(request: carriers.EMail_SaveToMailServerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Save the passed e-mail back to the mail server
     * @param email - The e-mail to save
     * @returns The updated saved entity
     */
    public async SaveToMailServer(email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async SaveToMailServer(email:carriers.EMailEntity|carriers.EMail_SaveToMailServerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_SaveToMailServerRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = email;
        if( typeof( first ) === "object" && first && ( typeof(first.Email)!='undefined' ) )
        {
            _request = email as carriers.EMail_SaveToMailServerRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Email: email as carriers.EMailEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveToMailServer( _request, _options );
    }


    private async _Send(request: carriers.EMail_SendRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Send", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity[] = converters.Create_EMailEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Send the provided e-mails
     * @param request - Emails
     * @returns The sent e-mails (updated with message id etc.)
     */
    public async Send(request: carriers.EMail_SendRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] >;

    /**
     * Send the provided e-mails
     * @param emails - The e-mails to send
     * @returns The sent e-mails (updated with message id etc.)
     */
    public async Send(emails: carriers.EMailEntity[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] >;

    public async Send(emails:carriers.EMailEntity[]|carriers.EMail_SendRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity[] > {
        let _request : carriers.EMail_SendRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emails;
        if( typeof( first ) === "object" && first && ( typeof(first.Emails)!='undefined' ) )
        {
            _request = emails as carriers.EMail_SendRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Emails: emails as carriers.EMailEntity[],
                       };   
            _options = webapi_options;
        }
        return this._Send( _request, _options );
    }


    private async _CreateForwardEmail(request: carriers.EMail_CreateForwardEmailRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateForwardEmail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create forward email
     * @param request - Email
     * @returns The new forward email entity
     */
    public async CreateForwardEmail(request: carriers.EMail_CreateForwardEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Create forward email
     * @param email - The e-mail to forward
     * @returns The new forward email entity
     */
    public async CreateForwardEmail(email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async CreateForwardEmail(email:carriers.EMailEntity|carriers.EMail_CreateForwardEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_CreateForwardEmailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = email;
        if( typeof( first ) === "object" && first && ( typeof(first.Email)!='undefined' ) )
        {
            _request = email as carriers.EMail_CreateForwardEmailRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Email: email as carriers.EMailEntity,
                       };   
            _options = webapi_options;
        }
        return this._CreateForwardEmail( _request, _options );
    }


    private async _FindContactOrPersonByEmailName(request: carriers.EMail_FindContactOrPersonByEmailNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactOrPersonFromEmail[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindContactOrPersonByEmailName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactOrPersonFromEmail[] = converters.Create_ContactOrPersonFromEmailArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - Name, EmailAddress
     * @returns Contacts and persons matching emailaddress and name
     */
    public async FindContactOrPersonByEmailName(request: carriers.EMail_FindContactOrPersonByEmailNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] >;

    /**
     * 
     * @param name - The sender name
     * @param emailAddress - The sender email address
     * @returns Contacts and persons matching emailaddress and name
     */
    public async FindContactOrPersonByEmailName(name: string, emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] >;

    public async FindContactOrPersonByEmailName(name:string|carriers.EMail_FindContactOrPersonByEmailNameRequest, emailAddress?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] > {
        let _request : carriers.EMail_FindContactOrPersonByEmailNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' || typeof(first.EmailAddress)!='undefined' ) )
        {
            _request = name as carriers.EMail_FindContactOrPersonByEmailNameRequest;
            _options = emailAddress as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       EmailAddress: emailAddress as string,
                       };   
            _options = webapi_options;
        }
        return this._FindContactOrPersonByEmailName( _request, _options );
    }


    private async _FindContactOrPersonByEmailNameWithLimit(request: carriers.EMail_FindContactOrPersonByEmailNameWithLimitRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactOrPersonFromEmail[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindContactOrPersonByEmailNameWithLimit", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactOrPersonFromEmail[] = converters.Create_ContactOrPersonFromEmailArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - Name, EmailAddress, NumberOfContacts, NumberOfPersons
     * @returns Contacts and persons matching emailaddress and name
     */
    public async FindContactOrPersonByEmailNameWithLimit(request: carriers.EMail_FindContactOrPersonByEmailNameWithLimitRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] >;

    /**
     * 
     * @param name - The sender name
     * @param emailAddress - The sender email address
     * @param numberOfContacts - Maximum returned number of contacts
     * @param numberOfPersons - Maximum returned number of persons
     * @returns Contacts and persons matching emailaddress and name
     */
    public async FindContactOrPersonByEmailNameWithLimit(name: string, emailAddress: string, numberOfContacts: number, numberOfPersons: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] >;

    public async FindContactOrPersonByEmailNameWithLimit(name:string|carriers.EMail_FindContactOrPersonByEmailNameWithLimitRequest, emailAddress?:string|base.WebApiRequestOptions, numberOfContacts?:number, numberOfPersons?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactOrPersonFromEmail[] > {
        let _request : carriers.EMail_FindContactOrPersonByEmailNameWithLimitRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' || typeof(first.EmailAddress)!='undefined' || typeof(first.NumberOfContacts)!='undefined' || typeof(first.NumberOfPersons)!='undefined' ) )
        {
            _request = name as carriers.EMail_FindContactOrPersonByEmailNameWithLimitRequest;
            _options = emailAddress as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       EmailAddress: emailAddress as string,
                       NumberOfContacts: numberOfContacts as number,
                       NumberOfPersons: numberOfPersons as number,
                       };   
            _options = webapi_options;
        }
        return this._FindContactOrPersonByEmailNameWithLimit( _request, _options );
    }


    private async _RefreshFolderForAssociate(request: carriers.EMail_RefreshFolderForAssociateRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RefreshFolderForAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all emails in folder(s) from current associate
     * @param request - Folders
     * @returns JSON serialized string containing array of data about each folder
     */
    public async RefreshFolderForAssociate(request: carriers.EMail_RefreshFolderForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get all emails in folder(s) from current associate
     * @param folders - List of folder names to refresh
     * @returns JSON serialized string containing array of data about each folder
     */
    public async RefreshFolderForAssociate(folders: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async RefreshFolderForAssociate(folders:string[]|carriers.EMail_RefreshFolderForAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.EMail_RefreshFolderForAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = folders;
        if( typeof( first ) === "object" && first && ( typeof(first.Folders)!='undefined' ) )
        {
            _request = folders as carriers.EMail_RefreshFolderForAssociateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Folders: folders as string[],
                       };   
            _options = webapi_options;
        }
        return this._RefreshFolderForAssociate( _request, _options );
    }


    private async _GetNewMail(request: carriers.EMail_GetNewMailRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEnvelope[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNewMail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEnvelope[] = converters.Create_EMailEnvelopeArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get new email in folder(s) for current associate
     * @param request - Folders
     * @returns The downloaded email envelopes
     */
    public async GetNewMail(request: carriers.EMail_GetNewMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] >;

    /**
     * Get new email in folder(s) for current associate
     * @param folders - List of folder ids to check for new email
     * @returns The downloaded email envelopes
     */
    public async GetNewMail(folders: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] >;

    public async GetNewMail(folders:number[]|carriers.EMail_GetNewMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEnvelope[] > {
        let _request : carriers.EMail_GetNewMailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = folders;
        if( typeof( first ) === "object" && first && ( typeof(first.Folders)!='undefined' ) )
        {
            _request = folders as carriers.EMail_GetNewMailRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Folders: folders as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetNewMail( _request, _options );
    }


    private async _CacheFolderList( options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailFolder[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CacheFolderList", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailFolder[] = converters.Create_EMailFolderArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Fetch list of folders from email server for the current account, and cache in DB
     * @returns List of folders from mail server
     */
    public async CacheFolderList(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailFolder[] >
    {
        return this._CacheFolderList(webapi_options);
    }


    private async _MoveEmailsToFolder(request: carriers.EMail_MoveEmailsToFolderRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveEmailsToFolder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Move one or more emails to the specified folder in the DB, and on the server
     * @param request - FolderId, EmailItemIds
     * @returns 
     */
    public async MoveEmailsToFolder(request: carriers.EMail_MoveEmailsToFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Move one or more emails to the specified folder in the DB, and on the server
     * @param folderId - The EmailFolderId of the folder to move to
     * @param emailItemIds - The emails to move
     * @returns 
     */
    public async MoveEmailsToFolder(folderId: number, emailItemIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async MoveEmailsToFolder(folderId:number|carriers.EMail_MoveEmailsToFolderRequest, emailItemIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_MoveEmailsToFolderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = folderId;
        if( typeof( first ) === "object" && first && ( typeof(first.FolderId)!='undefined' || typeof(first.EmailItemIds)!='undefined' ) )
        {
            _request = folderId as carriers.EMail_MoveEmailsToFolderRequest;
            _options = emailItemIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FolderId: folderId as number,
                       EmailItemIds: emailItemIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._MoveEmailsToFolder( _request, _options );
    }


    private async _GetMailFromMessageId(request: carriers.EMail_GetMailFromMessageIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMailFromMessageId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get email from db based on Message Id
     * @param request - MessageId
     * @returns EMailEntity with the provided message id
     */
    public async GetMailFromMessageId(request: carriers.EMail_GetMailFromMessageIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get email from db based on Message Id
     * @param messageId - The message id
     * @returns EMailEntity with the provided message id
     */
    public async GetMailFromMessageId(messageId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetMailFromMessageId(messageId:string|carriers.EMail_GetMailFromMessageIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetMailFromMessageIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = messageId;
        if( typeof( first ) === "object" && first && ( typeof(first.MessageId)!='undefined' ) )
        {
            _request = messageId as carriers.EMail_GetMailFromMessageIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MessageId: messageId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetMailFromMessageId( _request, _options );
    }


    private async _GetMailFromInReplyTo(request: carriers.EMail_GetMailFromInReplyToRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMailFromInReplyTo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get email from db based on In-Reply-To Message Id
     * @param request - MessageId
     * @returns EMailEntity that is in reply to the provided messageId
     */
    public async GetMailFromInReplyTo(request: carriers.EMail_GetMailFromInReplyToRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get email from db based on In-Reply-To Message Id
     * @param messageId - The message id
     * @returns EMailEntity that is in reply to the provided messageId
     */
    public async GetMailFromInReplyTo(messageId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetMailFromInReplyTo(messageId:string|carriers.EMail_GetMailFromInReplyToRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetMailFromInReplyToRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = messageId;
        if( typeof( first ) === "object" && first && ( typeof(first.MessageId)!='undefined' ) )
        {
            _request = messageId as carriers.EMail_GetMailFromInReplyToRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MessageId: messageId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetMailFromInReplyTo( _request, _options );
    }


    private async _SendAndSaveEmailToTmpDocument(request: carriers.EMail_SendAndSaveEmailToTmpDocumentRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendAndSaveEmailToTmpDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Send the provided e-mail and create tmp document ready to archive
     * @param request - Email, StripAttachments
     * @returns Filename of the tmp document
     */
    public async SendAndSaveEmailToTmpDocument(request: carriers.EMail_SendAndSaveEmailToTmpDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Send the provided e-mail and create tmp document ready to archive
     * @param email - The e-mail to send
     * @param stripAttachments - If true, do not include attachments in tmp document
     * @returns Filename of the tmp document
     */
    public async SendAndSaveEmailToTmpDocument(email: carriers.EMailEntity, stripAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SendAndSaveEmailToTmpDocument(email:carriers.EMailEntity|carriers.EMail_SendAndSaveEmailToTmpDocumentRequest, stripAttachments?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.EMail_SendAndSaveEmailToTmpDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = email;
        if( typeof( first ) === "object" && first && ( typeof(first.Email)!='undefined' || typeof(first.StripAttachments)!='undefined' ) )
        {
            _request = email as carriers.EMail_SendAndSaveEmailToTmpDocumentRequest;
            _options = stripAttachments as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Email: email as carriers.EMailEntity,
                       StripAttachments: stripAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SendAndSaveEmailToTmpDocument( _request, _options );
    }


    private async _SaveEmailToTmpDocument(request: carriers.EMail_SaveEmailToTmpDocumentRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveEmailToTmpDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save the Email as a tmp document ready to archive
     * @param request - Email, FolderId, StripAttachments
     * @returns Filename of the tmp document
     */
    public async SaveEmailToTmpDocument(request: carriers.EMail_SaveEmailToTmpDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Save the Email as a tmp document ready to archive
     * @param email - The e-mail to save
     * @param folderId - The folder id where the email is
     * @param stripAttachments - If true, do not include attachments in tmp document
     * @returns Filename of the tmp document
     */
    public async SaveEmailToTmpDocument(email: carriers.EMailEntity, folderId: number, stripAttachments: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SaveEmailToTmpDocument(email:carriers.EMailEntity|carriers.EMail_SaveEmailToTmpDocumentRequest, folderId?:number|base.WebApiRequestOptions, stripAttachments?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.EMail_SaveEmailToTmpDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = email;
        if( typeof( first ) === "object" && first && ( typeof(first.Email)!='undefined' || typeof(first.FolderId)!='undefined' || typeof(first.StripAttachments)!='undefined' ) )
        {
            _request = email as carriers.EMail_SaveEmailToTmpDocumentRequest;
            _options = folderId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Email: email as carriers.EMailEntity,
                       FolderId: folderId as number,
                       StripAttachments: stripAttachments as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SaveEmailToTmpDocument( _request, _options );
    }


    private async _SaveDraft(request: carriers.EMail_SaveDraftRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDraft", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save the Email entity to the drafts folder
     * @param request - Entity
     * @returns The saved e-mail entity
     */
    public async SaveDraft(request: carriers.EMail_SaveDraftRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Save the Email entity to the drafts folder
     * @param entity - The entity to save
     * @returns The saved e-mail entity
     */
    public async SaveDraft(entity: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async SaveDraft(entity:carriers.EMailEntity|carriers.EMail_SaveDraftRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_SaveDraftRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = entity;
        if( typeof( first ) === "object" && first && ( typeof(first.Entity)!='undefined' ) )
        {
            _request = entity as carriers.EMail_SaveDraftRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Entity: entity as carriers.EMailEntity,
                       };   
            _options = webapi_options;
        }
        return this._SaveDraft( _request, _options );
    }


    private async _SetRepliedAt(request: carriers.EMail_SetRepliedAtRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRepliedAt", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the replied_at field based on the MessageID
     * @param request - MessageId
     * @returns 
     */
    public async SetRepliedAt(request: carriers.EMail_SetRepliedAtRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the replied_at field based on the MessageID
     * @param messageId - The MessageID
     * @returns 
     */
    public async SetRepliedAt(messageId: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetRepliedAt(messageId:string|carriers.EMail_SetRepliedAtRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_SetRepliedAtRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = messageId;
        if( typeof( first ) === "object" && first && ( typeof(first.MessageId)!='undefined' ) )
        {
            _request = messageId as carriers.EMail_SetRepliedAtRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MessageId: messageId as string,
                       };   
            _options = webapi_options;
        }
        return this._SetRepliedAt( _request, _options );
    }


    private async _GetEMailFromDocumentIdWithoutAttachmentStream(request: carriers.EMail_GetEMailFromDocumentIdWithoutAttachmentStreamRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromDocumentIdWithoutAttachmentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on an archived document
     * @param request - DocumentId
     * @returns The e-mail
     */
    public async GetEMailFromDocumentIdWithoutAttachmentStream(request: carriers.EMail_GetEMailFromDocumentIdWithoutAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on an archived document
     * @param documentId - Unique id of the document
     * @returns The e-mail
     */
    public async GetEMailFromDocumentIdWithoutAttachmentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetEMailFromDocumentIdWithoutAttachmentStream(documentId:number|carriers.EMail_GetEMailFromDocumentIdWithoutAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetEMailFromDocumentIdWithoutAttachmentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.EMail_GetEMailFromDocumentIdWithoutAttachmentStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetEMailFromDocumentIdWithoutAttachmentStream( _request, _options );
    }


    private async _GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream(request: carriers.EMail_GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailEntity = converters.Create_EMailEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an e-mail based on an archived document. The returned value is not sanitized.
     * @param request - DocumentId
     * @returns The e-mail
     */
    public async GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream(request: carriers.EMail_GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    /**
     * Get an e-mail based on an archived document. The returned value is not sanitized.
     * @param documentId - Unique id of the document
     * @returns The e-mail
     */
    public async GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity >;

    public async GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream(documentId:number|carriers.EMail_GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailEntity > {
        let _request : carriers.EMail_GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.EMail_GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream( _request, _options );
    }


    private async _GetAttachmentFromId(request: carriers.EMail_GetAttachmentFromIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAttachment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachmentFromId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAttachment = converters.Create_EMailAttachment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve an attachment from an e-mail
     * @param request - MailItemId, AttachmentId
     * @returns The attachment
     */
    public async GetAttachmentFromId(request: carriers.EMail_GetAttachmentFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    /**
     * Retrieve an attachment from an e-mail
     * @param mailItemId - Unique ID for the e-mail to retrieve the attachment from
     * @param attachmentId - Id of the attachment in the e-mail
     * @returns The attachment
     */
    public async GetAttachmentFromId(mailItemId: number, attachmentId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    public async GetAttachmentFromId(mailItemId:number|carriers.EMail_GetAttachmentFromIdRequest, attachmentId?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        let _request : carriers.EMail_GetAttachmentFromIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mailItemId;
        if( typeof( first ) === "object" && first && ( typeof(first.MailItemId)!='undefined' || typeof(first.AttachmentId)!='undefined' ) )
        {
            _request = mailItemId as carriers.EMail_GetAttachmentFromIdRequest;
            _options = attachmentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MailItemId: mailItemId as number,
                       AttachmentId: attachmentId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAttachmentFromId( _request, _options );
    }


    private async _GetPreviewAttachmentFromId(request: carriers.EMail_GetPreviewAttachmentFromIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAttachment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewAttachmentFromId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAttachment = converters.Create_EMailAttachment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve an attachment from an e-mail. The returned data is intended to be use for a preview.
     * @param request - MailItemId, AttachmentId, AttachmentType, AttachmentFilename
     * @returns The attachment
     */
    public async GetPreviewAttachmentFromId(request: carriers.EMail_GetPreviewAttachmentFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    /**
     * Retrieve an attachment from an e-mail. The returned data is intended to be use for a preview.
     * @param mailItemId - Unique ID for the e-mail to retrieve the attachment from
     * @param attachmentId - Id of the attachment in the e-mail
     * @param attachmentType - Mimetype of the attachment. Must be set if attachmentId contains a chain.
     * @param attachmentFilename - Filename of the attachment. Must be set if attachmentId contains a chain.
     * @returns The attachment
     */
    public async GetPreviewAttachmentFromId(mailItemId: number, attachmentId: string, attachmentType: string, attachmentFilename: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    public async GetPreviewAttachmentFromId(mailItemId:number|carriers.EMail_GetPreviewAttachmentFromIdRequest, attachmentId?:string|base.WebApiRequestOptions, attachmentType?:string, attachmentFilename?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        let _request : carriers.EMail_GetPreviewAttachmentFromIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mailItemId;
        if( typeof( first ) === "object" && first && ( typeof(first.MailItemId)!='undefined' || typeof(first.AttachmentId)!='undefined' || typeof(first.AttachmentType)!='undefined' || typeof(first.AttachmentFilename)!='undefined' ) )
        {
            _request = mailItemId as carriers.EMail_GetPreviewAttachmentFromIdRequest;
            _options = attachmentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MailItemId: mailItemId as number,
                       AttachmentId: attachmentId as string,
                       AttachmentType: attachmentType as string,
                       AttachmentFilename: attachmentFilename as string,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviewAttachmentFromId( _request, _options );
    }


    private async _GetUnsanitizedPreviewAttachmentFromId(request: carriers.EMail_GetUnsanitizedPreviewAttachmentFromIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAttachment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedPreviewAttachmentFromId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAttachment = converters.Create_EMailAttachment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve an attachment from an e-mail. The returned data is intended to be use for a preview. The returned data is not sanitized.
     * @param request - MailItemId, AttachmentId, AttachmentType, AttachmentFilename
     * @returns The attachment
     */
    public async GetUnsanitizedPreviewAttachmentFromId(request: carriers.EMail_GetUnsanitizedPreviewAttachmentFromIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    /**
     * Retrieve an attachment from an e-mail. The returned data is intended to be use for a preview. The returned data is not sanitized.
     * @param mailItemId - Unique ID for the e-mail to retrieve the attachment from
     * @param attachmentId - Id of the attachment in the e-mail
     * @param attachmentType - Mimetype of the attachment. Must be set if attachmentId contains a chain.
     * @param attachmentFilename - Filename of the attachment. Must be set if attachmentId contains a chain.
     * @returns The attachment
     */
    public async GetUnsanitizedPreviewAttachmentFromId(mailItemId: number, attachmentId: string, attachmentType: string, attachmentFilename: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    public async GetUnsanitizedPreviewAttachmentFromId(mailItemId:number|carriers.EMail_GetUnsanitizedPreviewAttachmentFromIdRequest, attachmentId?:string|base.WebApiRequestOptions, attachmentType?:string, attachmentFilename?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        let _request : carriers.EMail_GetUnsanitizedPreviewAttachmentFromIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mailItemId;
        if( typeof( first ) === "object" && first && ( typeof(first.MailItemId)!='undefined' || typeof(first.AttachmentId)!='undefined' || typeof(first.AttachmentType)!='undefined' || typeof(first.AttachmentFilename)!='undefined' ) )
        {
            _request = mailItemId as carriers.EMail_GetUnsanitizedPreviewAttachmentFromIdRequest;
            _options = attachmentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MailItemId: mailItemId as number,
                       AttachmentId: attachmentId as string,
                       AttachmentType: attachmentType as string,
                       AttachmentFilename: attachmentFilename as string,
                       };   
            _options = webapi_options;
        }
        return this._GetUnsanitizedPreviewAttachmentFromId( _request, _options );
    }


    private async _GetPreviewAttachmentFromDocId(request: carriers.EMail_GetPreviewAttachmentFromDocIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAttachment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewAttachmentFromDocId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAttachment = converters.Create_EMailAttachment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve an attachment from an e-mail stored in the document archive. The returned data is intended to be use for a preview.
     * @param request - DocId, AttachmentId
     * @returns The attachment
     */
    public async GetPreviewAttachmentFromDocId(request: carriers.EMail_GetPreviewAttachmentFromDocIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    /**
     * Retrieve an attachment from an e-mail stored in the document archive. The returned data is intended to be use for a preview.
     * @param docId - Unique ID for the e-mail in the document archive to retrieve the attachment from
     * @param attachmentId - Id of the attachment in the e-mail
     * @returns The attachment
     */
    public async GetPreviewAttachmentFromDocId(docId: number, attachmentId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    public async GetPreviewAttachmentFromDocId(docId:number|carriers.EMail_GetPreviewAttachmentFromDocIdRequest, attachmentId?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        let _request : carriers.EMail_GetPreviewAttachmentFromDocIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = docId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocId)!='undefined' || typeof(first.AttachmentId)!='undefined' ) )
        {
            _request = docId as carriers.EMail_GetPreviewAttachmentFromDocIdRequest;
            _options = attachmentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocId: docId as number,
                       AttachmentId: attachmentId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviewAttachmentFromDocId( _request, _options );
    }


    private async _GetUnsanitizedPreviewAttachmentFromDocId(request: carriers.EMail_GetUnsanitizedPreviewAttachmentFromDocIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAttachment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedPreviewAttachmentFromDocId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAttachment = converters.Create_EMailAttachment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve an attachment from an e-mail stored in the document archive. The returned data is intended to be use for a preview. The returned data is not sanitized.
     * @param request - DocId, AttachmentId
     * @returns The attachment
     */
    public async GetUnsanitizedPreviewAttachmentFromDocId(request: carriers.EMail_GetUnsanitizedPreviewAttachmentFromDocIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    /**
     * Retrieve an attachment from an e-mail stored in the document archive. The returned data is intended to be use for a preview. The returned data is not sanitized.
     * @param docId - Unique ID for the e-mail in the document archive to retrieve the attachment from
     * @param attachmentId - Id of the attachment in the e-mail
     * @returns The attachment
     */
    public async GetUnsanitizedPreviewAttachmentFromDocId(docId: number, attachmentId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment >;

    public async GetUnsanitizedPreviewAttachmentFromDocId(docId:number|carriers.EMail_GetUnsanitizedPreviewAttachmentFromDocIdRequest, attachmentId?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAttachment > {
        let _request : carriers.EMail_GetUnsanitizedPreviewAttachmentFromDocIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = docId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocId)!='undefined' || typeof(first.AttachmentId)!='undefined' ) )
        {
            _request = docId as carriers.EMail_GetUnsanitizedPreviewAttachmentFromDocIdRequest;
            _options = attachmentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocId: docId as number,
                       AttachmentId: attachmentId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetUnsanitizedPreviewAttachmentFromDocId( _request, _options );
    }


    private async _TestAuthenticate( options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestAuthenticate", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Test if logged-in user has a working mail account 
     * @returns 
     */
    public async TestAuthenticate(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >
    {
        return this._TestAuthenticate(webapi_options);
    }


    private async _ToggleSubscription(request: carriers.EMail_ToggleSubscriptionRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleSubscription", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set subscription on or off on a set of folders
     * @param request - FolderId, SubscriptionStatus
     * @returns 
     */
    public async ToggleSubscription(request: carriers.EMail_ToggleSubscriptionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set subscription on or off on a set of folders
     * @param folderId - The folder id to set subscription value on
     * @param subscriptionStatus - The subscription status to set
     * @returns 
     */
    public async ToggleSubscription(folderId: number, subscriptionStatus: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ToggleSubscription(folderId:number|carriers.EMail_ToggleSubscriptionRequest, subscriptionStatus?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_ToggleSubscriptionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = folderId;
        if( typeof( first ) === "object" && first && ( typeof(first.FolderId)!='undefined' || typeof(first.SubscriptionStatus)!='undefined' ) )
        {
            _request = folderId as carriers.EMail_ToggleSubscriptionRequest;
            _options = subscriptionStatus as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FolderId: folderId as number,
                       SubscriptionStatus: subscriptionStatus as boolean,
                       };   
            _options = webapi_options;
        }
        return this._ToggleSubscription( _request, _options );
    }


    private async _HasNewMail(request: carriers.EMail_HasNewMailRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasNewMail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Fast check for new mail in the database
     * @param request - MailItemId, FolderId
     * @returns Has new mail if true
     */
    public async HasNewMail(request: carriers.EMail_HasNewMailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Fast check for new mail in the database
     * @param mailItemId - The last known mailitemid
     * @param folderId - The folderId for the folder to check for new mail
     * @returns Has new mail if true
     */
    public async HasNewMail(mailItemId: number, folderId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasNewMail(mailItemId:number|carriers.EMail_HasNewMailRequest, folderId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.EMail_HasNewMailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mailItemId;
        if( typeof( first ) === "object" && first && ( typeof(first.MailItemId)!='undefined' || typeof(first.FolderId)!='undefined' ) )
        {
            _request = mailItemId as carriers.EMail_HasNewMailRequest;
            _options = folderId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MailItemId: mailItemId as number,
                       FolderId: folderId as number,
                       };   
            _options = webapi_options;
        }
        return this._HasNewMail( _request, _options );
    }


    private async _LatestItemIdByFolder(request: carriers.EMail_LatestItemIdByFolderRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("LatestItemIdByFolder", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the latest id of the mail item by folder
     * @param request - FolderId
     * @returns Mail Item id
     */
    public async LatestItemIdByFolder(request: carriers.EMail_LatestItemIdByFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Returns the latest id of the mail item by folder
     * @param folderId - The folderId for the folder to check for the latest mail id
     * @returns Mail Item id
     */
    public async LatestItemIdByFolder(folderId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async LatestItemIdByFolder(folderId:number|carriers.EMail_LatestItemIdByFolderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.EMail_LatestItemIdByFolderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = folderId;
        if( typeof( first ) === "object" && first && ( typeof(first.FolderId)!='undefined' ) )
        {
            _request = folderId as carriers.EMail_LatestItemIdByFolderRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FolderId: folderId as number,
                       };   
            _options = webapi_options;
        }
        return this._LatestItemIdByFolder( _request, _options );
    }


    private async _CreateInlineHtmlHeader(request: carriers.EMail_CreateInlineHtmlHeaderRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateInlineHtmlHeader", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create Outlook style HTML header to use in for instance reply entities and when printing
     * @param request - Email
     * @returns The generated HTML header
     */
    public async CreateInlineHtmlHeader(request: carriers.EMail_CreateInlineHtmlHeaderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Create Outlook style HTML header to use in for instance reply entities and when printing
     * @param email - The e-mail to generate header based on
     * @returns The generated HTML header
     */
    public async CreateInlineHtmlHeader(email: carriers.EMailEntity, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async CreateInlineHtmlHeader(email:carriers.EMailEntity|carriers.EMail_CreateInlineHtmlHeaderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.EMail_CreateInlineHtmlHeaderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = email;
        if( typeof( first ) === "object" && first && ( typeof(first.Email)!='undefined' ) )
        {
            _request = email as carriers.EMail_CreateInlineHtmlHeaderRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Email: email as carriers.EMailEntity,
                       };   
            _options = webapi_options;
        }
        return this._CreateInlineHtmlHeader( _request, _options );
    }


    private async _GetEmailAppointment(request: carriers.EMail_GetEmailAppointmentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EMailAppointment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailAppointment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailAppointment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EMailAppointment = converters.Create_EMailAppointment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get appointment data contained in the emails iCal attachment
     * @param request - MailItemId
     * @returns Appointment data
     */
    public async GetEmailAppointment(request: carriers.EMail_GetEmailAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAppointment >;

    /**
     * Get appointment data contained in the emails iCal attachment
     * @param mailItemId - Id identifying the email
     * @returns Appointment data
     */
    public async GetEmailAppointment(mailItemId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAppointment >;

    public async GetEmailAppointment(mailItemId:number|carriers.EMail_GetEmailAppointmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EMailAppointment > {
        let _request : carriers.EMail_GetEmailAppointmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mailItemId;
        if( typeof( first ) === "object" && first && ( typeof(first.MailItemId)!='undefined' ) )
        {
            _request = mailItemId as carriers.EMail_GetEmailAppointmentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MailItemId: mailItemId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetEmailAppointment( _request, _options );
    }


    private async _GetEmailAppointmentRecurrence(request: carriers.EMail_GetEmailAppointmentRecurrenceRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RecurrenceInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailAppointmentRecurrence", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RecurrenceInfo = converters.Create_RecurrenceInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get recurrence data contained in the email iCal attachment
     * @param request - MailItemId
     * @returns Recurrence information
     */
    public async GetEmailAppointmentRecurrence(request: carriers.EMail_GetEmailAppointmentRecurrenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;

    /**
     * Get recurrence data contained in the email iCal attachment
     * @param mailItemId - Id identifying the email
     * @returns Recurrence information
     */
    public async GetEmailAppointmentRecurrence(mailItemId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo >;

    public async GetEmailAppointmentRecurrence(mailItemId:number|carriers.EMail_GetEmailAppointmentRecurrenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecurrenceInfo > {
        let _request : carriers.EMail_GetEmailAppointmentRecurrenceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mailItemId;
        if( typeof( first ) === "object" && first && ( typeof(first.MailItemId)!='undefined' ) )
        {
            _request = mailItemId as carriers.EMail_GetEmailAppointmentRecurrenceRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MailItemId: mailItemId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetEmailAppointmentRecurrence( _request, _options );
    }


    private async _GetParticipantInfoFromEmailAddress(request: carriers.EMail_GetParticipantInfoFromEmailAddressRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Person > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetParticipantInfoFromEmailAddress", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person = converters.Create_Person_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get participant data associated with the participant in the emails iCal attachment
     * @param request - EmailAddress, AppointmentId
     * @returns Person information
     */
    public async GetParticipantInfoFromEmailAddress(request: carriers.EMail_GetParticipantInfoFromEmailAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >;

    /**
     * Get participant data associated with the participant in the emails iCal attachment
     * @param emailAddress - Email address of participant
     * @param appointmentId - Appointment id of participant
     * @returns Person information
     */
    public async GetParticipantInfoFromEmailAddress(emailAddress: string, appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >;

    public async GetParticipantInfoFromEmailAddress(emailAddress:string|carriers.EMail_GetParticipantInfoFromEmailAddressRequest, appointmentId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person > {
        let _request : carriers.EMail_GetParticipantInfoFromEmailAddressRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailAddress;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailAddress)!='undefined' || typeof(first.AppointmentId)!='undefined' ) )
        {
            _request = emailAddress as carriers.EMail_GetParticipantInfoFromEmailAddressRequest;
            _options = appointmentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailAddress: emailAddress as string,
                       AppointmentId: appointmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetParticipantInfoFromEmailAddress( _request, _options );
    }


    private async _GetEmailDocumentAsMimeStream(request: carriers.EMail_GetEmailDocumentAsMimeStreamRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailDocumentAsMimeStream", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a particular document, and tries to parse it, and returns it in MIME/RFC822 format.
     * @param request - DocumentId
     * @returns A document-stream representing the document in MIME/RFC822 format.
     */
    public async GetEmailDocumentAsMimeStream(request: carriers.EMail_GetEmailDocumentAsMimeStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Gets a particular document, and tries to parse it, and returns it in MIME/RFC822 format.
     * @param documentId - SuperOffice document ID
     * @returns A document-stream representing the document in MIME/RFC822 format.
     */
    public async GetEmailDocumentAsMimeStream(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetEmailDocumentAsMimeStream(documentId:number|carriers.EMail_GetEmailDocumentAsMimeStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.EMail_GetEmailDocumentAsMimeStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.EMail_GetEmailDocumentAsMimeStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetEmailDocumentAsMimeStream( _request, _options );
    }

    /*
     * Gets a EMailSOInfo object.
     * @param eMailSOInfoId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single EMailSOInfo
     */
    public async GetEMailSOInfo(eMailSOInfoId: number, options?:base.WebApiRequestOptions) : Promise< carriers.EMailSOInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EMailSOInfo >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetEMailSOInfo?eMailSOInfoId=" + eMailSOInfoId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailSOInfo_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetReadySyncEmailAccounts( options?:base.WebApiRequestOptions) : Promise< carriers.SyncUserAccount[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SyncUserAccount[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetReadySyncEmailAccounts", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SyncUserAccount[] = converters.Create_SyncUserAccountArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets the list of SyncUserAccounts that should be synced.
     * @returns List of accounts to sync
     */
    public async GetReadySyncEmailAccounts(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SyncUserAccount[] >
    {
        return this._GetReadySyncEmailAccounts(webapi_options);
    }


    private async _SyncEmailAccount(request: carriers.EMail_SyncEmailAccountRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SyncEmailAccount", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sync the given account
     * @param request - SyncUserAccount
     * @returns A void return
     */
    public async SyncEmailAccount(request: carriers.EMail_SyncEmailAccountRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sync the given account
     * @param syncUserAccount - Account to sync
     * @returns A void return
     */
    public async SyncEmailAccount(syncUserAccount: carriers.SyncUserAccount, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SyncEmailAccount(syncUserAccount:carriers.SyncUserAccount|carriers.EMail_SyncEmailAccountRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_SyncEmailAccountRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = syncUserAccount;
        if( typeof( first ) === "object" && first && ( typeof(first.SyncUserAccount)!='undefined' ) )
        {
            _request = syncUserAccount as carriers.EMail_SyncEmailAccountRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SyncUserAccount: syncUserAccount as carriers.SyncUserAccount,
                       };   
            _options = webapi_options;
        }
        return this._SyncEmailAccount( _request, _options );
    }


    private async _SyncEmailAccounts(request: carriers.EMail_SyncEmailAccountsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SyncEmailAccounts", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Start syncing of the given accounts
     * @param request - SyncUserAccounts
     * @returns A void return
     */
    public async SyncEmailAccounts(request: carriers.EMail_SyncEmailAccountsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Start syncing of the given accounts
     * @param syncUserAccounts - Accounts to sync
     * @returns A void return
     */
    public async SyncEmailAccounts(syncUserAccounts: carriers.SyncUserAccount[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SyncEmailAccounts(syncUserAccounts:carriers.SyncUserAccount[]|carriers.EMail_SyncEmailAccountsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.EMail_SyncEmailAccountsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = syncUserAccounts;
        if( typeof( first ) === "object" && first && ( typeof(first.SyncUserAccounts)!='undefined' ) )
        {
            _request = syncUserAccounts as carriers.EMail_SyncEmailAccountsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SyncUserAccounts: syncUserAccounts as carriers.SyncUserAccount[],
                       };   
            _options = webapi_options;
        }
        return this._SyncEmailAccounts( _request, _options );
    }

    } // class v1EMailAgentController 



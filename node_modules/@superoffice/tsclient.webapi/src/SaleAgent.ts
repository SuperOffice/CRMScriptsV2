// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/SaleAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Sale data services
 */
export interface ISaleAgent {
    CreateDefaultSaleEntity(): Promise< carriers.SaleEntity >;
    SaveSaleEntity(entity: carriers.SaleEntity) : Promise< carriers.SaleEntity >;
    DeleteSaleEntity(SaleEntityId: number) : Promise<void>;
    CreateDefaultSaleStakeholder(): Promise< carriers.SaleStakeholder >;
    SaveSaleStakeholder(entity: carriers.SaleStakeholder) : Promise< carriers.SaleStakeholder >;
    DeleteSaleStakeholder(SaleStakeholderId: number) : Promise<void>;
    CreateDefaultSaleSummary(): Promise< carriers.SaleSummary >;
    GetSale(saleId: number) :  Promise< carriers.Sale >;
    GetSaleEntity(saleEntityId: number) :  Promise< carriers.SaleEntity >;
    HasGuide(request: carriers.Sale_HasGuideRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasGuide(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetNextDueDate(request: carriers.Sale_GetNextDueDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< Date >;
    GetNextDueDate(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< Date >;
    BatchUpdateNextDueDate(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetNextSaleStage(request: carriers.Sale_GetNextSaleStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetNextSaleStage(saleId: number, includeCurrentStage: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    HasGuideActivities(request: carriers.Sale_HasGuideActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasGuideActivities(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    OfferAutoNextStageOnApppointmentCompleted(request: carriers.Sale_OfferAutoNextStageOnApppointmentCompletedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    OfferAutoNextStageOnApppointmentCompleted(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetProbabilityFromStage(request: carriers.Sale_GetProbabilityFromStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetProbabilityFromStage(stageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    IsNumberValid(request: carriers.Sale_IsNumberValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsNumberValid(contactId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    AddSaleStakeholders(request: carriers.Sale_AddSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddSaleStakeholders(saleId: number, saleStakeholders: carriers.SaleStakeholder[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteSaleStakeholders(request: carriers.Sale_DeleteSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteSaleStakeholders(saleStakeholderIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    HasStakeholderSetting(request: carriers.Sale_HasStakeholderSettingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasStakeholderSetting(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ValidateSaleEntity(request: carriers.Sale_ValidateSaleEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    ValidateSaleEntity(saleEntity: carriers.SaleEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetSaleList(saleIds: number[]) :  Promise< carriers.Sale[] >;
    GetMyOpportunities(request: carriers.Sale_GetMyOpportunitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetMyOpportunities(count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetRecentSales(request: carriers.Sale_GetRecentSalesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetRecentSales(amountLimit: number, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetUpcomingSales(request: carriers.Sale_GetUpcomingSalesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetUpcomingSales(weightedAmountLimit: number, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetSalesByDate(request: carriers.Sale_GetSalesByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetSalesByDate(fromDate: Date, toDate: Date, amountLimit: number, status: enums.SaleStatus, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetOpenSalesForContact(request: carriers.Sale_GetOpenSalesForContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetOpenSalesForContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    SetAsSold(request: carriers.Sale_SetAsSoldRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetAsSold(saleIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetAsLost(request: carriers.Sale_SetAsLostRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetAsLost(saleIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetSalesFromContact(request: carriers.Sale_GetSalesFromContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetSalesFromContact(contactId: number, onlyOpenSales: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetSalesFromPerson(request: carriers.Sale_GetSalesFromPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetSalesFromPerson(personId: number, onlyOpenSales: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;
    GetSaleStakeholder(saleStakeholderId: number) :  Promise< carriers.SaleStakeholder >;
    GetSaleStakeholderList(saleStakeholderIds: number[]) :  Promise< carriers.SaleStakeholder[] >;
    GetSaleStakeholders(request: carriers.Sale_GetSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;
    GetSaleStakeholders(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;
    UpdateSaleStakeholders(request: carriers.Sale_UpdateSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;
    UpdateSaleStakeholders(stakeholders: carriers.SaleStakeholder[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;
    GetSaleStakeholderById(request: carriers.Sale_GetSaleStakeholderByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;
    GetSaleStakeholderById(saleStakeholderIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;
    GetSummaryByAssociate(request: carriers.Sale_GetSummaryByAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;
    GetSummaryByAssociate(associateId: number, fromDate: Date, toDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;
    GetSummaryByGroup(request: carriers.Sale_GetSummaryByGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;
    GetSummaryByGroup(groupId: number, fromDate: Date, toDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;
    GetSummaryByContact(request: carriers.Sale_GetSummaryByContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;
    GetSummaryByContact(contactId: number, fromDate: Date, toDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;
} // interface ISaleAgent




/**
 * Sale data services
 */
export class SaleAgent extends base.WebApiBase implements ISaleAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Sale/";
        super(options);
    }



    /**
     * Set default values into a new SaleEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSaleEntity(options?:base.WebApiRequestOptions) : Promise< carriers.SaleEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleEntity = converters.Create_SaleEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SaleEntity or creates a new SaleEntity if the id parameter is empty
     * @param entity - The SaleEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SaleEntity
     */
    public async SaveSaleEntity(entity: carriers.SaleEntity, options?:base.WebApiRequestOptions) : Promise< carriers.SaleEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSaleEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleEntity = converters.Create_SaleEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the SaleEntity
     * @param SaleEntityId - The id of the SaleEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteSaleEntity(SaleEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteSaleEntity?SaleEntityId=" + SaleEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new SaleStakeholder.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSaleStakeholder(options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStakeholder >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleStakeholder", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleStakeholder = converters.Create_SaleStakeholder_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SaleStakeholder or creates a new SaleStakeholder if the id parameter is empty
     * @param entity - The SaleStakeholder to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SaleStakeholder
     */
    public async SaveSaleStakeholder(entity: carriers.SaleStakeholder, options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStakeholder >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSaleStakeholder", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleStakeholder = converters.Create_SaleStakeholder_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the SaleStakeholder
     * @param SaleStakeholderId - The id of the SaleStakeholder to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteSaleStakeholder(SaleStakeholderId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteSaleStakeholder?SaleStakeholderId=" + SaleStakeholderId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new SaleSummary.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSaleSummary(options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleSummary >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleSummary", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleSummary = converters.Create_SaleSummary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Sale object.
     * @param saleId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Sale
     */
    public async GetSale(saleId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Sale > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sale >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSale?saleId=" + saleId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Sale_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a SaleEntity object.
     * @param saleEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleEntity
     */
    public async GetSaleEntity(saleEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SaleEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleEntity?saleEntityId=" + saleEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _HasGuide(request: carriers.Sale_HasGuideRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasGuide", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Does this sale have a sale guide associated with its sale type?
     * @param request - SaleId
     * @returns True if the sale has a guide
     */
    public async HasGuide(request: carriers.Sale_HasGuideRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Does this sale have a sale guide associated with its sale type?
     * @param saleId - Sale id
     * @returns True if the sale has a guide
     */
    public async HasGuide(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasGuide(saleId:number|carriers.Sale_HasGuideRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Sale_HasGuideRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' ) )
        {
            _request = saleId as carriers.Sale_HasGuideRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       };   
            _options = webapi_options;
        }
        return this._HasGuide( _request, _options );
    }


    private async _GetNextDueDate(request: carriers.Sale_GetNextDueDateRequest, options?:base.WebApiRequestOptions) : Promise< Date > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< Date >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextDueDate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : Date = response.data as Date;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the next due date for a sale. The next due date is the next future appointment that is not completed.
     * @param request - SaleId
     * @returns Next due date for the given sale.
     */
    public async GetNextDueDate(request: carriers.Sale_GetNextDueDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< Date >;

    /**
     * Gets the next due date for a sale. The next due date is the next future appointment that is not completed.
     * @param saleId - Sale id
     * @returns Next due date for the given sale.
     */
    public async GetNextDueDate(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< Date >;

    public async GetNextDueDate(saleId:number|carriers.Sale_GetNextDueDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< Date > {
        let _request : carriers.Sale_GetNextDueDateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' ) )
        {
            _request = saleId as carriers.Sale_GetNextDueDateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetNextDueDate( _request, _options );
    }


    private async _BatchUpdateNextDueDate( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("BatchUpdateNextDueDate", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Re-calculate all the next due dates
     * @returns 
     */
    public async BatchUpdateNextDueDate(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._BatchUpdateNextDueDate(webapi_options);
    }


    private async _GetNextSaleStage(request: carriers.Sale_GetNextSaleStageRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextSaleStage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the next (not deleted) sale stage id if the current stage is deleted. If the current stage is not deleted, the CurrentStageId is returned
     * @param request - SaleId, IncludeCurrentStage
     * @returns 
     */
    public async GetNextSaleStage(request: carriers.Sale_GetNextSaleStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Gets the next (not deleted) sale stage id if the current stage is deleted. If the current stage is not deleted, the CurrentStageId is returned
     * @param saleId - 
     * @param includeCurrentStage - 
     * @returns 
     */
    public async GetNextSaleStage(saleId: number, includeCurrentStage: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async GetNextSaleStage(saleId:number|carriers.Sale_GetNextSaleStageRequest, includeCurrentStage?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Sale_GetNextSaleStageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' || typeof(first.IncludeCurrentStage)!='undefined' ) )
        {
            _request = saleId as carriers.Sale_GetNextSaleStageRequest;
            _options = includeCurrentStage as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       IncludeCurrentStage: includeCurrentStage as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetNextSaleStage( _request, _options );
    }


    private async _HasGuideActivities(request: carriers.Sale_HasGuideActivitiesRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasGuideActivities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - SaleId
     * @returns 
     */
    public async HasGuideActivities(request: carriers.Sale_HasGuideActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param saleId - 
     * @returns 
     */
    public async HasGuideActivities(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasGuideActivities(saleId:number|carriers.Sale_HasGuideActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Sale_HasGuideActivitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' ) )
        {
            _request = saleId as carriers.Sale_HasGuideActivitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       };   
            _options = webapi_options;
        }
        return this._HasGuideActivities( _request, _options );
    }


    private async _OfferAutoNextStageOnApppointmentCompleted(request: carriers.Sale_OfferAutoNextStageOnApppointmentCompletedRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("OfferAutoNextStageOnApppointmentCompleted", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AppointmentId
     * @returns 
     */
    public async OfferAutoNextStageOnApppointmentCompleted(request: carriers.Sale_OfferAutoNextStageOnApppointmentCompletedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param appointmentId - 
     * @returns 
     */
    public async OfferAutoNextStageOnApppointmentCompleted(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async OfferAutoNextStageOnApppointmentCompleted(appointmentId:number|carriers.Sale_OfferAutoNextStageOnApppointmentCompletedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Sale_OfferAutoNextStageOnApppointmentCompletedRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' ) )
        {
            _request = appointmentId as carriers.Sale_OfferAutoNextStageOnApppointmentCompletedRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._OfferAutoNextStageOnApppointmentCompleted( _request, _options );
    }


    private async _GetProbabilityFromStage(request: carriers.Sale_GetProbabilityFromStageRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProbabilityFromStage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the probability percentage for a given sale stage
     * @param request - StageId
     * @returns Probability percentage
     */
    public async GetProbabilityFromStage(request: carriers.Sale_GetProbabilityFromStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Get the probability percentage for a given sale stage
     * @param stageId - Probability list id
     * @returns Probability percentage
     */
    public async GetProbabilityFromStage(stageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async GetProbabilityFromStage(stageId:number|carriers.Sale_GetProbabilityFromStageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Sale_GetProbabilityFromStageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = stageId;
        if( typeof( first ) === "object" && first && ( typeof(first.StageId)!='undefined' ) )
        {
            _request = stageId as carriers.Sale_GetProbabilityFromStageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StageId: stageId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProbabilityFromStage( _request, _options );
    }


    private async _IsNumberValid(request: carriers.Sale_IsNumberValidRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNumberValid", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Checks if the number is unique or required.  The setting is configured from admin under system options.
     * @param request - ContactId, Number
     * @returns True if the number is valid
     */
    public async IsNumberValid(request: carriers.Sale_IsNumberValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Checks if the number is unique or required.  The setting is configured from admin under system options.
     * @param contactId - SaleId
     * @param number - Number value to check for uniqueness/required
     * @returns True if the number is valid
     */
    public async IsNumberValid(contactId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async IsNumberValid(contactId:number|carriers.Sale_IsNumberValidRequest, number?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Sale_IsNumberValidRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.Number)!='undefined' ) )
        {
            _request = contactId as carriers.Sale_IsNumberValidRequest;
            _options = number as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       Number: number as string,
                       };   
            _options = webapi_options;
        }
        return this._IsNumberValid( _request, _options );
    }


    private async _AddSaleStakeholders(request: carriers.Sale_AddSaleStakeholdersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddSaleStakeholders", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - SaleId, SaleStakeholders
     * @returns 
     */
    public async AddSaleStakeholders(request: carriers.Sale_AddSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * 
     * @param saleId - 
     * @param saleStakeholders - 
     * @returns 
     */
    public async AddSaleStakeholders(saleId: number, saleStakeholders: carriers.SaleStakeholder[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddSaleStakeholders(saleId:number|carriers.Sale_AddSaleStakeholdersRequest, saleStakeholders?:carriers.SaleStakeholder[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Sale_AddSaleStakeholdersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' || typeof(first.SaleStakeholders)!='undefined' ) )
        {
            _request = saleId as carriers.Sale_AddSaleStakeholdersRequest;
            _options = saleStakeholders as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       SaleStakeholders: saleStakeholders as carriers.SaleStakeholder[],
                       };   
            _options = webapi_options;
        }
        return this._AddSaleStakeholders( _request, _options );
    }


    private async _DeleteSaleStakeholders(request: carriers.Sale_DeleteSaleStakeholdersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteSaleStakeholders", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - SaleStakeholderIds
     * @returns 
     */
    public async DeleteSaleStakeholders(request: carriers.Sale_DeleteSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * 
     * @param saleStakeholderIds - 
     * @returns 
     */
    public async DeleteSaleStakeholders(saleStakeholderIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteSaleStakeholders(saleStakeholderIds:number[]|carriers.Sale_DeleteSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Sale_DeleteSaleStakeholdersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleStakeholderIds;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleStakeholderIds)!='undefined' ) )
        {
            _request = saleStakeholderIds as carriers.Sale_DeleteSaleStakeholdersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleStakeholderIds: saleStakeholderIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeleteSaleStakeholders( _request, _options );
    }


    private async _HasStakeholderSetting(request: carriers.Sale_HasStakeholderSettingRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasStakeholderSetting", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - SaleId
     * @returns 
     */
    public async HasStakeholderSetting(request: carriers.Sale_HasStakeholderSettingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param saleId - 
     * @returns 
     */
    public async HasStakeholderSetting(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasStakeholderSetting(saleId:number|carriers.Sale_HasStakeholderSettingRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Sale_HasStakeholderSettingRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' ) )
        {
            _request = saleId as carriers.Sale_HasStakeholderSettingRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       };   
            _options = webapi_options;
        }
        return this._HasStakeholderSetting( _request, _options );
    }


    private async _ValidateSaleEntity(request: carriers.Sale_ValidateSaleEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateSaleEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param request - SaleEntity
     * @returns Error messages tagged by field.
     */
    public async ValidateSaleEntity(request: carriers.Sale_ValidateSaleEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param saleEntity - Entity to be checked for errors.
     * @returns Error messages tagged by field.
     */
    public async ValidateSaleEntity(saleEntity: carriers.SaleEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async ValidateSaleEntity(saleEntity:carriers.SaleEntity|carriers.Sale_ValidateSaleEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Sale_ValidateSaleEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleEntity)!='undefined' ) )
        {
            _request = saleEntity as carriers.Sale_ValidateSaleEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleEntity: saleEntity as carriers.SaleEntity,
                       };   
            _options = webapi_options;
        }
        return this._ValidateSaleEntity( _request, _options );
    }

    /*
     * Gets an array of Sale objects.
     * @param saleIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Sale
     */
    public async GetSaleList(saleIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sale[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleList", saleIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetMyOpportunities(request: carriers.Sale_GetMyOpportunitiesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sale[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyOpportunities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Sale[] = converters.Create_SaleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returning the opportunities (open sales) belonging to the user currently logged on
     * @param request - Count
     * @returns Array of open sales (opportunities).
     */
    public async GetMyOpportunities(request: carriers.Sale_GetMyOpportunitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    /**
     * Returning the opportunities (open sales) belonging to the user currently logged on
     * @param count - The number of sales that is returned. -1 returns all.
     * @returns Array of open sales (opportunities).
     */
    public async GetMyOpportunities(count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    public async GetMyOpportunities(count:number|carriers.Sale_GetMyOpportunitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        let _request : carriers.Sale_GetMyOpportunitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = count;
        if( typeof( first ) === "object" && first && ( typeof(first.Count)!='undefined' ) )
        {
            _request = count as carriers.Sale_GetMyOpportunitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetMyOpportunities( _request, _options );
    }


    private async _GetRecentSales(request: carriers.Sale_GetRecentSalesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sale[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecentSales", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Sale[] = converters.Create_SaleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the latest sales (that are sold) limited by their amount. The result is sorted descending with the latest first. If the amount is -1, the amount restriction is omitted.
     * @param request - AmountLimit, Count
     * @returns Array of all recent sales.
     */
    public async GetRecentSales(request: carriers.Sale_GetRecentSalesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    /**
     * Returns the latest sales (that are sold) limited by their amount. The result is sorted descending with the latest first. If the amount is -1, the amount restriction is omitted.
     * @param amountLimit - The amount limit in the local currency.
     * @param count - The maximum number of items to return. If -1 all are returned.
     * @returns Array of all recent sales.
     */
    public async GetRecentSales(amountLimit: number, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    public async GetRecentSales(amountLimit:number|carriers.Sale_GetRecentSalesRequest, count?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        let _request : carriers.Sale_GetRecentSalesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = amountLimit;
        if( typeof( first ) === "object" && first && ( typeof(first.AmountLimit)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = amountLimit as carriers.Sale_GetRecentSalesRequest;
            _options = count as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AmountLimit: amountLimit as number,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetRecentSales( _request, _options );
    }


    private async _GetUpcomingSales(request: carriers.Sale_GetUpcomingSalesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sale[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUpcomingSales", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Sale[] = converters.Create_SaleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all open sales, sorted descending with the latest first.  If the weigthed amount is -1, the amount restriction is omitted.
     * @param request - WeightedAmountLimit, Count
     * @returns Array of upcoming sales.
     */
    public async GetUpcomingSales(request: carriers.Sale_GetUpcomingSalesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    /**
     * Returns all open sales, sorted descending with the latest first.  If the weigthed amount is -1, the amount restriction is omitted.
     * @param weightedAmountLimit - The amount weighted by the probability that the sale is closed (amount * probability).
     * @param count - The maximum number of items to return. If -1 all are returned.
     * @returns Array of upcoming sales.
     */
    public async GetUpcomingSales(weightedAmountLimit: number, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    public async GetUpcomingSales(weightedAmountLimit:number|carriers.Sale_GetUpcomingSalesRequest, count?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        let _request : carriers.Sale_GetUpcomingSalesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = weightedAmountLimit;
        if( typeof( first ) === "object" && first && ( typeof(first.WeightedAmountLimit)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = weightedAmountLimit as carriers.Sale_GetUpcomingSalesRequest;
            _options = count as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       WeightedAmountLimit: weightedAmountLimit as number,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetUpcomingSales( _request, _options );
    }


    private async _GetSalesByDate(request: carriers.Sale_GetSalesByDateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sale[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSalesByDate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Sale[] = converters.Create_SaleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all sales within a time period. The sales array can be limited by amount and status.
     * @param request - FromDate, ToDate, AmountLimit, Status
     * @returns Array of sales.
     */
    public async GetSalesByDate(request: carriers.Sale_GetSalesByDateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    /**
     * Returns all sales within a time period. The sales array can be limited by amount and status.
     * @param fromDate - The beginning of the time interval.
     * @param toDate - The end of the time interval.
     * @param amountLimit - The amount limit in the local currency.  -1 means no amount limit
     * @param status - The sale status (Lost, Open, Sold, Unknown). SaleStatus.Unknown means no status filtering.
     * @returns Array of sales.
     */
    public async GetSalesByDate(fromDate: Date, toDate: Date, amountLimit: number, status: enums.SaleStatus, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    public async GetSalesByDate(fromDate:Date|carriers.Sale_GetSalesByDateRequest, toDate?:Date|base.WebApiRequestOptions, amountLimit?:number, status?:enums.SaleStatus, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        let _request : carriers.Sale_GetSalesByDateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = fromDate;
        if( typeof( first ) === "object" && first && ( typeof(first.FromDate)!='undefined' || typeof(first.ToDate)!='undefined' || typeof(first.AmountLimit)!='undefined' || typeof(first.Status)!='undefined' ) )
        {
            _request = fromDate as carriers.Sale_GetSalesByDateRequest;
            _options = toDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FromDate: fromDate as Date,
                       ToDate: toDate as Date,
                       AmountLimit: amountLimit as number,
                       Status: status as enums.SaleStatus,
                       };   
            _options = webapi_options;
        }
        return this._GetSalesByDate( _request, _options );
    }


    private async _GetOpenSalesForContact(request: carriers.Sale_GetOpenSalesForContactRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sale[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOpenSalesForContact", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Sale[] = converters.Create_SaleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all open sales for the contact provided.
     * @param request - ContactId
     * @returns Aray of sales.
     */
    public async GetOpenSalesForContact(request: carriers.Sale_GetOpenSalesForContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    /**
     * Returns all open sales for the contact provided.
     * @param contactId - The ID of the contact whose sales we want.
     * @returns Aray of sales.
     */
    public async GetOpenSalesForContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    public async GetOpenSalesForContact(contactId:number|carriers.Sale_GetOpenSalesForContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        let _request : carriers.Sale_GetOpenSalesForContactRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.Sale_GetOpenSalesForContactRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetOpenSalesForContact( _request, _options );
    }


    private async _SetAsSold(request: carriers.Sale_SetAsSoldRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetAsSold", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change the status of one or more Sales to Sold. Note that this does not mark them as Completed.
     * @param request - SaleIds
     * @returns 
     */
    public async SetAsSold(request: carriers.Sale_SetAsSoldRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Change the status of one or more Sales to Sold. Note that this does not mark them as Completed.
     * @param saleIds - Array of sale ids to be marked as lost. All the normal write access rules apply.
     * @returns 
     */
    public async SetAsSold(saleIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetAsSold(saleIds:number[]|carriers.Sale_SetAsSoldRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Sale_SetAsSoldRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleIds;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleIds)!='undefined' ) )
        {
            _request = saleIds as carriers.Sale_SetAsSoldRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleIds: saleIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetAsSold( _request, _options );
    }


    private async _SetAsLost(request: carriers.Sale_SetAsLostRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetAsLost", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change the status of one or more sales to Lost. Note that this does not affect the Completed state of the sale.
     * @param request - SaleIds
     * @returns 
     */
    public async SetAsLost(request: carriers.Sale_SetAsLostRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Change the status of one or more sales to Lost. Note that this does not affect the Completed state of the sale.
     * @param saleIds - Array of sale ids to be marked as lost. All normal write access rules apply.
     * @returns 
     */
    public async SetAsLost(saleIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetAsLost(saleIds:number[]|carriers.Sale_SetAsLostRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Sale_SetAsLostRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleIds;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleIds)!='undefined' ) )
        {
            _request = saleIds as carriers.Sale_SetAsLostRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleIds: saleIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetAsLost( _request, _options );
    }


    private async _GetSalesFromContact(request: carriers.Sale_GetSalesFromContactRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sale[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSalesFromContact", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Sale[] = converters.Create_SaleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all sales for the contact provided.
     * @param request - ContactId, OnlyOpenSales
     * @returns List of sales matching query
     */
    public async GetSalesFromContact(request: carriers.Sale_GetSalesFromContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    /**
     * Returns all sales for the contact provided.
     * @param contactId - The ID of the contact whose sales we want.
     * @param onlyOpenSales - If true, only get open sales.
     * @returns List of sales matching query
     */
    public async GetSalesFromContact(contactId: number, onlyOpenSales: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    public async GetSalesFromContact(contactId:number|carriers.Sale_GetSalesFromContactRequest, onlyOpenSales?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        let _request : carriers.Sale_GetSalesFromContactRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.OnlyOpenSales)!='undefined' ) )
        {
            _request = contactId as carriers.Sale_GetSalesFromContactRequest;
            _options = onlyOpenSales as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       OnlyOpenSales: onlyOpenSales as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetSalesFromContact( _request, _options );
    }


    private async _GetSalesFromPerson(request: carriers.Sale_GetSalesFromPersonRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Sale[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSalesFromPerson", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Sale[] = converters.Create_SaleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all sales for the person provided.
     * @param request - PersonId, OnlyOpenSales
     * @returns List of sales matching query
     */
    public async GetSalesFromPerson(request: carriers.Sale_GetSalesFromPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    /**
     * Returns all sales for the person provided.
     * @param personId - The ID of the person whose sales we want.
     * @param onlyOpenSales - If true, only get open sales.
     * @returns List of sales matching query
     */
    public async GetSalesFromPerson(personId: number, onlyOpenSales: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] >;

    public async GetSalesFromPerson(personId:number|carriers.Sale_GetSalesFromPersonRequest, onlyOpenSales?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Sale[] > {
        let _request : carriers.Sale_GetSalesFromPersonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.OnlyOpenSales)!='undefined' ) )
        {
            _request = personId as carriers.Sale_GetSalesFromPersonRequest;
            _options = onlyOpenSales as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       OnlyOpenSales: onlyOpenSales as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetSalesFromPerson( _request, _options );
    }

    /*
     * Gets a SaleStakeholder object.
     * @param saleStakeholderId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleStakeholder
     */
    public async GetSaleStakeholder(saleStakeholderId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStakeholder >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleStakeholder?saleStakeholderId=" + saleStakeholderId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStakeholder_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets an array of SaleStakeholder objects.
     * @param saleStakeholderIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of SaleStakeholder
     */
    public async GetSaleStakeholderList(saleStakeholderIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStakeholder[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleStakeholderList", saleStakeholderIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStakeholderArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetSaleStakeholders(request: carriers.Sale_GetSaleStakeholdersRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStakeholder[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSaleStakeholders", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleStakeholder[] = converters.Create_SaleStakeholderArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - SaleId
     * @returns 
     */
    public async GetSaleStakeholders(request: carriers.Sale_GetSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;

    /**
     * 
     * @param saleId - 
     * @returns 
     */
    public async GetSaleStakeholders(saleId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;

    public async GetSaleStakeholders(saleId:number|carriers.Sale_GetSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] > {
        let _request : carriers.Sale_GetSaleStakeholdersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleId;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleId)!='undefined' ) )
        {
            _request = saleId as carriers.Sale_GetSaleStakeholdersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleId: saleId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetSaleStakeholders( _request, _options );
    }


    private async _UpdateSaleStakeholders(request: carriers.Sale_UpdateSaleStakeholdersRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStakeholder[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateSaleStakeholders", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleStakeholder[] = converters.Create_SaleStakeholderArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - Stakeholders
     * @returns 
     */
    public async UpdateSaleStakeholders(request: carriers.Sale_UpdateSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;

    /**
     * 
     * @param stakeholders - 
     * @returns 
     */
    public async UpdateSaleStakeholders(stakeholders: carriers.SaleStakeholder[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;

    public async UpdateSaleStakeholders(stakeholders:carriers.SaleStakeholder[]|carriers.Sale_UpdateSaleStakeholdersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] > {
        let _request : carriers.Sale_UpdateSaleStakeholdersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = stakeholders;
        if( typeof( first ) === "object" && first && ( typeof(first.Stakeholders)!='undefined' ) )
        {
            _request = stakeholders as carriers.Sale_UpdateSaleStakeholdersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Stakeholders: stakeholders as carriers.SaleStakeholder[],
                       };   
            _options = webapi_options;
        }
        return this._UpdateSaleStakeholders( _request, _options );
    }


    private async _GetSaleStakeholderById(request: carriers.Sale_GetSaleStakeholderByIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleStakeholder[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSaleStakeholderById", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleStakeholder[] = converters.Create_SaleStakeholderArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - SaleStakeholderIds
     * @returns 
     */
    public async GetSaleStakeholderById(request: carriers.Sale_GetSaleStakeholderByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;

    /**
     * 
     * @param saleStakeholderIds - 
     * @returns 
     */
    public async GetSaleStakeholderById(saleStakeholderIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] >;

    public async GetSaleStakeholderById(saleStakeholderIds:number[]|carriers.Sale_GetSaleStakeholderByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleStakeholder[] > {
        let _request : carriers.Sale_GetSaleStakeholderByIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = saleStakeholderIds;
        if( typeof( first ) === "object" && first && ( typeof(first.SaleStakeholderIds)!='undefined' ) )
        {
            _request = saleStakeholderIds as carriers.Sale_GetSaleStakeholderByIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SaleStakeholderIds: saleStakeholderIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetSaleStakeholderById( _request, _options );
    }


    private async _GetSummaryByAssociate(request: carriers.Sale_GetSummaryByAssociateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleSummary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSummaryByAssociate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleSummary = converters.Create_SaleSummary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AssociateId, FromDate, ToDate
     * @returns 
     */
    public async GetSummaryByAssociate(request: carriers.Sale_GetSummaryByAssociateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;

    /**
     * 
     * @param associateId - 
     * @param fromDate - 
     * @param toDate - 
     * @returns 
     */
    public async GetSummaryByAssociate(associateId: number, fromDate: Date, toDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;

    public async GetSummaryByAssociate(associateId:number|carriers.Sale_GetSummaryByAssociateRequest, fromDate?:Date|base.WebApiRequestOptions, toDate?:Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary > {
        let _request : carriers.Sale_GetSummaryByAssociateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.FromDate)!='undefined' || typeof(first.ToDate)!='undefined' ) )
        {
            _request = associateId as carriers.Sale_GetSummaryByAssociateRequest;
            _options = fromDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       FromDate: fromDate as Date,
                       ToDate: toDate as Date,
                       };   
            _options = webapi_options;
        }
        return this._GetSummaryByAssociate( _request, _options );
    }


    private async _GetSummaryByGroup(request: carriers.Sale_GetSummaryByGroupRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleSummary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSummaryByGroup", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleSummary = converters.Create_SaleSummary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - GroupId, FromDate, ToDate
     * @returns 
     */
    public async GetSummaryByGroup(request: carriers.Sale_GetSummaryByGroupRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;

    /**
     * 
     * @param groupId - 
     * @param fromDate - 
     * @param toDate - 
     * @returns 
     */
    public async GetSummaryByGroup(groupId: number, fromDate: Date, toDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;

    public async GetSummaryByGroup(groupId:number|carriers.Sale_GetSummaryByGroupRequest, fromDate?:Date|base.WebApiRequestOptions, toDate?:Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary > {
        let _request : carriers.Sale_GetSummaryByGroupRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = groupId;
        if( typeof( first ) === "object" && first && ( typeof(first.GroupId)!='undefined' || typeof(first.FromDate)!='undefined' || typeof(first.ToDate)!='undefined' ) )
        {
            _request = groupId as carriers.Sale_GetSummaryByGroupRequest;
            _options = fromDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       GroupId: groupId as number,
                       FromDate: fromDate as Date,
                       ToDate: toDate as Date,
                       };   
            _options = webapi_options;
        }
        return this._GetSummaryByGroup( _request, _options );
    }


    private async _GetSummaryByContact(request: carriers.Sale_GetSummaryByContactRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SaleSummary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSummaryByContact", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SaleSummary = converters.Create_SaleSummary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ContactId, FromDate, ToDate
     * @returns 
     */
    public async GetSummaryByContact(request: carriers.Sale_GetSummaryByContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;

    /**
     * 
     * @param contactId - 
     * @param fromDate - 
     * @param toDate - 
     * @returns 
     */
    public async GetSummaryByContact(contactId: number, fromDate: Date, toDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary >;

    public async GetSummaryByContact(contactId:number|carriers.Sale_GetSummaryByContactRequest, fromDate?:Date|base.WebApiRequestOptions, toDate?:Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SaleSummary > {
        let _request : carriers.Sale_GetSummaryByContactRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.FromDate)!='undefined' || typeof(first.ToDate)!='undefined' ) )
        {
            _request = contactId as carriers.Sale_GetSummaryByContactRequest;
            _options = fromDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       FromDate: fromDate as Date,
                       ToDate: toDate as Date,
                       };   
            _options = webapi_options;
        }
        return this._GetSummaryByContact( _request, _options );
    }

    } // class v1SaleAgentController 



// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/DashboardAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Agent lets you configure dashboard tiles and retrieve dashboard data
 */
export interface IDashboardAgent {
    CreateDefaultDashboard(): Promise< carriers.Dashboard >;
    SaveDashboard(entity: carriers.Dashboard) : Promise< carriers.Dashboard >;
    DeleteDashboard(DashboardId: number) : Promise<void>;
    CreateDefaultDashboardTile(): Promise< carriers.DashboardTile >;
    SaveDashboardTile(entity: carriers.DashboardTile) : Promise< carriers.DashboardTile >;
    DeleteDashboardTile(DashboardTileId: number) : Promise<void>;
    GetDashboard(dashboardId: number) :  Promise< carriers.Dashboard >;
    GetDashboards(request: carriers.Dashboard_GetDashboardsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard[] >;
    GetDashboards(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard[] >;
    SetTile(request: carriers.Dashboard_SetTileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard >;
    SetTile(dashboardId: number, tileId: number, position: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard >;
    GetDashboardTile(dashboardTileId: number) :  Promise< carriers.DashboardTile >;
    GetDashboardTiles(request: carriers.Dashboard_GetDashboardTilesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile[] >;
    GetDashboardTiles(dashboardTileIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile[] >;
    GetStandardDashboardTileFromChartId(request: carriers.Dashboard_GetStandardDashboardTileFromChartIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile >;
    GetStandardDashboardTileFromChartId(chartId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile >;
    GetData(request: carriers.Dashboard_GetDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] >;
    GetData(dashboardTileId: number, restrictions: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] >;
    CreateNewFromTemplate(request: carriers.Dashboard_CreateNewFromTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile >;
    CreateNewFromTemplate(dashboardTileId: number, caption: string, description: string, selectionId: number, visibleFor: carriers.VisibleFor[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile >;
    GetDataWithSelection(request: carriers.Dashboard_GetDataWithSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] >;
    GetDataWithSelection(dashboardTileId: number, selectionId: number, restrictions: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] >;
} // interface IDashboardAgent




/**
 * Agent lets you configure dashboard tiles and retrieve dashboard data
 */
export class DashboardAgent extends base.WebApiBase implements IDashboardAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Dashboard/";
        super(options);
    }



    /**
     * Set default values into a new Dashboard.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDashboard(options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dashboard >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashboard", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Dashboard = converters.Create_Dashboard_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing Dashboard or creates a new Dashboard if the id parameter is empty
     * @param entity - The Dashboard to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated Dashboard
     */
    public async SaveDashboard(entity: carriers.Dashboard, options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dashboard >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDashboard", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Dashboard = converters.Create_Dashboard_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the Dashboard
     * @param DashboardId - The id of the Dashboard to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteDashboard(DashboardId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDashboard?DashboardId=" + DashboardId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new DashboardTile.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDashboardTile(options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashboardTile >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashboardTile", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashboardTile = converters.Create_DashboardTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DashboardTile or creates a new DashboardTile if the id parameter is empty
     * @param entity - The DashboardTile to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DashboardTile
     */
    public async SaveDashboardTile(entity: carriers.DashboardTile, options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashboardTile >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDashboardTile", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashboardTile = converters.Create_DashboardTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the DashboardTile
     * @param DashboardTileId - The id of the DashboardTile to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteDashboardTile(DashboardTileId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDashboardTile?DashboardTileId=" + DashboardTileId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Dashboard object.
     * @param dashboardId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Dashboard
     */
    public async GetDashboard(dashboardId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dashboard >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDashboard?dashboardId=" + dashboardId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Dashboard_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetDashboards(request: carriers.Dashboard_GetDashboardsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dashboard[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashboards", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Dashboard[] = converters.Create_DashboardArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets all dashboards for an associate
     * @param request - AssociateId
     * @returns All the users dashboards
     */
    public async GetDashboards(request: carriers.Dashboard_GetDashboardsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard[] >;

    /**
     * Gets all dashboards for an associate
     * @param associateId - Associate Id
     * @returns All the users dashboards
     */
    public async GetDashboards(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard[] >;

    public async GetDashboards(associateId:number|carriers.Dashboard_GetDashboardsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard[] > {
        let _request : carriers.Dashboard_GetDashboardsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.Dashboard_GetDashboardsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDashboards( _request, _options );
    }


    private async _SetTile(request: carriers.Dashboard_SetTileRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dashboard >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTile", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Dashboard = converters.Create_Dashboard_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets tile in the given dashboard position
     * @param request - DashboardId, TileId, Position
     * @returns The new dashboard is returned after the tile change
     */
    public async SetTile(request: carriers.Dashboard_SetTileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard >;

    /**
     * Sets tile in the given dashboard position
     * @param dashboardId - Dashboard Id
     * @param tileId - Tile Id
     * @param position - Tile position in the dashboard
     * @returns The new dashboard is returned after the tile change
     */
    public async SetTile(dashboardId: number, tileId: number, position: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard >;

    public async SetTile(dashboardId:number|carriers.Dashboard_SetTileRequest, tileId?:number|base.WebApiRequestOptions, position?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dashboard > {
        let _request : carriers.Dashboard_SetTileRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardId)!='undefined' || typeof(first.TileId)!='undefined' || typeof(first.Position)!='undefined' ) )
        {
            _request = dashboardId as carriers.Dashboard_SetTileRequest;
            _options = tileId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardId: dashboardId as number,
                       TileId: tileId as number,
                       Position: position as number,
                       };   
            _options = webapi_options;
        }
        return this._SetTile( _request, _options );
    }

    /*
     * Gets a DashboardTile object.
     * @param dashboardTileId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DashboardTile
     */
    public async GetDashboardTile(dashboardTileId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashboardTile >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDashboardTile?dashboardTileId=" + dashboardTileId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashboardTile_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetDashboardTiles(request: carriers.Dashboard_GetDashboardTilesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashboardTile[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashboardTiles", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashboardTile[] = converters.Create_DashboardTileArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets an array of dashboard tiles for the provided ids
     * @param request - DashboardTileIds
     * @returns Dashboard tiles
     */
    public async GetDashboardTiles(request: carriers.Dashboard_GetDashboardTilesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile[] >;

    /**
     * Gets an array of dashboard tiles for the provided ids
     * @param dashboardTileIds - The ids of the tiles to get
     * @returns Dashboard tiles
     */
    public async GetDashboardTiles(dashboardTileIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile[] >;

    public async GetDashboardTiles(dashboardTileIds:number[]|carriers.Dashboard_GetDashboardTilesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile[] > {
        let _request : carriers.Dashboard_GetDashboardTilesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardTileIds;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardTileIds)!='undefined' ) )
        {
            _request = dashboardTileIds as carriers.Dashboard_GetDashboardTilesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardTileIds: dashboardTileIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetDashboardTiles( _request, _options );
    }


    private async _GetStandardDashboardTileFromChartId(request: carriers.Dashboard_GetStandardDashboardTileFromChartIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashboardTile >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetStandardDashboardTileFromChartId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashboardTile = converters.Create_DashboardTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the standard tile (not personal tile) corresponding to the given chart id
     * @param request - ChartId
     * @returns Standard tile
     */
    public async GetStandardDashboardTileFromChartId(request: carriers.Dashboard_GetStandardDashboardTileFromChartIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile >;

    /**
     * Gets the standard tile (not personal tile) corresponding to the given chart id
     * @param chartId - The ChartId of the wanted chart/tile
     * @returns Standard tile
     */
    public async GetStandardDashboardTileFromChartId(chartId: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile >;

    public async GetStandardDashboardTileFromChartId(chartId:string|carriers.Dashboard_GetStandardDashboardTileFromChartIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile > {
        let _request : carriers.Dashboard_GetStandardDashboardTileFromChartIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chartId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChartId)!='undefined' ) )
        {
            _request = chartId as carriers.Dashboard_GetStandardDashboardTileFromChartIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChartId: chartId as string,
                       };   
            _options = webapi_options;
        }
        return this._GetStandardDashboardTileFromChartId( _request, _options );
    }


    private async _GetData(request: carriers.Dashboard_GetDataRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TileData[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetData", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TileData[] = converters.Create_TileDataArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get data for this tile
     * @param request - DashboardTileId, Restrictions
     * @returns The data
     */
    public async GetData(request: carriers.Dashboard_GetDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] >;

    /**
     * Get data for this tile
     * @param dashboardTileId - Tile Id
     * @param restrictions - Replacement restrictions
     * @returns The data
     */
    public async GetData(dashboardTileId: number, restrictions: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] >;

    public async GetData(dashboardTileId:number|carriers.Dashboard_GetDataRequest, restrictions?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] > {
        let _request : carriers.Dashboard_GetDataRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardTileId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardTileId)!='undefined' || typeof(first.Restrictions)!='undefined' ) )
        {
            _request = dashboardTileId as carriers.Dashboard_GetDataRequest;
            _options = restrictions as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardTileId: dashboardTileId as number,
                       Restrictions: restrictions as string,
                       };   
            _options = webapi_options;
        }
        return this._GetData( _request, _options );
    }


    private async _CreateNewFromTemplate(request: carriers.Dashboard_CreateNewFromTemplateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashboardTile >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewFromTemplate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashboardTile = converters.Create_DashboardTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create new tile from another tile used as template
     * @param request - DashboardTileId, Caption, Description, SelectionId, VisibleFor
     * @returns The new tile
     */
    public async CreateNewFromTemplate(request: carriers.Dashboard_CreateNewFromTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile >;

    /**
     * Create new tile from another tile used as template
     * @param dashboardTileId - Tile template Id
     * @param caption - Caption of new tile
     * @param description - Description of new tile
     * @param selectionId - Selection id of new tile
     * @param visibleFor - Who the tile should be visible for
     * @returns The new tile
     */
    public async CreateNewFromTemplate(dashboardTileId: number, caption: string, description: string, selectionId: number, visibleFor: carriers.VisibleFor[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile >;

    public async CreateNewFromTemplate(dashboardTileId:number|carriers.Dashboard_CreateNewFromTemplateRequest, caption?:string|base.WebApiRequestOptions, description?:string, selectionId?:number, visibleFor?:carriers.VisibleFor[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashboardTile > {
        let _request : carriers.Dashboard_CreateNewFromTemplateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardTileId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardTileId)!='undefined' || typeof(first.Caption)!='undefined' || typeof(first.Description)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.VisibleFor)!='undefined' ) )
        {
            _request = dashboardTileId as carriers.Dashboard_CreateNewFromTemplateRequest;
            _options = caption as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardTileId: dashboardTileId as number,
                       Caption: caption as string,
                       Description: description as string,
                       SelectionId: selectionId as number,
                       VisibleFor: visibleFor as carriers.VisibleFor[],
                       };   
            _options = webapi_options;
        }
        return this._CreateNewFromTemplate( _request, _options );
    }


    private async _GetDataWithSelection(request: carriers.Dashboard_GetDataWithSelectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TileData[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDataWithSelection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TileData[] = converters.Create_TileDataArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get data for this tile
     * @param request - DashboardTileId, SelectionId, Restrictions
     * @returns The data
     */
    public async GetDataWithSelection(request: carriers.Dashboard_GetDataWithSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] >;

    /**
     * Get data for this tile
     * @param dashboardTileId - Tile Id
     * @param selectionId - Selection Id
     * @param restrictions - Replacement restrictions
     * @returns The data
     */
    public async GetDataWithSelection(dashboardTileId: number, selectionId: number, restrictions: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] >;

    public async GetDataWithSelection(dashboardTileId:number|carriers.Dashboard_GetDataWithSelectionRequest, selectionId?:number|base.WebApiRequestOptions, restrictions?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TileData[] > {
        let _request : carriers.Dashboard_GetDataWithSelectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardTileId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardTileId)!='undefined' || typeof(first.SelectionId)!='undefined' || typeof(first.Restrictions)!='undefined' ) )
        {
            _request = dashboardTileId as carriers.Dashboard_GetDataWithSelectionRequest;
            _options = selectionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardTileId: dashboardTileId as number,
                       SelectionId: selectionId as number,
                       Restrictions: restrictions as string,
                       };   
            _options = webapi_options;
        }
        return this._GetDataWithSelection( _request, _options );
    }

    } // class v1DashboardAgentController 



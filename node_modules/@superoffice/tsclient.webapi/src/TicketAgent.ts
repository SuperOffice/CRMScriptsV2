// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/TicketAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Agent used for Ticket functions
 */
export interface ITicketAgent {
    CreateDefaultAttachmentEntity(): Promise< carriers.AttachmentEntity >;
    SaveAttachmentEntity(entity: carriers.AttachmentEntity) : Promise< carriers.AttachmentEntity >;
    CreateDefaultTicketEntity(): Promise< carriers.TicketEntity >;
    SaveTicketEntity(entity: carriers.TicketEntity) : Promise< carriers.TicketEntity >;
    CreateDefaultTicketMessageEntity(): Promise< carriers.TicketMessageEntity >;
    SaveTicketMessageEntity(entity: carriers.TicketMessageEntity) : Promise< carriers.TicketMessageEntity >;
    GetAttachmentEntity(attachmentEntityId: number) :  Promise< carriers.AttachmentEntity >;
    CopyFromCRMDocument(request: carriers.Ticket_CopyFromCRMDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity >;
    CopyFromCRMDocument(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity >;
    CopyToTempFile(request: carriers.Ticket_CopyToTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    CopyToTempFile(filename: string, attachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    UploadAttachment(request: carriers.Ticket_UploadAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    UploadAttachment(attachmentId: number, content: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetAttachmentStream(request: carriers.Ticket_GetAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetAttachmentStream(attachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetTicket(ticketId: number) :  Promise< carriers.Ticket >;
    GetTickets(request: carriers.Ticket_GetTicketsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Ticket[] >;
    GetTickets(ticketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Ticket[] >;
    GetTicketEntity(ticketEntityId: number) :  Promise< carriers.TicketEntity >;
    GetForRmUi(request: carriers.Ticket_GetForRmUiRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    GetForRmUi(ticketId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    DeleteTicketEntity(request: carriers.Ticket_DeleteTicketEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteTicketEntity(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotifyNewTicket(request: carriers.Ticket_NotifyNewTicketRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotifyNewTicket(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotifyNewTicketMessage(request: carriers.Ticket_NotifyNewTicketMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotifyNewTicketMessage(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetTicketAttachments(request: carriers.Ticket_GetTicketAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;
    GetTicketAttachments(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;
    ValidateAttachments(request: carriers.Ticket_ValidateAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentValidationResult[] >;
    ValidateAttachments(attachmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentValidationResult[] >;
    SetTicketReadByOwner(request: carriers.Ticket_SetTicketReadByOwnerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    SetTicketReadByOwner(ticketEntityId: number, readStatus: enums.TicketReadStatus, checkEscalating: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    SaveTicketEntityWithNotify(request: carriers.Ticket_SaveTicketEntityWithNotifyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    SaveTicketEntityWithNotify(newEntity: carriers.TicketEntity, notify: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    GetNextInQueue(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    ProcessTicketWhenRead(request: carriers.Ticket_ProcessTicketWhenReadRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    ProcessTicketWhenRead(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    SplitTicket(request: carriers.Ticket_SplitTicketRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    SplitTicket(sourceTicketEntityId: number, transferMessageIds: number[], newTicketEntity: carriers.TicketEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    SplitTicketMessage(request: carriers.Ticket_SplitTicketMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    SplitTicketMessage(sourceTicketMessage: carriers.TicketMessageEntity, newTicketEntity: carriers.TicketEntity, newTicketMessage: carriers.TicketMessageEntity, transferAttachmentsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    UpdateTicketsReadStatus(request: carriers.Ticket_UpdateTicketsReadStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    UpdateTicketsReadStatus(ticketIds: number[], newStatus: enums.TicketReadStatus, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    UpdateTicketsReadStatusByProvider(request: carriers.Ticket_UpdateTicketsReadStatusByProviderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    UpdateTicketsReadStatusByProvider(provider: string, restrictions: carriers.ArchiveRestrictionInfo[], newStatus: enums.TicketReadStatus, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    MergeTickets(request: carriers.Ticket_MergeTicketsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    MergeTickets(mergedTicketEntity: carriers.TicketEntity, secondaryTicketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;
    SetDeletedStatusByIds(request: carriers.Ticket_SetDeletedStatusByIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    SetDeletedStatusByIds(ticketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    SetDeletedStatusByProvider(request: carriers.Ticket_SetDeletedStatusByProviderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    SetDeletedStatusByProvider(providerName: string, restrictions: carriers.ArchiveRestrictionInfo[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    UndeleteByIds(request: carriers.Ticket_UndeleteByIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    UndeleteByIds(ticketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ResolveTicketId(request: carriers.Ticket_ResolveTicketIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    ResolveTicketId(ticketId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    BatchForward(request: carriers.Ticket_BatchForwardRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    BatchForward(ticketIds: number[], to: string[], cc: string[], bcc: string[], comment: string, closeTicket: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    BatchReply(request: carriers.Ticket_BatchReplyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    BatchReply(batchReplyData: carriers.TicketBatchReplyData, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    ClearNotify(request: carriers.Ticket_ClearNotifyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ClearNotify(ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetTicketMessage(ticketMessageId: number) :  Promise< carriers.TicketMessage >;
    GetTicketMessageEntity(ticketMessageEntityId: number) :  Promise< carriers.TicketMessageEntity >;
    DeleteTicketMessageEntity(request: carriers.Ticket_DeleteTicketMessageEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteTicketMessageEntity(ticketMessageEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SanitizeMailContent(request: carriers.Ticket_SanitizeMailContentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SanitizeMailContent(content: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SanitizeMailContents(request: carriers.Ticket_SanitizeMailContentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    SanitizeMailContents(contents: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    Html2Text(request: carriers.Ticket_Html2TextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    Html2Text(content: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetAttachmentInfo(request: carriers.Ticket_GetAttachmentInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;
    GetAttachmentInfo(ticketMessageEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;
    GetAttachmentInfoNonInline(request: carriers.Ticket_GetAttachmentInfoNonInlineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;
    GetAttachmentInfoNonInline(ticketMessageEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;
    AddAttachments(request: carriers.Ticket_AddAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddAttachments(ticketMessageEntityId: number, attachmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveMessageAttachments(request: carriers.Ticket_RemoveMessageAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveMessageAttachments(ticketMessageEntityId: number, attachmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPreviewAttachmentStream(request: carriers.Ticket_GetPreviewAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;
    GetPreviewAttachmentStream(attachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;
    SendTicketMessage(request: carriers.Ticket_SendTicketMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SendTicketMessage(ticketMessageEntityId: number, to: string[], cc: string[], bcc: string[], subject: string, replyTemplateId: number, gdprSource: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SendTicketMessageSms(request: carriers.Ticket_SendTicketMessageSmsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SendTicketMessageSms(ticketMessageEntityId: number, replyTemplateId: number, sms: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetTicketMessageImportant(request: carriers.Ticket_SetTicketMessageImportantRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetTicketMessageImportant(ticketMessageId: number, important: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CalculateMessageRecipients(request: carriers.Ticket_CalculateMessageRecipientsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Recipient[] >;
    CalculateMessageRecipients(ticketId: number, actionType: enums.MessageActionType, messageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Recipient[] >;
    SaveTicketMessageEntityWithNotify(request: carriers.Ticket_SaveTicketMessageEntityWithNotifyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;
    SaveTicketMessageEntityWithNotify(newEntity: carriers.TicketMessageEntity, notify: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;
    SaveTicketMessageEntityWithOptions(request: carriers.Ticket_SaveTicketMessageEntityWithOptionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;
    SaveTicketMessageEntityWithOptions(entity: carriers.TicketMessageEntity, notify: boolean, attachmentIds: number[], updateRepliedAt: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;
    GetDefaultMessageContent(request: carriers.Ticket_GetDefaultMessageContentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetDefaultMessageContent(ticketId: number, messageActionType: enums.MessageActionType, ticketMessageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetTicketMessageWithEmbeddedData(request: carriers.Ticket_GetTicketMessageWithEmbeddedDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;
    GetTicketMessageWithEmbeddedData(id: number, embedImages: enums.ImageEmbedType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;
    DeleteMessageHeaders(request: carriers.Ticket_DeleteMessageHeadersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteMessageHeaders(headerIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetTicketMessageWithOptions(request: carriers.Ticket_GetTicketMessageWithOptionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;
    GetTicketMessageWithOptions(ticketMessageEntityId: number, includeNonInlineAttachmentsInfo: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;
    GetTicketSummaries(request: carriers.Ticket_GetTicketSummariesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketSummaryItem[] >;
    GetTicketSummaries(ticketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketSummaryItem[] >;
} // interface ITicketAgent




/**
 * Agent used for Ticket functions
 */
export class TicketAgent extends base.WebApiBase implements ITicketAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Ticket/";
        super(options);
    }



    /**
     * Set default values into a new AttachmentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultAttachmentEntity(options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AttachmentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultAttachmentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AttachmentEntity = converters.Create_AttachmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing AttachmentEntity or creates a new AttachmentEntity if the id parameter is empty
     * @param entity - The AttachmentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated AttachmentEntity
     */
    public async SaveAttachmentEntity(entity: carriers.AttachmentEntity, options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AttachmentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveAttachmentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AttachmentEntity = converters.Create_AttachmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new TicketEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultTicketEntity(options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketEntity or creates a new TicketEntity if the id parameter is empty
     * @param entity - The TicketEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketEntity
     */
    public async SaveTicketEntity(entity: carriers.TicketEntity, options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new TicketMessageEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultTicketMessageEntity(options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketMessageEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketMessageEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketMessageEntity = converters.Create_TicketMessageEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketMessageEntity or creates a new TicketMessageEntity if the id parameter is empty
     * @param entity - The TicketMessageEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketMessageEntity
     */
    public async SaveTicketMessageEntity(entity: carriers.TicketMessageEntity, options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketMessageEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketMessageEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketMessageEntity = converters.Create_TicketMessageEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a AttachmentEntity object.
     * @param attachmentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single AttachmentEntity
     */
    public async GetAttachmentEntity(attachmentEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AttachmentEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAttachmentEntity?attachmentEntityId=" + attachmentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AttachmentEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _CopyFromCRMDocument(request: carriers.Ticket_CopyFromCRMDocumentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AttachmentEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyFromCRMDocument", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AttachmentEntity = converters.Create_AttachmentEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Copy CRM document to an attachment
     * @param request - DocumentId
     * @returns 
     */
    public async CopyFromCRMDocument(request: carriers.Ticket_CopyFromCRMDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity >;

    /**
     * Copy CRM document to an attachment
     * @param documentId - The id of the document to copy to an attachment
     * @returns 
     */
    public async CopyFromCRMDocument(documentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity >;

    public async CopyFromCRMDocument(documentId:number|carriers.Ticket_CopyFromCRMDocumentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity > {
        let _request : carriers.Ticket_CopyFromCRMDocumentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = documentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DocumentId)!='undefined' ) )
        {
            _request = documentId as carriers.Ticket_CopyFromCRMDocumentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DocumentId: documentId as number,
                       };   
            _options = webapi_options;
        }
        return this._CopyFromCRMDocument( _request, _options );
    }


    private async _CopyToTempFile(request: carriers.Ticket_CopyToTempFileRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyToTempFile", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Copy ticket attachment to temporary file. Needed for existing document dialog compatibility
     * @param request - Filename, AttachmentId
     * @returns Temporary document filename
     */
    public async CopyToTempFile(request: carriers.Ticket_CopyToTempFileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Copy ticket attachment to temporary file. Needed for existing document dialog compatibility
     * @param filename - Preferred filename
     * @param attachmentId - The id of the attachment to copy
     * @returns Temporary document filename
     */
    public async CopyToTempFile(filename: string, attachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async CopyToTempFile(filename:string|carriers.Ticket_CopyToTempFileRequest, attachmentId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Ticket_CopyToTempFileRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = filename;
        if( typeof( first ) === "object" && first && ( typeof(first.Filename)!='undefined' || typeof(first.AttachmentId)!='undefined' ) )
        {
            _request = filename as carriers.Ticket_CopyToTempFileRequest;
            _options = attachmentId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Filename: filename as string,
                       AttachmentId: attachmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._CopyToTempFile( _request, _options );
    }


    private async _UploadAttachment(request: carriers.Ticket_UploadAttachmentRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UploadAttachment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Upload the content for an attachment
     * @param request - AttachmentId, Content
     * @returns This method has no return value
     */
    public async UploadAttachment(request: carriers.Ticket_UploadAttachmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Upload the content for an attachment
     * @param attachmentId - The id of the attachment row, for which to attach the upload data
     * @param content - A stream to the content to be uploaded
     * @returns This method has no return value
     */
    public async UploadAttachment(attachmentId: number, content: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async UploadAttachment(attachmentId:number|carriers.Ticket_UploadAttachmentRequest, content?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_UploadAttachmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = attachmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AttachmentId)!='undefined' || typeof(first.Content)!='undefined' ) )
        {
            _request = attachmentId as carriers.Ticket_UploadAttachmentRequest;
            _options = content as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AttachmentId: attachmentId as number,
                       Content: content as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Content = ToBase64(_request.Content);
        return this._UploadAttachment( _request, _options );
    }


    private async _GetAttachmentStream(request: carriers.Ticket_GetAttachmentStreamRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachmentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the content of an attachment
     * @param request - AttachmentId
     * @returns A stream to the attachment content
     */
    public async GetAttachmentStream(request: carriers.Ticket_GetAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Get the content of an attachment
     * @param attachmentId - The id of the attachment to retrieve
     * @returns A stream to the attachment content
     */
    public async GetAttachmentStream(attachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetAttachmentStream(attachmentId:number|carriers.Ticket_GetAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Ticket_GetAttachmentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = attachmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AttachmentId)!='undefined' ) )
        {
            _request = attachmentId as carriers.Ticket_GetAttachmentStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AttachmentId: attachmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAttachmentStream( _request, _options );
    }

    /*
     * Gets a Ticket object.
     * @param ticketId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Ticket
     */
    public async GetTicket(ticketId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Ticket > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Ticket >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicket?ticketId=" + ticketId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Ticket_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetTickets(request: carriers.Ticket_GetTicketsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Ticket[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Ticket[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTickets", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Ticket[] = converters.Create_TicketArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get multiple tickets
     * @param request - TicketIds
     * @returns Returns array of tickets in same order as input ids
     */
    public async GetTickets(request: carriers.Ticket_GetTicketsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Ticket[] >;

    /**
     * Get multiple tickets
     * @param ticketIds - The ids of tickets to get
     * @returns Returns array of tickets in same order as input ids
     */
    public async GetTickets(ticketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Ticket[] >;

    public async GetTickets(ticketIds:number[]|carriers.Ticket_GetTicketsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Ticket[] > {
        let _request : carriers.Ticket_GetTicketsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketIds;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketIds)!='undefined' ) )
        {
            _request = ticketIds as carriers.Ticket_GetTicketsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketIds: ticketIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetTickets( _request, _options );
    }

    /*
     * Gets a TicketEntity object.
     * @param ticketEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketEntity
     */
    public async GetTicketEntity(ticketEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketEntity?ticketEntityId=" + ticketEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetForRmUi(request: carriers.Ticket_GetForRmUiRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetForRmUi", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a ticket entity, adapted to the specific needs of the Request Management UI. WARNING: This endpoint is not guaranteed to be stable/compatible between versions
     * @param request - TicketId
     * @returns The ticket entity. Information is filtered/adapted to the current needs of the UI
     */
    public async GetForRmUi(request: carriers.Ticket_GetForRmUiRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    /**
     * Get a ticket entity, adapted to the specific needs of the Request Management UI. WARNING: This endpoint is not guaranteed to be stable/compatible between versions
     * @param ticketId - Primary key of ticket to fetch
     * @returns The ticket entity. Information is filtered/adapted to the current needs of the UI
     */
    public async GetForRmUi(ticketId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    public async GetForRmUi(ticketId:number|carriers.Ticket_GetForRmUiRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        let _request : carriers.Ticket_GetForRmUiRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketId)!='undefined' ) )
        {
            _request = ticketId as carriers.Ticket_GetForRmUiRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketId: ticketId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetForRmUi( _request, _options );
    }


    private async _DeleteTicketEntity(request: carriers.Ticket_DeleteTicketEntityRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteTicketEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a ticket
     * @param request - TicketEntityId
     * @returns returns void
     */
    public async DeleteTicketEntity(request: carriers.Ticket_DeleteTicketEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a ticket
     * @param ticketEntityId - The ticket to delete
     * @returns returns void
     */
    public async DeleteTicketEntity(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteTicketEntity(ticketEntityId:number|carriers.Ticket_DeleteTicketEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_DeleteTicketEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketEntityId)!='undefined' ) )
        {
            _request = ticketEntityId as carriers.Ticket_DeleteTicketEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketEntityId: ticketEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteTicketEntity( _request, _options );
    }


    private async _NotifyNewTicket(request: carriers.Ticket_NotifyNewTicketRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotifyNewTicket", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Notify user agents about the creation of a new ticket
     * @param request - TicketEntityId
     * @returns This method has no return value
     */
    public async NotifyNewTicket(request: carriers.Ticket_NotifyNewTicketRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Notify user agents about the creation of a new ticket
     * @param ticketEntityId - The id of the ticket to notify about
     * @returns This method has no return value
     */
    public async NotifyNewTicket(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async NotifyNewTicket(ticketEntityId:number|carriers.Ticket_NotifyNewTicketRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_NotifyNewTicketRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketEntityId)!='undefined' ) )
        {
            _request = ticketEntityId as carriers.Ticket_NotifyNewTicketRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketEntityId: ticketEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._NotifyNewTicket( _request, _options );
    }


    private async _NotifyNewTicketMessage(request: carriers.Ticket_NotifyNewTicketMessageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotifyNewTicketMessage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Notify user agents about the creation of a new message on a ticket
     * @param request - TicketEntityId
     * @returns This method has no return value
     */
    public async NotifyNewTicketMessage(request: carriers.Ticket_NotifyNewTicketMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Notify user agents about the creation of a new message on a ticket
     * @param ticketEntityId - The id of the ticket to notify about
     * @returns This method has no return value
     */
    public async NotifyNewTicketMessage(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async NotifyNewTicketMessage(ticketEntityId:number|carriers.Ticket_NotifyNewTicketMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_NotifyNewTicketMessageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketEntityId)!='undefined' ) )
        {
            _request = ticketEntityId as carriers.Ticket_NotifyNewTicketMessageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketEntityId: ticketEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._NotifyNewTicketMessage( _request, _options );
    }


    private async _GetTicketAttachments(request: carriers.Ticket_GetTicketAttachmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AttachmentEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketAttachments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AttachmentEntity[] = converters.Create_AttachmentEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get attachment infos for all attachments connected to messages in specified ticket
     * @param request - TicketEntityId
     * @returns An array containing attachment info objects for all the attachments
     */
    public async GetTicketAttachments(request: carriers.Ticket_GetTicketAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;

    /**
     * Get attachment infos for all attachments connected to messages in specified ticket
     * @param ticketEntityId - The id of the ticket to get attachment infos from
     * @returns An array containing attachment info objects for all the attachments
     */
    public async GetTicketAttachments(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;

    public async GetTicketAttachments(ticketEntityId:number|carriers.Ticket_GetTicketAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] > {
        let _request : carriers.Ticket_GetTicketAttachmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketEntityId)!='undefined' ) )
        {
            _request = ticketEntityId as carriers.Ticket_GetTicketAttachmentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketEntityId: ticketEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetTicketAttachments( _request, _options );
    }


    private async _ValidateAttachments(request: carriers.Ticket_ValidateAttachmentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentValidationResult[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AttachmentValidationResult[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateAttachments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AttachmentValidationResult[] = converters.Create_AttachmentValidationResultArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check attachments, return validation result for each item
     * @param request - AttachmentIds
     * @returns Validation result
     */
    public async ValidateAttachments(request: carriers.Ticket_ValidateAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentValidationResult[] >;

    /**
     * Check attachments, return validation result for each item
     * @param attachmentIds - The IDs of the attachments to validate
     * @returns Validation result
     */
    public async ValidateAttachments(attachmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentValidationResult[] >;

    public async ValidateAttachments(attachmentIds:number[]|carriers.Ticket_ValidateAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentValidationResult[] > {
        let _request : carriers.Ticket_ValidateAttachmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = attachmentIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AttachmentIds)!='undefined' ) )
        {
            _request = attachmentIds as carriers.Ticket_ValidateAttachmentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AttachmentIds: attachmentIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._ValidateAttachments( _request, _options );
    }


    private async _SetTicketReadByOwner(request: carriers.Ticket_SetTicketReadByOwnerRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketReadByOwner", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the ReadByOwner status for a ticket. It will only have an effect if the calling user is the same as the owner of the ticket
     * @param request - TicketEntityId, ReadStatus, CheckEscalating
     * @returns The ticket entity after setting the ReadByOwner
     */
    public async SetTicketReadByOwner(request: carriers.Ticket_SetTicketReadByOwnerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    /**
     * Set the ReadByOwner status for a ticket. It will only have an effect if the calling user is the same as the owner of the ticket
     * @param ticketEntityId - The id of the ticket to set
     * @param readStatus - The read status to set. See the enum for explanation of the different colors. Setting Unknown does nothing
     * @param checkEscalating - If true, then the escalation system will be called and executed when setting the ReadByOwner
     * @returns The ticket entity after setting the ReadByOwner
     */
    public async SetTicketReadByOwner(ticketEntityId: number, readStatus: enums.TicketReadStatus, checkEscalating: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    public async SetTicketReadByOwner(ticketEntityId:number|carriers.Ticket_SetTicketReadByOwnerRequest, readStatus?:enums.TicketReadStatus|base.WebApiRequestOptions, checkEscalating?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        let _request : carriers.Ticket_SetTicketReadByOwnerRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketEntityId)!='undefined' || typeof(first.ReadStatus)!='undefined' || typeof(first.CheckEscalating)!='undefined' ) )
        {
            _request = ticketEntityId as carriers.Ticket_SetTicketReadByOwnerRequest;
            _options = readStatus as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketEntityId: ticketEntityId as number,
                       ReadStatus: readStatus as enums.TicketReadStatus,
                       CheckEscalating: checkEscalating as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetTicketReadByOwner( _request, _options );
    }


    private async _SaveTicketEntityWithNotify(request: carriers.Ticket_SaveTicketEntityWithNotifyRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTicketEntityWithNotify", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a ticket and performs any user notifications
     * @param request - NewEntity, Notify
     * @returns The newly saved entity
     */
    public async SaveTicketEntityWithNotify(request: carriers.Ticket_SaveTicketEntityWithNotifyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    /**
     * Saves a ticket and performs any user notifications
     * @param newEntity - The ticket to save
     * @param notify - If true, then the notifications will be sent
     * @returns The newly saved entity
     */
    public async SaveTicketEntityWithNotify(newEntity: carriers.TicketEntity, notify: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    public async SaveTicketEntityWithNotify(newEntity:carriers.TicketEntity|carriers.Ticket_SaveTicketEntityWithNotifyRequest, notify?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        let _request : carriers.Ticket_SaveTicketEntityWithNotifyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = newEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.NewEntity)!='undefined' || typeof(first.Notify)!='undefined' ) )
        {
            _request = newEntity as carriers.Ticket_SaveTicketEntityWithNotifyRequest;
            _options = notify as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       NewEntity: newEntity as carriers.TicketEntity,
                       Notify: notify as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SaveTicketEntityWithNotify( _request, _options );
    }


    private async _GetNextInQueue( options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextInQueue", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Assign a ticket to the caller based on intelligent queue system
     * @returns The ticket entity after assigning it to the caller
     */
    public async GetNextInQueue(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >
    {
        return this._GetNextInQueue(webapi_options);
    }


    private async _ProcessTicketWhenRead(request: carriers.Ticket_ProcessTicketWhenReadRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ProcessTicketWhenRead", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * When a user view/read a ticket, a number of action should be performed: set read status, escalation handling, remove notifications, etc. Which actions will be performed depends on owner, caller and configuration
     * @param request - TicketEntityId
     * @returns The ticket entity after marking it as read
     */
    public async ProcessTicketWhenRead(request: carriers.Ticket_ProcessTicketWhenReadRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    /**
     * When a user view/read a ticket, a number of action should be performed: set read status, escalation handling, remove notifications, etc. Which actions will be performed depends on owner, caller and configuration
     * @param ticketEntityId - The id of the ticket to mark as read
     * @returns The ticket entity after marking it as read
     */
    public async ProcessTicketWhenRead(ticketEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    public async ProcessTicketWhenRead(ticketEntityId:number|carriers.Ticket_ProcessTicketWhenReadRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        let _request : carriers.Ticket_ProcessTicketWhenReadRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketEntityId)!='undefined' ) )
        {
            _request = ticketEntityId as carriers.Ticket_ProcessTicketWhenReadRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketEntityId: ticketEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._ProcessTicketWhenRead( _request, _options );
    }


    private async _SplitTicket(request: carriers.Ticket_SplitTicketRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SplitTicket", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save new ticket and move/copy data from existing ticket in a single request. Specified messages will be moved.
     * @param request - SourceTicketEntityId, TransferMessageIds, NewTicketEntity
     * @returns The newly created entity
     */
    public async SplitTicket(request: carriers.Ticket_SplitTicketRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    /**
     * Save new ticket and move/copy data from existing ticket in a single request. Specified messages will be moved.
     * @param sourceTicketEntityId - The id of the ticket to split
     * @param transferMessageIds - IDs of messages that should be transferred from the original ticket to the new one
     * @param newTicketEntity - The new ticket to save. Includes new values for simple properties like title, category, status, etc., but not messages.
     * @returns The newly created entity
     */
    public async SplitTicket(sourceTicketEntityId: number, transferMessageIds: number[], newTicketEntity: carriers.TicketEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    public async SplitTicket(sourceTicketEntityId:number|carriers.Ticket_SplitTicketRequest, transferMessageIds?:number[]|base.WebApiRequestOptions, newTicketEntity?:carriers.TicketEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        let _request : carriers.Ticket_SplitTicketRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceTicketEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceTicketEntityId)!='undefined' || typeof(first.TransferMessageIds)!='undefined' || typeof(first.NewTicketEntity)!='undefined' ) )
        {
            _request = sourceTicketEntityId as carriers.Ticket_SplitTicketRequest;
            _options = transferMessageIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceTicketEntityId: sourceTicketEntityId as number,
                       TransferMessageIds: transferMessageIds as number[],
                       NewTicketEntity: newTicketEntity as carriers.TicketEntity,
                       };   
            _options = webapi_options;
        }
        return this._SplitTicket( _request, _options );
    }


    private async _SplitTicketMessage(request: carriers.Ticket_SplitTicketMessageRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SplitTicketMessage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create new ticket and move/copy data from existing ticket in addition update old message and save new message in a single request.
     * @param request - SourceTicketMessage, NewTicketEntity, NewTicketMessage, TransferAttachmentsIds
     * @returns The newly created entity
     */
    public async SplitTicketMessage(request: carriers.Ticket_SplitTicketMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    /**
     * Create new ticket and move/copy data from existing ticket in addition update old message and save new message in a single request.
     * @param sourceTicketMessage - The message being splitted, content can be modified as part of the split.
     * @param newTicketEntity - The new ticket to save. Includes new values for simple properties like title, category, status, etc., but not messages.
     * @param newTicketMessage - The new message to be saved
     * @param transferAttachmentsIds - IDs of attachments that should be transferred from the original message to the new one
     * @returns The newly created entity
     */
    public async SplitTicketMessage(sourceTicketMessage: carriers.TicketMessageEntity, newTicketEntity: carriers.TicketEntity, newTicketMessage: carriers.TicketMessageEntity, transferAttachmentsIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    public async SplitTicketMessage(sourceTicketMessage:carriers.TicketMessageEntity|carriers.Ticket_SplitTicketMessageRequest, newTicketEntity?:carriers.TicketEntity|base.WebApiRequestOptions, newTicketMessage?:carriers.TicketMessageEntity, transferAttachmentsIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        let _request : carriers.Ticket_SplitTicketMessageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceTicketMessage;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceTicketMessage)!='undefined' || typeof(first.NewTicketEntity)!='undefined' || typeof(first.NewTicketMessage)!='undefined' || typeof(first.TransferAttachmentsIds)!='undefined' ) )
        {
            _request = sourceTicketMessage as carriers.Ticket_SplitTicketMessageRequest;
            _options = newTicketEntity as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceTicketMessage: sourceTicketMessage as carriers.TicketMessageEntity,
                       NewTicketEntity: newTicketEntity as carriers.TicketEntity,
                       NewTicketMessage: newTicketMessage as carriers.TicketMessageEntity,
                       TransferAttachmentsIds: transferAttachmentsIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SplitTicketMessage( _request, _options );
    }


    private async _UpdateTicketsReadStatus(request: carriers.Ticket_UpdateTicketsReadStatusRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateTicketsReadStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method changes multiple tickets&apos; read status
     * @param request - TicketIds, NewStatus
     * @returns Updated ticket ids
     */
    public async UpdateTicketsReadStatus(request: carriers.Ticket_UpdateTicketsReadStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * This method changes multiple tickets&apos; read status
     * @param ticketIds - Ticket ids to be updated
     * @param newStatus - New read status
     * @returns Updated ticket ids
     */
    public async UpdateTicketsReadStatus(ticketIds: number[], newStatus: enums.TicketReadStatus, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async UpdateTicketsReadStatus(ticketIds:number[]|carriers.Ticket_UpdateTicketsReadStatusRequest, newStatus?:enums.TicketReadStatus|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.Ticket_UpdateTicketsReadStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketIds;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketIds)!='undefined' || typeof(first.NewStatus)!='undefined' ) )
        {
            _request = ticketIds as carriers.Ticket_UpdateTicketsReadStatusRequest;
            _options = newStatus as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketIds: ticketIds as number[],
                       NewStatus: newStatus as enums.TicketReadStatus,
                       };   
            _options = webapi_options;
        }
        return this._UpdateTicketsReadStatus( _request, _options );
    }


    private async _UpdateTicketsReadStatusByProvider(request: carriers.Ticket_UpdateTicketsReadStatusByProviderRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateTicketsReadStatusByProvider", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method changes multiple tickets&apos; read status
     * @param request - Provider, Restrictions, NewStatus
     * @returns Updated ticket ids
     */
    public async UpdateTicketsReadStatusByProvider(request: carriers.Ticket_UpdateTicketsReadStatusByProviderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * This method changes multiple tickets&apos; read status
     * @param provider - Name of the provider that returns ticket rows.
     * @param restrictions - Query restrictions to be added to provider. Fixed providers, such as LastTicketsProvider, FavouriteTicketsProvider etc. already have mandatory restrictions setup - in such case extra restrictions will be combined, however for general use case for fixed providers you can pass an empty array and provider will return default results. For selection providers generally you should pass selectionId as a restriction.
     * @param newStatus - New read status
     * @returns Updated ticket ids
     */
    public async UpdateTicketsReadStatusByProvider(provider: string, restrictions: carriers.ArchiveRestrictionInfo[], newStatus: enums.TicketReadStatus, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async UpdateTicketsReadStatusByProvider(provider:string|carriers.Ticket_UpdateTicketsReadStatusByProviderRequest, restrictions?:carriers.ArchiveRestrictionInfo[]|base.WebApiRequestOptions, newStatus?:enums.TicketReadStatus, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.Ticket_UpdateTicketsReadStatusByProviderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = provider;
        if( typeof( first ) === "object" && first && ( typeof(first.Provider)!='undefined' || typeof(first.Restrictions)!='undefined' || typeof(first.NewStatus)!='undefined' ) )
        {
            _request = provider as carriers.Ticket_UpdateTicketsReadStatusByProviderRequest;
            _options = restrictions as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Provider: provider as string,
                       Restrictions: restrictions as carriers.ArchiveRestrictionInfo[],
                       NewStatus: newStatus as enums.TicketReadStatus,
                       };   
            _options = webapi_options;
        }
        return this._UpdateTicketsReadStatusByProvider( _request, _options );
    }


    private async _MergeTickets(request: carriers.Ticket_MergeTicketsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MergeTickets", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketEntity = converters.Create_TicketEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Merge one or more tickets into one primary ticket
     * @param request - MergedTicketEntity, SecondaryTicketIds
     * @returns The newly merged entity
     */
    public async MergeTickets(request: carriers.Ticket_MergeTicketsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    /**
     * Merge one or more tickets into one primary ticket
     * @param mergedTicketEntity - Merged ticket entity
     * @param secondaryTicketIds - Ids of secondary tickets
     * @returns The newly merged entity
     */
    public async MergeTickets(mergedTicketEntity: carriers.TicketEntity, secondaryTicketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity >;

    public async MergeTickets(mergedTicketEntity:carriers.TicketEntity|carriers.Ticket_MergeTicketsRequest, secondaryTicketIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketEntity > {
        let _request : carriers.Ticket_MergeTicketsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mergedTicketEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.MergedTicketEntity)!='undefined' || typeof(first.SecondaryTicketIds)!='undefined' ) )
        {
            _request = mergedTicketEntity as carriers.Ticket_MergeTicketsRequest;
            _options = secondaryTicketIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MergedTicketEntity: mergedTicketEntity as carriers.TicketEntity,
                       SecondaryTicketIds: secondaryTicketIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._MergeTickets( _request, _options );
    }


    private async _SetDeletedStatusByIds(request: carriers.Ticket_SetDeletedStatusByIdsRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDeletedStatusByIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets tickets&apos; status to Deleted. After a grace period these tickets will be deleted by a background job.
     * @param request - TicketIds
     * @returns Ids of tickets set for deletion.
     */
    public async SetDeletedStatusByIds(request: carriers.Ticket_SetDeletedStatusByIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * Sets tickets&apos; status to Deleted. After a grace period these tickets will be deleted by a background job.
     * @param ticketIds - Ids of tickets to be set for deletion.
     * @returns Ids of tickets set for deletion.
     */
    public async SetDeletedStatusByIds(ticketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async SetDeletedStatusByIds(ticketIds:number[]|carriers.Ticket_SetDeletedStatusByIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.Ticket_SetDeletedStatusByIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketIds;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketIds)!='undefined' ) )
        {
            _request = ticketIds as carriers.Ticket_SetDeletedStatusByIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketIds: ticketIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SetDeletedStatusByIds( _request, _options );
    }


    private async _SetDeletedStatusByProvider(request: carriers.Ticket_SetDeletedStatusByProviderRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDeletedStatusByProvider", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets tickets&apos; status to Deleted. After a grace period these tickets will be deleted by a background job.
     * @param request - ProviderName, Restrictions
     * @returns Ids of tickets set for deletion.
     */
    public async SetDeletedStatusByProvider(request: carriers.Ticket_SetDeletedStatusByProviderRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * Sets tickets&apos; status to Deleted. After a grace period these tickets will be deleted by a background job.
     * @param providerName - Name of the provider that returns ticket rows.
     * @param restrictions - Query restrictions to be added to provider. Fixed providers, such as LastTicketsProvider, FavouriteTicketsProvider etc. already have mandatory restrictions setup - in such case extra restrictions will be combined, however for general use case for fixed providers you can pass an empty array and provider will return default results. For selection providers generally you should pass selectionId as a restriction.
     * @returns Ids of tickets set for deletion.
     */
    public async SetDeletedStatusByProvider(providerName: string, restrictions: carriers.ArchiveRestrictionInfo[], webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async SetDeletedStatusByProvider(providerName:string|carriers.Ticket_SetDeletedStatusByProviderRequest, restrictions?:carriers.ArchiveRestrictionInfo[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.Ticket_SetDeletedStatusByProviderRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = providerName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProviderName)!='undefined' || typeof(first.Restrictions)!='undefined' ) )
        {
            _request = providerName as carriers.Ticket_SetDeletedStatusByProviderRequest;
            _options = restrictions as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProviderName: providerName as string,
                       Restrictions: restrictions as carriers.ArchiveRestrictionInfo[],
                       };   
            _options = webapi_options;
        }
        return this._SetDeletedStatusByProvider( _request, _options );
    }


    private async _UndeleteByIds(request: carriers.Ticket_UndeleteByIdsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UndeleteByIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Restores deleted tickets by their ids. Status is set to a default open status defined in Registry table
     * @param request - TicketIds
     * @returns This method has no return value
     */
    public async UndeleteByIds(request: carriers.Ticket_UndeleteByIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Restores deleted tickets by their ids. Status is set to a default open status defined in Registry table
     * @param ticketIds - Ids of tickets to be restored.
     * @returns This method has no return value
     */
    public async UndeleteByIds(ticketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async UndeleteByIds(ticketIds:number[]|carriers.Ticket_UndeleteByIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_UndeleteByIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketIds;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketIds)!='undefined' ) )
        {
            _request = ticketIds as carriers.Ticket_UndeleteByIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketIds: ticketIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._UndeleteByIds( _request, _options );
    }


    private async _ResolveTicketId(request: carriers.Ticket_ResolveTicketIdRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResolveTicketId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Ticket can be connected (merged) to another ticket. This method traverses through its connection(s) and returns proper ticketId
     * @param request - TicketId
     * @returns Correct ticketId. Returns 0 in case ticket does not exists
     */
    public async ResolveTicketId(request: carriers.Ticket_ResolveTicketIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Ticket can be connected (merged) to another ticket. This method traverses through its connection(s) and returns proper ticketId
     * @param ticketId - Potentially correct ticketId
     * @returns Correct ticketId. Returns 0 in case ticket does not exists
     */
    public async ResolveTicketId(ticketId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async ResolveTicketId(ticketId:number|carriers.Ticket_ResolveTicketIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Ticket_ResolveTicketIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketId)!='undefined' ) )
        {
            _request = ticketId as carriers.Ticket_ResolveTicketIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketId: ticketId as number,
                       };   
            _options = webapi_options;
        }
        return this._ResolveTicketId( _request, _options );
    }


    private async _BatchForward(request: carriers.Ticket_BatchForwardRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("BatchForward", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Forwards selected tickets to specified recipients. This method starts a batch task.
     * @param request - TicketIds, To, Cc, Bcc, Comment, CloseTicket
     * @returns ID of the new batch task.
     */
    public async BatchForward(request: carriers.Ticket_BatchForwardRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Forwards selected tickets to specified recipients. This method starts a batch task.
     * @param ticketIds - Ids of tickets to be forwarded.
     * @param to - The To-recipients. Each recipient must be in correct mailbox format (john@example.com or John Doe <john@example.com>).
     * @param cc - The Cc-recipients. Each recipient must be in correct mailbox format (john@example.com or John Doe <john@example.com>).
     * @param bcc - The Bcc-recipients. Each recipient must be in correct mailbox format (john@example.com or John Doe <john@example.com>).
     * @param comment - Comment will be included before ticket messages. Might be empty
     * @param closeTicket - If true, ticket will be closed after forwarding
     * @returns ID of the new batch task.
     */
    public async BatchForward(ticketIds: number[], to: string[], cc: string[], bcc: string[], comment: string, closeTicket: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async BatchForward(ticketIds:number[]|carriers.Ticket_BatchForwardRequest, to?:string[]|base.WebApiRequestOptions, cc?:string[], bcc?:string[], comment?:string, closeTicket?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Ticket_BatchForwardRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketIds;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketIds)!='undefined' || typeof(first.To)!='undefined' || typeof(first.Cc)!='undefined' || typeof(first.Bcc)!='undefined' || typeof(first.Comment)!='undefined' || typeof(first.CloseTicket)!='undefined' ) )
        {
            _request = ticketIds as carriers.Ticket_BatchForwardRequest;
            _options = to as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketIds: ticketIds as number[],
                       To: to as string[],
                       Cc: cc as string[],
                       Bcc: bcc as string[],
                       Comment: comment as string,
                       CloseTicket: closeTicket as boolean,
                       };   
            _options = webapi_options;
        }
        return this._BatchForward( _request, _options );
    }


    private async _BatchReply(request: carriers.Ticket_BatchReplyRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("BatchReply", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Replies to the specified tickets. This method starts a batch task.
     * @param request - BatchReplyData
     * @returns ID of the new batch task.
     */
    public async BatchReply(request: carriers.Ticket_BatchReplyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Replies to the specified tickets. This method starts a batch task.
     * @param batchReplyData - All data needed to initiate a mass ticket reply sending.
     * @returns ID of the new batch task.
     */
    public async BatchReply(batchReplyData: carriers.TicketBatchReplyData, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async BatchReply(batchReplyData:carriers.TicketBatchReplyData|carriers.Ticket_BatchReplyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Ticket_BatchReplyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = batchReplyData;
        if( typeof( first ) === "object" && first && ( typeof(first.BatchReplyData)!='undefined' ) )
        {
            _request = batchReplyData as carriers.Ticket_BatchReplyRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       BatchReplyData: batchReplyData as carriers.TicketBatchReplyData,
                       };   
            _options = webapi_options;
        }
        return this._BatchReply( _request, _options );
    }


    private async _ClearNotify(request: carriers.Ticket_ClearNotifyRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ClearNotify", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Clear notification status for one or more tickets.
     * @param request - Ids
     * @returns This method has no return value
     */
    public async ClearNotify(request: carriers.Ticket_ClearNotifyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Clear notification status for one or more tickets.
     * @param ids - List of notify IDs.
     * @returns This method has no return value
     */
    public async ClearNotify(ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ClearNotify(ids:number[]|carriers.Ticket_ClearNotifyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_ClearNotifyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ids;
        if( typeof( first ) === "object" && first && ( typeof(first.Ids)!='undefined' ) )
        {
            _request = ids as carriers.Ticket_ClearNotifyRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Ids: ids as number[],
                       };   
            _options = webapi_options;
        }
        return this._ClearNotify( _request, _options );
    }

    /*
     * Gets a TicketMessage object.
     * @param ticketMessageId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketMessage
     */
    public async GetTicketMessage(ticketMessageId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessage > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketMessage >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketMessage?ticketMessageId=" + ticketMessageId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessage_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a TicketMessageEntity object.
     * @param ticketMessageEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketMessageEntity
     */
    public async GetTicketMessageEntity(ticketMessageEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketMessageEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketMessageEntity?ticketMessageEntityId=" + ticketMessageEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessageEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _DeleteTicketMessageEntity(request: carriers.Ticket_DeleteTicketMessageEntityRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteTicketMessageEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a ticket message
     * @param request - TicketMessageEntityId
     * @returns returns void
     */
    public async DeleteTicketMessageEntity(request: carriers.Ticket_DeleteTicketMessageEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a ticket message
     * @param ticketMessageEntityId - The ticket message to delete
     * @returns returns void
     */
    public async DeleteTicketMessageEntity(ticketMessageEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteTicketMessageEntity(ticketMessageEntityId:number|carriers.Ticket_DeleteTicketMessageEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_DeleteTicketMessageEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketMessageEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketMessageEntityId)!='undefined' ) )
        {
            _request = ticketMessageEntityId as carriers.Ticket_DeleteTicketMessageEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketMessageEntityId: ticketMessageEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteTicketMessageEntity( _request, _options );
    }


    private async _SanitizeMailContent(request: carriers.Ticket_SanitizeMailContentRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SanitizeMailContent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove harmful HTML tags and attributes from an email
     * @param request - Content
     * @returns The sanitized email content
     */
    public async SanitizeMailContent(request: carriers.Ticket_SanitizeMailContentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Remove harmful HTML tags and attributes from an email
     * @param content - The email content to sanitize
     * @returns The sanitized email content
     */
    public async SanitizeMailContent(content: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async SanitizeMailContent(content:string|carriers.Ticket_SanitizeMailContentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Ticket_SanitizeMailContentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = content;
        if( typeof( first ) === "object" && first && ( typeof(first.Content)!='undefined' ) )
        {
            _request = content as carriers.Ticket_SanitizeMailContentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Content: content as string,
                       };   
            _options = webapi_options;
        }
        return this._SanitizeMailContent( _request, _options );
    }


    private async _SanitizeMailContents(request: carriers.Ticket_SanitizeMailContentsRequest, options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SanitizeMailContents", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove harmful HTML tags and attributes from an email
     * @param request - Contents
     * @returns The sanitized email contents
     */
    public async SanitizeMailContents(request: carriers.Ticket_SanitizeMailContentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    /**
     * Remove harmful HTML tags and attributes from an email
     * @param contents - The email contents to sanitize
     * @returns The sanitized email contents
     */
    public async SanitizeMailContents(contents: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;

    public async SanitizeMailContents(contents:string[]|carriers.Ticket_SanitizeMailContentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string[] > {
        let _request : carriers.Ticket_SanitizeMailContentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contents;
        if( typeof( first ) === "object" && first && ( typeof(first.Contents)!='undefined' ) )
        {
            _request = contents as carriers.Ticket_SanitizeMailContentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Contents: contents as string[],
                       };   
            _options = webapi_options;
        }
        return this._SanitizeMailContents( _request, _options );
    }


    private async _Html2Text(request: carriers.Ticket_Html2TextRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Html2Text", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a plain text version of the html, suitable for email
     * @param request - Content
     * @returns The plain text version
     */
    public async Html2Text(request: carriers.Ticket_Html2TextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Create a plain text version of the html, suitable for email
     * @param content - The html version
     * @returns The plain text version
     */
    public async Html2Text(content: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async Html2Text(content:string|carriers.Ticket_Html2TextRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Ticket_Html2TextRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = content;
        if( typeof( first ) === "object" && first && ( typeof(first.Content)!='undefined' ) )
        {
            _request = content as carriers.Ticket_Html2TextRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Content: content as string,
                       };   
            _options = webapi_options;
        }
        return this._Html2Text( _request, _options );
    }


    private async _GetAttachmentInfo(request: carriers.Ticket_GetAttachmentInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AttachmentEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachmentInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AttachmentEntity[] = converters.Create_AttachmentEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list with meta data for all attached attachments
     * @param request - TicketMessageEntityId
     * @returns An array with AttachmentEntity objects, describing each attachment
     */
    public async GetAttachmentInfo(request: carriers.Ticket_GetAttachmentInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;

    /**
     * Get a list with meta data for all attached attachments
     * @param ticketMessageEntityId - The id of the ticket message to get attachment infos for
     * @returns An array with AttachmentEntity objects, describing each attachment
     */
    public async GetAttachmentInfo(ticketMessageEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;

    public async GetAttachmentInfo(ticketMessageEntityId:number|carriers.Ticket_GetAttachmentInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] > {
        let _request : carriers.Ticket_GetAttachmentInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketMessageEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketMessageEntityId)!='undefined' ) )
        {
            _request = ticketMessageEntityId as carriers.Ticket_GetAttachmentInfoRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketMessageEntityId: ticketMessageEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAttachmentInfo( _request, _options );
    }


    private async _GetAttachmentInfoNonInline(request: carriers.Ticket_GetAttachmentInfoNonInlineRequest, options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.AttachmentEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachmentInfoNonInline", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.AttachmentEntity[] = converters.Create_AttachmentEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list with meta data for all attached attachments, EXCEPT those marked as inline
     * @param request - TicketMessageEntityId
     * @returns An array with AttachmentEntity objects, describing each attachment; those marked as INLINE will be skipped
     */
    public async GetAttachmentInfoNonInline(request: carriers.Ticket_GetAttachmentInfoNonInlineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;

    /**
     * Get a list with meta data for all attached attachments, EXCEPT those marked as inline
     * @param ticketMessageEntityId - The id of the ticket message to get attachment infos for
     * @returns An array with AttachmentEntity objects, describing each attachment; those marked as INLINE will be skipped
     */
    public async GetAttachmentInfoNonInline(ticketMessageEntityId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] >;

    public async GetAttachmentInfoNonInline(ticketMessageEntityId:number|carriers.Ticket_GetAttachmentInfoNonInlineRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.AttachmentEntity[] > {
        let _request : carriers.Ticket_GetAttachmentInfoNonInlineRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketMessageEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketMessageEntityId)!='undefined' ) )
        {
            _request = ticketMessageEntityId as carriers.Ticket_GetAttachmentInfoNonInlineRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketMessageEntityId: ticketMessageEntityId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAttachmentInfoNonInline( _request, _options );
    }


    private async _AddAttachments(request: carriers.Ticket_AddAttachmentsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddAttachments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Connect existing attachments with this TicketMessage. Can connect multiple attachments
     * @param request - TicketMessageEntityId, AttachmentIds
     * @returns 
     */
    public async AddAttachments(request: carriers.Ticket_AddAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Connect existing attachments with this TicketMessage. Can connect multiple attachments
     * @param ticketMessageEntityId - The id of the ticket message to connect the attachments to
     * @param attachmentIds - An array of attachments to connect to this TicketMessage
     * @returns 
     */
    public async AddAttachments(ticketMessageEntityId: number, attachmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddAttachments(ticketMessageEntityId:number|carriers.Ticket_AddAttachmentsRequest, attachmentIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_AddAttachmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketMessageEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketMessageEntityId)!='undefined' || typeof(first.AttachmentIds)!='undefined' ) )
        {
            _request = ticketMessageEntityId as carriers.Ticket_AddAttachmentsRequest;
            _options = attachmentIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketMessageEntityId: ticketMessageEntityId as number,
                       AttachmentIds: attachmentIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._AddAttachments( _request, _options );
    }


    private async _RemoveMessageAttachments(request: carriers.Ticket_RemoveMessageAttachmentsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveMessageAttachments", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes attachments from the message as specified in the collection of entity ids. The ids are attachment ids (attachment primary key)
     * @param request - TicketMessageEntityId, AttachmentIds
     * @returns This method has no return value
     */
    public async RemoveMessageAttachments(request: carriers.Ticket_RemoveMessageAttachmentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Removes attachments from the message as specified in the collection of entity ids. The ids are attachment ids (attachment primary key)
     * @param ticketMessageEntityId - The id of the ticket message to remove attachments from
     * @param attachmentIds - Attachment primary keys
     * @returns This method has no return value
     */
    public async RemoveMessageAttachments(ticketMessageEntityId: number, attachmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveMessageAttachments(ticketMessageEntityId:number|carriers.Ticket_RemoveMessageAttachmentsRequest, attachmentIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_RemoveMessageAttachmentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketMessageEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketMessageEntityId)!='undefined' || typeof(first.AttachmentIds)!='undefined' ) )
        {
            _request = ticketMessageEntityId as carriers.Ticket_RemoveMessageAttachmentsRequest;
            _options = attachmentIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketMessageEntityId: ticketMessageEntityId as number,
                       AttachmentIds: attachmentIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._RemoveMessageAttachments( _request, _options );
    }


    private async _GetPreviewAttachmentStream(request: carriers.Ticket_GetPreviewAttachmentStreamRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DocumentPreview >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewAttachmentStream", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DocumentPreview = converters.Create_DocumentPreview_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve an attachment from ticket message. The returned data is intended to be used for a preview. The returned data is sanitized.
     * @param request - AttachmentId
     * @returns Sanitized preview version of the attachment
     */
    public async GetPreviewAttachmentStream(request: carriers.Ticket_GetPreviewAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;

    /**
     * Retrieve an attachment from ticket message. The returned data is intended to be used for a preview. The returned data is sanitized.
     * @param attachmentId - The id of the attachment to retrieve
     * @returns Sanitized preview version of the attachment
     */
    public async GetPreviewAttachmentStream(attachmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview >;

    public async GetPreviewAttachmentStream(attachmentId:number|carriers.Ticket_GetPreviewAttachmentStreamRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DocumentPreview > {
        let _request : carriers.Ticket_GetPreviewAttachmentStreamRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = attachmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AttachmentId)!='undefined' ) )
        {
            _request = attachmentId as carriers.Ticket_GetPreviewAttachmentStreamRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AttachmentId: attachmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviewAttachmentStream( _request, _options );
    }


    private async _SendTicketMessage(request: carriers.Ticket_SendTicketMessageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendTicketMessage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Send a message to recipients by email
     * @param request - TicketMessageEntityId, To, Cc, Bcc, Subject, ReplyTemplateId, GdprSource
     * @returns This method has no return value
     */
    public async SendTicketMessage(request: carriers.Ticket_SendTicketMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Send a message to recipients by email
     * @param ticketMessageEntityId - The id of the ticket message to send
     * @param to - The To-recipients. Each recipient must be in correct format
     * @param cc - The Cc-recipients. Each recipient must be in correct format
     * @param bcc - The Bcc-recipients. Each recipient must be in correct format
     * @param subject - The subject
     * @param replyTemplateId - Optional ID of reply template to merge message with. <= 0 to skip.
     * @param gdprSource - Obsolete
     * @returns This method has no return value
     */
    public async SendTicketMessage(ticketMessageEntityId: number, to: string[], cc: string[], bcc: string[], subject: string, replyTemplateId: number, gdprSource: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SendTicketMessage(ticketMessageEntityId:number|carriers.Ticket_SendTicketMessageRequest, to?:string[]|base.WebApiRequestOptions, cc?:string[], bcc?:string[], subject?:string, replyTemplateId?:number, gdprSource?:string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_SendTicketMessageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketMessageEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketMessageEntityId)!='undefined' || typeof(first.To)!='undefined' || typeof(first.Cc)!='undefined' || typeof(first.Bcc)!='undefined' || typeof(first.Subject)!='undefined' || typeof(first.ReplyTemplateId)!='undefined' || typeof(first.GdprSource)!='undefined' ) )
        {
            _request = ticketMessageEntityId as carriers.Ticket_SendTicketMessageRequest;
            _options = to as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketMessageEntityId: ticketMessageEntityId as number,
                       To: to as string[],
                       Cc: cc as string[],
                       Bcc: bcc as string[],
                       Subject: subject as string,
                       ReplyTemplateId: replyTemplateId as number,
                       GdprSource: gdprSource as string,
                       };   
            _options = webapi_options;
        }
        return this._SendTicketMessage( _request, _options );
    }


    private async _SendTicketMessageSms(request: carriers.Ticket_SendTicketMessageSmsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendTicketMessageSms", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Send a message to recipients by sms
     * @param request - TicketMessageEntityId, ReplyTemplateId, Sms
     * @returns This method has no return value
     */
    public async SendTicketMessageSms(request: carriers.Ticket_SendTicketMessageSmsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Send a message to recipients by sms
     * @param ticketMessageEntityId - The id of the ticket message to send
     * @param replyTemplateId - Optional ID of reply template to merge message with. <= 0 to skip.
     * @param sms - The Sms-recipients. Each recipient must be in correct format
     * @returns This method has no return value
     */
    public async SendTicketMessageSms(ticketMessageEntityId: number, replyTemplateId: number, sms: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SendTicketMessageSms(ticketMessageEntityId:number|carriers.Ticket_SendTicketMessageSmsRequest, replyTemplateId?:number|base.WebApiRequestOptions, sms?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_SendTicketMessageSmsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketMessageEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketMessageEntityId)!='undefined' || typeof(first.ReplyTemplateId)!='undefined' || typeof(first.Sms)!='undefined' ) )
        {
            _request = ticketMessageEntityId as carriers.Ticket_SendTicketMessageSmsRequest;
            _options = replyTemplateId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketMessageEntityId: ticketMessageEntityId as number,
                       ReplyTemplateId: replyTemplateId as number,
                       Sms: sms as string[],
                       };   
            _options = webapi_options;
        }
        return this._SendTicketMessageSms( _request, _options );
    }


    private async _SetTicketMessageImportant(request: carriers.Ticket_SetTicketMessageImportantRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketMessageImportant", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the important flag on or off for a ticket message
     * @param request - TicketMessageId, Important
     * @returns 
     */
    public async SetTicketMessageImportant(request: carriers.Ticket_SetTicketMessageImportantRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the important flag on or off for a ticket message
     * @param ticketMessageId - The id of the ticket message to set the important flag on
     * @param important - Turn on or off the important flag
     * @returns 
     */
    public async SetTicketMessageImportant(ticketMessageId: number, important: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetTicketMessageImportant(ticketMessageId:number|carriers.Ticket_SetTicketMessageImportantRequest, important?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_SetTicketMessageImportantRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketMessageId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketMessageId)!='undefined' || typeof(first.Important)!='undefined' ) )
        {
            _request = ticketMessageId as carriers.Ticket_SetTicketMessageImportantRequest;
            _options = important as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketMessageId: ticketMessageId as number,
                       Important: important as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetTicketMessageImportant( _request, _options );
    }


    private async _CalculateMessageRecipients(request: carriers.Ticket_CalculateMessageRecipientsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Recipient[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Recipient[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CalculateMessageRecipients", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Recipient[] = converters.Create_RecipientArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets recipients for new message
     * @param request - TicketId, ActionType, MessageId
     * @returns An array with Recipient objects
     */
    public async CalculateMessageRecipients(request: carriers.Ticket_CalculateMessageRecipientsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Recipient[] >;

    /**
     * Gets recipients for new message
     * @param ticketId - The id of the ticket
     * @param actionType - Message action
     * @param messageId - Optional ID of message being replied. Value <= 0 ignores parameter
     * @returns An array with Recipient objects
     */
    public async CalculateMessageRecipients(ticketId: number, actionType: enums.MessageActionType, messageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Recipient[] >;

    public async CalculateMessageRecipients(ticketId:number|carriers.Ticket_CalculateMessageRecipientsRequest, actionType?:enums.MessageActionType|base.WebApiRequestOptions, messageId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Recipient[] > {
        let _request : carriers.Ticket_CalculateMessageRecipientsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketId)!='undefined' || typeof(first.ActionType)!='undefined' || typeof(first.MessageId)!='undefined' ) )
        {
            _request = ticketId as carriers.Ticket_CalculateMessageRecipientsRequest;
            _options = actionType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketId: ticketId as number,
                       ActionType: actionType as enums.MessageActionType,
                       MessageId: messageId as number,
                       };   
            _options = webapi_options;
        }
        return this._CalculateMessageRecipients( _request, _options );
    }


    private async _SaveTicketMessageEntityWithNotify(request: carriers.Ticket_SaveTicketMessageEntityWithNotifyRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketMessageEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTicketMessageEntityWithNotify", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketMessageEntity = converters.Create_TicketMessageEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a ticket message and performs any user notifications
     * @param request - NewEntity, Notify
     * @returns The saved entity
     */
    public async SaveTicketMessageEntityWithNotify(request: carriers.Ticket_SaveTicketMessageEntityWithNotifyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;

    /**
     * Saves a ticket message and performs any user notifications
     * @param newEntity - The ticket message to save
     * @param notify - If true, then the notification will be sent along with the save
     * @returns The saved entity
     */
    public async SaveTicketMessageEntityWithNotify(newEntity: carriers.TicketMessageEntity, notify: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;

    public async SaveTicketMessageEntityWithNotify(newEntity:carriers.TicketMessageEntity|carriers.Ticket_SaveTicketMessageEntityWithNotifyRequest, notify?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        let _request : carriers.Ticket_SaveTicketMessageEntityWithNotifyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = newEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.NewEntity)!='undefined' || typeof(first.Notify)!='undefined' ) )
        {
            _request = newEntity as carriers.Ticket_SaveTicketMessageEntityWithNotifyRequest;
            _options = notify as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       NewEntity: newEntity as carriers.TicketMessageEntity,
                       Notify: notify as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SaveTicketMessageEntityWithNotify( _request, _options );
    }


    private async _SaveTicketMessageEntityWithOptions(request: carriers.Ticket_SaveTicketMessageEntityWithOptionsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketMessageEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTicketMessageEntityWithOptions", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketMessageEntity = converters.Create_TicketMessageEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves a ticket message and performs additional actions
     * @param request - Entity, Notify, AttachmentIds, UpdateRepliedAt
     * @returns The saved entity
     */
    public async SaveTicketMessageEntityWithOptions(request: carriers.Ticket_SaveTicketMessageEntityWithOptionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;

    /**
     * Saves a ticket message and performs additional actions
     * @param entity - The ticket message to save
     * @param notify - If true, then the notification will be sent along with the save
     * @param attachmentIds - An array of attachments to connect to this TicketMessage
     * @param updateRepliedAt - Updates ticket's replied_at field if needed
     * @returns The saved entity
     */
    public async SaveTicketMessageEntityWithOptions(entity: carriers.TicketMessageEntity, notify: boolean, attachmentIds: number[], updateRepliedAt: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;

    public async SaveTicketMessageEntityWithOptions(entity:carriers.TicketMessageEntity|carriers.Ticket_SaveTicketMessageEntityWithOptionsRequest, notify?:boolean|base.WebApiRequestOptions, attachmentIds?:number[], updateRepliedAt?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        let _request : carriers.Ticket_SaveTicketMessageEntityWithOptionsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = entity;
        if( typeof( first ) === "object" && first && ( typeof(first.Entity)!='undefined' || typeof(first.Notify)!='undefined' || typeof(first.AttachmentIds)!='undefined' || typeof(first.UpdateRepliedAt)!='undefined' ) )
        {
            _request = entity as carriers.Ticket_SaveTicketMessageEntityWithOptionsRequest;
            _options = notify as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Entity: entity as carriers.TicketMessageEntity,
                       Notify: notify as boolean,
                       AttachmentIds: attachmentIds as number[],
                       UpdateRepliedAt: updateRepliedAt as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SaveTicketMessageEntityWithOptions( _request, _options );
    }


    private async _GetDefaultMessageContent(request: carriers.Ticket_GetDefaultMessageContentRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultMessageContent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Generate a default message body (possibly including user signature, quoted message content) as sanitized HTML
     * @param request - TicketId, MessageActionType, TicketMessageId
     * @returns Sanitized HTML content including possibly user signature and quoted message
     */
    public async GetDefaultMessageContent(request: carriers.Ticket_GetDefaultMessageContentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Generate a default message body (possibly including user signature, quoted message content) as sanitized HTML
     * @param ticketId - The id of the ticket
     * @param messageActionType - Message action type: None/Reply/ReplyAll/Forward
     * @param ticketMessageId - The id of the message to quote in the returned content. 0 to skip/ignore
     * @returns Sanitized HTML content including possibly user signature and quoted message
     */
    public async GetDefaultMessageContent(ticketId: number, messageActionType: enums.MessageActionType, ticketMessageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetDefaultMessageContent(ticketId:number|carriers.Ticket_GetDefaultMessageContentRequest, messageActionType?:enums.MessageActionType|base.WebApiRequestOptions, ticketMessageId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Ticket_GetDefaultMessageContentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketId)!='undefined' || typeof(first.MessageActionType)!='undefined' || typeof(first.TicketMessageId)!='undefined' ) )
        {
            _request = ticketId as carriers.Ticket_GetDefaultMessageContentRequest;
            _options = messageActionType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketId: ticketId as number,
                       MessageActionType: messageActionType as enums.MessageActionType,
                       TicketMessageId: ticketMessageId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDefaultMessageContent( _request, _options );
    }


    private async _GetTicketMessageWithEmbeddedData(request: carriers.Ticket_GetTicketMessageWithEmbeddedDataRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketMessageEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketMessageWithEmbeddedData", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketMessageEntity = converters.Create_TicketMessageEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a ticket message entity with posibillity to change embedded images to be represented with inline data within the HTML body. If using inline data, be sure not to save this back to the database.
     * @param request - Id, EmbedImages
     * @returns The entity to get
     */
    public async GetTicketMessageWithEmbeddedData(request: carriers.Ticket_GetTicketMessageWithEmbeddedDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;

    /**
     * Get a ticket message entity with posibillity to change embedded images to be represented with inline data within the HTML body. If using inline data, be sure not to save this back to the database.
     * @param id - The id of the ticket message entity
     * @param embedImages - If set to Inline, then use inline base64 data to represent the images in the HTML body. Default: Link will use link to the image.
     * @returns The entity to get
     */
    public async GetTicketMessageWithEmbeddedData(id: number, embedImages: enums.ImageEmbedType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;

    public async GetTicketMessageWithEmbeddedData(id:number|carriers.Ticket_GetTicketMessageWithEmbeddedDataRequest, embedImages?:enums.ImageEmbedType|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        let _request : carriers.Ticket_GetTicketMessageWithEmbeddedDataRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' || typeof(first.EmbedImages)!='undefined' ) )
        {
            _request = id as carriers.Ticket_GetTicketMessageWithEmbeddedDataRequest;
            _options = embedImages as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       EmbedImages: embedImages as enums.ImageEmbedType,
                       };   
            _options = webapi_options;
        }
        return this._GetTicketMessageWithEmbeddedData( _request, _options );
    }


    private async _DeleteMessageHeaders(request: carriers.Ticket_DeleteMessageHeadersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteMessageHeaders", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes headers from the message as specified in the collection of entity ids. The ids are message header ids (message header primary key)
     * @param request - HeaderIds
     * @returns This method has no return value
     */
    public async DeleteMessageHeaders(request: carriers.Ticket_DeleteMessageHeadersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Removes headers from the message as specified in the collection of entity ids. The ids are message header ids (message header primary key)
     * @param headerIds - Message header primary keys
     * @returns This method has no return value
     */
    public async DeleteMessageHeaders(headerIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteMessageHeaders(headerIds:number[]|carriers.Ticket_DeleteMessageHeadersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Ticket_DeleteMessageHeadersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = headerIds;
        if( typeof( first ) === "object" && first && ( typeof(first.HeaderIds)!='undefined' ) )
        {
            _request = headerIds as carriers.Ticket_DeleteMessageHeadersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       HeaderIds: headerIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeleteMessageHeaders( _request, _options );
    }


    private async _GetTicketMessageWithOptions(request: carriers.Ticket_GetTicketMessageWithOptionsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketMessageEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketMessageWithOptions", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketMessageEntity = converters.Create_TicketMessageEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a ticket message entity with additional options.
     * @param request - TicketMessageEntityId, IncludeNonInlineAttachmentsInfo
     * @returns The entity to get
     */
    public async GetTicketMessageWithOptions(request: carriers.Ticket_GetTicketMessageWithOptionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;

    /**
     * Get a ticket message entity with additional options.
     * @param ticketMessageEntityId - The id of the ticket message entity
     * @param includeNonInlineAttachmentsInfo - If true, then non inline attachments info will be loaded into TicketMessageEntity
     * @returns The entity to get
     */
    public async GetTicketMessageWithOptions(ticketMessageEntityId: number, includeNonInlineAttachmentsInfo: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity >;

    public async GetTicketMessageWithOptions(ticketMessageEntityId:number|carriers.Ticket_GetTicketMessageWithOptionsRequest, includeNonInlineAttachmentsInfo?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketMessageEntity > {
        let _request : carriers.Ticket_GetTicketMessageWithOptionsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketMessageEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketMessageEntityId)!='undefined' || typeof(first.IncludeNonInlineAttachmentsInfo)!='undefined' ) )
        {
            _request = ticketMessageEntityId as carriers.Ticket_GetTicketMessageWithOptionsRequest;
            _options = includeNonInlineAttachmentsInfo as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketMessageEntityId: ticketMessageEntityId as number,
                       IncludeNonInlineAttachmentsInfo: includeNonInlineAttachmentsInfo as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetTicketMessageWithOptions( _request, _options );
    }


    private async _GetTicketSummaries(request: carriers.Ticket_GetTicketSummariesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketSummaryItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketSummaryItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketSummaries", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketSummaryItem[] = converters.Create_TicketSummaryItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an array of summaryitem for the given tickets
     * @param request - TicketIds
     * @returns Summary items for the given id's, in no particular order
     */
    public async GetTicketSummaries(request: carriers.Ticket_GetTicketSummariesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketSummaryItem[] >;

    /**
     * Get an array of summaryitem for the given tickets
     * @param ticketIds - The tickets to fetch summaries for
     * @returns Summary items for the given id's, in no particular order
     */
    public async GetTicketSummaries(ticketIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketSummaryItem[] >;

    public async GetTicketSummaries(ticketIds:number[]|carriers.Ticket_GetTicketSummariesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketSummaryItem[] > {
        let _request : carriers.Ticket_GetTicketSummariesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketIds;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketIds)!='undefined' ) )
        {
            _request = ticketIds as carriers.Ticket_GetTicketSummariesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketIds: ticketIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetTicketSummaries( _request, _options );
    }

    } // class v1TicketAgentController 



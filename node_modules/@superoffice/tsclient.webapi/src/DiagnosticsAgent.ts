// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/DiagnosticsAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Diagnostics, usage data collection, caches and flushing
 */
export interface IDiagnosticsAgent {
    FlushCaches(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetCacheNames(webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    FlushCachesByName(request: carriers.Diagnostics_FlushCachesByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    FlushCachesByName(cacheNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetCacheState(request: carriers.Diagnostics_GetCacheStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCacheState(cacheNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetEntityCountsForCurrentUser(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EntityCounts[] >;
    LogViewState(request: carriers.Diagnostics_LogViewStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    LogViewState(viewState: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangeLogSettings(request: carriers.Diagnostics_ChangeLogSettingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ChangeLogSettings(logWarning: boolean, logInformation: boolean, logSuccessAudit: boolean, logFailureAudit: boolean, logToEventLog: boolean, logToSuperOffice: boolean, logToFile: boolean, logToTrace: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CollectDataAdditions(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CollectWinUsage(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CollectWebUsage(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CollectTableSizes(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ResyncUsers(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    PerformTasksAfterUpgrade(webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    AddWebAppUsage(request: carriers.Diagnostics_AddWebAppUsageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddWebAppUsage(webAppUsages: carriers.WebAppUsage[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    WebAppUsageExistsInPeriod(request: carriers.Diagnostics_WebAppUsageExistsInPeriodRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    WebAppUsageExistsInPeriod(associateId: number, viewState: string, fromDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetWebAppUsagesForPeriod(request: carriers.Diagnostics_GetWebAppUsagesForPeriodRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebAppUsage[] >;
    GetWebAppUsagesForPeriod(fromDate: Date, toDate: Date, searchTerm: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebAppUsage[] >;
} // interface IDiagnosticsAgent




/**
 * Diagnostics, usage data collection, caches and flushing
 */
export class DiagnosticsAgent extends base.WebApiBase implements IDiagnosticsAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Diagnostics/";
        super(options);
    }



    private async _FlushCaches( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FlushCaches", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Flushes all NetServer caches
     * @returns 
     */
    public async FlushCaches(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._FlushCaches(webapi_options);
    }


    private async _GetCacheNames( options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCacheNames", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the name of the caches that can be flushed
     * @returns Name of the caches that can be flusehd
     */
    public async GetCacheNames(webapi_options?:base.WebApiRequestOptions) : Promise< string[] >
    {
        return this._GetCacheNames(webapi_options);
    }


    private async _FlushCachesByName(request: carriers.Diagnostics_FlushCachesByNameRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FlushCachesByName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Flushes all NetServer caches named
     * @param request - CacheNames
     * @returns This method has no return value
     */
    public async FlushCachesByName(request: carriers.Diagnostics_FlushCachesByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Flushes all NetServer caches named
     * @param cacheNames - Name of the cachnes to flush
     * @returns This method has no return value
     */
    public async FlushCachesByName(cacheNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async FlushCachesByName(cacheNames:string[]|carriers.Diagnostics_FlushCachesByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Diagnostics_FlushCachesByNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = cacheNames;
        if( typeof( first ) === "object" && first && ( typeof(first.CacheNames)!='undefined' ) )
        {
            _request = cacheNames as carriers.Diagnostics_FlushCachesByNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       CacheNames: cacheNames as string[],
                       };   
            _options = webapi_options;
        }
        return this._FlushCachesByName( _request, _options );
    }


    private async _GetCacheState(request: carriers.Diagnostics_GetCacheStateRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCacheState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the current generation value of the named caches. State is opaque.
     * @param request - CacheNames
     * @returns Current state of the caches named. If not the same as previous value, then it is time to flush
     */
    public async GetCacheState(request: carriers.Diagnostics_GetCacheStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the current generation value of the named caches. State is opaque.
     * @param cacheNames - Names of the caches to check
     * @returns Current state of the caches named. If not the same as previous value, then it is time to flush
     */
    public async GetCacheState(cacheNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetCacheState(cacheNames:string[]|carriers.Diagnostics_GetCacheStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Diagnostics_GetCacheStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = cacheNames;
        if( typeof( first ) === "object" && first && ( typeof(first.CacheNames)!='undefined' ) )
        {
            _request = cacheNames as carriers.Diagnostics_GetCacheStateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       CacheNames: cacheNames as string[],
                       };   
            _options = webapi_options;
        }
        return this._GetCacheState( _request, _options );
    }


    private async _GetEntityCountsForCurrentUser( options?:base.WebApiRequestOptions) : Promise< carriers.EntityCounts[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EntityCounts[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEntityCountsForCurrentUser", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EntityCounts[] = converters.Create_EntityCountsArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get an array of entities and number of entities created for the current associate
     * @returns Array of EntityCounts[] for the current associate
     */
    public async GetEntityCountsForCurrentUser(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EntityCounts[] >
    {
        return this._GetEntityCountsForCurrentUser(webapi_options);
    }


    private async _LogViewState(request: carriers.Diagnostics_LogViewStateRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("LogViewState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Log a change in view state. The granularity of the logging depends on the current configuration. This call returns asynchronously, leaving the server to finish processing later on.
     * @param request - ViewState
     * @returns 
     */
    public async LogViewState(request: carriers.Diagnostics_LogViewStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Log a change in view state. The granularity of the logging depends on the current configuration. This call returns asynchronously, leaving the server to finish processing later on.
     * @param viewState - Current view state to be logged
     * @returns 
     */
    public async LogViewState(viewState: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async LogViewState(viewState:string|carriers.Diagnostics_LogViewStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Diagnostics_LogViewStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = viewState;
        if( typeof( first ) === "object" && first && ( typeof(first.ViewState)!='undefined' ) )
        {
            _request = viewState as carriers.Diagnostics_LogViewStateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ViewState: viewState as string,
                       };   
            _options = webapi_options;
        }
        return this._LogViewState( _request, _options );
    }


    private async _ChangeLogSettings(request: carriers.Diagnostics_ChangeLogSettingsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeLogSettings", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change NetServer log settings.
     * @param request - LogWarning, LogInformation, LogSuccessAudit, LogFailureAudit, LogToEventLog, LogToSuperOffice, LogToFile, LogToTrace
     * @returns 
     */
    public async ChangeLogSettings(request: carriers.Diagnostics_ChangeLogSettingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Change NetServer log settings.
     * @param logWarning - Turn on warning log
     * @param logInformation - Turn on information log
     * @param logSuccessAudit - Turn on success audit log
     * @param logFailureAudit - Turn on failure audit log
     * @param logToEventLog - Log to event log
     * @param logToSuperOffice - Log to SuperOffice
     * @param logToFile - Log to file
     * @param logToTrace - Log to trace
     * @returns 
     */
    public async ChangeLogSettings(logWarning: boolean, logInformation: boolean, logSuccessAudit: boolean, logFailureAudit: boolean, logToEventLog: boolean, logToSuperOffice: boolean, logToFile: boolean, logToTrace: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async ChangeLogSettings(logWarning:boolean|carriers.Diagnostics_ChangeLogSettingsRequest, logInformation?:boolean|base.WebApiRequestOptions, logSuccessAudit?:boolean, logFailureAudit?:boolean, logToEventLog?:boolean, logToSuperOffice?:boolean, logToFile?:boolean, logToTrace?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Diagnostics_ChangeLogSettingsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = logWarning;
        if( typeof( first ) === "object" && first && ( typeof(first.LogWarning)!='undefined' || typeof(first.LogInformation)!='undefined' || typeof(first.LogSuccessAudit)!='undefined' || typeof(first.LogFailureAudit)!='undefined' || typeof(first.LogToEventLog)!='undefined' || typeof(first.LogToSuperOffice)!='undefined' || typeof(first.LogToFile)!='undefined' || typeof(first.LogToTrace)!='undefined' ) )
        {
            _request = logWarning as carriers.Diagnostics_ChangeLogSettingsRequest;
            _options = logInformation as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       LogWarning: logWarning as boolean,
                       LogInformation: logInformation as boolean,
                       LogSuccessAudit: logSuccessAudit as boolean,
                       LogFailureAudit: logFailureAudit as boolean,
                       LogToEventLog: logToEventLog as boolean,
                       LogToSuperOffice: logToSuperOffice as boolean,
                       LogToFile: logToFile as boolean,
                       LogToTrace: logToTrace as boolean,
                       };   
            _options = webapi_options;
        }
        return this._ChangeLogSettings( _request, _options );
    }


    private async _CollectDataAdditions( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CollectDataAdditions", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Collect and transmit usage statistics: Database Additions. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    public async CollectDataAdditions(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._CollectDataAdditions(webapi_options);
    }


    private async _CollectWinUsage( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CollectWinUsage", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Collect and transmit usage statistics: Windows CRM Client Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    public async CollectWinUsage(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._CollectWinUsage(webapi_options);
    }


    private async _CollectWebUsage( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CollectWebUsage", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Collect and transmit usage statistics: Web-based clients Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    public async CollectWebUsage(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._CollectWebUsage(webapi_options);
    }


    private async _CollectTableSizes( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CollectTableSizes", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Collect and transmit usage statistics: Table Sizes. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    public async CollectTableSizes(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._CollectTableSizes(webapi_options);
    }


    private async _ResyncUsers( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResyncUsers", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Resynchronize user information with SuperOffice Community, if opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    public async ResyncUsers(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._ResyncUsers(webapi_options);
    }


    private async _PerformTasksAfterUpgrade( options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PerformTasksAfterUpgrade", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * After upgrading to a new fileset, there may be tasks that need to be done. Examples - import new TypicalSearches, if present. Tasks performed here need to be idempotent and independent of the actual upgrade jump (what was the previous version). They should complete in a reasonable time, not more than a few minutes maximum.
     * @returns Message that can be shown to the user, summarizing what has been done, if anything.
     */
    public async PerformTasksAfterUpgrade(webapi_options?:base.WebApiRequestOptions) : Promise< string >
    {
        return this._PerformTasksAfterUpgrade(webapi_options);
    }


    private async _AddWebAppUsage(request: carriers.Diagnostics_AddWebAppUsageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddWebAppUsage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Adds WebApp usage to existing log
     * @param request - WebAppUsages
     * @returns 
     */
    public async AddWebAppUsage(request: carriers.Diagnostics_AddWebAppUsageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Adds WebApp usage to existing log
     * @param webAppUsages - Web app usage.
     * @returns 
     */
    public async AddWebAppUsage(webAppUsages: carriers.WebAppUsage[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddWebAppUsage(webAppUsages:carriers.WebAppUsage[]|carriers.Diagnostics_AddWebAppUsageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Diagnostics_AddWebAppUsageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = webAppUsages;
        if( typeof( first ) === "object" && first && ( typeof(first.WebAppUsages)!='undefined' ) )
        {
            _request = webAppUsages as carriers.Diagnostics_AddWebAppUsageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       WebAppUsages: webAppUsages as carriers.WebAppUsage[],
                       };   
            _options = webapi_options;
        }
        return this._AddWebAppUsage( _request, _options );
    }


    private async _WebAppUsageExistsInPeriod(request: carriers.Diagnostics_WebAppUsageExistsInPeriodRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("WebAppUsageExistsInPeriod", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns true if viewState has been clicked at least once since FromDate, if asscoiateId &lt; 0 or FromDate is DateTime.MinValue no restriction given for those parameters
     * @param request - AssociateId, ViewState, FromDate
     * @returns Returns true if viewState has been clicked at least once since FromDate
     */
    public async WebAppUsageExistsInPeriod(request: carriers.Diagnostics_WebAppUsageExistsInPeriodRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Returns true if viewState has been clicked at least once since FromDate, if asscoiateId &lt; 0 or FromDate is DateTime.MinValue no restriction given for those parameters
     * @param associateId - The asscoiate id to look for webapp usage
     * @param viewState - The viewState to search for
     * @param fromDate - The datetime to restrict webapp usage on
     * @returns Returns true if viewState has been clicked at least once since FromDate
     */
    public async WebAppUsageExistsInPeriod(associateId: number, viewState: string, fromDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async WebAppUsageExistsInPeriod(associateId:number|carriers.Diagnostics_WebAppUsageExistsInPeriodRequest, viewState?:string|base.WebApiRequestOptions, fromDate?:Date, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Diagnostics_WebAppUsageExistsInPeriodRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.ViewState)!='undefined' || typeof(first.FromDate)!='undefined' ) )
        {
            _request = associateId as carriers.Diagnostics_WebAppUsageExistsInPeriodRequest;
            _options = viewState as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       ViewState: viewState as string,
                       FromDate: fromDate as Date,
                       };   
            _options = webapi_options;
        }
        return this._WebAppUsageExistsInPeriod( _request, _options );
    }


    private async _GetWebAppUsagesForPeriod(request: carriers.Diagnostics_GetWebAppUsagesForPeriodRequest, options?:base.WebApiRequestOptions) : Promise< carriers.WebAppUsage[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.WebAppUsage[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWebAppUsagesForPeriod", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.WebAppUsage[] = converters.Create_WebAppUsageArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all WebAppUsages for a given period, that match an optional search term
     * @param request - FromDate, ToDate, SearchTerm
     * @returns 
     */
    public async GetWebAppUsagesForPeriod(request: carriers.Diagnostics_GetWebAppUsagesForPeriodRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebAppUsage[] >;

    /**
     * Get all WebAppUsages for a given period, that match an optional search term
     * @param fromDate - 
     * @param toDate - 
     * @param searchTerm - ViewState search term. '%' is the wildcard character, for example 'Pocket%' will match all viewstates starting with 'Pocket'. If empty, all viewstates will be matched
     * @returns 
     */
    public async GetWebAppUsagesForPeriod(fromDate: Date, toDate: Date, searchTerm: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebAppUsage[] >;

    public async GetWebAppUsagesForPeriod(fromDate:Date|carriers.Diagnostics_GetWebAppUsagesForPeriodRequest, toDate?:Date|base.WebApiRequestOptions, searchTerm?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.WebAppUsage[] > {
        let _request : carriers.Diagnostics_GetWebAppUsagesForPeriodRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = fromDate;
        if( typeof( first ) === "object" && first && ( typeof(first.FromDate)!='undefined' || typeof(first.ToDate)!='undefined' || typeof(first.SearchTerm)!='undefined' ) )
        {
            _request = fromDate as carriers.Diagnostics_GetWebAppUsagesForPeriodRequest;
            _options = toDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FromDate: fromDate as Date,
                       ToDate: toDate as Date,
                       SearchTerm: searchTerm as string,
                       };   
            _options = webapi_options;
        }
        return this._GetWebAppUsagesForPeriod( _request, _options );
    }

    } // class v1DiagnosticsAgentController 



// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/BatchAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Start, stop and monitor predefined batch tasks
 */
export interface IBatchAgent {
    GetBatchTaskInfo(request: carriers.Batch_GetBatchTaskInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    GetBatchTaskInfo(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    GetBatchTaskInfosByAssociates(request: carriers.Batch_GetBatchTaskInfosByAssociatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetBatchTaskInfosByAssociates(associateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    StartBatchJob(request: carriers.Batch_StartBatchJobRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    StartBatchJob(batchTaskInfo: carriers.BatchTaskInfo, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    StopBatchJob(request: carriers.Batch_StopBatchJobRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    StopBatchJob(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetBatchTaskInfosByState(request: carriers.Batch_GetBatchTaskInfosByStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetBatchTaskInfosByState(state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    UpdateBatchTask(request: carriers.Batch_UpdateBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    UpdateBatchTask(batchTaskInfo: carriers.BatchTaskInfo, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    GetBatchTaskInfosByNameAndState(request: carriers.Batch_GetBatchTaskInfosByNameAndStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetBatchTaskInfosByNameAndState(name: string, state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetBatchTaskInfosByNameAndAssociates(request: carriers.Batch_GetBatchTaskInfosByNameAndAssociatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetBatchTaskInfosByNameAndAssociates(name: string, associateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetBatchTaskInfosByAssociatesAndState(request: carriers.Batch_GetBatchTaskInfosByAssociatesAndStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetBatchTaskInfosByAssociatesAndState(associateIds: number[], state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    DeleteBatchTasks(request: carriers.Batch_DeleteBatchTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteBatchTasks(batchTaskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteBatchTask(request: carriers.Batch_DeleteBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteBatchTask(batchTaskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetAllBatchTaskInfosByName(request: carriers.Batch_GetAllBatchTaskInfosByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetAllBatchTaskInfosByName(taskName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetAllBatchTaskInfosByNameAndState(request: carriers.Batch_GetAllBatchTaskInfosByNameAndStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetAllBatchTaskInfosByNameAndState(taskName: string, state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetSystemBatchTaskInfosByName(request: carriers.Batch_GetSystemBatchTaskInfosByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetSystemBatchTaskInfosByName(taskName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetSystemBatchTaskInfosByNameAndState(request: carriers.Batch_GetSystemBatchTaskInfosByNameAndStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
    GetSystemBatchTaskInfosByNameAndState(taskName: string, state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;
} // interface IBatchAgent




/**
 * Start, stop and monitor predefined batch tasks
 */
export class BatchAgent extends base.WebApiBase implements IBatchAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Batch/";
        super(options);
    }



    private async _GetBatchTaskInfo(request: carriers.Batch_GetBatchTaskInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBatchTaskInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo = converters.Create_BatchTaskInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a single BatchTaskInfo based on Id.
     * @param request - Id
     * @returns Returns a BatchTaskInfo.
     */
    public async GetBatchTaskInfo(request: carriers.Batch_GetBatchTaskInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    /**
     * Get a single BatchTaskInfo based on Id.
     * @param id - Id of the BatchTaskInfo to get.
     * @returns Returns a BatchTaskInfo.
     */
    public async GetBatchTaskInfo(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    public async GetBatchTaskInfo(id:number|carriers.Batch_GetBatchTaskInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        let _request : carriers.Batch_GetBatchTaskInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.Batch_GetBatchTaskInfoRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._GetBatchTaskInfo( _request, _options );
    }


    private async _GetBatchTaskInfosByAssociates(request: carriers.Batch_GetBatchTaskInfosByAssociatesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBatchTaskInfosByAssociates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo[] = converters.Create_BatchTaskInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an array of BatchTaskInfo for the provided associate id&apos;s.
     * @param request - AssociateIds
     * @returns Returns an array of user's BatchTaskInfo.
     */
    public async GetBatchTaskInfosByAssociates(request: carriers.Batch_GetBatchTaskInfosByAssociatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    /**
     * Get an array of BatchTaskInfo for the provided associate id&apos;s.
     * @param associateIds - Array of associate id's. empty array = all tasks, 0 = system tasks, -1 = all user tasks.
     * @returns Returns an array of user's BatchTaskInfo.
     */
    public async GetBatchTaskInfosByAssociates(associateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    public async GetBatchTaskInfosByAssociates(associateIds:number[]|carriers.Batch_GetBatchTaskInfosByAssociatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        let _request : carriers.Batch_GetBatchTaskInfosByAssociatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateIds)!='undefined' ) )
        {
            _request = associateIds as carriers.Batch_GetBatchTaskInfosByAssociatesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateIds: associateIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetBatchTaskInfosByAssociates( _request, _options );
    }


    private async _StartBatchJob(request: carriers.Batch_StartBatchJobRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("StartBatchJob", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Start a batch job based on BatchTaskInfo.
     * @param request - BatchTaskInfo
     * @returns Returns the id of the created batch job.
     */
    public async StartBatchJob(request: carriers.Batch_StartBatchJobRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Start a batch job based on BatchTaskInfo.
     * @param batchTaskInfo - Use BatchTaskInfo to describe the new batch job.
     * @returns Returns the id of the created batch job.
     */
    public async StartBatchJob(batchTaskInfo: carriers.BatchTaskInfo, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async StartBatchJob(batchTaskInfo:carriers.BatchTaskInfo|carriers.Batch_StartBatchJobRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Batch_StartBatchJobRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = batchTaskInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.BatchTaskInfo)!='undefined' ) )
        {
            _request = batchTaskInfo as carriers.Batch_StartBatchJobRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       BatchTaskInfo: batchTaskInfo as carriers.BatchTaskInfo,
                       };   
            _options = webapi_options;
        }
        return this._StartBatchJob( _request, _options );
    }


    private async _StopBatchJob(request: carriers.Batch_StopBatchJobRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("StopBatchJob", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Stop a batch job based on Id.
     * @param request - Id
     * @returns Returns true if the job was stopped successfully.
     */
    public async StopBatchJob(request: carriers.Batch_StopBatchJobRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Stop a batch job based on Id.
     * @param id - Id of the batch job to stop.
     * @returns Returns true if the job was stopped successfully.
     */
    public async StopBatchJob(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async StopBatchJob(id:number|carriers.Batch_StopBatchJobRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Batch_StopBatchJobRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.Batch_StopBatchJobRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._StopBatchJob( _request, _options );
    }


    private async _GetBatchTaskInfosByState(request: carriers.Batch_GetBatchTaskInfosByStateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBatchTaskInfosByState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo[] = converters.Create_BatchTaskInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets an array of user BatchTaskInfo with state defined by a BatchTaskState.
     * @param request - State
     * @returns Returns an array of user BatchTaskInfo. System tasks are excluded.
     */
    public async GetBatchTaskInfosByState(request: carriers.Batch_GetBatchTaskInfosByStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    /**
     * Gets an array of user BatchTaskInfo with state defined by a BatchTaskState.
     * @param state - The BatchTaskState to get batch tasks for.
     * @returns Returns an array of user BatchTaskInfo. System tasks are excluded.
     */
    public async GetBatchTaskInfosByState(state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    public async GetBatchTaskInfosByState(state:enums.BatchTaskState|carriers.Batch_GetBatchTaskInfosByStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        let _request : carriers.Batch_GetBatchTaskInfosByStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = state;
        if( typeof( first ) === "object" && first && ( typeof(first.State)!='undefined' ) )
        {
            _request = state as carriers.Batch_GetBatchTaskInfosByStateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       State: state as enums.BatchTaskState,
                       };   
            _options = webapi_options;
        }
        return this._GetBatchTaskInfosByState( _request, _options );
    }


    private async _UpdateBatchTask(request: carriers.Batch_UpdateBatchTaskRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateBatchTask", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo = converters.Create_BatchTaskInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update information about a BatchTask. Only the following properties can be updated: State, Description, Response and Request.
     * @param request - BatchTaskInfo
     * @returns The updated BatchTaskInfo
     */
    public async UpdateBatchTask(request: carriers.Batch_UpdateBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    /**
     * Update information about a BatchTask. Only the following properties can be updated: State, Description, Response and Request.
     * @param batchTaskInfo - The updated information to save.
     * @returns The updated BatchTaskInfo
     */
    public async UpdateBatchTask(batchTaskInfo: carriers.BatchTaskInfo, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    public async UpdateBatchTask(batchTaskInfo:carriers.BatchTaskInfo|carriers.Batch_UpdateBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        let _request : carriers.Batch_UpdateBatchTaskRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = batchTaskInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.BatchTaskInfo)!='undefined' ) )
        {
            _request = batchTaskInfo as carriers.Batch_UpdateBatchTaskRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       BatchTaskInfo: batchTaskInfo as carriers.BatchTaskInfo,
                       };   
            _options = webapi_options;
        }
        return this._UpdateBatchTask( _request, _options );
    }


    private async _GetBatchTaskInfosByNameAndState(request: carriers.Batch_GetBatchTaskInfosByNameAndStateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBatchTaskInfosByNameAndState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo[] = converters.Create_BatchTaskInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets an array of user BatchTaskInfo with state defined by a BatchTaskState and the batchtask definition name.
     * @param request - Name, State
     * @returns Returns an array of user BatchTaskInfo. System tasks are excluded.
     */
    public async GetBatchTaskInfosByNameAndState(request: carriers.Batch_GetBatchTaskInfosByNameAndStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    /**
     * Gets an array of user BatchTaskInfo with state defined by a BatchTaskState and the batchtask definition name.
     * @param name - Batchtask definition name. Blank for all tasks.
     * @param state - The BatchTaskState to get batch tasks for.
     * @returns Returns an array of user BatchTaskInfo. System tasks are excluded.
     */
    public async GetBatchTaskInfosByNameAndState(name: string, state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    public async GetBatchTaskInfosByNameAndState(name:string|carriers.Batch_GetBatchTaskInfosByNameAndStateRequest, state?:enums.BatchTaskState|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        let _request : carriers.Batch_GetBatchTaskInfosByNameAndStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' || typeof(first.State)!='undefined' ) )
        {
            _request = name as carriers.Batch_GetBatchTaskInfosByNameAndStateRequest;
            _options = state as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       State: state as enums.BatchTaskState,
                       };   
            _options = webapi_options;
        }
        return this._GetBatchTaskInfosByNameAndState( _request, _options );
    }


    private async _GetBatchTaskInfosByNameAndAssociates(request: carriers.Batch_GetBatchTaskInfosByNameAndAssociatesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBatchTaskInfosByNameAndAssociates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo[] = converters.Create_BatchTaskInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an array of BatchTaskInfo for the provided associate id&apos;s and batch task definition name.
     * @param request - Name, AssociateIds
     * @returns Returns an array of BatchTaskInfo.
     */
    public async GetBatchTaskInfosByNameAndAssociates(request: carriers.Batch_GetBatchTaskInfosByNameAndAssociatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    /**
     * Get an array of BatchTaskInfo for the provided associate id&apos;s and batch task definition name.
     * @param name - Batchtask definition name. Blank for all tasks.
     * @param associateIds - Array of associate id's. Empty array for all. 0 for system tasks, -1 for all users, or specific user ids.
     * @returns Returns an array of BatchTaskInfo.
     */
    public async GetBatchTaskInfosByNameAndAssociates(name: string, associateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    public async GetBatchTaskInfosByNameAndAssociates(name:string|carriers.Batch_GetBatchTaskInfosByNameAndAssociatesRequest, associateIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        let _request : carriers.Batch_GetBatchTaskInfosByNameAndAssociatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' || typeof(first.AssociateIds)!='undefined' ) )
        {
            _request = name as carriers.Batch_GetBatchTaskInfosByNameAndAssociatesRequest;
            _options = associateIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       AssociateIds: associateIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetBatchTaskInfosByNameAndAssociates( _request, _options );
    }


    private async _GetBatchTaskInfosByAssociatesAndState(request: carriers.Batch_GetBatchTaskInfosByAssociatesAndStateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBatchTaskInfosByAssociatesAndState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo[] = converters.Create_BatchTaskInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an array of BatchTaskInfo for the provided associate id&apos;s and batch task state.
     * @param request - AssociateIds, State
     * @returns Returns an array of BatchTaskInfo.
     */
    public async GetBatchTaskInfosByAssociatesAndState(request: carriers.Batch_GetBatchTaskInfosByAssociatesAndStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    /**
     * Get an array of BatchTaskInfo for the provided associate id&apos;s and batch task state.
     * @param associateIds - Array of associate id's. Empty array for all. 0 for system tasks, -1 for all users, or specific user ids.
     * @param state - The BatchTaskState to get batch tasks for.
     * @returns Returns an array of BatchTaskInfo.
     */
    public async GetBatchTaskInfosByAssociatesAndState(associateIds: number[], state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    public async GetBatchTaskInfosByAssociatesAndState(associateIds:number[]|carriers.Batch_GetBatchTaskInfosByAssociatesAndStateRequest, state?:enums.BatchTaskState|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        let _request : carriers.Batch_GetBatchTaskInfosByAssociatesAndStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateIds)!='undefined' || typeof(first.State)!='undefined' ) )
        {
            _request = associateIds as carriers.Batch_GetBatchTaskInfosByAssociatesAndStateRequest;
            _options = state as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateIds: associateIds as number[],
                       State: state as enums.BatchTaskState,
                       };   
            _options = webapi_options;
        }
        return this._GetBatchTaskInfosByAssociatesAndState( _request, _options );
    }


    private async _DeleteBatchTasks(request: carriers.Batch_DeleteBatchTasksRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteBatchTasks", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete batch tasks from the database.
     * @param request - BatchTaskIds
     * @returns 
     */
    public async DeleteBatchTasks(request: carriers.Batch_DeleteBatchTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete batch tasks from the database.
     * @param batchTaskIds - Array of batchTask ids to delete.
     * @returns 
     */
    public async DeleteBatchTasks(batchTaskIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteBatchTasks(batchTaskIds:number[]|carriers.Batch_DeleteBatchTasksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Batch_DeleteBatchTasksRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = batchTaskIds;
        if( typeof( first ) === "object" && first && ( typeof(first.BatchTaskIds)!='undefined' ) )
        {
            _request = batchTaskIds as carriers.Batch_DeleteBatchTasksRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       BatchTaskIds: batchTaskIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeleteBatchTasks( _request, _options );
    }


    private async _DeleteBatchTask(request: carriers.Batch_DeleteBatchTaskRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteBatchTask", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a batch task from the database.
     * @param request - BatchTaskId
     * @returns 
     */
    public async DeleteBatchTask(request: carriers.Batch_DeleteBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a batch task from the database.
     * @param batchTaskId - The batchTask id to delete.
     * @returns 
     */
    public async DeleteBatchTask(batchTaskId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteBatchTask(batchTaskId:number|carriers.Batch_DeleteBatchTaskRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Batch_DeleteBatchTaskRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = batchTaskId;
        if( typeof( first ) === "object" && first && ( typeof(first.BatchTaskId)!='undefined' ) )
        {
            _request = batchTaskId as carriers.Batch_DeleteBatchTaskRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       BatchTaskId: batchTaskId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteBatchTask( _request, _options );
    }


    private async _GetAllBatchTaskInfosByName(request: carriers.Batch_GetAllBatchTaskInfosByNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllBatchTaskInfosByName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo[] = converters.Create_BatchTaskInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an array of system and user BatchTaskInfo for the provided task name.
     * @param request - TaskName
     * @returns Returns an array of user and system BatchTaskInfos.
     */
    public async GetAllBatchTaskInfosByName(request: carriers.Batch_GetAllBatchTaskInfosByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    /**
     * Get an array of system and user BatchTaskInfo for the provided task name.
     * @param taskName - A task name, NULL or blank to get all tasks
     * @returns Returns an array of user and system BatchTaskInfos.
     */
    public async GetAllBatchTaskInfosByName(taskName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    public async GetAllBatchTaskInfosByName(taskName:string|carriers.Batch_GetAllBatchTaskInfosByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        let _request : carriers.Batch_GetAllBatchTaskInfosByNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = taskName;
        if( typeof( first ) === "object" && first && ( typeof(first.TaskName)!='undefined' ) )
        {
            _request = taskName as carriers.Batch_GetAllBatchTaskInfosByNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TaskName: taskName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetAllBatchTaskInfosByName( _request, _options );
    }


    private async _GetAllBatchTaskInfosByNameAndState(request: carriers.Batch_GetAllBatchTaskInfosByNameAndStateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllBatchTaskInfosByNameAndState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo[] = converters.Create_BatchTaskInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an array of system and user BatchTaskInfo for the provided task name and state.
     * @param request - TaskName, State
     * @returns Returns an array of user and system BatchTaskInfos.
     */
    public async GetAllBatchTaskInfosByNameAndState(request: carriers.Batch_GetAllBatchTaskInfosByNameAndStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    /**
     * Get an array of system and user BatchTaskInfo for the provided task name and state.
     * @param taskName - A task name, NULL or blank to get all tasks
     * @param state - The BatchTaskState to get batch tasks for.
     * @returns Returns an array of user and system BatchTaskInfos.
     */
    public async GetAllBatchTaskInfosByNameAndState(taskName: string, state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    public async GetAllBatchTaskInfosByNameAndState(taskName:string|carriers.Batch_GetAllBatchTaskInfosByNameAndStateRequest, state?:enums.BatchTaskState|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        let _request : carriers.Batch_GetAllBatchTaskInfosByNameAndStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = taskName;
        if( typeof( first ) === "object" && first && ( typeof(first.TaskName)!='undefined' || typeof(first.State)!='undefined' ) )
        {
            _request = taskName as carriers.Batch_GetAllBatchTaskInfosByNameAndStateRequest;
            _options = state as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TaskName: taskName as string,
                       State: state as enums.BatchTaskState,
                       };   
            _options = webapi_options;
        }
        return this._GetAllBatchTaskInfosByNameAndState( _request, _options );
    }


    private async _GetSystemBatchTaskInfosByName(request: carriers.Batch_GetSystemBatchTaskInfosByNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSystemBatchTaskInfosByName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo[] = converters.Create_BatchTaskInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an array of system BatchTaskInfo for the provided task name.
     * @param request - TaskName
     * @returns Returns an array of system BatchTaskInfos.
     */
    public async GetSystemBatchTaskInfosByName(request: carriers.Batch_GetSystemBatchTaskInfosByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    /**
     * Get an array of system BatchTaskInfo for the provided task name.
     * @param taskName - A task name, NULL or blank to get all tasks
     * @returns Returns an array of system BatchTaskInfos.
     */
    public async GetSystemBatchTaskInfosByName(taskName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    public async GetSystemBatchTaskInfosByName(taskName:string|carriers.Batch_GetSystemBatchTaskInfosByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        let _request : carriers.Batch_GetSystemBatchTaskInfosByNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = taskName;
        if( typeof( first ) === "object" && first && ( typeof(first.TaskName)!='undefined' ) )
        {
            _request = taskName as carriers.Batch_GetSystemBatchTaskInfosByNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TaskName: taskName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetSystemBatchTaskInfosByName( _request, _options );
    }


    private async _GetSystemBatchTaskInfosByNameAndState(request: carriers.Batch_GetSystemBatchTaskInfosByNameAndStateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSystemBatchTaskInfosByNameAndState", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo[] = converters.Create_BatchTaskInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an array of system BatchTaskInfo for the provided task name and state.
     * @param request - TaskName, State
     * @returns Returns an array of system BatchTaskInfos.
     */
    public async GetSystemBatchTaskInfosByNameAndState(request: carriers.Batch_GetSystemBatchTaskInfosByNameAndStateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    /**
     * Get an array of system BatchTaskInfo for the provided task name and state.
     * @param taskName - A task name, NULL or blank to get all tasks
     * @param state - The BatchTaskState to get batch tasks for.
     * @returns Returns an array of system BatchTaskInfos.
     */
    public async GetSystemBatchTaskInfosByNameAndState(taskName: string, state: enums.BatchTaskState, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] >;

    public async GetSystemBatchTaskInfosByNameAndState(taskName:string|carriers.Batch_GetSystemBatchTaskInfosByNameAndStateRequest, state?:enums.BatchTaskState|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo[] > {
        let _request : carriers.Batch_GetSystemBatchTaskInfosByNameAndStateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = taskName;
        if( typeof( first ) === "object" && first && ( typeof(first.TaskName)!='undefined' || typeof(first.State)!='undefined' ) )
        {
            _request = taskName as carriers.Batch_GetSystemBatchTaskInfosByNameAndStateRequest;
            _options = state as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TaskName: taskName as string,
                       State: state as enums.BatchTaskState,
                       };   
            _options = webapi_options;
        }
        return this._GetSystemBatchTaskInfosByNameAndState( _request, _options );
    }

    } // class v1BatchAgentController 



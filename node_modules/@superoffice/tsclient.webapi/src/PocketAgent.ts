// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/PocketAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Agent with Pocket specific functionality
 */
export interface IPocketAgent {
    GetMyCallerIDs(request: carriers.Pocket_GetMyCallerIDsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection >;
    GetMyCallerIDs(lastHash: string, minDate: Date, maxDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection >;
    GetCallerIDsFromSelection(request: carriers.Pocket_GetCallerIDsFromSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection >;
    GetCallerIDsFromSelection(selectionId: number, lastHash: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection >;
    GetPocketStartupData(request: carriers.Pocket_GetPocketStartupDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketStartupData >;
    GetPocketStartupData(tables: string[], currentClientTime: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketStartupData >;
    RegisterDeviceForPushNotification(request: carriers.Pocket_RegisterDeviceForPushNotificationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RegisterDeviceForPushNotification(deviceInfo: carriers.PocketDeviceInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetRegisteredDevices(request: carriers.Pocket_GetRegisteredDevicesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketDeviceInfo[] >;
    GetRegisteredDevices(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketDeviceInfo[] >;
    SetPushNotificationTagsForDevice(request: carriers.Pocket_SetPushNotificationTagsForDeviceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetPushNotificationTagsForDevice(deviceIdentifier: string, tags: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetPushNotificationTagsForUser(request: carriers.Pocket_SetPushNotificationTagsForUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetPushNotificationTagsForUser(associateId: number, tags: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPushNotificationTagsForDevice(request: carriers.Pocket_GetPushNotificationTagsForDeviceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetPushNotificationTagsForDevice(deviceIdentifier: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    SendPushNotification(request: carriers.Pocket_SendPushNotificationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SendPushNotification(associateIds: number[], message: carriers.PocketNotificationMessage, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RunAppointmentAlarmBroker(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotifyUsers(request: carriers.Pocket_NotifyUsersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotifyUsers(notificationEventType: enums.NotificationEventType, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotificationHandled(request: carriers.Pocket_NotificationHandledRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotificationHandled(notificationEventType: enums.NotificationEventType, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotificationsHandled(request: carriers.Pocket_NotificationsHandledRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    NotificationsHandled(notificationEvents: carriers.NotificationEvent[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
} // interface IPocketAgent




/**
 * Agent with Pocket specific functionality
 */
export class PocketAgent extends base.WebApiBase implements IPocketAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Pocket/";
        super(options);
    }



    private async _GetMyCallerIDs(request: carriers.Pocket_GetMyCallerIDsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CallerIDCollection >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyCallerIDs", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CallerIDCollection = converters.Create_CallerIDCollection_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get caller ids that the current principal might be interested in (phone numbers of related persons in sales and appointments created/owned/touched by ourselves or colleagues in our primary group
     * @param request - LastHash, MinDate, MaxDate
     * @returns Collection of caller IDs, containing the hash of the caller ids
     */
    public async GetMyCallerIDs(request: carriers.Pocket_GetMyCallerIDsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection >;

    /**
     * Get caller ids that the current principal might be interested in (phone numbers of related persons in sales and appointments created/owned/touched by ourselves or colleagues in our primary group
     * @param lastHash - Hash for the previous call, used for checking if the same set of caller ids was sent in a previous call, and returning null in that case
     * @param minDate - Only check activities after this date
     * @param maxDate - Only check activities before this date
     * @returns Collection of caller IDs, containing the hash of the caller ids
     */
    public async GetMyCallerIDs(lastHash: string, minDate: Date, maxDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection >;

    public async GetMyCallerIDs(lastHash:string|carriers.Pocket_GetMyCallerIDsRequest, minDate?:Date|base.WebApiRequestOptions, maxDate?:Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection > {
        let _request : carriers.Pocket_GetMyCallerIDsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = lastHash;
        if( typeof( first ) === "object" && first && ( typeof(first.LastHash)!='undefined' || typeof(first.MinDate)!='undefined' || typeof(first.MaxDate)!='undefined' ) )
        {
            _request = lastHash as carriers.Pocket_GetMyCallerIDsRequest;
            _options = minDate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       LastHash: lastHash as string,
                       MinDate: minDate as Date,
                       MaxDate: maxDate as Date,
                       };   
            _options = webapi_options;
        }
        return this._GetMyCallerIDs( _request, _options );
    }


    private async _GetCallerIDsFromSelection(request: carriers.Pocket_GetCallerIDsFromSelectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CallerIDCollection >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCallerIDsFromSelection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CallerIDCollection = converters.Create_CallerIDCollection_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get caller ids from a selection. Queries the shadow selection of persons and companies, so selections of any kind can be used
     * @param request - SelectionId, LastHash
     * @returns Collection of caller IDs, containing the hash of the caller ids
     */
    public async GetCallerIDsFromSelection(request: carriers.Pocket_GetCallerIDsFromSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection >;

    /**
     * Get caller ids from a selection. Queries the shadow selection of persons and companies, so selections of any kind can be used
     * @param selectionId - Id of selection to get caller ids from
     * @param lastHash - Hash for the previous call, used for checking if the same set of caller ids was sent in an earlier call, and returning null in that case
     * @returns Collection of caller IDs, containing the hash of the caller ids
     */
    public async GetCallerIDsFromSelection(selectionId: number, lastHash: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection >;

    public async GetCallerIDsFromSelection(selectionId:number|carriers.Pocket_GetCallerIDsFromSelectionRequest, lastHash?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CallerIDCollection > {
        let _request : carriers.Pocket_GetCallerIDsFromSelectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.LastHash)!='undefined' ) )
        {
            _request = selectionId as carriers.Pocket_GetCallerIDsFromSelectionRequest;
            _options = lastHash as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       LastHash: lastHash as string,
                       };   
            _options = webapi_options;
        }
        return this._GetCallerIDsFromSelection( _request, _options );
    }


    private async _GetPocketStartupData(request: carriers.Pocket_GetPocketStartupDataRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PocketStartupData > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PocketStartupData >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPocketStartupData", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PocketStartupData = converters.Create_PocketStartupData_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - Tables, CurrentClientTime
     * @returns Startup data for pocket
     */
    public async GetPocketStartupData(request: carriers.Pocket_GetPocketStartupDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketStartupData >;

    /**
     * 
     * @param tables - Tables to check for license
     * @param currentClientTime - Current time on the client, used for overdue sale lookup having correct timezone relative to client
     * @returns Startup data for pocket
     */
    public async GetPocketStartupData(tables: string[], currentClientTime: Date, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketStartupData >;

    public async GetPocketStartupData(tables:string[]|carriers.Pocket_GetPocketStartupDataRequest, currentClientTime?:Date|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketStartupData > {
        let _request : carriers.Pocket_GetPocketStartupDataRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tables;
        if( typeof( first ) === "object" && first && ( typeof(first.Tables)!='undefined' || typeof(first.CurrentClientTime)!='undefined' ) )
        {
            _request = tables as carriers.Pocket_GetPocketStartupDataRequest;
            _options = currentClientTime as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Tables: tables as string[],
                       CurrentClientTime: currentClientTime as Date,
                       };   
            _options = webapi_options;
        }
        return this._GetPocketStartupData( _request, _options );
    }


    private async _RegisterDeviceForPushNotification(request: carriers.Pocket_RegisterDeviceForPushNotificationRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RegisterDeviceForPushNotification", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Register a device that should receive push notifications when notable events occour
     * @param request - DeviceInfo
     * @returns This method has no return value
     */
    public async RegisterDeviceForPushNotification(request: carriers.Pocket_RegisterDeviceForPushNotificationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Register a device that should receive push notifications when notable events occour
     * @param deviceInfo - Properties for the device to register
     * @returns This method has no return value
     */
    public async RegisterDeviceForPushNotification(deviceInfo: carriers.PocketDeviceInfo, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RegisterDeviceForPushNotification(deviceInfo:carriers.PocketDeviceInfo|carriers.Pocket_RegisterDeviceForPushNotificationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Pocket_RegisterDeviceForPushNotificationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = deviceInfo;
        if( typeof( first ) === "object" && first && ( typeof(first.DeviceInfo)!='undefined' ) )
        {
            _request = deviceInfo as carriers.Pocket_RegisterDeviceForPushNotificationRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DeviceInfo: deviceInfo as carriers.PocketDeviceInfo,
                       };   
            _options = webapi_options;
        }
        return this._RegisterDeviceForPushNotification( _request, _options );
    }


    private async _GetRegisteredDevices(request: carriers.Pocket_GetRegisteredDevicesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PocketDeviceInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PocketDeviceInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRegisteredDevices", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PocketDeviceInfo[] = converters.Create_PocketDeviceInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve all registered devices for an associate
     * @param request - AssociateId
     * @returns 
     */
    public async GetRegisteredDevices(request: carriers.Pocket_GetRegisteredDevicesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketDeviceInfo[] >;

    /**
     * Retrieve all registered devices for an associate
     * @param associateId - The user to get devices for
     * @returns 
     */
    public async GetRegisteredDevices(associateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketDeviceInfo[] >;

    public async GetRegisteredDevices(associateId:number|carriers.Pocket_GetRegisteredDevicesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PocketDeviceInfo[] > {
        let _request : carriers.Pocket_GetRegisteredDevicesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' ) )
        {
            _request = associateId as carriers.Pocket_GetRegisteredDevicesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetRegisteredDevices( _request, _options );
    }


    private async _SetPushNotificationTagsForDevice(request: carriers.Pocket_SetPushNotificationTagsForDeviceRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPushNotificationTagsForDevice", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Specify what kind of notification events a device should receive push notifications for
     * @param request - DeviceIdentifier, Tags
     * @returns This method has no return value
     */
    public async SetPushNotificationTagsForDevice(request: carriers.Pocket_SetPushNotificationTagsForDeviceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Specify what kind of notification events a device should receive push notifications for
     * @param deviceIdentifier - The unique identifier for a device
     * @param tags - A comma separated list of events this device should receive push events for
     * @returns This method has no return value
     */
    public async SetPushNotificationTagsForDevice(deviceIdentifier: string, tags: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetPushNotificationTagsForDevice(deviceIdentifier:string|carriers.Pocket_SetPushNotificationTagsForDeviceRequest, tags?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Pocket_SetPushNotificationTagsForDeviceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = deviceIdentifier;
        if( typeof( first ) === "object" && first && ( typeof(first.DeviceIdentifier)!='undefined' || typeof(first.Tags)!='undefined' ) )
        {
            _request = deviceIdentifier as carriers.Pocket_SetPushNotificationTagsForDeviceRequest;
            _options = tags as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DeviceIdentifier: deviceIdentifier as string,
                       Tags: tags as string,
                       };   
            _options = webapi_options;
        }
        return this._SetPushNotificationTagsForDevice( _request, _options );
    }


    private async _SetPushNotificationTagsForUser(request: carriers.Pocket_SetPushNotificationTagsForUserRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPushNotificationTagsForUser", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Specify what kind of notification events a user should receive push notifications for.  This will update all registerred devices for this user.
     * @param request - AssociateId, Tags
     * @returns This method has no return value
     */
    public async SetPushNotificationTagsForUser(request: carriers.Pocket_SetPushNotificationTagsForUserRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Specify what kind of notification events a user should receive push notifications for.  This will update all registerred devices for this user.
     * @param associateId - The associate to set tags for
     * @param tags - A comma separated list of events the associate should receive push events for
     * @returns This method has no return value
     */
    public async SetPushNotificationTagsForUser(associateId: number, tags: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetPushNotificationTagsForUser(associateId:number|carriers.Pocket_SetPushNotificationTagsForUserRequest, tags?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Pocket_SetPushNotificationTagsForUserRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateId;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateId)!='undefined' || typeof(first.Tags)!='undefined' ) )
        {
            _request = associateId as carriers.Pocket_SetPushNotificationTagsForUserRequest;
            _options = tags as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateId: associateId as number,
                       Tags: tags as string,
                       };   
            _options = webapi_options;
        }
        return this._SetPushNotificationTagsForUser( _request, _options );
    }


    private async _GetPushNotificationTagsForDevice(request: carriers.Pocket_GetPushNotificationTagsForDeviceRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPushNotificationTagsForDevice", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Retrieve current tag value for a device
     * @param request - DeviceIdentifier
     * @returns A comma separated list of events this device should receive push events for
     */
    public async GetPushNotificationTagsForDevice(request: carriers.Pocket_GetPushNotificationTagsForDeviceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Retrieve current tag value for a device
     * @param deviceIdentifier - The unique identifier of this device
     * @returns A comma separated list of events this device should receive push events for
     */
    public async GetPushNotificationTagsForDevice(deviceIdentifier: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetPushNotificationTagsForDevice(deviceIdentifier:string|carriers.Pocket_GetPushNotificationTagsForDeviceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Pocket_GetPushNotificationTagsForDeviceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = deviceIdentifier;
        if( typeof( first ) === "object" && first && ( typeof(first.DeviceIdentifier)!='undefined' ) )
        {
            _request = deviceIdentifier as carriers.Pocket_GetPushNotificationTagsForDeviceRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DeviceIdentifier: deviceIdentifier as string,
                       };   
            _options = webapi_options;
        }
        return this._GetPushNotificationTagsForDevice( _request, _options );
    }


    private async _SendPushNotification(request: carriers.Pocket_SendPushNotificationRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendPushNotification", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Send a push notification to one or more associates
     * @param request - AssociateIds, Message
     * @returns This method has no return value
     */
    public async SendPushNotification(request: carriers.Pocket_SendPushNotificationRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Send a push notification to one or more associates
     * @param associateIds - The associates to send the push notification message to
     * @param message - The message to send
     * @returns This method has no return value
     */
    public async SendPushNotification(associateIds: number[], message: carriers.PocketNotificationMessage, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SendPushNotification(associateIds:number[]|carriers.Pocket_SendPushNotificationRequest, message?:carriers.PocketNotificationMessage|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Pocket_SendPushNotificationRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateIds)!='undefined' || typeof(first.Message)!='undefined' ) )
        {
            _request = associateIds as carriers.Pocket_SendPushNotificationRequest;
            _options = message as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateIds: associateIds as number[],
                       Message: message as carriers.PocketNotificationMessage,
                       };   
            _options = webapi_options;
        }
        return this._SendPushNotification( _request, _options );
    }


    private async _RunAppointmentAlarmBroker( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RunAppointmentAlarmBroker", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Execute the AppointmentAlarmBroker once
     * @returns This method has no return value
     */
    public async RunAppointmentAlarmBroker(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._RunAppointmentAlarmBroker(webapi_options);
    }


    private async _NotifyUsers(request: carriers.Pocket_NotifyUsersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotifyUsers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Notify users about a new or changed entity
     * @param request - NotificationEventType, Id
     * @returns This method has no return value
     */
    public async NotifyUsers(request: carriers.Pocket_NotifyUsersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Notify users about a new or changed entity
     * @param notificationEventType - Type of notification
     * @param id - Id of entity to notify about
     * @returns This method has no return value
     */
    public async NotifyUsers(notificationEventType: enums.NotificationEventType, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async NotifyUsers(notificationEventType:enums.NotificationEventType|carriers.Pocket_NotifyUsersRequest, id?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Pocket_NotifyUsersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = notificationEventType;
        if( typeof( first ) === "object" && first && ( typeof(first.NotificationEventType)!='undefined' || typeof(first.Id)!='undefined' ) )
        {
            _request = notificationEventType as carriers.Pocket_NotifyUsersRequest;
            _options = id as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       NotificationEventType: notificationEventType as enums.NotificationEventType,
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._NotifyUsers( _request, _options );
    }


    private async _NotificationHandled(request: carriers.Pocket_NotificationHandledRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotificationHandled", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Mark a notification as handled, so it can be cleaned up on other clients that have received the notification
     * @param request - NotificationEventType, Id
     * @returns This method has no return value
     */
    public async NotificationHandled(request: carriers.Pocket_NotificationHandledRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Mark a notification as handled, so it can be cleaned up on other clients that have received the notification
     * @param notificationEventType - Type of notification
     * @param id - Id of entity to notify about
     * @returns This method has no return value
     */
    public async NotificationHandled(notificationEventType: enums.NotificationEventType, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async NotificationHandled(notificationEventType:enums.NotificationEventType|carriers.Pocket_NotificationHandledRequest, id?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Pocket_NotificationHandledRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = notificationEventType;
        if( typeof( first ) === "object" && first && ( typeof(first.NotificationEventType)!='undefined' || typeof(first.Id)!='undefined' ) )
        {
            _request = notificationEventType as carriers.Pocket_NotificationHandledRequest;
            _options = id as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       NotificationEventType: notificationEventType as enums.NotificationEventType,
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._NotificationHandled( _request, _options );
    }


    private async _NotificationsHandled(request: carriers.Pocket_NotificationsHandledRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotificationsHandled", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Mark a set of notifications as handled, so they can be cleaned up on other clients that have received the notification
     * @param request - NotificationEvents
     * @returns This method has no return value
     */
    public async NotificationsHandled(request: carriers.Pocket_NotificationsHandledRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Mark a set of notifications as handled, so they can be cleaned up on other clients that have received the notification
     * @param notificationEvents - List of notifications to mark as handled
     * @returns This method has no return value
     */
    public async NotificationsHandled(notificationEvents: carriers.NotificationEvent[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async NotificationsHandled(notificationEvents:carriers.NotificationEvent[]|carriers.Pocket_NotificationsHandledRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Pocket_NotificationsHandledRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = notificationEvents;
        if( typeof( first ) === "object" && first && ( typeof(first.NotificationEvents)!='undefined' ) )
        {
            _request = notificationEvents as carriers.Pocket_NotificationsHandledRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       NotificationEvents: notificationEvents as carriers.NotificationEvent[],
                       };   
            _options = webapi_options;
        }
        return this._NotificationsHandled( _request, _options );
    }

    } // class v1PocketAgentController 



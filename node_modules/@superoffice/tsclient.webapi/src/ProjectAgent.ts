// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/ProjectAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Collection of all services that works with Project data.
 */
export interface IProjectAgent {
    CreateDefaultProjectEntity(): Promise< carriers.ProjectEntity >;
    SaveProjectEntity(entity: carriers.ProjectEntity) : Promise< carriers.ProjectEntity >;
    DeleteProjectEntity(ProjectEntityId: number) : Promise<void>;
    CreateDefaultProjectEventEntity(): Promise< carriers.ProjectEventEntity >;
    SaveProjectEventEntity(entity: carriers.ProjectEventEntity) : Promise< carriers.ProjectEventEntity >;
    DeleteProjectEventEntity(ProjectEventEntityId: number) : Promise<void>;
    CreateDefaultProjectMember(): Promise< carriers.ProjectMember >;
    SaveProjectMember(entity: carriers.ProjectMember) : Promise< carriers.ProjectMember >;
    DeleteProjectMember(ProjectMemberId: number) : Promise<void>;
    GetProject(projectId: number) :  Promise< carriers.Project >;
    GetProjectEntity(projectEntityId: number) :  Promise< carriers.ProjectEntity >;
    AddProjectMembers(request: carriers.Project_AddProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddProjectMembers(projectEntityId: number, projectMembers: carriers.ProjectMember[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteProjectMembers(request: carriers.Project_DeleteProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteProjectMembers(projectEntityId: number, memberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetProjectImage(request: carriers.Project_GetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetProjectImage(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SetProjectImage(request: carriers.Project_SetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetProjectImage(projectId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteProjectMemberByIds(request: carriers.Project_DeleteProjectMemberByIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteProjectMemberByIds(projectMemberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetDuplicates(request: carriers.Project_GetDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;
    GetDuplicates(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;
    CreateNewEntry(request: carriers.Project_CreateNewEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CreateNewEntry(duplicate: carriers.DuplicateEntry, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    SetDuplicateRulesStatus(request: carriers.Project_SetDuplicateRulesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetDuplicateRulesStatus(rules: carriers.DuplicateRule[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetDuplicateRules(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateRule[] >;
    Merge(request: carriers.Project_MergeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Merge(sourceProjectId: number, destinationProjectId: number, replaceEmptyFieldsOnDestination: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    IsNumberValid(request: carriers.Project_IsNumberValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsNumberValid(contactId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasGuide(request: carriers.Project_HasGuideRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasGuide(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetNextMilestone(request: carriers.Project_GetNextMilestoneRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;
    GetNextMilestone(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;
    OfferAutoNextStatusOnApppointmentCompleted(request: carriers.Project_OfferAutoNextStatusOnApppointmentCompletedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    OfferAutoNextStatusOnApppointmentCompleted(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetNextProjectStatus(request: carriers.Project_GetNextProjectStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetNextProjectStatus(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    HasGuideActivities(request: carriers.Project_HasGuideActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasGuideActivities(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ValidateProjectEntity(request: carriers.Project_ValidateProjectEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    ValidateProjectEntity(projectEntity: carriers.ProjectEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetProjectEvent(projectEventId: number) :  Promise< carriers.ProjectEvent >;
    GetProjectEventOnPerson(request: carriers.Project_GetProjectEventOnPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent >;
    GetProjectEventOnPerson(projectId: number, personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent >;
    GetProjectEventEntity(projectEventEntityId: number) :  Promise< carriers.ProjectEventEntity >;
    GetProjectEventEntityFromProjectId(request: carriers.Project_GetProjectEventEntityFromProjectIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEventEntity >;
    GetProjectEventEntityFromProjectId(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEventEntity >;
    DeleteProjectEventEntityFromProjectId(request: carriers.Project_DeleteProjectEventEntityFromProjectIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteProjectEventEntityFromProjectId(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetProjectEventList(projectEventIds: number[]) :  Promise< carriers.ProjectEvent[] >;
    GetMyProjectEvents(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] >;
    GetProjectEventsOnPerson(request: carriers.Project_GetProjectEventsOnPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] >;
    GetProjectEventsOnPerson(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] >;
    GetProjectList(projectIds: number[]) :  Promise< carriers.Project[] >;
    GetMyProjects(request: carriers.Project_GetMyProjectsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetMyProjects(includeMemberProjects: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetMyMemberProjects(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetProjectsFromPerson(request: carriers.Project_GetProjectsFromPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetProjectsFromPerson(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetProjectsFromContact(request: carriers.Project_GetProjectsFromContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetProjectsFromContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetPublishedProject(request: carriers.Project_GetPublishedProjectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project >;
    GetPublishedProject(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project >;
    GetPublishedProjects(request: carriers.Project_GetPublishedProjectsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetPublishedProjects(projectIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetMyPublishedProjects(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetPublishedProjectsOnPersonId(request: carriers.Project_GetPublishedProjectsOnPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetPublishedProjectsOnPersonId(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;
    GetProjectMember(projectMemberId: number) :  Promise< carriers.ProjectMember >;
    GetProjectMembers(request: carriers.Project_GetProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] >;
    GetProjectMembers(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] >;
    UpdateProjectMember(request: carriers.Project_UpdateProjectMemberRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember >;
    UpdateProjectMember(projectMember: carriers.ProjectMember, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember >;
    GetProjectMembersById(request: carriers.Project_GetProjectMembersByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] >;
    GetProjectMembersById(projectMemberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] >;
    SaveProjectMembersFunctionAndComment(request: carriers.Project_SaveProjectMembersFunctionAndCommentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveProjectMembersFunctionAndComment(projectMemberIds: number[], roleId: number, comment: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
} // interface IProjectAgent




/**
 * Collection of all services that works with Project data.
 */
export class ProjectAgent extends base.WebApiBase implements IProjectAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Project/";
        super(options);
    }



    /**
     * Set default values into a new ProjectEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultProjectEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProjectEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectEntity = converters.Create_ProjectEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ProjectEntity or creates a new ProjectEntity if the id parameter is empty
     * @param entity - The ProjectEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ProjectEntity
     */
    public async SaveProjectEntity(entity: carriers.ProjectEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProjectEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectEntity = converters.Create_ProjectEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ProjectEntity
     * @param ProjectEntityId - The id of the ProjectEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteProjectEntity(ProjectEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteProjectEntity?ProjectEntityId=" + ProjectEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ProjectEventEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultProjectEventEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEventEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEventEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProjectEventEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectEventEntity = converters.Create_ProjectEventEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ProjectEventEntity or creates a new ProjectEventEntity if the id parameter is empty
     * @param entity - The ProjectEventEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ProjectEventEntity
     */
    public async SaveProjectEventEntity(entity: carriers.ProjectEventEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEventEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEventEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProjectEventEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectEventEntity = converters.Create_ProjectEventEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ProjectEventEntity
     * @param ProjectEventEntityId - The id of the ProjectEventEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteProjectEventEntity(ProjectEventEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteProjectEventEntity?ProjectEventEntityId=" + ProjectEventEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ProjectMember.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultProjectMember(options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectMember >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProjectMember", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectMember = converters.Create_ProjectMember_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ProjectMember or creates a new ProjectMember if the id parameter is empty
     * @param entity - The ProjectMember to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ProjectMember
     */
    public async SaveProjectMember(entity: carriers.ProjectMember, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectMember >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProjectMember", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectMember = converters.Create_ProjectMember_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ProjectMember
     * @param ProjectMemberId - The id of the ProjectMember to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteProjectMember(ProjectMemberId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteProjectMember?ProjectMemberId=" + ProjectMemberId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Project object.
     * @param projectId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Project
     */
    public async GetProject(projectId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Project > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProject?projectId=" + projectId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Project_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a ProjectEntity object.
     * @param projectEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectEntity
     */
    public async GetProjectEntity(projectEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectEntity?projectEntityId=" + projectEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _AddProjectMembers(request: carriers.Project_AddProjectMembersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddProjectMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add multiple project members to a project
     * @param request - ProjectEntityId, ProjectMembers
     * @returns 
     */
    public async AddProjectMembers(request: carriers.Project_AddProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Add multiple project members to a project
     * @param projectEntityId - Project to add members to
     * @param projectMembers - Project members to add
     * @returns 
     */
    public async AddProjectMembers(projectEntityId: number, projectMembers: carriers.ProjectMember[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddProjectMembers(projectEntityId:number|carriers.Project_AddProjectMembersRequest, projectMembers?:carriers.ProjectMember[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Project_AddProjectMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectEntityId)!='undefined' || typeof(first.ProjectMembers)!='undefined' ) )
        {
            _request = projectEntityId as carriers.Project_AddProjectMembersRequest;
            _options = projectMembers as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectEntityId: projectEntityId as number,
                       ProjectMembers: projectMembers as carriers.ProjectMember[],
                       };   
            _options = webapi_options;
        }
        return this._AddProjectMembers( _request, _options );
    }


    private async _DeleteProjectMembers(request: carriers.Project_DeleteProjectMembersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteProjectMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete the given project members from a project
     * @param request - ProjectEntityId, MemberIds
     * @returns 
     */
    public async DeleteProjectMembers(request: carriers.Project_DeleteProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete the given project members from a project
     * @param projectEntityId - Project to remove members from
     * @param memberIds - Project member ids
     * @returns 
     */
    public async DeleteProjectMembers(projectEntityId: number, memberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteProjectMembers(projectEntityId:number|carriers.Project_DeleteProjectMembersRequest, memberIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Project_DeleteProjectMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectEntityId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectEntityId)!='undefined' || typeof(first.MemberIds)!='undefined' ) )
        {
            _request = projectEntityId as carriers.Project_DeleteProjectMembersRequest;
            _options = memberIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectEntityId: projectEntityId as number,
                       MemberIds: memberIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeleteProjectMembers( _request, _options );
    }


    private async _GetProjectImage(request: carriers.Project_GetProjectImageRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectImage", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the project image that is displayed in the CRM application.
     * @param request - ProjectId
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetProjectImage(request: carriers.Project_GetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the project image that is displayed in the CRM application.
     * @param projectId - The project id of the project the image belongs to.
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetProjectImage(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetProjectImage(projectId:number|carriers.Project_GetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Project_GetProjectImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_GetProjectImageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectImage( _request, _options );
    }


    private async _SetProjectImage(request: carriers.Project_SetProjectImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetProjectImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Stores the project image that is displayed in the CRM application.
     * @param request - ProjectId, Image
     * @returns 
     */
    public async SetProjectImage(request: carriers.Project_SetProjectImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Stores the project image that is displayed in the CRM application.
     * @param projectId - The project id of the project the image belongs to.
     * @param image - The image that is stored on the project (System.Drawing.Image)
     * @returns 
     */
    public async SetProjectImage(projectId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetProjectImage(projectId:number|carriers.Project_SetProjectImageRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Project_SetProjectImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.Image)!='undefined' ) )
        {
            _request = projectId as carriers.Project_SetProjectImageRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       Image: image as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SetProjectImage( _request, _options );
    }


    private async _DeleteProjectMemberByIds(request: carriers.Project_DeleteProjectMemberByIdsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteProjectMemberByIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes projectmembers rows.
     * @param request - ProjectMemberIds
     * @returns 
     */
    public async DeleteProjectMemberByIds(request: carriers.Project_DeleteProjectMemberByIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes projectmembers rows.
     * @param projectMemberIds - An Array of projectmember ids.
     * @returns 
     */
    public async DeleteProjectMemberByIds(projectMemberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteProjectMemberByIds(projectMemberIds:number[]|carriers.Project_DeleteProjectMemberByIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Project_DeleteProjectMemberByIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectMemberIds;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectMemberIds)!='undefined' ) )
        {
            _request = projectMemberIds as carriers.Project_DeleteProjectMemberByIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectMemberIds: projectMemberIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeleteProjectMemberByIds( _request, _options );
    }


    private async _GetDuplicates(request: carriers.Project_GetDuplicatesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DuplicateEntry[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DuplicateEntry[] = converters.Create_DuplicateEntryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get duplicates(exact or similar in the database) based on the name
     * @param request - Name
     * @returns Any records matching the specified name
     */
    public async GetDuplicates(request: carriers.Project_GetDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;

    /**
     * Get duplicates(exact or similar in the database) based on the name
     * @param name - Name used for lookup
     * @returns Any records matching the specified name
     */
    public async GetDuplicates(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;

    public async GetDuplicates(name:string|carriers.Project_GetDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] > {
        let _request : carriers.Project_GetDuplicatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' ) )
        {
            _request = name as carriers.Project_GetDuplicatesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._GetDuplicates( _request, _options );
    }


    private async _CreateNewEntry(request: carriers.Project_CreateNewEntryRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewEntry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a new project based on external duplicate
     * @param request - Duplicate
     * @returns The database identity of the newly created entry
     */
    public async CreateNewEntry(request: carriers.Project_CreateNewEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Creates a new project based on external duplicate
     * @param duplicate - The duplicate to create a new entry based upon
     * @returns The database identity of the newly created entry
     */
    public async CreateNewEntry(duplicate: carriers.DuplicateEntry, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async CreateNewEntry(duplicate:carriers.DuplicateEntry|carriers.Project_CreateNewEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Project_CreateNewEntryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = duplicate;
        if( typeof( first ) === "object" && first && ( typeof(first.Duplicate)!='undefined' ) )
        {
            _request = duplicate as carriers.Project_CreateNewEntryRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Duplicate: duplicate as carriers.DuplicateEntry,
                       };   
            _options = webapi_options;
        }
        return this._CreateNewEntry( _request, _options );
    }


    private async _SetDuplicateRulesStatus(request: carriers.Project_SetDuplicateRulesStatusRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDuplicateRulesStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set which duplicate rules should be active or not
     * @param request - Rules
     * @returns 
     */
    public async SetDuplicateRulesStatus(request: carriers.Project_SetDuplicateRulesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set which duplicate rules should be active or not
     * @param rules - Duplicate rules to update active status for
     * @returns 
     */
    public async SetDuplicateRulesStatus(rules: carriers.DuplicateRule[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetDuplicateRulesStatus(rules:carriers.DuplicateRule[]|carriers.Project_SetDuplicateRulesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Project_SetDuplicateRulesStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = rules;
        if( typeof( first ) === "object" && first && ( typeof(first.Rules)!='undefined' ) )
        {
            _request = rules as carriers.Project_SetDuplicateRulesStatusRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Rules: rules as carriers.DuplicateRule[],
                       };   
            _options = webapi_options;
        }
        return this._SetDuplicateRulesStatus( _request, _options );
    }


    private async _GetDuplicateRules( options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateRule[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DuplicateRule[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicateRules", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DuplicateRule[] = converters.Create_DuplicateRuleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Retrieve all available duplicate rules for project
     * @returns All available duplicate rules
     */
    public async GetDuplicateRules(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateRule[] >
    {
        return this._GetDuplicateRules(webapi_options);
    }


    private async _Merge(request: carriers.Project_MergeRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Merge", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Merge two projects into one, removing the source project in the process
     * @param request - SourceProjectId, DestinationProjectId, ReplaceEmptyFieldsOnDestination
     * @returns 
     */
    public async Merge(request: carriers.Project_MergeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Merge two projects into one, removing the source project in the process
     * @param sourceProjectId - Id of source project for merge. This project is removed after the merge is completed.
     * @param destinationProjectId - Id of destination project to merge to. This project is updated with info from the source.
     * @param replaceEmptyFieldsOnDestination - Fill in empty fields on destination from source?
     * @returns 
     */
    public async Merge(sourceProjectId: number, destinationProjectId: number, replaceEmptyFieldsOnDestination: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Merge(sourceProjectId:number|carriers.Project_MergeRequest, destinationProjectId?:number|base.WebApiRequestOptions, replaceEmptyFieldsOnDestination?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Project_MergeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceProjectId;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceProjectId)!='undefined' || typeof(first.DestinationProjectId)!='undefined' || typeof(first.ReplaceEmptyFieldsOnDestination)!='undefined' ) )
        {
            _request = sourceProjectId as carriers.Project_MergeRequest;
            _options = destinationProjectId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceProjectId: sourceProjectId as number,
                       DestinationProjectId: destinationProjectId as number,
                       ReplaceEmptyFieldsOnDestination: replaceEmptyFieldsOnDestination as boolean,
                       };   
            _options = webapi_options;
        }
        return this._Merge( _request, _options );
    }


    private async _IsNumberValid(request: carriers.Project_IsNumberValidRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNumberValid", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Checks if the number is unique or required.  The setting is configured from admin under system options.
     * @param request - ContactId, Number
     * @returns True if the number is valid
     */
    public async IsNumberValid(request: carriers.Project_IsNumberValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Checks if the number is unique or required.  The setting is configured from admin under system options.
     * @param contactId - The Project id
     * @param number - The number to check for uniqueness and validity
     * @returns True if the number is valid
     */
    public async IsNumberValid(contactId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async IsNumberValid(contactId:number|carriers.Project_IsNumberValidRequest, number?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Project_IsNumberValidRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.Number)!='undefined' ) )
        {
            _request = contactId as carriers.Project_IsNumberValidRequest;
            _options = number as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       Number: number as string,
                       };   
            _options = webapi_options;
        }
        return this._IsNumberValid( _request, _options );
    }


    private async _HasGuide(request: carriers.Project_HasGuideRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasGuide", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Does this project have a guide associated with its project type?
     * @param request - ProjectId
     * @returns True if the project has a guide
     */
    public async HasGuide(request: carriers.Project_HasGuideRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Does this project have a guide associated with its project type?
     * @param projectId - Project id
     * @returns True if the project has a guide
     */
    public async HasGuide(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasGuide(projectId:number|carriers.Project_HasGuideRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Project_HasGuideRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_HasGuideRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._HasGuide( _request, _options );
    }


    private async _GetNextMilestone(request: carriers.Project_GetNextMilestoneRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Appointment > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Appointment >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextMilestone", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Appointment = converters.Create_Appointment_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Next upcoming milestone appointment
     * @param request - ProjectId
     * @returns Upcoming milestone appointment
     */
    public async GetNextMilestone(request: carriers.Project_GetNextMilestoneRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;

    /**
     * Next upcoming milestone appointment
     * @param projectId - Project id - primary key
     * @returns Upcoming milestone appointment
     */
    public async GetNextMilestone(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment >;

    public async GetNextMilestone(projectId:number|carriers.Project_GetNextMilestoneRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Appointment > {
        let _request : carriers.Project_GetNextMilestoneRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_GetNextMilestoneRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetNextMilestone( _request, _options );
    }


    private async _OfferAutoNextStatusOnApppointmentCompleted(request: carriers.Project_OfferAutoNextStatusOnApppointmentCompletedRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("OfferAutoNextStatusOnApppointmentCompleted", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - AppointmentId
     * @returns 
     */
    public async OfferAutoNextStatusOnApppointmentCompleted(request: carriers.Project_OfferAutoNextStatusOnApppointmentCompletedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param appointmentId - 
     * @returns 
     */
    public async OfferAutoNextStatusOnApppointmentCompleted(appointmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async OfferAutoNextStatusOnApppointmentCompleted(appointmentId:number|carriers.Project_OfferAutoNextStatusOnApppointmentCompletedRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Project_OfferAutoNextStatusOnApppointmentCompletedRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = appointmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.AppointmentId)!='undefined' ) )
        {
            _request = appointmentId as carriers.Project_OfferAutoNextStatusOnApppointmentCompletedRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AppointmentId: appointmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._OfferAutoNextStatusOnApppointmentCompleted( _request, _options );
    }


    private async _GetNextProjectStatus(request: carriers.Project_GetNextProjectStatusRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextProjectStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ProjectId
     * @returns 
     */
    public async GetNextProjectStatus(request: carriers.Project_GetNextProjectStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * 
     * @param projectId - 
     * @returns 
     */
    public async GetNextProjectStatus(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async GetNextProjectStatus(projectId:number|carriers.Project_GetNextProjectStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Project_GetNextProjectStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_GetNextProjectStatusRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetNextProjectStatus( _request, _options );
    }


    private async _HasGuideActivities(request: carriers.Project_HasGuideActivitiesRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasGuideActivities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * 
     * @param request - ProjectId
     * @returns 
     */
    public async HasGuideActivities(request: carriers.Project_HasGuideActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * 
     * @param projectId - 
     * @returns 
     */
    public async HasGuideActivities(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasGuideActivities(projectId:number|carriers.Project_HasGuideActivitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Project_HasGuideActivitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_HasGuideActivitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._HasGuideActivities( _request, _options );
    }


    private async _ValidateProjectEntity(request: carriers.Project_ValidateProjectEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateProjectEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param request - ProjectEntity
     * @returns Error messages tagged by field.
     */
    public async ValidateProjectEntity(request: carriers.Project_ValidateProjectEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param projectEntity - Entity to be checked for errors.
     * @returns Error messages tagged by field.
     */
    public async ValidateProjectEntity(projectEntity: carriers.ProjectEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async ValidateProjectEntity(projectEntity:carriers.ProjectEntity|carriers.Project_ValidateProjectEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Project_ValidateProjectEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectEntity)!='undefined' ) )
        {
            _request = projectEntity as carriers.Project_ValidateProjectEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectEntity: projectEntity as carriers.ProjectEntity,
                       };   
            _options = webapi_options;
        }
        return this._ValidateProjectEntity( _request, _options );
    }

    /*
     * Gets a ProjectEvent object.
     * @param projectEventId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectEvent
     */
    public async GetProjectEvent(projectEventId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEvent >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectEvent?projectEventId=" + projectEventId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEvent_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetProjectEventOnPerson(request: carriers.Project_GetProjectEventOnPersonRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEvent >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectEventOnPerson", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectEvent = converters.Create_ProjectEvent_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a ProjectEvent object from a project and a person.
     * @param request - ProjectId, PersonId
     * @returns 
     */
    public async GetProjectEventOnPerson(request: carriers.Project_GetProjectEventOnPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent >;

    /**
     * Gets a ProjectEvent object from a project and a person.
     * @param projectId - The project Id
     * @param personId - Id of the person the project events belong to.
     * @returns 
     */
    public async GetProjectEventOnPerson(projectId: number, personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent >;

    public async GetProjectEventOnPerson(projectId:number|carriers.Project_GetProjectEventOnPersonRequest, personId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent > {
        let _request : carriers.Project_GetProjectEventOnPersonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' || typeof(first.PersonId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_GetProjectEventOnPersonRequest;
            _options = personId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectEventOnPerson( _request, _options );
    }

    /*
     * Gets a ProjectEventEntity object.
     * @param projectEventEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectEventEntity
     */
    public async GetProjectEventEntity(projectEventEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEventEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEventEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectEventEntity?projectEventEntityId=" + projectEventEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEventEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetProjectEventEntityFromProjectId(request: carriers.Project_GetProjectEventEntityFromProjectIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEventEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEventEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectEventEntityFromProjectId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectEventEntity = converters.Create_ProjectEventEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a ProjectEventEntity based on a projectId.
     * @param request - ProjectId
     * @returns ProjectEventEntity
     */
    public async GetProjectEventEntityFromProjectId(request: carriers.Project_GetProjectEventEntityFromProjectIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEventEntity >;

    /**
     * Get a ProjectEventEntity based on a projectId.
     * @param projectId - The projectId to get a ProjectEventEntity for
     * @returns ProjectEventEntity
     */
    public async GetProjectEventEntityFromProjectId(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEventEntity >;

    public async GetProjectEventEntityFromProjectId(projectId:number|carriers.Project_GetProjectEventEntityFromProjectIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEventEntity > {
        let _request : carriers.Project_GetProjectEventEntityFromProjectIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_GetProjectEventEntityFromProjectIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectEventEntityFromProjectId( _request, _options );
    }


    private async _DeleteProjectEventEntityFromProjectId(request: carriers.Project_DeleteProjectEventEntityFromProjectIdRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteProjectEventEntityFromProjectId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete a project event based on a project id. Does not delete the project, but does delete the published and ExternalEvent and AudienceVisibility records.
     * @param request - ProjectId
     * @returns Nothing
     */
    public async DeleteProjectEventEntityFromProjectId(request: carriers.Project_DeleteProjectEventEntityFromProjectIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete a project event based on a project id. Does not delete the project, but does delete the published and ExternalEvent and AudienceVisibility records.
     * @param projectId - The project id of the external event to delete.
     * @returns Nothing
     */
    public async DeleteProjectEventEntityFromProjectId(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteProjectEventEntityFromProjectId(projectId:number|carriers.Project_DeleteProjectEventEntityFromProjectIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Project_DeleteProjectEventEntityFromProjectIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_DeleteProjectEventEntityFromProjectIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteProjectEventEntityFromProjectId( _request, _options );
    }

    /*
     * Gets an array of ProjectEvent objects.
     * @param projectEventIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ProjectEvent
     */
    public async GetProjectEventList(projectEventIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEvent[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectEventList", projectEventIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEventArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetMyProjectEvents( options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEvent[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyProjectEvents", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectEvent[] = converters.Create_ProjectEventArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets all project events that belongs to the currently logged on user. The list of events are filtered by the Audience Visibility restrictions set when the project event is created.
     * @returns Array of project events
     */
    public async GetMyProjectEvents(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] >
    {
        return this._GetMyProjectEvents(webapi_options);
    }


    private async _GetProjectEventsOnPerson(request: carriers.Project_GetProjectEventsOnPersonRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectEvent[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectEventsOnPerson", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectEvent[] = converters.Create_ProjectEventArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets all project events that belongs to the person specified. The list of events are filtered by the Audience Visibility restrictions set when the project event is created.
     * @param request - PersonId
     * @returns Array of project events
     */
    public async GetProjectEventsOnPerson(request: carriers.Project_GetProjectEventsOnPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] >;

    /**
     * Gets all project events that belongs to the person specified. The list of events are filtered by the Audience Visibility restrictions set when the project event is created.
     * @param personId - Id of the person the project events belong to.
     * @returns Array of project events
     */
    public async GetProjectEventsOnPerson(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] >;

    public async GetProjectEventsOnPerson(personId:number|carriers.Project_GetProjectEventsOnPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectEvent[] > {
        let _request : carriers.Project_GetProjectEventsOnPersonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Project_GetProjectEventsOnPersonRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectEventsOnPerson( _request, _options );
    }

    /*
     * Gets an array of Project objects.
     * @param projectIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Project
     */
    public async GetProjectList(projectIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectList", projectIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetMyProjects(request: carriers.Project_GetMyProjectsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyProjects", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Project[] = converters.Create_ProjectArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returning the projects belonging to an associate. If memberProjects is false only the projects where the associate is project responsible is returned, otherwise both the projects where the associate is project responsible and project member is returned.
     * @param request - IncludeMemberProjects
     * @returns The list of projects
     */
    public async GetMyProjects(request: carriers.Project_GetMyProjectsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    /**
     * Returning the projects belonging to an associate. If memberProjects is false only the projects where the associate is project responsible is returned, otherwise both the projects where the associate is project responsible and project member is returned.
     * @param includeMemberProjects - True to include projects where the user is project member.
     * @returns The list of projects
     */
    public async GetMyProjects(includeMemberProjects: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    public async GetMyProjects(includeMemberProjects:boolean|carriers.Project_GetMyProjectsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        let _request : carriers.Project_GetMyProjectsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = includeMemberProjects;
        if( typeof( first ) === "object" && first && ( typeof(first.IncludeMemberProjects)!='undefined' ) )
        {
            _request = includeMemberProjects as carriers.Project_GetMyProjectsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       IncludeMemberProjects: includeMemberProjects as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetMyProjects( _request, _options );
    }


    private async _GetMyMemberProjects( options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyMemberProjects", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Project[] = converters.Create_ProjectArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returning the projects where an user is project member.
     * @returns The list of projects.
     */
    public async GetMyMemberProjects(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >
    {
        return this._GetMyMemberProjects(webapi_options);
    }


    private async _GetProjectsFromPerson(request: carriers.Project_GetProjectsFromPersonRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectsFromPerson", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Project[] = converters.Create_ProjectArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Return all projects where the person is project member.
     * @param request - PersonId
     * @returns ProjectListEntity
     */
    public async GetProjectsFromPerson(request: carriers.Project_GetProjectsFromPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    /**
     * Return all projects where the person is project member.
     * @param personId - The person id
     * @returns ProjectListEntity
     */
    public async GetProjectsFromPerson(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    public async GetProjectsFromPerson(personId:number|carriers.Project_GetProjectsFromPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        let _request : carriers.Project_GetProjectsFromPersonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Project_GetProjectsFromPersonRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectsFromPerson( _request, _options );
    }


    private async _GetProjectsFromContact(request: carriers.Project_GetProjectsFromContactRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectsFromContact", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Project[] = converters.Create_ProjectArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all projects where the given contact has projectmembers.
     * @param request - ContactId
     * @returns ProjectListEntity
     */
    public async GetProjectsFromContact(request: carriers.Project_GetProjectsFromContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    /**
     * Returns all projects where the given contact has projectmembers.
     * @param contactId - The contact id
     * @returns ProjectListEntity
     */
    public async GetProjectsFromContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    public async GetProjectsFromContact(contactId:number|carriers.Project_GetProjectsFromContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        let _request : carriers.Project_GetProjectsFromContactRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.Project_GetProjectsFromContactRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectsFromContact( _request, _options );
    }


    private async _GetPublishedProject(request: carriers.Project_GetPublishedProjectRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Project > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProject", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Project = converters.Create_Project_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get published project by project id.
     * @param request - ProjectId
     * @returns Project
     */
    public async GetPublishedProject(request: carriers.Project_GetPublishedProjectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project >;

    /**
     * Get published project by project id.
     * @param projectId - The project id.
     * @returns Project
     */
    public async GetPublishedProject(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project >;

    public async GetPublishedProject(projectId:number|carriers.Project_GetPublishedProjectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project > {
        let _request : carriers.Project_GetPublishedProjectRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_GetPublishedProjectRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedProject( _request, _options );
    }


    private async _GetPublishedProjects(request: carriers.Project_GetPublishedProjectsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProjects", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Project[] = converters.Create_ProjectArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get published projects by project ids.
     * @param request - ProjectIds
     * @returns Projects
     */
    public async GetPublishedProjects(request: carriers.Project_GetPublishedProjectsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    /**
     * Get published projects by project ids.
     * @param projectIds - The array of project ids
     * @returns Projects
     */
    public async GetPublishedProjects(projectIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    public async GetPublishedProjects(projectIds:number[]|carriers.Project_GetPublishedProjectsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        let _request : carriers.Project_GetPublishedProjectsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectIds;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectIds)!='undefined' ) )
        {
            _request = projectIds as carriers.Project_GetPublishedProjectsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectIds: projectIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedProjects( _request, _options );
    }


    private async _GetMyPublishedProjects( options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyPublishedProjects", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Project[] = converters.Create_ProjectArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get published projects from the logged in user.
     * @returns Projects
     */
    public async GetMyPublishedProjects(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >
    {
        return this._GetMyPublishedProjects(webapi_options);
    }


    private async _GetPublishedProjectsOnPersonId(request: carriers.Project_GetPublishedProjectsOnPersonIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Project[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProjectsOnPersonId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Project[] = converters.Create_ProjectArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get published projects where person  is a member
     * @param request - PersonId
     * @returns Array of project
     */
    public async GetPublishedProjectsOnPersonId(request: carriers.Project_GetPublishedProjectsOnPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    /**
     * Get published projects where person  is a member
     * @param personId - The person id
     * @returns Array of project
     */
    public async GetPublishedProjectsOnPersonId(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] >;

    public async GetPublishedProjectsOnPersonId(personId:number|carriers.Project_GetPublishedProjectsOnPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Project[] > {
        let _request : carriers.Project_GetPublishedProjectsOnPersonIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Project_GetPublishedProjectsOnPersonIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPublishedProjectsOnPersonId( _request, _options );
    }

    /*
     * Gets a ProjectMember object.
     * @param projectMemberId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectMember
     */
    public async GetProjectMember(projectMemberId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectMember >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectMember?projectMemberId=" + projectMemberId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectMember_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetProjectMembers(request: carriers.Project_GetProjectMembersRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectMember[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectMember[] = converters.Create_ProjectMemberArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns an array of project members
     * @param request - ProjectId
     * @returns An array of project members
     */
    public async GetProjectMembers(request: carriers.Project_GetProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] >;

    /**
     * Returns an array of project members
     * @param projectId - The project id
     * @returns An array of project members
     */
    public async GetProjectMembers(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] >;

    public async GetProjectMembers(projectId:number|carriers.Project_GetProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] > {
        let _request : carriers.Project_GetProjectMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Project_GetProjectMembersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMembers( _request, _options );
    }


    private async _UpdateProjectMember(request: carriers.Project_UpdateProjectMemberRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectMember >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateProjectMember", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectMember = converters.Create_ProjectMember_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Updates a ProjectMember row.
     * @param request - ProjectMember
     * @returns The Updated ProjectMember
     */
    public async UpdateProjectMember(request: carriers.Project_UpdateProjectMemberRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember >;

    /**
     * Updates a ProjectMember row.
     * @param projectMember - ProjectMember to update
     * @returns The Updated ProjectMember
     */
    public async UpdateProjectMember(projectMember: carriers.ProjectMember, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember >;

    public async UpdateProjectMember(projectMember:carriers.ProjectMember|carriers.Project_UpdateProjectMemberRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember > {
        let _request : carriers.Project_UpdateProjectMemberRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectMember;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectMember)!='undefined' ) )
        {
            _request = projectMember as carriers.Project_UpdateProjectMemberRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectMember: projectMember as carriers.ProjectMember,
                       };   
            _options = webapi_options;
        }
        return this._UpdateProjectMember( _request, _options );
    }


    private async _GetProjectMembersById(request: carriers.Project_GetProjectMembersByIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ProjectMember[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMembersById", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ProjectMember[] = converters.Create_ProjectMemberArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns an array of project members
     * @param request - ProjectMemberIds
     * @returns An array of project members
     */
    public async GetProjectMembersById(request: carriers.Project_GetProjectMembersByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] >;

    /**
     * Returns an array of project members
     * @param projectMemberIds - 
     * @returns An array of project members
     */
    public async GetProjectMembersById(projectMemberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] >;

    public async GetProjectMembersById(projectMemberIds:number[]|carriers.Project_GetProjectMembersByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ProjectMember[] > {
        let _request : carriers.Project_GetProjectMembersByIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectMemberIds;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectMemberIds)!='undefined' ) )
        {
            _request = projectMemberIds as carriers.Project_GetProjectMembersByIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectMemberIds: projectMemberIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetProjectMembersById( _request, _options );
    }


    private async _SaveProjectMembersFunctionAndComment(request: carriers.Project_SaveProjectMembersFunctionAndCommentRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveProjectMembersFunctionAndComment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves role and comment on an array of projectmembers represented by ids
     * @param request - ProjectMemberIds, RoleId, Comment
     * @returns 
     */
    public async SaveProjectMembersFunctionAndComment(request: carriers.Project_SaveProjectMembersFunctionAndCommentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Saves role and comment on an array of projectmembers represented by ids
     * @param projectMemberIds - 
     * @param roleId - 
     * @param comment - 
     * @returns 
     */
    public async SaveProjectMembersFunctionAndComment(projectMemberIds: number[], roleId: number, comment: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveProjectMembersFunctionAndComment(projectMemberIds:number[]|carriers.Project_SaveProjectMembersFunctionAndCommentRequest, roleId?:number|base.WebApiRequestOptions, comment?:string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Project_SaveProjectMembersFunctionAndCommentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectMemberIds;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectMemberIds)!='undefined' || typeof(first.RoleId)!='undefined' || typeof(first.Comment)!='undefined' ) )
        {
            _request = projectMemberIds as carriers.Project_SaveProjectMembersFunctionAndCommentRequest;
            _options = roleId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectMemberIds: projectMemberIds as number[],
                       RoleId: roleId as number,
                       Comment: comment as string,
                       };   
            _options = webapi_options;
        }
        return this._SaveProjectMembersFunctionAndComment( _request, _options );
    }

    } // class v1ProjectAgentController 



// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/ChatAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Chat functions. Manage chat channels, sessions and messages.
 */
export interface IChatAgent {
    CreateDefaultChatSessionEntity(): Promise< carriers.ChatSessionEntity >;
    SaveChatSessionEntity(entity: carriers.ChatSessionEntity) : Promise< carriers.ChatSessionEntity >;
    DeleteChatSessionEntity(ChatSessionEntityId: number) : Promise<void>;
    CreateDefaultChatTopicAgent(): Promise< carriers.ChatTopicAgent >;
    CreateDefaultChatTopicEntity(): Promise< carriers.ChatTopicEntity >;
    SaveChatTopicEntity(entity: carriers.ChatTopicEntity) : Promise< carriers.ChatTopicEntity >;
    DeleteChatTopicEntity(ChatTopicEntityId: number) : Promise<void>;
    GetChatPresence(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatPresence[] >;
    SaveChatPresence(request: carriers.Chat_SaveChatPresenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveChatPresence(chatPresence: carriers.ChatPresence[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetChatSessionEntity(chatSessionEntityId: number) :  Promise< carriers.ChatSessionEntity >;
    ChatSessionsForUser(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity[] >;
    TransferChatSession(request: carriers.Chat_TransferChatSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    TransferChatSession(chatSessionId: number, toAssociate: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    AcceptChatSessionTransfer(request: carriers.Chat_AcceptChatSessionTransferRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    AcceptChatSessionTransfer(chatSessionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    RejectChatSessionTransfer(request: carriers.Chat_RejectChatSessionTransferRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    RejectChatSessionTransfer(chatSessionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    PickUpChatSession(request: carriers.Chat_PickUpChatSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    PickUpChatSession(chatSessionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    PickUpFirstChatSession(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    ResetChatSession(request: carriers.Chat_ResetChatSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    ResetChatSession(chatSessionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    GetChatTranscript(request: carriers.Chat_GetChatTranscriptRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetChatTranscript(chatSessionId: number, html: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetChatMessages(request: carriers.Chat_GetChatMessagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage[] >;
    GetChatMessages(chatSessionId: number, after: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage[] >;
    AddChatMessage(request: carriers.Chat_AddChatMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage >;
    AddChatMessage(chatSessionId: number, message: carriers.ChatMessage, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage >;
    GetChatTopicEntity(chatTopicEntityId: number) :  Promise< carriers.ChatTopicEntity >;
    IsWithinOpeningHours(request: carriers.Chat_IsWithinOpeningHoursRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsWithinOpeningHours(chatTopicId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    ChatTopicsForUser(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicEntity[] >;
    GetUserAgentList(request: carriers.Chat_GetUserAgentListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    GetUserAgentList(flat: boolean, onlyPresent: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    GetChatTopicUserAgentList(request: carriers.Chat_GetChatTopicUserAgentListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] >;
    GetChatTopicUserAgentList(chatTopicId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] >;
    GetChatTopicUserAgent(request: carriers.Chat_GetChatTopicUserAgentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;
    GetChatTopicUserAgent(chatTopicId: number, username: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;
    AddChatTopicUserAgent(request: carriers.Chat_AddChatTopicUserAgentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;
    AddChatTopicUserAgent(chatTopicId: number, useragent: carriers.ChatTopicAgent, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;
    UpdateChatTopicUserAgent(request: carriers.Chat_UpdateChatTopicUserAgentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;
    UpdateChatTopicUserAgent(chatTopicId: number, username: string, useragent: carriers.ChatTopicAgent, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;
    UpdateChatTopicUserAgents(request: carriers.Chat_UpdateChatTopicUserAgentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] >;
    UpdateChatTopicUserAgents(chatTopicId: number, useragents: carriers.ChatTopicAgent[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] >;
    DeleteChatTopicUserAgent(request: carriers.Chat_DeleteChatTopicUserAgentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteChatTopicUserAgent(chatTopicId: number, username: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateChatSessionForTopic(request: carriers.Chat_CreateChatSessionForTopicRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
    CreateChatSessionForTopic(chatTopicId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;
} // interface IChatAgent




/**
 * Chat functions. Manage chat channels, sessions and messages.
 */
export class ChatAgent extends base.WebApiBase implements IChatAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Chat/";
        super(options);
    }



    /**
     * Set default values into a new ChatSessionEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultChatSessionEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultChatSessionEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity = converters.Create_ChatSessionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ChatSessionEntity or creates a new ChatSessionEntity if the id parameter is empty
     * @param entity - The ChatSessionEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ChatSessionEntity
     */
    public async SaveChatSessionEntity(entity: carriers.ChatSessionEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveChatSessionEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity = converters.Create_ChatSessionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ChatSessionEntity
     * @param ChatSessionEntityId - The id of the ChatSessionEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteChatSessionEntity(ChatSessionEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteChatSessionEntity?ChatSessionEntityId=" + ChatSessionEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ChatTopicAgent.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultChatTopicAgent(options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicAgent >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultChatTopicAgent", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatTopicAgent = converters.Create_ChatTopicAgent_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new ChatTopicEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultChatTopicEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultChatTopicEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatTopicEntity = converters.Create_ChatTopicEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ChatTopicEntity or creates a new ChatTopicEntity if the id parameter is empty
     * @param entity - The ChatTopicEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ChatTopicEntity
     */
    public async SaveChatTopicEntity(entity: carriers.ChatTopicEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveChatTopicEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatTopicEntity = converters.Create_ChatTopicEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ChatTopicEntity
     * @param ChatTopicEntityId - The id of the ChatTopicEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteChatTopicEntity(ChatTopicEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteChatTopicEntity?ChatTopicEntityId=" + ChatTopicEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    private async _GetChatPresence( options?:base.WebApiRequestOptions) : Promise< carriers.ChatPresence[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatPresence[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatPresence", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatPresence[] = converters.Create_ChatPresenceArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the chat presence status for all chat users
     * @returns An array with ChatPresence objects for each user
     */
    public async GetChatPresence(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatPresence[] >
    {
        return this._GetChatPresence(webapi_options);
    }


    private async _SaveChatPresence(request: carriers.Chat_SaveChatPresenceRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveChatPresence", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save the chat presence for specified users
     * @param request - ChatPresence
     * @returns void
     */
    public async SaveChatPresence(request: carriers.Chat_SaveChatPresenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Save the chat presence for specified users
     * @param chatPresence - An array with ChatPresence objects. Only the UserId and Present information is used while saving
     * @returns void
     */
    public async SaveChatPresence(chatPresence: carriers.ChatPresence[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveChatPresence(chatPresence:carriers.ChatPresence[]|carriers.Chat_SaveChatPresenceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Chat_SaveChatPresenceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatPresence;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatPresence)!='undefined' ) )
        {
            _request = chatPresence as carriers.Chat_SaveChatPresenceRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatPresence: chatPresence as carriers.ChatPresence[],
                       };   
            _options = webapi_options;
        }
        return this._SaveChatPresence( _request, _options );
    }

    /*
     * Gets a ChatSessionEntity object.
     * @param chatSessionEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ChatSessionEntity
     */
    public async GetChatSessionEntity(chatSessionEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetChatSessionEntity?chatSessionEntityId=" + chatSessionEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _ChatSessionsForUser( options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChatSessionsForUser", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity[] = converters.Create_ChatSessionEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get all chat sessions which this user is a member of. Members means that you have at least one of: Can Respond, Notifications, Listen or Manager
     * @returns Array of chat sessions the current user can access
     */
    public async ChatSessionsForUser(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity[] >
    {
        return this._ChatSessionsForUser(webapi_options);
    }


    private async _TransferChatSession(request: carriers.Chat_TransferChatSessionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TransferChatSession", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity = converters.Create_ChatSessionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Request to send the session to another user. If the session does not belong to the user, nothing happens.
     * @param request - ChatSessionId, ToAssociate
     * @returns The updated chat session
     */
    public async TransferChatSession(request: carriers.Chat_TransferChatSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    /**
     * Request to send the session to another user. If the session does not belong to the user, nothing happens.
     * @param chatSessionId - id of the chat session to send
     * @param toAssociate - Associate username or associate id to send session to.
     * @returns The updated chat session
     */
    public async TransferChatSession(chatSessionId: number, toAssociate: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    public async TransferChatSession(chatSessionId:number|carriers.Chat_TransferChatSessionRequest, toAssociate?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        let _request : carriers.Chat_TransferChatSessionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatSessionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatSessionId)!='undefined' || typeof(first.ToAssociate)!='undefined' ) )
        {
            _request = chatSessionId as carriers.Chat_TransferChatSessionRequest;
            _options = toAssociate as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatSessionId: chatSessionId as number,
                       ToAssociate: toAssociate as string,
                       };   
            _options = webapi_options;
        }
        return this._TransferChatSession( _request, _options );
    }


    private async _AcceptChatSessionTransfer(request: carriers.Chat_AcceptChatSessionTransferRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AcceptChatSessionTransfer", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity = converters.Create_ChatSessionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Accept the transfer: assign the session to the user. If the session is not being transferred, nothing happens.
     * @param request - ChatSessionId
     * @returns The updated chat session
     */
    public async AcceptChatSessionTransfer(request: carriers.Chat_AcceptChatSessionTransferRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    /**
     * Accept the transfer: assign the session to the user. If the session is not being transferred, nothing happens.
     * @param chatSessionId - id of the chat session to send
     * @returns The updated chat session
     */
    public async AcceptChatSessionTransfer(chatSessionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    public async AcceptChatSessionTransfer(chatSessionId:number|carriers.Chat_AcceptChatSessionTransferRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        let _request : carriers.Chat_AcceptChatSessionTransferRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatSessionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatSessionId)!='undefined' ) )
        {
            _request = chatSessionId as carriers.Chat_AcceptChatSessionTransferRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatSessionId: chatSessionId as number,
                       };   
            _options = webapi_options;
        }
        return this._AcceptChatSessionTransfer( _request, _options );
    }


    private async _RejectChatSessionTransfer(request: carriers.Chat_RejectChatSessionTransferRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RejectChatSessionTransfer", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity = converters.Create_ChatSessionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Do not want. Deny the transfer to the user. If the session is not being transferred, nothing happens.
     * @param request - ChatSessionId
     * @returns The updated chat session
     */
    public async RejectChatSessionTransfer(request: carriers.Chat_RejectChatSessionTransferRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    /**
     * Do not want. Deny the transfer to the user. If the session is not being transferred, nothing happens.
     * @param chatSessionId - id of the chat session to send back
     * @returns The updated chat session
     */
    public async RejectChatSessionTransfer(chatSessionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    public async RejectChatSessionTransfer(chatSessionId:number|carriers.Chat_RejectChatSessionTransferRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        let _request : carriers.Chat_RejectChatSessionTransferRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatSessionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatSessionId)!='undefined' ) )
        {
            _request = chatSessionId as carriers.Chat_RejectChatSessionTransferRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatSessionId: chatSessionId as number,
                       };   
            _options = webapi_options;
        }
        return this._RejectChatSessionTransfer( _request, _options );
    }


    private async _PickUpChatSession(request: carriers.Chat_PickUpChatSessionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PickUpChatSession", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity = converters.Create_ChatSessionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * &apos;answer&apos; the session: assign the session to the user. The welcome message is sent to the customer. Returns NULL if session was not in queue.
     * @param request - ChatSessionId
     * @returns The chat session
     */
    public async PickUpChatSession(request: carriers.Chat_PickUpChatSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    /**
     * &apos;answer&apos; the session: assign the session to the user. The welcome message is sent to the customer. Returns NULL if session was not in queue.
     * @param chatSessionId - id of the chat session to answer
     * @returns The chat session
     */
    public async PickUpChatSession(chatSessionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    public async PickUpChatSession(chatSessionId:number|carriers.Chat_PickUpChatSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        let _request : carriers.Chat_PickUpChatSessionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatSessionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatSessionId)!='undefined' ) )
        {
            _request = chatSessionId as carriers.Chat_PickUpChatSessionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatSessionId: chatSessionId as number,
                       };   
            _options = webapi_options;
        }
        return this._PickUpChatSession( _request, _options );
    }


    private async _PickUpFirstChatSession( options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PickUpFirstChatSession", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity = converters.Create_ChatSessionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * &apos;answer&apos; the first available session from the queue: assign the session to the user. The welcome message is sent to the customer.
     * @returns The picked-up chat session
     */
    public async PickUpFirstChatSession(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >
    {
        return this._PickUpFirstChatSession(webapi_options);
    }


    private async _ResetChatSession(request: carriers.Chat_ResetChatSessionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResetChatSession", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity = converters.Create_ChatSessionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Reset chat session, put it back on the queue for pickup. Used by bots to hand off a session to human
     * @param request - ChatSessionId
     * @returns The updated chat session
     */
    public async ResetChatSession(request: carriers.Chat_ResetChatSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    /**
     * Reset chat session, put it back on the queue for pickup. Used by bots to hand off a session to human
     * @param chatSessionId - id of the chat session to reset
     * @returns The updated chat session
     */
    public async ResetChatSession(chatSessionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    public async ResetChatSession(chatSessionId:number|carriers.Chat_ResetChatSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        let _request : carriers.Chat_ResetChatSessionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatSessionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatSessionId)!='undefined' ) )
        {
            _request = chatSessionId as carriers.Chat_ResetChatSessionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatSessionId: chatSessionId as number,
                       };   
            _options = webapi_options;
        }
        return this._ResetChatSession( _request, _options );
    }


    private async _GetChatTranscript(request: carriers.Chat_GetChatTranscriptRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatTranscript", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the chat transcript, formatted as plain text or html
     * @param request - ChatSessionId, Html
     * @returns The transcript in text or HTML
     */
    public async GetChatTranscript(request: carriers.Chat_GetChatTranscriptRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the chat transcript, formatted as plain text or html
     * @param chatSessionId - id of the chat session to get the transcript for
     * @param html - Get transcript as HTML
     * @returns The transcript in text or HTML
     */
    public async GetChatTranscript(chatSessionId: number, html: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetChatTranscript(chatSessionId:number|carriers.Chat_GetChatTranscriptRequest, html?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Chat_GetChatTranscriptRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatSessionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatSessionId)!='undefined' || typeof(first.Html)!='undefined' ) )
        {
            _request = chatSessionId as carriers.Chat_GetChatTranscriptRequest;
            _options = html as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatSessionId: chatSessionId as number,
                       Html: html as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetChatTranscript( _request, _options );
    }


    private async _GetChatMessages(request: carriers.Chat_GetChatMessagesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatMessage[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatMessages", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatMessage[] = converters.Create_ChatMessageArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all or some of the messages in a chat session
     * @param request - ChatSessionId, After
     * @returns Array of chat messages in the session
     */
    public async GetChatMessages(request: carriers.Chat_GetChatMessagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage[] >;

    /**
     * Get all or some of the messages in a chat session
     * @param chatSessionId - id of the chat session to reset
     * @param after - Return messages after this message id
     * @returns Array of chat messages in the session
     */
    public async GetChatMessages(chatSessionId: number, after: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage[] >;

    public async GetChatMessages(chatSessionId:number|carriers.Chat_GetChatMessagesRequest, after?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage[] > {
        let _request : carriers.Chat_GetChatMessagesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatSessionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatSessionId)!='undefined' || typeof(first.After)!='undefined' ) )
        {
            _request = chatSessionId as carriers.Chat_GetChatMessagesRequest;
            _options = after as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatSessionId: chatSessionId as number,
                       After: after as number,
                       };   
            _options = webapi_options;
        }
        return this._GetChatMessages( _request, _options );
    }


    private async _AddChatMessage(request: carriers.Chat_AddChatMessageRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatMessage >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddChatMessage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatMessage = converters.Create_ChatMessage_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add a new message to a chat session
     * @param request - ChatSessionId, Message
     * @returns The chat message added to the session
     */
    public async AddChatMessage(request: carriers.Chat_AddChatMessageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage >;

    /**
     * Add a new message to a chat session
     * @param chatSessionId - id of the chat session to add message to
     * @param message - Message to add
     * @returns The chat message added to the session
     */
    public async AddChatMessage(chatSessionId: number, message: carriers.ChatMessage, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage >;

    public async AddChatMessage(chatSessionId:number|carriers.Chat_AddChatMessageRequest, message?:carriers.ChatMessage|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatMessage > {
        let _request : carriers.Chat_AddChatMessageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatSessionId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatSessionId)!='undefined' || typeof(first.Message)!='undefined' ) )
        {
            _request = chatSessionId as carriers.Chat_AddChatMessageRequest;
            _options = message as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatSessionId: chatSessionId as number,
                       Message: message as carriers.ChatMessage,
                       };   
            _options = webapi_options;
        }
        return this._AddChatMessage( _request, _options );
    }

    /*
     * Gets a ChatTopicEntity object.
     * @param chatTopicEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ChatTopicEntity
     */
    public async GetChatTopicEntity(chatTopicEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetChatTopicEntity?chatTopicEntityId=" + chatTopicEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _IsWithinOpeningHours(request: carriers.Chat_IsWithinOpeningHoursRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsWithinOpeningHours", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check if we are right now within the opening hours of the given topic. Will use timezones to calculate if configured.
     * @param request - ChatTopicId
     * @returns True if we are within opening hours, or if the topic does not use opening hours
     */
    public async IsWithinOpeningHours(request: carriers.Chat_IsWithinOpeningHoursRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Check if we are right now within the opening hours of the given topic. Will use timezones to calculate if configured.
     * @param chatTopicId - The id of the topic to check
     * @returns True if we are within opening hours, or if the topic does not use opening hours
     */
    public async IsWithinOpeningHours(chatTopicId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async IsWithinOpeningHours(chatTopicId:number|carriers.Chat_IsWithinOpeningHoursRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Chat_IsWithinOpeningHoursRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatTopicId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatTopicId)!='undefined' ) )
        {
            _request = chatTopicId as carriers.Chat_IsWithinOpeningHoursRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatTopicId: chatTopicId as number,
                       };   
            _options = webapi_options;
        }
        return this._IsWithinOpeningHours( _request, _options );
    }


    private async _ChatTopicsForUser( options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicEntity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicEntity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChatTopicsForUser", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatTopicEntity[] = converters.Create_ChatTopicEntityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get all chat topics which this user is a member of. Members means that you have at least one of: Can Respond, Notifications, Listen or Manager
     * @returns Array of chat topics the current user can access
     */
    public async ChatTopicsForUser(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicEntity[] >
    {
        return this._ChatTopicsForUser(webapi_options);
    }


    private async _GetUserAgentList(request: carriers.Chat_GetUserAgentListRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserAgentList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MDOListItem[] = converters.Create_MDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get list of users that can be assigned to chat topics. Users with Chat-CALs from the MDO list &apos;chatuser&apos;
     * @param request - Flat, OnlyPresent
     * @returns List of user agents that can be assigned to chat topics, possibly grouped by usergroup.
     */
    public async GetUserAgentList(request: carriers.Chat_GetUserAgentListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    /**
     * Get list of users that can be assigned to chat topics. Users with Chat-CALs from the MDO list &apos;chatuser&apos;
     * @param flat - Return flat list instead of grouping by usergroup.
     * @param onlyPresent - Only show users who are present
     * @returns List of user agents that can be assigned to chat topics, possibly grouped by usergroup.
     */
    public async GetUserAgentList(flat: boolean, onlyPresent: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    public async GetUserAgentList(flat:boolean|carriers.Chat_GetUserAgentListRequest, onlyPresent?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        let _request : carriers.Chat_GetUserAgentListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = flat;
        if( typeof( first ) === "object" && first && ( typeof(first.Flat)!='undefined' || typeof(first.OnlyPresent)!='undefined' ) )
        {
            _request = flat as carriers.Chat_GetUserAgentListRequest;
            _options = onlyPresent as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Flat: flat as boolean,
                       OnlyPresent: onlyPresent as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetUserAgentList( _request, _options );
    }


    private async _GetChatTopicUserAgentList(request: carriers.Chat_GetChatTopicUserAgentListRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicAgent[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatTopicUserAgentList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatTopicAgent[] = converters.Create_ChatTopicAgentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get list of users assigned to a chat topic
     * @param request - ChatTopicId
     * @returns List of user agents assigned to chat topic.
     */
    public async GetChatTopicUserAgentList(request: carriers.Chat_GetChatTopicUserAgentListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] >;

    /**
     * Get list of users assigned to a chat topic
     * @param chatTopicId - Id of the chat topic
     * @returns List of user agents assigned to chat topic.
     */
    public async GetChatTopicUserAgentList(chatTopicId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] >;

    public async GetChatTopicUserAgentList(chatTopicId:number|carriers.Chat_GetChatTopicUserAgentListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] > {
        let _request : carriers.Chat_GetChatTopicUserAgentListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatTopicId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatTopicId)!='undefined' ) )
        {
            _request = chatTopicId as carriers.Chat_GetChatTopicUserAgentListRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatTopicId: chatTopicId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetChatTopicUserAgentList( _request, _options );
    }


    private async _GetChatTopicUserAgent(request: carriers.Chat_GetChatTopicUserAgentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicAgent >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatTopicUserAgent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatTopicAgent = converters.Create_ChatTopicAgent_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a user assigned to a topic
     * @param request - ChatTopicId, Username
     * @returns The user's role within the chat topic.
     */
    public async GetChatTopicUserAgent(request: carriers.Chat_GetChatTopicUserAgentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;

    /**
     * Get a user assigned to a topic
     * @param chatTopicId - Id of the chat topic
     * @param username - Associate username or associate id to get.
     * @returns The user's role within the chat topic.
     */
    public async GetChatTopicUserAgent(chatTopicId: number, username: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;

    public async GetChatTopicUserAgent(chatTopicId:number|carriers.Chat_GetChatTopicUserAgentRequest, username?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent > {
        let _request : carriers.Chat_GetChatTopicUserAgentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatTopicId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatTopicId)!='undefined' || typeof(first.Username)!='undefined' ) )
        {
            _request = chatTopicId as carriers.Chat_GetChatTopicUserAgentRequest;
            _options = username as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatTopicId: chatTopicId as number,
                       Username: username as string,
                       };   
            _options = webapi_options;
        }
        return this._GetChatTopicUserAgent( _request, _options );
    }


    private async _AddChatTopicUserAgent(request: carriers.Chat_AddChatTopicUserAgentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicAgent >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddChatTopicUserAgent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatTopicAgent = converters.Create_ChatTopicAgent_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add a user to a chat topic
     * @param request - ChatTopicId, Useragent
     * @returns The user's role within the chat topic.
     */
    public async AddChatTopicUserAgent(request: carriers.Chat_AddChatTopicUserAgentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;

    /**
     * Add a user to a chat topic
     * @param chatTopicId - Id of the chat topic
     * @param useragent - User's role within the chat topic to add to topic.
     * @returns The user's role within the chat topic.
     */
    public async AddChatTopicUserAgent(chatTopicId: number, useragent: carriers.ChatTopicAgent, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;

    public async AddChatTopicUserAgent(chatTopicId:number|carriers.Chat_AddChatTopicUserAgentRequest, useragent?:carriers.ChatTopicAgent|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent > {
        let _request : carriers.Chat_AddChatTopicUserAgentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatTopicId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatTopicId)!='undefined' || typeof(first.Useragent)!='undefined' ) )
        {
            _request = chatTopicId as carriers.Chat_AddChatTopicUserAgentRequest;
            _options = useragent as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatTopicId: chatTopicId as number,
                       Useragent: useragent as carriers.ChatTopicAgent,
                       };   
            _options = webapi_options;
        }
        return this._AddChatTopicUserAgent( _request, _options );
    }


    private async _UpdateChatTopicUserAgent(request: carriers.Chat_UpdateChatTopicUserAgentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicAgent >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateChatTopicUserAgent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatTopicAgent = converters.Create_ChatTopicAgent_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update a user&apos;s role in a chat topic
     * @param request - ChatTopicId, Username, Useragent
     * @returns The user's role within the chat topic.
     */
    public async UpdateChatTopicUserAgent(request: carriers.Chat_UpdateChatTopicUserAgentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;

    /**
     * Update a user&apos;s role in a chat topic
     * @param chatTopicId - Id of the chat topic
     * @param username - Associate username or associate id to get.
     * @param useragent - User's updated role within the chat topic.
     * @returns The user's role within the chat topic.
     */
    public async UpdateChatTopicUserAgent(chatTopicId: number, username: string, useragent: carriers.ChatTopicAgent, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent >;

    public async UpdateChatTopicUserAgent(chatTopicId:number|carriers.Chat_UpdateChatTopicUserAgentRequest, username?:string|base.WebApiRequestOptions, useragent?:carriers.ChatTopicAgent, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent > {
        let _request : carriers.Chat_UpdateChatTopicUserAgentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatTopicId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatTopicId)!='undefined' || typeof(first.Username)!='undefined' || typeof(first.Useragent)!='undefined' ) )
        {
            _request = chatTopicId as carriers.Chat_UpdateChatTopicUserAgentRequest;
            _options = username as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatTopicId: chatTopicId as number,
                       Username: username as string,
                       Useragent: useragent as carriers.ChatTopicAgent,
                       };   
            _options = webapi_options;
        }
        return this._UpdateChatTopicUserAgent( _request, _options );
    }


    private async _UpdateChatTopicUserAgents(request: carriers.Chat_UpdateChatTopicUserAgentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatTopicAgent[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateChatTopicUserAgents", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatTopicAgent[] = converters.Create_ChatTopicAgentArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update users roles in a chat topic
     * @param request - ChatTopicId, Useragents
     * @returns The updated agents within the chat topic.
     */
    public async UpdateChatTopicUserAgents(request: carriers.Chat_UpdateChatTopicUserAgentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] >;

    /**
     * Update users roles in a chat topic
     * @param chatTopicId - Id of the chat topic
     * @param useragents - Users new/updated roles within the chat topic. Replaces existing roles
     * @returns The updated agents within the chat topic.
     */
    public async UpdateChatTopicUserAgents(chatTopicId: number, useragents: carriers.ChatTopicAgent[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] >;

    public async UpdateChatTopicUserAgents(chatTopicId:number|carriers.Chat_UpdateChatTopicUserAgentsRequest, useragents?:carriers.ChatTopicAgent[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatTopicAgent[] > {
        let _request : carriers.Chat_UpdateChatTopicUserAgentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatTopicId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatTopicId)!='undefined' || typeof(first.Useragents)!='undefined' ) )
        {
            _request = chatTopicId as carriers.Chat_UpdateChatTopicUserAgentsRequest;
            _options = useragents as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatTopicId: chatTopicId as number,
                       Useragents: useragents as carriers.ChatTopicAgent[],
                       };   
            _options = webapi_options;
        }
        return this._UpdateChatTopicUserAgents( _request, _options );
    }


    private async _DeleteChatTopicUserAgent(request: carriers.Chat_DeleteChatTopicUserAgentRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteChatTopicUserAgent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove a user from a topic
     * @param request - ChatTopicId, Username
     * @returns This method has no return value
     */
    public async DeleteChatTopicUserAgent(request: carriers.Chat_DeleteChatTopicUserAgentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Remove a user from a topic
     * @param chatTopicId - Id of the chat topic
     * @param username - Associate username or associate id to delete.
     * @returns This method has no return value
     */
    public async DeleteChatTopicUserAgent(chatTopicId: number, username: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteChatTopicUserAgent(chatTopicId:number|carriers.Chat_DeleteChatTopicUserAgentRequest, username?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Chat_DeleteChatTopicUserAgentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatTopicId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatTopicId)!='undefined' || typeof(first.Username)!='undefined' ) )
        {
            _request = chatTopicId as carriers.Chat_DeleteChatTopicUserAgentRequest;
            _options = username as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatTopicId: chatTopicId as number,
                       Username: username as string,
                       };   
            _options = webapi_options;
        }
        return this._DeleteChatTopicUserAgent( _request, _options );
    }


    private async _CreateChatSessionForTopic(request: carriers.Chat_CreateChatSessionForTopicRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ChatSessionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateChatSessionForTopic", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ChatSessionEntity = converters.Create_ChatSessionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a new session on a chat topic
     * @param request - ChatTopicId
     * @returns The new chat session.
     */
    public async CreateChatSessionForTopic(request: carriers.Chat_CreateChatSessionForTopicRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    /**
     * Create a new session on a chat topic
     * @param chatTopicId - Id of the chat topic
     * @returns The new chat session.
     */
    public async CreateChatSessionForTopic(chatTopicId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity >;

    public async CreateChatSessionForTopic(chatTopicId:number|carriers.Chat_CreateChatSessionForTopicRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ChatSessionEntity > {
        let _request : carriers.Chat_CreateChatSessionForTopicRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = chatTopicId;
        if( typeof( first ) === "object" && first && ( typeof(first.ChatTopicId)!='undefined' ) )
        {
            _request = chatTopicId as carriers.Chat_CreateChatSessionForTopicRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ChatTopicId: chatTopicId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateChatSessionForTopic( _request, _options );
    }

    } // class v1ChatAgentController 



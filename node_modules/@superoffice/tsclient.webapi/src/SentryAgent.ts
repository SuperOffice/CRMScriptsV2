// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/SentryAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Data and function right queries
 */
export interface ISentryAgent {
    GetNewTableRight(request: carriers.Sentry_GetNewTableRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;
    GetNewTableRight(tableName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;
    GetTableRightByOwnership(request: carriers.Sentry_GetTableRightByOwnershipRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;
    GetTableRightByOwnership(tableName: string, contactGroupId: number, contactAssociateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;
    GetFunctionRights(webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    HasFunctionRight(request: carriers.Sentry_HasFunctionRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasFunctionRight(functionRight: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CanCreateAppointmentInAssociateDiaries(request: carriers.Sentry_CanCreateAppointmentInAssociateDiariesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CanCreateAppointmentInAssociateDiaries(associateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CanCreateAppointmentInAllDiaries(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetTableRightByContactOwnership(request: carriers.Sentry_GetTableRightByContactOwnershipRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;
    GetTableRightByContactOwnership(tableName: string, contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;
} // interface ISentryAgent




/**
 * Data and function right queries
 */
export class SentryAgent extends base.WebApiBase implements ISentryAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Sentry/";
        super(options);
    }



    private async _GetNewTableRight(request: carriers.Sentry_GetNewTableRightRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TableRight > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TableRight >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNewTableRight", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TableRight = converters.Create_TableRight_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns a TableRight for a new row based on tableName parameter.
     * @param request - TableName
     * @returns The TableRight
     */
    public async GetNewTableRight(request: carriers.Sentry_GetNewTableRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;

    /**
     * Returns a TableRight for a new row based on tableName parameter.
     * @param tableName - Name of the table to get the TableRights from
     * @returns The TableRight
     */
    public async GetNewTableRight(tableName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;

    public async GetNewTableRight(tableName:string|carriers.Sentry_GetNewTableRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight > {
        let _request : carriers.Sentry_GetNewTableRightRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' ) )
        {
            _request = tableName as carriers.Sentry_GetNewTableRightRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetNewTableRight( _request, _options );
    }


    private async _GetTableRightByOwnership(request: carriers.Sentry_GetTableRightByOwnershipRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TableRight > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TableRight >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTableRightByOwnership", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TableRight = converters.Create_TableRight_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Return the TableRight from the relationship between the current user and the given user and group.
     * @param request - TableName, ContactGroupId, ContactAssociateId
     * @returns The TableRight
     */
    public async GetTableRightByOwnership(request: carriers.Sentry_GetTableRightByOwnershipRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;

    /**
     * Return the TableRight from the relationship between the current user and the given user and group.
     * @param tableName - Name of the table to get the TableRights from.
     * @param contactGroupId - The user-group that the associate id is part of.
     * @param contactAssociateId - The associate id of the owner of the record
     * @returns The TableRight
     */
    public async GetTableRightByOwnership(tableName: string, contactGroupId: number, contactAssociateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;

    public async GetTableRightByOwnership(tableName:string|carriers.Sentry_GetTableRightByOwnershipRequest, contactGroupId?:number|base.WebApiRequestOptions, contactAssociateId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight > {
        let _request : carriers.Sentry_GetTableRightByOwnershipRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.ContactGroupId)!='undefined' || typeof(first.ContactAssociateId)!='undefined' ) )
        {
            _request = tableName as carriers.Sentry_GetTableRightByOwnershipRequest;
            _options = contactGroupId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       ContactGroupId: contactGroupId as number,
                       ContactAssociateId: contactAssociateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetTableRightByOwnership( _request, _options );
    }


    private async _GetFunctionRights( options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFunctionRights", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get a string array of all functions rights for the role of the current associate.
     * @returns String array with the technical names of assigned function rights
     */
    public async GetFunctionRights(webapi_options?:base.WebApiRequestOptions) : Promise< string[] >
    {
        return this._GetFunctionRights(webapi_options);
    }


    private async _HasFunctionRight(request: carriers.Sentry_HasFunctionRightRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasFunctionRight", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a boolean value indicating if the current user has the functional right.
     * @param request - FunctionRight
     * @returns 
     */
    public async HasFunctionRight(request: carriers.Sentry_HasFunctionRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Get a boolean value indicating if the current user has the functional right.
     * @param functionRight - Function right to check.
     * @returns 
     */
    public async HasFunctionRight(functionRight: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasFunctionRight(functionRight:string|carriers.Sentry_HasFunctionRightRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Sentry_HasFunctionRightRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = functionRight;
        if( typeof( first ) === "object" && first && ( typeof(first.FunctionRight)!='undefined' ) )
        {
            _request = functionRight as carriers.Sentry_HasFunctionRightRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FunctionRight: functionRight as string,
                       };   
            _options = webapi_options;
        }
        return this._HasFunctionRight( _request, _options );
    }


    private async _CanCreateAppointmentInAssociateDiaries(request: carriers.Sentry_CanCreateAppointmentInAssociateDiariesRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanCreateAppointmentInAssociateDiaries", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * CanCreateAppointmentInAssociateDiaries will check if the current associate can create appointments in diaries belonging to the associates listed in associateIds. CanCreateAppointmentInAssociateDiaries will only check against associates that are diary owners. If none of the associates listed in the associateIds parameter is a diary owner, the method will return true.
     * @param request - AssociateIds
     * @returns Returns true if the current associate can create appointments in the diary of all the other associates, otherwise false.
     */
    public async CanCreateAppointmentInAssociateDiaries(request: carriers.Sentry_CanCreateAppointmentInAssociateDiariesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * CanCreateAppointmentInAssociateDiaries will check if the current associate can create appointments in diaries belonging to the associates listed in associateIds. CanCreateAppointmentInAssociateDiaries will only check against associates that are diary owners. If none of the associates listed in the associateIds parameter is a diary owner, the method will return true.
     * @param associateIds - Array of associate ids to check.
     * @returns Returns true if the current associate can create appointments in the diary of all the other associates, otherwise false.
     */
    public async CanCreateAppointmentInAssociateDiaries(associateIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async CanCreateAppointmentInAssociateDiaries(associateIds:number[]|carriers.Sentry_CanCreateAppointmentInAssociateDiariesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Sentry_CanCreateAppointmentInAssociateDiariesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = associateIds;
        if( typeof( first ) === "object" && first && ( typeof(first.AssociateIds)!='undefined' ) )
        {
            _request = associateIds as carriers.Sentry_CanCreateAppointmentInAssociateDiariesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AssociateIds: associateIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._CanCreateAppointmentInAssociateDiaries( _request, _options );
    }


    private async _CanCreateAppointmentInAllDiaries( options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanCreateAppointmentInAllDiaries", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * CanCreateAppointmentInAllDiaries will check if the current associate can create appointments in diaries belonging all other associates. CanCreateAppointmentInAssociateDiaries will only check against associates that are diary owners.
     * @returns Returns true if the current associate can create appointments in the diary of all the other associates, otherwise false.
     */
    public async CanCreateAppointmentInAllDiaries(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >
    {
        return this._CanCreateAppointmentInAllDiaries(webapi_options);
    }


    private async _GetTableRightByContactOwnership(request: carriers.Sentry_GetTableRightByContactOwnershipRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TableRight > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TableRight >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTableRightByContactOwnership", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TableRight = converters.Create_TableRight_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Return the TableRight from the relationship between the current user and the given user and group.
     * @param request - TableName, ContactId
     * @returns The TableRight
     */
    public async GetTableRightByContactOwnership(request: carriers.Sentry_GetTableRightByContactOwnershipRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;

    /**
     * Return the TableRight from the relationship between the current user and the given user and group.
     * @param tableName - Name of the table to get the TableRights from.
     * @param contactId - The owner contact.
     * @returns The TableRight
     */
    public async GetTableRightByContactOwnership(tableName: string, contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight >;

    public async GetTableRightByContactOwnership(tableName:string|carriers.Sentry_GetTableRightByContactOwnershipRequest, contactId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TableRight > {
        let _request : carriers.Sentry_GetTableRightByContactOwnershipRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.ContactId)!='undefined' ) )
        {
            _request = tableName as carriers.Sentry_GetTableRightByContactOwnershipRequest;
            _options = contactId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetTableRightByContactOwnership( _request, _options );
    }

    } // class v1SentryAgentController 



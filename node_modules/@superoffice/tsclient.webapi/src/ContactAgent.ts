// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/ContactAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Contact (company) data services.
 */
export interface IContactAgent {
    CreateDefaultContactEntity(): Promise< carriers.ContactEntity >;
    SaveContactEntity(entity: carriers.ContactEntity) : Promise< carriers.ContactEntity >;
    DeleteContactEntity(ContactEntityId: number) : Promise<void>;
    CreateDefaultPreviewContact(): Promise< carriers.PreviewContact >;
    GetContact(contactId: number) :  Promise< carriers.Contact >;
    GetMyActiveContacts(request: carriers.Contact_GetMyActiveContactsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactActivity[] >;
    GetMyActiveContacts(activityStartTime: Date, contactCategories: number[], actionType: enums.ContactAction, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactActivity[] >;
    GetContactEntity(contactEntityId: number) :  Promise< carriers.ContactEntity >;
    Undelete(request: carriers.Contact_UndeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Undelete(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPersons(request: carriers.Contact_GetPersonsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetPersons(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetContactWithPersons(request: carriers.Contact_GetContactWithPersonsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;
    GetContactWithPersons(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;
    GetMyContact(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;
    GetMyBizCard(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;
    ChangeCountry(request: carriers.Contact_ChangeCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;
    ChangeCountry(contactEntity: carriers.ContactEntity, toCountryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;
    GetAddress(request: carriers.Contact_GetAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    GetAddress(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    GetAddressByCountry(request: carriers.Contact_GetAddressByCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    GetAddressByCountry(contactId: number, countryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    AddPerson(request: carriers.Contact_AddPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    AddPerson(contactId: number, newPersonEntity: carriers.PersonEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    GetDuplicates(request: carriers.Contact_GetDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;
    GetDuplicates(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;
    CreateNewEntry(request: carriers.Contact_CreateNewEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CreateNewEntry(duplicate: carriers.DuplicateEntry, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetDuplicateRules(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateRule[] >;
    SetDuplicateRulesStatus(request: carriers.Contact_SetDuplicateRulesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetDuplicateRulesStatus(rules: carriers.DuplicateRule[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Merge(request: carriers.Contact_MergeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Merge(sourceContactId: number, destinationContactId: number, mergeIdenticalPersons: boolean, replaceEmptyFieldsOnDestination: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Copy(request: carriers.Contact_CopyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    Copy(sourceContactId: number, destinationContactName: string, destinationContactDepartment: string, copyPersons: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetNameDepartmentDuplicates(request: carriers.Contact_GetNameDepartmentDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;
    GetNameDepartmentDuplicates(name: string, department: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;
    IsNumberValid(request: carriers.Contact_IsNumberValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsNumberValid(contactId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetQuoteVersionAddresses(request: carriers.Contact_GetQuoteVersionAddressesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address[] >;
    GetQuoteVersionAddresses(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address[] >;
    SaveQuoteVersionAddress(request: carriers.Contact_SaveQuoteVersionAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    SaveQuoteVersionAddress(quoteVersionId: number, address: carriers.Address, addressType: enums.AddressType, countryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    DeleteExpired(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetContactSummary(request: carriers.Contact_GetContactSummaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactSummary >;
    GetContactSummary(contactId: number, limit: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactSummary >;
    ValidateContactEntity(request: carriers.Contact_ValidateContactEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    ValidateContactEntity(contactEntity: carriers.ContactEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    GetContactList(contactIds: number[]) :  Promise< carriers.Contact[] >;
    GetMyContacts(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] >;
    GetMyRecentContacts(request: carriers.Contact_GetMyRecentContactsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] >;
    GetMyRecentContacts(sourceType: enums.ContactSourceType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] >;
    GetPreviewContact(request: carriers.Contact_GetPreviewContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewContact >;
    GetPreviewContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewContact >;
} // interface IContactAgent




/**
 * Contact (company) data services.
 */
export class ContactAgent extends base.WebApiBase implements IContactAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Contact/";
        super(options);
    }



    /**
     * Set default values into a new ContactEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultContactEntity(options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultContactEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactEntity = converters.Create_ContactEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ContactEntity or creates a new ContactEntity if the id parameter is empty
     * @param entity - The ContactEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ContactEntity
     */
    public async SaveContactEntity(entity: carriers.ContactEntity, options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveContactEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactEntity = converters.Create_ContactEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ContactEntity
     * @param ContactEntityId - The id of the ContactEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteContactEntity(ContactEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteContactEntity?ContactEntityId=" + ContactEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new PreviewContact.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultPreviewContact(options?:base.WebApiRequestOptions) : Promise< carriers.PreviewContact > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreviewContact >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreviewContact", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreviewContact = converters.Create_PreviewContact_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Contact object.
     * @param contactId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Contact
     */
    public async GetContact(contactId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Contact > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Contact >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetContact?contactId=" + contactId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Contact_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetMyActiveContacts(request: carriers.Contact_GetMyActiveContactsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ContactActivity[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactActivity[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyActiveContacts", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactActivity[] = converters.Create_ContactActivityArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the contacts where there has been activity since activityStartTime. If activityStartTime is larger than the current date, all contacts with activity since last log-out are returned. The result set can be filtered by category and action type.
     * @param request - ActivityStartTime, ContactCategories, ActionType
     * @returns Array of contacts where there have been activity in the period.
     */
    public async GetMyActiveContacts(request: carriers.Contact_GetMyActiveContactsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactActivity[] >;

    /**
     * Returns the contacts where there has been activity since activityStartTime. If activityStartTime is larger than the current date, all contacts with activity since last log-out are returned. The result set can be filtered by category and action type.
     * @param activityStartTime - The start time of the activities. If the start time is set to a future date; activites since the user last logged out are returned.
     * @param contactCategories - Integer array of categories to filter on. If the array is empty contacts from all categories will be selected.
     * @param actionType - The type of action that has occured. E.g. updates, deletes, new appointments, etc.
     * @returns Array of contacts where there have been activity in the period.
     */
    public async GetMyActiveContacts(activityStartTime: Date, contactCategories: number[], actionType: enums.ContactAction, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactActivity[] >;

    public async GetMyActiveContacts(activityStartTime:Date|carriers.Contact_GetMyActiveContactsRequest, contactCategories?:number[]|base.WebApiRequestOptions, actionType?:enums.ContactAction, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactActivity[] > {
        let _request : carriers.Contact_GetMyActiveContactsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = activityStartTime;
        if( typeof( first ) === "object" && first && ( typeof(first.ActivityStartTime)!='undefined' || typeof(first.ContactCategories)!='undefined' || typeof(first.ActionType)!='undefined' ) )
        {
            _request = activityStartTime as carriers.Contact_GetMyActiveContactsRequest;
            _options = contactCategories as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ActivityStartTime: activityStartTime as Date,
                       ContactCategories: contactCategories as number[],
                       ActionType: actionType as enums.ContactAction,
                       };   
            _options = webapi_options;
        }
        return this._GetMyActiveContacts( _request, _options );
    }

    /*
     * Gets a ContactEntity object.
     * @param contactEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ContactEntity
     */
    public async GetContactEntity(contactEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetContactEntity?contactEntityId=" + contactEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _Undelete(request: carriers.Contact_UndeleteRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Undelete", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This entity supports Soft Delete. Call this method to Undelete a previously soft-deleted record
     * @param request - Id
     * @returns This method has no return value
     */
    public async Undelete(request: carriers.Contact_UndeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * This entity supports Soft Delete. Call this method to Undelete a previously soft-deleted record
     * @param id - The primary key of the entity to undelete
     * @returns This method has no return value
     */
    public async Undelete(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Undelete(id:number|carriers.Contact_UndeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Contact_UndeleteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.Contact_UndeleteRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._Undelete( _request, _options );
    }


    private async _GetPersons(request: carriers.Contact_GetPersonsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersons", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person[] = converters.Create_PersonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns an array of all the contact persons for the company card.
     * @param request - ContactId
     * @returns Array of Persons
     */
    public async GetPersons(request: carriers.Contact_GetPersonsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    /**
     * Returns an array of all the contact persons for the company card.
     * @param contactId - 
     * @returns Array of Persons
     */
    public async GetPersons(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    public async GetPersons(contactId:number|carriers.Contact_GetPersonsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        let _request : carriers.Contact_GetPersonsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.Contact_GetPersonsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersons( _request, _options );
    }


    private async _GetContactWithPersons(request: carriers.Contact_GetContactWithPersonsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactWithPersons", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactEntity = converters.Create_ContactEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the contact with all the contact persons belonging to the contact
     * @param request - ContactId
     * @returns ContactEntity with all data and persons.
     */
    public async GetContactWithPersons(request: carriers.Contact_GetContactWithPersonsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;

    /**
     * Returns the contact with all the contact persons belonging to the contact
     * @param contactId - The id of the contact.
     * @returns ContactEntity with all data and persons.
     */
    public async GetContactWithPersons(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;

    public async GetContactWithPersons(contactId:number|carriers.Contact_GetContactWithPersonsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity > {
        let _request : carriers.Contact_GetContactWithPersonsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.Contact_GetContactWithPersonsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactWithPersons( _request, _options );
    }


    private async _GetMyContact( options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyContact", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactEntity = converters.Create_ContactEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets the contact belonging to the currently logged on user.
     * @returns The Contact
     */
    public async GetMyContact(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >
    {
        return this._GetMyContact(webapi_options);
    }


    private async _GetMyBizCard( options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyBizCard", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactEntity = converters.Create_ContactEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all data needed to display the logged on person&apos;s business card. That is company, person, and company interest data.
     * @returns The contact object with persons and interests
     */
    public async GetMyBizCard(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >
    {
        return this._GetMyBizCard(webapi_options);
    }


    private async _ChangeCountry(request: carriers.Contact_ChangeCountryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeCountry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactEntity = converters.Create_ContactEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change country regenerates the default values and localized information such as phone number and address format
     * @param request - ContactEntity, ToCountryId
     * @returns 
     */
    public async ChangeCountry(request: carriers.Contact_ChangeCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;

    /**
     * Change country regenerates the default values and localized information such as phone number and address format
     * @param contactEntity - 
     * @param toCountryId - The country to switch to
     * @returns 
     */
    public async ChangeCountry(contactEntity: carriers.ContactEntity, toCountryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity >;

    public async ChangeCountry(contactEntity:carriers.ContactEntity|carriers.Contact_ChangeCountryRequest, toCountryId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactEntity > {
        let _request : carriers.Contact_ChangeCountryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactEntity)!='undefined' || typeof(first.ToCountryId)!='undefined' ) )
        {
            _request = contactEntity as carriers.Contact_ChangeCountryRequest;
            _options = toCountryId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactEntity: contactEntity as carriers.ContactEntity,
                       ToCountryId: toCountryId as number,
                       };   
            _options = webapi_options;
        }
        return this._ChangeCountry( _request, _options );
    }


    private async _GetAddress(request: carriers.Contact_GetAddressRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Address >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAddress", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Address = converters.Create_Address_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the contact&apos;s localized address.
     * @param request - ContactId
     * @returns The address as LocalizedField[][].
     */
    public async GetAddress(request: carriers.Contact_GetAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    /**
     * Gets the contact&apos;s localized address.
     * @param contactId - The contact id
     * @returns The address as LocalizedField[][].
     */
    public async GetAddress(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    public async GetAddress(contactId:number|carriers.Contact_GetAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        let _request : carriers.Contact_GetAddressRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.Contact_GetAddressRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAddress( _request, _options );
    }


    private async _GetAddressByCountry(request: carriers.Contact_GetAddressByCountryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Address >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAddressByCountry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Address = converters.Create_Address_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the contact&apos;s localized address.
     * @param request - ContactId, CountryId
     * @returns The address as LocalizedField[][].
     */
    public async GetAddressByCountry(request: carriers.Contact_GetAddressByCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    /**
     * Gets the contact&apos;s localized address.
     * @param contactId - The contact id
     * @param countryId - 
     * @returns The address as LocalizedField[][].
     */
    public async GetAddressByCountry(contactId: number, countryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    public async GetAddressByCountry(contactId:number|carriers.Contact_GetAddressByCountryRequest, countryId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        let _request : carriers.Contact_GetAddressByCountryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.CountryId)!='undefined' ) )
        {
            _request = contactId as carriers.Contact_GetAddressByCountryRequest;
            _options = countryId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       CountryId: countryId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAddressByCountry( _request, _options );
    }


    private async _AddPerson(request: carriers.Contact_AddPersonRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddPerson", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonEntity = converters.Create_PersonEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add a person to the given contact
     * @param request - ContactId, NewPersonEntity
     * @returns Updated person object
     */
    public async AddPerson(request: carriers.Contact_AddPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    /**
     * Add a person to the given contact
     * @param contactId - Contact to add person to
     * @param newPersonEntity - Person object to add
     * @returns Updated person object
     */
    public async AddPerson(contactId: number, newPersonEntity: carriers.PersonEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    public async AddPerson(contactId:number|carriers.Contact_AddPersonRequest, newPersonEntity?:carriers.PersonEntity|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        let _request : carriers.Contact_AddPersonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.NewPersonEntity)!='undefined' ) )
        {
            _request = contactId as carriers.Contact_AddPersonRequest;
            _options = newPersonEntity as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       NewPersonEntity: newPersonEntity as carriers.PersonEntity,
                       };   
            _options = webapi_options;
        }
        return this._AddPerson( _request, _options );
    }


    private async _GetDuplicates(request: carriers.Contact_GetDuplicatesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DuplicateEntry[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DuplicateEntry[] = converters.Create_DuplicateEntryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get duplicates (exact or similar in the database) based on the name
     * @param request - Name
     * @returns Any records matching the specified name
     */
    public async GetDuplicates(request: carriers.Contact_GetDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;

    /**
     * Get duplicates (exact or similar in the database) based on the name
     * @param name - Name used for lookup
     * @returns Any records matching the specified name
     */
    public async GetDuplicates(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;

    public async GetDuplicates(name:string|carriers.Contact_GetDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] > {
        let _request : carriers.Contact_GetDuplicatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' ) )
        {
            _request = name as carriers.Contact_GetDuplicatesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._GetDuplicates( _request, _options );
    }


    private async _CreateNewEntry(request: carriers.Contact_CreateNewEntryRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewEntry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a new contact based on external duplicate
     * @param request - Duplicate
     * @returns The database identity of the newly created entry
     */
    public async CreateNewEntry(request: carriers.Contact_CreateNewEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Creates a new contact based on external duplicate
     * @param duplicate - The duplicate to create a new entry based upon
     * @returns The database identity of the newly created entry
     */
    public async CreateNewEntry(duplicate: carriers.DuplicateEntry, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async CreateNewEntry(duplicate:carriers.DuplicateEntry|carriers.Contact_CreateNewEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Contact_CreateNewEntryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = duplicate;
        if( typeof( first ) === "object" && first && ( typeof(first.Duplicate)!='undefined' ) )
        {
            _request = duplicate as carriers.Contact_CreateNewEntryRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Duplicate: duplicate as carriers.DuplicateEntry,
                       };   
            _options = webapi_options;
        }
        return this._CreateNewEntry( _request, _options );
    }


    private async _GetDuplicateRules( options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateRule[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DuplicateRule[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicateRules", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DuplicateRule[] = converters.Create_DuplicateRuleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Retrieve all available duplicate rules for contact
     * @returns All available duplicate rules
     */
    public async GetDuplicateRules(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateRule[] >
    {
        return this._GetDuplicateRules(webapi_options);
    }


    private async _SetDuplicateRulesStatus(request: carriers.Contact_SetDuplicateRulesStatusRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDuplicateRulesStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set which duplicate rules should be active or not
     * @param request - Rules
     * @returns 
     */
    public async SetDuplicateRulesStatus(request: carriers.Contact_SetDuplicateRulesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set which duplicate rules should be active or not
     * @param rules - Duplicate rules to update active status for
     * @returns 
     */
    public async SetDuplicateRulesStatus(rules: carriers.DuplicateRule[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetDuplicateRulesStatus(rules:carriers.DuplicateRule[]|carriers.Contact_SetDuplicateRulesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Contact_SetDuplicateRulesStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = rules;
        if( typeof( first ) === "object" && first && ( typeof(first.Rules)!='undefined' ) )
        {
            _request = rules as carriers.Contact_SetDuplicateRulesStatusRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Rules: rules as carriers.DuplicateRule[],
                       };   
            _options = webapi_options;
        }
        return this._SetDuplicateRulesStatus( _request, _options );
    }


    private async _Merge(request: carriers.Contact_MergeRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Merge", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Merge two contacts. The destination contact will remain.
     * @param request - SourceContactId, DestinationContactId, MergeIdenticalPersons, ReplaceEmptyFieldsOnDestination
     * @returns 
     */
    public async Merge(request: carriers.Contact_MergeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Merge two contacts. The destination contact will remain.
     * @param sourceContactId - Source contact to merge from. This contact will disappear after the merge.
     * @param destinationContactId - Destination contact to merge into
     * @param mergeIdenticalPersons - Persons with identical names will be merged
     * @param replaceEmptyFieldsOnDestination - If true, empty fields on destination will be replaced by values from source.
     * @returns 
     */
    public async Merge(sourceContactId: number, destinationContactId: number, mergeIdenticalPersons: boolean, replaceEmptyFieldsOnDestination: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Merge(sourceContactId:number|carriers.Contact_MergeRequest, destinationContactId?:number|base.WebApiRequestOptions, mergeIdenticalPersons?:boolean, replaceEmptyFieldsOnDestination?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Contact_MergeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceContactId;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceContactId)!='undefined' || typeof(first.DestinationContactId)!='undefined' || typeof(first.MergeIdenticalPersons)!='undefined' || typeof(first.ReplaceEmptyFieldsOnDestination)!='undefined' ) )
        {
            _request = sourceContactId as carriers.Contact_MergeRequest;
            _options = destinationContactId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceContactId: sourceContactId as number,
                       DestinationContactId: destinationContactId as number,
                       MergeIdenticalPersons: mergeIdenticalPersons as boolean,
                       ReplaceEmptyFieldsOnDestination: replaceEmptyFieldsOnDestination as boolean,
                       };   
            _options = webapi_options;
        }
        return this._Merge( _request, _options );
    }


    private async _Copy(request: carriers.Contact_CopyRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Copy", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Copy a contact. Activities and related data will be ignored
     * @param request - SourceContactId, DestinationContactName, DestinationContactDepartment, CopyPersons
     * @returns Id of copied contact
     */
    public async Copy(request: carriers.Contact_CopyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Copy a contact. Activities and related data will be ignored
     * @param sourceContactId - The id of the contact to copy
     * @param destinationContactName - The name of the destination contact
     * @param destinationContactDepartment - The department of the destination contact
     * @param copyPersons - If true, persons will be copied from source contact
     * @returns Id of copied contact
     */
    public async Copy(sourceContactId: number, destinationContactName: string, destinationContactDepartment: string, copyPersons: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async Copy(sourceContactId:number|carriers.Contact_CopyRequest, destinationContactName?:string|base.WebApiRequestOptions, destinationContactDepartment?:string, copyPersons?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Contact_CopyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceContactId;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceContactId)!='undefined' || typeof(first.DestinationContactName)!='undefined' || typeof(first.DestinationContactDepartment)!='undefined' || typeof(first.CopyPersons)!='undefined' ) )
        {
            _request = sourceContactId as carriers.Contact_CopyRequest;
            _options = destinationContactName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceContactId: sourceContactId as number,
                       DestinationContactName: destinationContactName as string,
                       DestinationContactDepartment: destinationContactDepartment as string,
                       CopyPersons: copyPersons as boolean,
                       };   
            _options = webapi_options;
        }
        return this._Copy( _request, _options );
    }


    private async _GetNameDepartmentDuplicates(request: carriers.Contact_GetNameDepartmentDuplicatesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DuplicateEntry[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNameDepartmentDuplicates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DuplicateEntry[] = converters.Create_DuplicateEntryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get duplicates based on the contact name and department
     * @param request - Name, Department
     * @returns Any records matching the specified name and department
     */
    public async GetNameDepartmentDuplicates(request: carriers.Contact_GetNameDepartmentDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;

    /**
     * Get duplicates based on the contact name and department
     * @param name - Name used for lookup
     * @param department - Department used for lookup (if any)
     * @returns Any records matching the specified name and department
     */
    public async GetNameDepartmentDuplicates(name: string, department: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;

    public async GetNameDepartmentDuplicates(name:string|carriers.Contact_GetNameDepartmentDuplicatesRequest, department?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] > {
        let _request : carriers.Contact_GetNameDepartmentDuplicatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' || typeof(first.Department)!='undefined' ) )
        {
            _request = name as carriers.Contact_GetNameDepartmentDuplicatesRequest;
            _options = department as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       Department: department as string,
                       };   
            _options = webapi_options;
        }
        return this._GetNameDepartmentDuplicates( _request, _options );
    }


    private async _IsNumberValid(request: carriers.Contact_IsNumberValidRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNumberValid", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Checks if the number is unique or required.  The setting is configured from admin under system options.
     * @param request - ContactId, Number
     * @returns True if the number satisifies the configured rules for uniqueness.
     */
    public async IsNumberValid(request: carriers.Contact_IsNumberValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Checks if the number is unique or required.  The setting is configured from admin under system options.
     * @param contactId - Primary key
     * @param number - Number field value to check.
     * @returns True if the number satisifies the configured rules for uniqueness.
     */
    public async IsNumberValid(contactId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async IsNumberValid(contactId:number|carriers.Contact_IsNumberValidRequest, number?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Contact_IsNumberValidRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.Number)!='undefined' ) )
        {
            _request = contactId as carriers.Contact_IsNumberValidRequest;
            _options = number as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       Number: number as string,
                       };   
            _options = webapi_options;
        }
        return this._IsNumberValid( _request, _options );
    }


    private async _GetQuoteVersionAddresses(request: carriers.Contact_GetQuoteVersionAddressesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Address[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Address[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionAddresses", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Address[] = converters.Create_AddressArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the associated billing and invoice quote version addresses. These addresses might be address on the contact, or a custom address.
     * @param request - QuoteVersionId
     * @returns The quote version addresses. Invoice and billing address, in that order.
     */
    public async GetQuoteVersionAddresses(request: carriers.Contact_GetQuoteVersionAddressesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address[] >;

    /**
     * Get the associated billing and invoice quote version addresses. These addresses might be address on the contact, or a custom address.
     * @param quoteVersionId - The version to get the addresses for.
     * @returns The quote version addresses. Invoice and billing address, in that order.
     */
    public async GetQuoteVersionAddresses(quoteVersionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address[] >;

    public async GetQuoteVersionAddresses(quoteVersionId:number|carriers.Contact_GetQuoteVersionAddressesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address[] > {
        let _request : carriers.Contact_GetQuoteVersionAddressesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Contact_GetQuoteVersionAddressesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetQuoteVersionAddresses( _request, _options );
    }


    private async _SaveQuoteVersionAddress(request: carriers.Contact_SaveQuoteVersionAddressRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Address >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteVersionAddress", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Address = converters.Create_Address_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save a custom quote version address.
     * @param request - QuoteVersionId, Address, AddressType, CountryId
     * @returns The saved addresses.
     */
    public async SaveQuoteVersionAddress(request: carriers.Contact_SaveQuoteVersionAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    /**
     * Save a custom quote version address.
     * @param quoteVersionId - The version to save the address on.
     * @param address - The address to save on the quote version.
     * @param addressType - Should be either QuoteBillingAddress or QuoteShippingAddress
     * @param countryId - The country for the custom address
     * @returns The saved addresses.
     */
    public async SaveQuoteVersionAddress(quoteVersionId: number, address: carriers.Address, addressType: enums.AddressType, countryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    public async SaveQuoteVersionAddress(quoteVersionId:number|carriers.Contact_SaveQuoteVersionAddressRequest, address?:carriers.Address|base.WebApiRequestOptions, addressType?:enums.AddressType, countryId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        let _request : carriers.Contact_SaveQuoteVersionAddressRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quoteVersionId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuoteVersionId)!='undefined' || typeof(first.Address)!='undefined' || typeof(first.AddressType)!='undefined' || typeof(first.CountryId)!='undefined' ) )
        {
            _request = quoteVersionId as carriers.Contact_SaveQuoteVersionAddressRequest;
            _options = address as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuoteVersionId: quoteVersionId as number,
                       Address: address as carriers.Address,
                       AddressType: addressType as enums.AddressType,
                       CountryId: countryId as number,
                       };   
            _options = webapi_options;
        }
        return this._SaveQuoteVersionAddress( _request, _options );
    }


    private async _DeleteExpired( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteExpired", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Trigger deletion of contacts (companies) that has been (soft) deleted and have timed out the expiry period (the SoftDeleteRetention preference).
     * @returns 
     */
    public async DeleteExpired(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._DeleteExpired(webapi_options);
    }


    private async _GetContactSummary(request: carriers.Contact_GetContactSummaryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ContactSummary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ContactSummary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactSummary", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ContactSummary = converters.Create_ContactSummary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get summary of contact and its recent activity.
     * @param request - ContactId, Limit
     * @returns Summary of contact, with recent requests, sales, follow-ups, chats.
     */
    public async GetContactSummary(request: carriers.Contact_GetContactSummaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactSummary >;

    /**
     * Get summary of contact and its recent activity.
     * @param contactId - The contact id to summarize.
     * @param limit - Max number of items to include in summary lists.
     * @returns Summary of contact, with recent requests, sales, follow-ups, chats.
     */
    public async GetContactSummary(contactId: number, limit: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactSummary >;

    public async GetContactSummary(contactId:number|carriers.Contact_GetContactSummaryRequest, limit?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ContactSummary > {
        let _request : carriers.Contact_GetContactSummaryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.Limit)!='undefined' ) )
        {
            _request = contactId as carriers.Contact_GetContactSummaryRequest;
            _options = limit as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       Limit: limit as number,
                       };   
            _options = webapi_options;
        }
        return this._GetContactSummary( _request, _options );
    }


    private async _ValidateContactEntity(request: carriers.Contact_ValidateContactEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateContactEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param request - ContactEntity
     * @returns Error messages tagged by field.
     */
    public async ValidateContactEntity(request: carriers.Contact_ValidateContactEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param contactEntity - Entity to be checked for errors.
     * @returns Error messages tagged by field.
     */
    public async ValidateContactEntity(contactEntity: carriers.ContactEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async ValidateContactEntity(contactEntity:carriers.ContactEntity|carriers.Contact_ValidateContactEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Contact_ValidateContactEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactEntity)!='undefined' ) )
        {
            _request = contactEntity as carriers.Contact_ValidateContactEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactEntity: contactEntity as carriers.ContactEntity,
                       };   
            _options = webapi_options;
        }
        return this._ValidateContactEntity( _request, _options );
    }

    /*
     * Gets an array of Contact objects.
     * @param contactIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Contact
     */
    public async GetContactList(contactIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Contact[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetContactList", contactIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetMyContacts( options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Contact[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyContacts", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Contact[] = converters.Create_ContactArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Getting the contacts where the user currently logged in is set as contact owner.
     * @returns Array of contacts
     */
    public async GetMyContacts(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] >
    {
        return this._GetMyContacts(webapi_options);
    }


    private async _GetMyRecentContacts(request: carriers.Contact_GetMyRecentContactsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Contact[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyRecentContacts", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Contact[] = converters.Create_ContactArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Method that returns a set of initial contacts. This could be the contacts in a favorites selection, the history list, the diary, or from all sources. If retrieved from the diary it will get appointments for the current and the next day.
     * @param request - SourceType
     * @returns Arrayof contacts
     */
    public async GetMyRecentContacts(request: carriers.Contact_GetMyRecentContactsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] >;

    /**
     * Method that returns a set of initial contacts. This could be the contacts in a favorites selection, the history list, the diary, or from all sources. If retrieved from the diary it will get appointments for the current and the next day.
     * @param sourceType - The source where the contacts are retrieved from (Favorites, History, Diary)
     * @returns Arrayof contacts
     */
    public async GetMyRecentContacts(sourceType: enums.ContactSourceType, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] >;

    public async GetMyRecentContacts(sourceType:enums.ContactSourceType|carriers.Contact_GetMyRecentContactsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Contact[] > {
        let _request : carriers.Contact_GetMyRecentContactsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceType;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceType)!='undefined' ) )
        {
            _request = sourceType as carriers.Contact_GetMyRecentContactsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceType: sourceType as enums.ContactSourceType,
                       };   
            _options = webapi_options;
        }
        return this._GetMyRecentContacts( _request, _options );
    }


    private async _GetPreviewContact(request: carriers.Contact_GetPreviewContactRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreviewContact > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreviewContact >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewContact", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreviewContact = converters.Create_PreviewContact_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a contact from its ID
     * @param request - ContactId
     * @returns Contact minimal contact suitable for preview
     */
    public async GetPreviewContact(request: carriers.Contact_GetPreviewContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewContact >;

    /**
     * Get a contact from its ID
     * @param contactId - Contact ID
     * @returns Contact minimal contact suitable for preview
     */
    public async GetPreviewContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewContact >;

    public async GetPreviewContact(contactId:number|carriers.Contact_GetPreviewContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewContact > {
        let _request : carriers.Contact_GetPreviewContactRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.Contact_GetPreviewContactRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviewContact( _request, _options );
    }

    } // class v1ContactAgentController 



// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/CustomerServiceAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Agent used for Customer Service methods
 */
export interface ICustomerServiceAgent {
    CreateDefaultCustomerCenterConfig(): Promise< carriers.CustomerCenterConfig >;
    SaveCustomerCenterConfig(entity: carriers.CustomerCenterConfig) : Promise< carriers.CustomerCenterConfig >;
    DeleteCustomerCenterConfig(CustomerCenterConfigId: number) : Promise<void>;
    CreateDefaultMailboxEntity(): Promise< carriers.MailboxEntity >;
    SaveMailboxEntity(entity: carriers.MailboxEntity) : Promise< carriers.MailboxEntity >;
    CreateDefaultSmsConfig(): Promise< carriers.SmsConfig >;
    SaveSmsConfig(entity: carriers.SmsConfig) : Promise< carriers.SmsConfig >;
    UpdateFeatureToggles(request: carriers.CustomerService_UpdateFeatureTogglesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    UpdateFeatureToggles(featureToggles: carriers.CsFeatureToggle[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    EventHandlerExists(request: carriers.CustomerService_EventHandlerExistsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    EventHandlerExists(eventHandlerType: enums.EventHandlerType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CreateSession(request: carriers.CustomerService_CreateSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CsSessionKey >;
    CreateSession(remoteIp: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CsSessionKey >;
    RemoveSession(request: carriers.CustomerService_RemoveSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveSession(loginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SessionIsValid(request: carriers.CustomerService_SessionIsValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SessionIsValid(csSessionKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasChatNotify(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    CheckSymmetricEncryption(request: carriers.CustomerService_CheckSymmetricEncryptionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    CheckSymmetricEncryption(encryptedString: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    ReportSessionActive(request: carriers.CustomerService_ReportSessionActiveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    ReportSessionActive(sessionKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetCustomerCenterConfig(customerCenterConfigId: number) :  Promise< carriers.CustomerCenterConfig >;
    GetAllCustomerCenterConfigs(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CustomerCenterConfig[] >;
    SaveAllCustomerCenterConfigs(request: carriers.CustomerService_SaveAllCustomerCenterConfigsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveAllCustomerCenterConfigs(custConfigs: carriers.CustomerCenterConfig[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CheckIfCustomizedTemplates(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetProgramUrl(request: carriers.CustomerService_GetProgramUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetProgramUrl(programName: string, external: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetFaqForCustomer(request: carriers.CustomerService_GetFaqForCustomerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetFaqForCustomer(faqEntryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetCustomerServiceStartup(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CustomerServiceStartup >;
    ExecuteEventHandlers(request: carriers.CustomerService_ExecuteEventHandlersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EventData >;
    ExecuteEventHandlers(eventData: carriers.EventData, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EventData >;
    GetMailboxes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Mailbox[] >;
    GetMailboxEntity(mailboxEntityId: number) :  Promise< carriers.MailboxEntity >;
    GetPreviewFaqEntry(request: carriers.CustomerService_GetPreviewFaqEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewFaqEntry >;
    GetPreviewFaqEntry(kbEntryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewFaqEntry >;
    GetPreviewQuickReply(request: carriers.CustomerService_GetPreviewQuickReplyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewQuickReply >;
    GetPreviewQuickReply(quickReplyId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewQuickReply >;
    GetPreviewReplyTemplate(request: carriers.CustomerService_GetPreviewReplyTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewReplyTemplate >;
    GetPreviewReplyTemplate(replyTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewReplyTemplate >;
    GetParsedTemplate(request: carriers.CustomerService_GetParsedTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;
    GetParsedTemplate(replyTemplateId: number, languageId: number, personId: number, ticketId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;
    GetUnparsedTemplate(request: carriers.CustomerService_GetUnparsedTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;
    GetUnparsedTemplate(replyTemplateId: number, languageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;
    GetSmsConfig(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SmsConfig >;
    TestSmtpServer(request: carriers.CustomerService_TestSmtpServerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SmtpTestResult >;
    TestSmtpServer(smtpUri: string, from: string, useStoredPassword: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SmtpTestResult >;
    GetStatistics(request: carriers.CustomerService_GetStatisticsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatisticsDataSet[] >;
    GetStatistics(functions: enums.StatusScreenPanelType[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatisticsDataSet[] >;
    GetSystemTemplateSettings(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SystemTemplateSettings >;
    SaveSystemTemplateSettings(request: carriers.CustomerService_SaveSystemTemplateSettingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SystemTemplateSettings >;
    SaveSystemTemplateSettings(systemTemplateSettings: carriers.SystemTemplateSettings, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SystemTemplateSettings >;
    CreateTicketFromMailData(request: carriers.CustomerService_CreateTicketFromMailDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo >;
    CreateTicketFromMailData(mailboxId: number, data: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo >;
    AddMessageFromMailData(request: carriers.CustomerService_AddMessageFromMailDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo >;
    AddMessageFromMailData(ticketId: number, data: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo >;
    FindTicketsByTitleOrId(request: carriers.CustomerService_FindTicketsByTitleOrIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo[] >;
    FindTicketsByTitleOrId(titleOrId: string, maxRows: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo[] >;
} // interface ICustomerServiceAgent




/**
 * Agent used for Customer Service methods
 */
export class CustomerServiceAgent extends base.WebApiBase implements ICustomerServiceAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/CustomerService/";
        super(options);
    }



    /**
     * Set default values into a new CustomerCenterConfig.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultCustomerCenterConfig(options?:base.WebApiRequestOptions) : Promise< carriers.CustomerCenterConfig > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CustomerCenterConfig >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultCustomerCenterConfig", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CustomerCenterConfig = converters.Create_CustomerCenterConfig_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing CustomerCenterConfig or creates a new CustomerCenterConfig if the id parameter is empty
     * @param entity - The CustomerCenterConfig to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated CustomerCenterConfig
     */
    public async SaveCustomerCenterConfig(entity: carriers.CustomerCenterConfig, options?:base.WebApiRequestOptions) : Promise< carriers.CustomerCenterConfig > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CustomerCenterConfig >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveCustomerCenterConfig", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CustomerCenterConfig = converters.Create_CustomerCenterConfig_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the CustomerCenterConfig
     * @param CustomerCenterConfigId - The id of the CustomerCenterConfig to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteCustomerCenterConfig(CustomerCenterConfigId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteCustomerCenterConfig?CustomerCenterConfigId=" + CustomerCenterConfigId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new MailboxEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultMailboxEntity(options?:base.WebApiRequestOptions) : Promise< carriers.MailboxEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MailboxEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultMailboxEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MailboxEntity = converters.Create_MailboxEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing MailboxEntity or creates a new MailboxEntity if the id parameter is empty
     * @param entity - The MailboxEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated MailboxEntity
     */
    public async SaveMailboxEntity(entity: carriers.MailboxEntity, options?:base.WebApiRequestOptions) : Promise< carriers.MailboxEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MailboxEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveMailboxEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MailboxEntity = converters.Create_MailboxEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new SmsConfig.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSmsConfig(options?:base.WebApiRequestOptions) : Promise< carriers.SmsConfig > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SmsConfig >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSmsConfig", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SmsConfig = converters.Create_SmsConfig_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SmsConfig or creates a new SmsConfig if the id parameter is empty
     * @param entity - The SmsConfig to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SmsConfig
     */
    public async SaveSmsConfig(entity: carriers.SmsConfig, options?:base.WebApiRequestOptions) : Promise< carriers.SmsConfig > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SmsConfig >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSmsConfig", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SmsConfig = converters.Create_SmsConfig_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    private async _UpdateFeatureToggles(request: carriers.CustomerService_UpdateFeatureTogglesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateFeatureToggles", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update the cached FeatureToggles for CS
     * @param request - FeatureToggles
     * @returns 
     */
    public async UpdateFeatureToggles(request: carriers.CustomerService_UpdateFeatureTogglesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Update the cached FeatureToggles for CS
     * @param featureToggles - Feature toggle name / state
     * @returns 
     */
    public async UpdateFeatureToggles(featureToggles: carriers.CsFeatureToggle[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async UpdateFeatureToggles(featureToggles:carriers.CsFeatureToggle[]|carriers.CustomerService_UpdateFeatureTogglesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.CustomerService_UpdateFeatureTogglesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = featureToggles;
        if( typeof( first ) === "object" && first && ( typeof(first.FeatureToggles)!='undefined' ) )
        {
            _request = featureToggles as carriers.CustomerService_UpdateFeatureTogglesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FeatureToggles: featureToggles as carriers.CsFeatureToggle[],
                       };   
            _options = webapi_options;
        }
        return this._UpdateFeatureToggles( _request, _options );
    }


    private async _EventHandlerExists(request: carriers.CustomerService_EventHandlerExistsRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("EventHandlerExists", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check if an eventhandler exists for a given enum
     * @param request - EventHandlerType
     * @returns True if it exists
     */
    public async EventHandlerExists(request: carriers.CustomerService_EventHandlerExistsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Check if an eventhandler exists for a given enum
     * @param eventHandlerType - The EventHandlerType we are checking
     * @returns True if it exists
     */
    public async EventHandlerExists(eventHandlerType: enums.EventHandlerType, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async EventHandlerExists(eventHandlerType:enums.EventHandlerType|carriers.CustomerService_EventHandlerExistsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.CustomerService_EventHandlerExistsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = eventHandlerType;
        if( typeof( first ) === "object" && first && ( typeof(first.EventHandlerType)!='undefined' ) )
        {
            _request = eventHandlerType as carriers.CustomerService_EventHandlerExistsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EventHandlerType: eventHandlerType as enums.EventHandlerType,
                       };   
            _options = webapi_options;
        }
        return this._EventHandlerExists( _request, _options );
    }


    private async _CreateSession(request: carriers.CustomerService_CreateSessionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.CsSessionKey > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CsSessionKey >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateSession", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CsSessionKey = converters.Create_CsSessionKey_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a login session for a CS user
     * @param request - RemoteIp
     * @returns The session key information
     */
    public async CreateSession(request: carriers.CustomerService_CreateSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CsSessionKey >;

    /**
     * Creates a login session for a CS user
     * @param remoteIp - The ip of the client creating the session
     * @returns The session key information
     */
    public async CreateSession(remoteIp: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CsSessionKey >;

    public async CreateSession(remoteIp:string|carriers.CustomerService_CreateSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CsSessionKey > {
        let _request : carriers.CustomerService_CreateSessionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = remoteIp;
        if( typeof( first ) === "object" && first && ( typeof(first.RemoteIp)!='undefined' ) )
        {
            _request = remoteIp as carriers.CustomerService_CreateSessionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RemoteIp: remoteIp as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateSession( _request, _options );
    }


    private async _RemoveSession(request: carriers.CustomerService_RemoveSessionRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveSession", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Remove a login session for a CS user
     * @param request - LoginId
     * @returns 
     */
    public async RemoveSession(request: carriers.CustomerService_RemoveSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Remove a login session for a CS user
     * @param loginId - The login id to remove
     * @returns 
     */
    public async RemoveSession(loginId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveSession(loginId:number|carriers.CustomerService_RemoveSessionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.CustomerService_RemoveSessionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = loginId;
        if( typeof( first ) === "object" && first && ( typeof(first.LoginId)!='undefined' ) )
        {
            _request = loginId as carriers.CustomerService_RemoveSessionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       LoginId: loginId as number,
                       };   
            _options = webapi_options;
        }
        return this._RemoveSession( _request, _options );
    }


    private async _SessionIsValid(request: carriers.CustomerService_SessionIsValidRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SessionIsValid", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check if a CS session is valid
     * @param request - CsSessionKey
     * @returns True if there is a valid CS session based on the session key
     */
    public async SessionIsValid(request: carriers.CustomerService_SessionIsValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Check if a CS session is valid
     * @param csSessionKey - The CS session key to check
     * @returns True if there is a valid CS session based on the session key
     */
    public async SessionIsValid(csSessionKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async SessionIsValid(csSessionKey:string|carriers.CustomerService_SessionIsValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.CustomerService_SessionIsValidRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = csSessionKey;
        if( typeof( first ) === "object" && first && ( typeof(first.CsSessionKey)!='undefined' ) )
        {
            _request = csSessionKey as carriers.CustomerService_SessionIsValidRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       CsSessionKey: csSessionKey as string,
                       };   
            _options = webapi_options;
        }
        return this._SessionIsValid( _request, _options );
    }


    private async _HasChatNotify( options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasChatNotify", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Check if user has any chat notification
     * @returns True if the user has at least one notification setting on
     */
    public async HasChatNotify(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >
    {
        return this._HasChatNotify(webapi_options);
    }


    private async _CheckSymmetricEncryption(request: carriers.CustomerService_CheckSymmetricEncryptionRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckSymmetricEncryption", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Do a test to check that we are using the same encryption keys
     * @param request - EncryptedString
     * @returns Encrypted version of the string done by NetServer
     */
    public async CheckSymmetricEncryption(request: carriers.CustomerService_CheckSymmetricEncryptionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Do a test to check that we are using the same encryption keys
     * @param encryptedString - An encrypted version of the string
     * @returns Encrypted version of the string done by NetServer
     */
    public async CheckSymmetricEncryption(encryptedString: string, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async CheckSymmetricEncryption(encryptedString:string|carriers.CustomerService_CheckSymmetricEncryptionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.CustomerService_CheckSymmetricEncryptionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = encryptedString;
        if( typeof( first ) === "object" && first && ( typeof(first.EncryptedString)!='undefined' ) )
        {
            _request = encryptedString as carriers.CustomerService_CheckSymmetricEncryptionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EncryptedString: encryptedString as string,
                       };   
            _options = webapi_options;
        }
        return this._CheckSymmetricEncryption( _request, _options );
    }


    private async _ReportSessionActive(request: carriers.CustomerService_ReportSessionActiveRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ReportSessionActive", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Report a session as being &apos;active&apos;; will update the corresponding row in login table, but not more than once per minute/session
     * @param request - SessionKey
     * @returns The ID of the login table row, or 0 if not found
     */
    public async ReportSessionActive(request: carriers.CustomerService_ReportSessionActiveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Report a session as being &apos;active&apos;; will update the corresponding row in login table, but not more than once per minute/session
     * @param sessionKey - CS session key, matching the 'login' table
     * @returns The ID of the login table row, or 0 if not found
     */
    public async ReportSessionActive(sessionKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async ReportSessionActive(sessionKey:string|carriers.CustomerService_ReportSessionActiveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.CustomerService_ReportSessionActiveRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sessionKey;
        if( typeof( first ) === "object" && first && ( typeof(first.SessionKey)!='undefined' ) )
        {
            _request = sessionKey as carriers.CustomerService_ReportSessionActiveRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SessionKey: sessionKey as string,
                       };   
            _options = webapi_options;
        }
        return this._ReportSessionActive( _request, _options );
    }

    /*
     * Gets a CustomerCenterConfig object.
     * @param customerCenterConfigId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single CustomerCenterConfig
     */
    public async GetCustomerCenterConfig(customerCenterConfigId: number, options?:base.WebApiRequestOptions) : Promise< carriers.CustomerCenterConfig > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CustomerCenterConfig >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCustomerCenterConfig?customerCenterConfigId=" + customerCenterConfigId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerCenterConfig_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetAllCustomerCenterConfigs( options?:base.WebApiRequestOptions) : Promise< carriers.CustomerCenterConfig[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CustomerCenterConfig[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllCustomerCenterConfigs", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CustomerCenterConfig[] = converters.Create_CustomerCenterConfigArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get all rows from cust_config as an array of CustomerCenterConfig entities
     * @returns An array of CustomerCenterConfig entities
     */
    public async GetAllCustomerCenterConfigs(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CustomerCenterConfig[] >
    {
        return this._GetAllCustomerCenterConfigs(webapi_options);
    }


    private async _SaveAllCustomerCenterConfigs(request: carriers.CustomerService_SaveAllCustomerCenterConfigsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveAllCustomerCenterConfigs", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Save an array of CustomerCenterConfig entities to the database
     * @param request - CustConfigs
     * @returns void
     */
    public async SaveAllCustomerCenterConfigs(request: carriers.CustomerService_SaveAllCustomerCenterConfigsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Save an array of CustomerCenterConfig entities to the database
     * @param custConfigs - The CustomerCenterConfig entities to be saved. If the id does not exists, a new one will be created. Unknown ids will be skipped
     * @returns void
     */
    public async SaveAllCustomerCenterConfigs(custConfigs: carriers.CustomerCenterConfig[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveAllCustomerCenterConfigs(custConfigs:carriers.CustomerCenterConfig[]|carriers.CustomerService_SaveAllCustomerCenterConfigsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.CustomerService_SaveAllCustomerCenterConfigsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = custConfigs;
        if( typeof( first ) === "object" && first && ( typeof(first.CustConfigs)!='undefined' ) )
        {
            _request = custConfigs as carriers.CustomerService_SaveAllCustomerCenterConfigsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       CustConfigs: custConfigs as carriers.CustomerCenterConfig[],
                       };   
            _options = webapi_options;
        }
        return this._SaveAllCustomerCenterConfigs( _request, _options );
    }


    private async _CheckIfCustomizedTemplates( options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckIfCustomizedTemplates", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Checks whether the core html templates are customized
     * @returns True if the templates are customized
     */
    public async CheckIfCustomizedTemplates(webapi_options?:base.WebApiRequestOptions) : Promise< boolean >
    {
        return this._CheckIfCustomizedTemplates(webapi_options);
    }


    private async _GetProgramUrl(request: carriers.CustomerService_GetProgramUrlRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProgramUrl", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will convert a module name into a Service URL.
     * @param request - ProgramName, External
     * @returns Returns a valid Service URL composed of the give parameters.
     */
    public async GetProgramUrl(request: carriers.CustomerService_GetProgramUrlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * This method will convert a module name into a Service URL.
     * @param programName - In this parameter you must specify which CS program you want to create an URL for. Valid examples are "ticket", "rms", "spm" etc.
     * @param external - If set to true, this will generate URLs that are accesible from the outside (for example Internet)
     * @returns Returns a valid Service URL composed of the give parameters.
     */
    public async GetProgramUrl(programName: string, external: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetProgramUrl(programName:string|carriers.CustomerService_GetProgramUrlRequest, external?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.CustomerService_GetProgramUrlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = programName;
        if( typeof( first ) === "object" && first && ( typeof(first.ProgramName)!='undefined' || typeof(first.External)!='undefined' ) )
        {
            _request = programName as carriers.CustomerService_GetProgramUrlRequest;
            _options = external as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProgramName: programName as string,
                       External: external as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GetProgramUrl( _request, _options );
    }


    private async _GetFaqForCustomer(request: carriers.CustomerService_GetFaqForCustomerRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFaqForCustomer", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a FAQ entry, ment to be displayed for a customer. This can either be a link to the FAQ entry on Custom Center, or it can be the answer and question. This is dependent on Registry setting with reg_id=157
     * @param request - FaqEntryId
     * @returns The FAQ to show to the customer. Either a clickable link or the question/answer itself.
     */
    public async GetFaqForCustomer(request: carriers.CustomerService_GetFaqForCustomerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get a FAQ entry, ment to be displayed for a customer. This can either be a link to the FAQ entry on Custom Center, or it can be the answer and question. This is dependent on Registry setting with reg_id=157
     * @param faqEntryId - The id of the FAQ entry to get. Only FAQ entries with access level public (both for unauthenticated and autenticated customer) will be returned
     * @returns The FAQ to show to the customer. Either a clickable link or the question/answer itself.
     */
    public async GetFaqForCustomer(faqEntryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetFaqForCustomer(faqEntryId:number|carriers.CustomerService_GetFaqForCustomerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.CustomerService_GetFaqForCustomerRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = faqEntryId;
        if( typeof( first ) === "object" && first && ( typeof(first.FaqEntryId)!='undefined' ) )
        {
            _request = faqEntryId as carriers.CustomerService_GetFaqForCustomerRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FaqEntryId: faqEntryId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetFaqForCustomer( _request, _options );
    }


    private async _GetCustomerServiceStartup( options?:base.WebApiRequestOptions) : Promise< carriers.CustomerServiceStartup > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.CustomerServiceStartup >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCustomerServiceStartup", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.CustomerServiceStartup = converters.Create_CustomerServiceStartup_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the carrier with data that Service needs when starting up
     * @returns The carrier containing the startup data
     */
    public async GetCustomerServiceStartup(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.CustomerServiceStartup >
    {
        return this._GetCustomerServiceStartup(webapi_options);
    }


    private async _ExecuteEventHandlers(request: carriers.CustomerService_ExecuteEventHandlersRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EventData > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EventData >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExecuteEventHandlers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EventData = converters.Create_EventData_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will execute event handlers in CRMScript for a given event.
     * @param request - EventData
     * @returns The EventData instance after event handler execution
     */
    public async ExecuteEventHandlers(request: carriers.CustomerService_ExecuteEventHandlersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EventData >;

    /**
     * This method will execute event handlers in CRMScript for a given event.
     * @param eventData - The EventData instance sent to the event handler
     * @returns The EventData instance after event handler execution
     */
    public async ExecuteEventHandlers(eventData: carriers.EventData, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EventData >;

    public async ExecuteEventHandlers(eventData:carriers.EventData|carriers.CustomerService_ExecuteEventHandlersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EventData > {
        let _request : carriers.CustomerService_ExecuteEventHandlersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = eventData;
        if( typeof( first ) === "object" && first && ( typeof(first.EventData)!='undefined' ) )
        {
            _request = eventData as carriers.CustomerService_ExecuteEventHandlersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EventData: eventData as carriers.EventData,
                       };   
            _options = webapi_options;
        }
        return this._ExecuteEventHandlers( _request, _options );
    }


    private async _GetMailboxes( options?:base.WebApiRequestOptions) : Promise< carriers.Mailbox[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Mailbox[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMailboxes", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Mailbox[] = converters.Create_MailboxArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * This method will get all registered mailboxes in Service
     * @returns An array of Mailbox objects
     */
    public async GetMailboxes(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Mailbox[] >
    {
        return this._GetMailboxes(webapi_options);
    }

    /*
     * Gets a MailboxEntity object.
     * @param mailboxEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single MailboxEntity
     */
    public async GetMailboxEntity(mailboxEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.MailboxEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MailboxEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetMailboxEntity?mailboxEntityId=" + mailboxEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MailboxEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetPreviewFaqEntry(request: carriers.CustomerService_GetPreviewFaqEntryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreviewFaqEntry > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreviewFaqEntry >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewFaqEntry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreviewFaqEntry = converters.Create_PreviewFaqEntry_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a faq entry from its faq entry id
     * @param request - KbEntryId
     * @returns FAQ entry suitable for preview
     */
    public async GetPreviewFaqEntry(request: carriers.CustomerService_GetPreviewFaqEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewFaqEntry >;

    /**
     * Get a faq entry from its faq entry id
     * @param kbEntryId - FAQ entry ID
     * @returns FAQ entry suitable for preview
     */
    public async GetPreviewFaqEntry(kbEntryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewFaqEntry >;

    public async GetPreviewFaqEntry(kbEntryId:number|carriers.CustomerService_GetPreviewFaqEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewFaqEntry > {
        let _request : carriers.CustomerService_GetPreviewFaqEntryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = kbEntryId;
        if( typeof( first ) === "object" && first && ( typeof(first.KbEntryId)!='undefined' ) )
        {
            _request = kbEntryId as carriers.CustomerService_GetPreviewFaqEntryRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       KbEntryId: kbEntryId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviewFaqEntry( _request, _options );
    }


    private async _GetPreviewQuickReply(request: carriers.CustomerService_GetPreviewQuickReplyRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreviewQuickReply > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreviewQuickReply >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewQuickReply", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreviewQuickReply = converters.Create_PreviewQuickReply_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a quick reply from its quick reply id
     * @param request - QuickReplyId
     * @returns Quick reply suitable for preview
     */
    public async GetPreviewQuickReply(request: carriers.CustomerService_GetPreviewQuickReplyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewQuickReply >;

    /**
     * Get a quick reply from its quick reply id
     * @param quickReplyId - Quick reply ID
     * @returns Quick reply suitable for preview
     */
    public async GetPreviewQuickReply(quickReplyId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewQuickReply >;

    public async GetPreviewQuickReply(quickReplyId:number|carriers.CustomerService_GetPreviewQuickReplyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewQuickReply > {
        let _request : carriers.CustomerService_GetPreviewQuickReplyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = quickReplyId;
        if( typeof( first ) === "object" && first && ( typeof(first.QuickReplyId)!='undefined' ) )
        {
            _request = quickReplyId as carriers.CustomerService_GetPreviewQuickReplyRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       QuickReplyId: quickReplyId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviewQuickReply( _request, _options );
    }


    private async _GetPreviewReplyTemplate(request: carriers.CustomerService_GetPreviewReplyTemplateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreviewReplyTemplate > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreviewReplyTemplate >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewReplyTemplate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreviewReplyTemplate = converters.Create_PreviewReplyTemplate_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a reply template from its reply template id
     * @param request - ReplyTemplateId
     * @returns Reply template suitable for preview
     */
    public async GetPreviewReplyTemplate(request: carriers.CustomerService_GetPreviewReplyTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewReplyTemplate >;

    /**
     * Get a reply template from its reply template id
     * @param replyTemplateId - Reply template ID
     * @returns Reply template suitable for preview
     */
    public async GetPreviewReplyTemplate(replyTemplateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewReplyTemplate >;

    public async GetPreviewReplyTemplate(replyTemplateId:number|carriers.CustomerService_GetPreviewReplyTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewReplyTemplate > {
        let _request : carriers.CustomerService_GetPreviewReplyTemplateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = replyTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.ReplyTemplateId)!='undefined' ) )
        {
            _request = replyTemplateId as carriers.CustomerService_GetPreviewReplyTemplateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ReplyTemplateId: replyTemplateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviewReplyTemplate( _request, _options );
    }


    private async _GetParsedTemplate(request: carriers.CustomerService_GetParsedTemplateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReplyTemplateParsed >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetParsedTemplate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReplyTemplateParsed = converters.Create_ReplyTemplateParsed_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a specific langauge version of the reply template, and run this trough the parser
     * @param request - ReplyTemplateId, LanguageId, PersonId, TicketId
     * @returns The parsed reply template
     */
    public async GetParsedTemplate(request: carriers.CustomerService_GetParsedTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;

    /**
     * Get a specific langauge version of the reply template, and run this trough the parser
     * @param replyTemplateId - The id of the reply template
     * @param languageId - The language id (prefered language). If 0 is given, the language of the person will be used
     * @param personId - The id of the person that will be populated into the parser
     * @param ticketId - The id of the ticket that will be populated into the parser
     * @returns The parsed reply template
     */
    public async GetParsedTemplate(replyTemplateId: number, languageId: number, personId: number, ticketId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;

    public async GetParsedTemplate(replyTemplateId:number|carriers.CustomerService_GetParsedTemplateRequest, languageId?:number|base.WebApiRequestOptions, personId?:number, ticketId?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed > {
        let _request : carriers.CustomerService_GetParsedTemplateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = replyTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.ReplyTemplateId)!='undefined' || typeof(first.LanguageId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.TicketId)!='undefined' ) )
        {
            _request = replyTemplateId as carriers.CustomerService_GetParsedTemplateRequest;
            _options = languageId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ReplyTemplateId: replyTemplateId as number,
                       LanguageId: languageId as number,
                       PersonId: personId as number,
                       TicketId: ticketId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetParsedTemplate( _request, _options );
    }


    private async _GetUnparsedTemplate(request: carriers.CustomerService_GetUnparsedTemplateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReplyTemplateParsed >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnparsedTemplate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReplyTemplateParsed = converters.Create_ReplyTemplateParsed_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a specific langauge version of the reply template. No parsing is performed.
     * @param request - ReplyTemplateId, LanguageId
     * @returns The unparsed reply template, but using the same return data structure
     */
    public async GetUnparsedTemplate(request: carriers.CustomerService_GetUnparsedTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;

    /**
     * Get a specific langauge version of the reply template. No parsing is performed.
     * @param replyTemplateId - The id of the reply template
     * @param languageId - The language id (prefered language). If 0 is given, the language of the person will be used
     * @returns The unparsed reply template, but using the same return data structure
     */
    public async GetUnparsedTemplate(replyTemplateId: number, languageId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;

    public async GetUnparsedTemplate(replyTemplateId:number|carriers.CustomerService_GetUnparsedTemplateRequest, languageId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed > {
        let _request : carriers.CustomerService_GetUnparsedTemplateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = replyTemplateId;
        if( typeof( first ) === "object" && first && ( typeof(first.ReplyTemplateId)!='undefined' || typeof(first.LanguageId)!='undefined' ) )
        {
            _request = replyTemplateId as carriers.CustomerService_GetUnparsedTemplateRequest;
            _options = languageId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ReplyTemplateId: replyTemplateId as number,
                       LanguageId: languageId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetUnparsedTemplate( _request, _options );
    }


    private async _GetSmsConfig( options?:base.WebApiRequestOptions) : Promise< carriers.SmsConfig > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SmsConfig >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSmsConfig", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SmsConfig = converters.Create_SmsConfig_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the SmsConfig settings for Customer Service sms providers.
     * @returns Current SMS configuration.
     */
    public async GetSmsConfig(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SmsConfig >
    {
        return this._GetSmsConfig(webapi_options);
    }


    private async _TestSmtpServer(request: carriers.CustomerService_TestSmtpServerRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SmtpTestResult > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SmtpTestResult >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestSmtpServer", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SmtpTestResult = converters.Create_SmtpTestResult_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will do a test of a SMTP account, by sending an email to a special @superoffice.com account
     * @param request - SmtpUri, From, UseStoredPassword
     * @returns Contains the result of the test
     */
    public async TestSmtpServer(request: carriers.CustomerService_TestSmtpServerRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SmtpTestResult >;

    /**
     * This method will do a test of a SMTP account, by sending an email to a special @superoffice.com account
     * @param smtpUri - An URI containing information to connect to the SMTP server, eg. smtps://myuser:mypassword@smtp.myserver.com:465. Note that username and password must be url encoded
     * @param from - The from-address used in the test
     * @param useStoredPassword - Use database persisted password
     * @returns Contains the result of the test
     */
    public async TestSmtpServer(smtpUri: string, from: string, useStoredPassword: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SmtpTestResult >;

    public async TestSmtpServer(smtpUri:string|carriers.CustomerService_TestSmtpServerRequest, from?:string|base.WebApiRequestOptions, useStoredPassword?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SmtpTestResult > {
        let _request : carriers.CustomerService_TestSmtpServerRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = smtpUri;
        if( typeof( first ) === "object" && first && ( typeof(first.SmtpUri)!='undefined' || typeof(first.From)!='undefined' || typeof(first.UseStoredPassword)!='undefined' ) )
        {
            _request = smtpUri as carriers.CustomerService_TestSmtpServerRequest;
            _options = from as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SmtpUri: smtpUri as string,
                       From: from as string,
                       UseStoredPassword: useStoredPassword as boolean,
                       };   
            _options = webapi_options;
        }
        return this._TestSmtpServer( _request, _options );
    }


    private async _GetStatistics(request: carriers.CustomerService_GetStatisticsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StatisticsDataSet[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StatisticsDataSet[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetStatistics", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StatisticsDataSet[] = converters.Create_StatisticsDataSetArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the calculated results for the required statistics for the Customer Service Status Page
     * @param request - Functions
     * @returns Array of StatisticsDataSet
     */
    public async GetStatistics(request: carriers.CustomerService_GetStatisticsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatisticsDataSet[] >;

    /**
     * Returns the calculated results for the required statistics for the Customer Service Status Page
     * @param functions - List of functions to calculate and return
     * @returns Array of StatisticsDataSet
     */
    public async GetStatistics(functions: enums.StatusScreenPanelType[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatisticsDataSet[] >;

    public async GetStatistics(functions:enums.StatusScreenPanelType[]|carriers.CustomerService_GetStatisticsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StatisticsDataSet[] > {
        let _request : carriers.CustomerService_GetStatisticsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = functions;
        if( typeof( first ) === "object" && first && ( typeof(first.Functions)!='undefined' ) )
        {
            _request = functions as carriers.CustomerService_GetStatisticsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Functions: functions as enums.StatusScreenPanelType[],
                       };   
            _options = webapi_options;
        }
        return this._GetStatistics( _request, _options );
    }


    private async _GetSystemTemplateSettings( options?:base.WebApiRequestOptions) : Promise< carriers.SystemTemplateSettings > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SystemTemplateSettings >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSystemTemplateSettings", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SystemTemplateSettings = converters.Create_SystemTemplateSettings_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns system template settings
     * @returns System template settings item
     */
    public async GetSystemTemplateSettings(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SystemTemplateSettings >
    {
        return this._GetSystemTemplateSettings(webapi_options);
    }


    private async _SaveSystemTemplateSettings(request: carriers.CustomerService_SaveSystemTemplateSettingsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SystemTemplateSettings > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SystemTemplateSettings >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveSystemTemplateSettings", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SystemTemplateSettings = converters.Create_SystemTemplateSettings_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves and validates updated system templates. Throws exception if validation fails
     * @param request - SystemTemplateSettings
     * @returns Updated system template settings
     */
    public async SaveSystemTemplateSettings(request: carriers.CustomerService_SaveSystemTemplateSettingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SystemTemplateSettings >;

    /**
     * Saves and validates updated system templates. Throws exception if validation fails
     * @param systemTemplateSettings - System template settings item with updated values
     * @returns Updated system template settings
     */
    public async SaveSystemTemplateSettings(systemTemplateSettings: carriers.SystemTemplateSettings, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SystemTemplateSettings >;

    public async SaveSystemTemplateSettings(systemTemplateSettings:carriers.SystemTemplateSettings|carriers.CustomerService_SaveSystemTemplateSettingsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SystemTemplateSettings > {
        let _request : carriers.CustomerService_SaveSystemTemplateSettingsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = systemTemplateSettings;
        if( typeof( first ) === "object" && first && ( typeof(first.SystemTemplateSettings)!='undefined' ) )
        {
            _request = systemTemplateSettings as carriers.CustomerService_SaveSystemTemplateSettingsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SystemTemplateSettings: systemTemplateSettings as carriers.SystemTemplateSettings,
                       };   
            _options = webapi_options;
        }
        return this._SaveSystemTemplateSettings( _request, _options );
    }


    private async _CreateTicketFromMailData(request: carriers.CustomerService_CreateTicketFromMailDataRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTicketFromMailData", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketInfo = converters.Create_TicketInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method create a new ticket in the same way as importMail would import an email. It accepts RFC822 formatted data
     * @param request - MailboxId, Data
     * @returns An object containing some meta data for the created ticket
     */
    public async CreateTicketFromMailData(request: carriers.CustomerService_CreateTicketFromMailDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo >;

    /**
     * This method create a new ticket in the same way as importMail would import an email. It accepts RFC822 formatted data
     * @param mailboxId - The id of the Service mailbox
     * @param data - RFC822 formatted data to import as a ticket
     * @returns An object containing some meta data for the created ticket
     */
    public async CreateTicketFromMailData(mailboxId: number, data: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo >;

    public async CreateTicketFromMailData(mailboxId:number|carriers.CustomerService_CreateTicketFromMailDataRequest, data?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo > {
        let _request : carriers.CustomerService_CreateTicketFromMailDataRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = mailboxId;
        if( typeof( first ) === "object" && first && ( typeof(first.MailboxId)!='undefined' || typeof(first.Data)!='undefined' ) )
        {
            _request = mailboxId as carriers.CustomerService_CreateTicketFromMailDataRequest;
            _options = data as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       MailboxId: mailboxId as number,
                       Data: data as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateTicketFromMailData( _request, _options );
    }


    private async _AddMessageFromMailData(request: carriers.CustomerService_AddMessageFromMailDataRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddMessageFromMailData", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketInfo = converters.Create_TicketInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method will add a message to an existing request in the sam way as importMail would do it from an email. It accepts RFC822 formatted data
     * @param request - TicketId, Data
     * @returns An object containing some meta data for the ticket
     */
    public async AddMessageFromMailData(request: carriers.CustomerService_AddMessageFromMailDataRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo >;

    /**
     * This method will add a message to an existing request in the sam way as importMail would do it from an email. It accepts RFC822 formatted data
     * @param ticketId - The id of the ticket to add a message
     * @param data - RFC822 formatted data to import as a message
     * @returns An object containing some meta data for the ticket
     */
    public async AddMessageFromMailData(ticketId: number, data: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo >;

    public async AddMessageFromMailData(ticketId:number|carriers.CustomerService_AddMessageFromMailDataRequest, data?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo > {
        let _request : carriers.CustomerService_AddMessageFromMailDataRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ticketId;
        if( typeof( first ) === "object" && first && ( typeof(first.TicketId)!='undefined' || typeof(first.Data)!='undefined' ) )
        {
            _request = ticketId as carriers.CustomerService_AddMessageFromMailDataRequest;
            _options = data as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TicketId: ticketId as number,
                       Data: data as string,
                       };   
            _options = webapi_options;
        }
        return this._AddMessageFromMailData( _request, _options );
    }


    private async _FindTicketsByTitleOrId(request: carriers.CustomerService_FindTicketsByTitleOrIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TicketInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindTicketsByTitleOrId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TicketInfo[] = converters.Create_TicketInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This method wil search for tickets matching title or id
     * @param request - TitleOrId, MaxRows
     * @returns An array of objects containing some meta data for matching tickets
     */
    public async FindTicketsByTitleOrId(request: carriers.CustomerService_FindTicketsByTitleOrIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo[] >;

    /**
     * This method wil search for tickets matching title or id
     * @param titleOrId - The search string. If this is a number, it will also search for a matching ticket id
     * @param maxRows - The maximum number of rows to be returned
     * @returns An array of objects containing some meta data for matching tickets
     */
    public async FindTicketsByTitleOrId(titleOrId: string, maxRows: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo[] >;

    public async FindTicketsByTitleOrId(titleOrId:string|carriers.CustomerService_FindTicketsByTitleOrIdRequest, maxRows?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TicketInfo[] > {
        let _request : carriers.CustomerService_FindTicketsByTitleOrIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = titleOrId;
        if( typeof( first ) === "object" && first && ( typeof(first.TitleOrId)!='undefined' || typeof(first.MaxRows)!='undefined' ) )
        {
            _request = titleOrId as carriers.CustomerService_FindTicketsByTitleOrIdRequest;
            _options = maxRows as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TitleOrId: titleOrId as string,
                       MaxRows: maxRows as number,
                       };   
            _options = webapi_options;
        }
        return this._FindTicketsByTitleOrId( _request, _options );
    }

    } // class v1CustomerServiceAgentController 



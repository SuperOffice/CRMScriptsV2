// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/ViewStateAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * User interface view state, history, currentXXX values
 */
export interface IViewStateAgent {
    GetLiveUiConfig(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LiveUiConfig >;
    GetHistory(historyId: number) :  Promise< carriers.History >;
    GetCurrent(request: carriers.ViewState_GetCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;
    GetCurrent(historyName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;
    SaveCurrent(request: carriers.ViewState_SaveCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;
    SaveCurrent(current: carriers.History, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;
    GetNextCurrent(request: carriers.ViewState_GetNextCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;
    GetNextCurrent(historyName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;
    GetPreviousCurrent(request: carriers.ViewState_GetPreviousCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;
    GetPreviousCurrent(historyName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;
    DeleteHistory(request: carriers.ViewState_DeleteHistoryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteHistory(historyName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetHistories(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    GetHistoriesByName(request: carriers.ViewState_GetHistoriesByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    GetHistoriesByName(historyName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    GetHistoriesByNames(request: carriers.ViewState_GetHistoriesByNamesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    GetHistoriesByNames(historyNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    SaveHistories(request: carriers.ViewState_SaveHistoriesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    SaveHistories(historyName: string, history: carriers.History[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    GetHistoryLengthPrefValue(webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    SetHistoryLengthPrefValue(request: carriers.ViewState_SetHistoryLengthPrefValueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetHistoryLengthPrefValue(length: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveCurrents(request: carriers.ViewState_SaveCurrentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    SaveCurrents(currents: carriers.History[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    GetHistoriesByNamesAndIds(request: carriers.ViewState_GetHistoriesByNamesAndIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    GetHistoriesByNamesAndIds(requests: carriers.HistoryRequest[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;
    PublishAndRetrieveUiEvents(request: carriers.ViewState_PublishAndRetrieveUiEventsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UiEvent[] >;
    PublishAndRetrieveUiEvents(latestKnownEventId: number, publishEvents: carriers.UiEvent[], metrics: carriers.MetricPair[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UiEvent[] >;
} // interface IViewStateAgent




/**
 * User interface view state, history, currentXXX values
 */
export class ViewStateAgent extends base.WebApiBase implements IViewStateAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/ViewState/";
        super(options);
    }



    private async _GetLiveUiConfig( options?:base.WebApiRequestOptions) : Promise< carriers.LiveUiConfig > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.LiveUiConfig >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLiveUiConfig", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.LiveUiConfig = converters.Create_LiveUiConfig_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets live UI configuration
     * @returns Live UI configuration containing the parameters needed for live UI functionality
     */
    public async GetLiveUiConfig(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.LiveUiConfig >
    {
        return this._GetLiveUiConfig(webapi_options);
    }

    /*
     * Gets a History object.
     * @param historyId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single History
     */
    public async GetHistory(historyId: number, options?:base.WebApiRequestOptions) : Promise< carriers.History > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetHistory?historyId=" + historyId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_History_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetCurrent(request: carriers.ViewState_GetCurrentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.History > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCurrent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History = converters.Create_History_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the current (most recent) value of the history list. This is the item with rank = 1. If no item exists a default value is returned. This is usually the first item in the table representing the history list.
     * @param request - HistoryName
     * @returns The current (most recent) history item
     */
    public async GetCurrent(request: carriers.ViewState_GetCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;

    /**
     * Get the current (most recent) value of the history list. This is the item with rank = 1. If no item exists a default value is returned. This is usually the first item in the table representing the history list.
     * @param historyName - Name of the history list, e.g. contact, project
     * @returns The current (most recent) history item
     */
    public async GetCurrent(historyName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;

    public async GetCurrent(historyName:string|carriers.ViewState_GetCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History > {
        let _request : carriers.ViewState_GetCurrentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = historyName;
        if( typeof( first ) === "object" && first && ( typeof(first.HistoryName)!='undefined' ) )
        {
            _request = historyName as carriers.ViewState_GetCurrentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       HistoryName: historyName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetCurrent( _request, _options );
    }


    private async _SaveCurrent(request: carriers.ViewState_SaveCurrentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.History > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveCurrent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History = converters.Create_History_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saving the current history item. This history item is saved with Rank = 1, and all the remaining elements rank values are shifted one down. The list is maintained with the max lenght of the History list length preference.
     * @param request - Current
     * @returns The current (most recent) history item
     */
    public async SaveCurrent(request: carriers.ViewState_SaveCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;

    /**
     * Saving the current history item. This history item is saved with Rank = 1, and all the remaining elements rank values are shifted one down. The list is maintained with the max lenght of the History list length preference.
     * @param current - The new current history element.
     * @returns The current (most recent) history item
     */
    public async SaveCurrent(current: carriers.History, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;

    public async SaveCurrent(current:carriers.History|carriers.ViewState_SaveCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History > {
        let _request : carriers.ViewState_SaveCurrentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = current;
        if( typeof( first ) === "object" && first && ( typeof(first.Current)!='undefined' ) )
        {
            _request = current as carriers.ViewState_SaveCurrentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Current: current as carriers.History,
                       };   
            _options = webapi_options;
        }
        return this._SaveCurrent( _request, _options );
    }


    private async _GetNextCurrent(request: carriers.ViewState_GetNextCurrentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.History > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextCurrent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History = converters.Create_History_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the next current item. If no item exists a default value is returned. This is usually the first item in the table representing the history list.
     * @param request - HistoryName, Id
     * @returns The current value.
     */
    public async GetNextCurrent(request: carriers.ViewState_GetNextCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;

    /**
     * Returns the next current item. If no item exists a default value is returned. This is usually the first item in the table representing the history list.
     * @param historyName - Name of the history list, e.g. contact, project
     * @param id - Id of the history element, e.g. Contact id
     * @returns The current value.
     */
    public async GetNextCurrent(historyName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;

    public async GetNextCurrent(historyName:string|carriers.ViewState_GetNextCurrentRequest, id?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History > {
        let _request : carriers.ViewState_GetNextCurrentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = historyName;
        if( typeof( first ) === "object" && first && ( typeof(first.HistoryName)!='undefined' || typeof(first.Id)!='undefined' ) )
        {
            _request = historyName as carriers.ViewState_GetNextCurrentRequest;
            _options = id as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       HistoryName: historyName as string,
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._GetNextCurrent( _request, _options );
    }


    private async _GetPreviousCurrent(request: carriers.ViewState_GetPreviousCurrentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.History > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviousCurrent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History = converters.Create_History_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the previous current item. If no item exists a default value is returned. This is usually the first item in the table representing the history list.
     * @param request - HistoryName, Id
     * @returns The current value.
     */
    public async GetPreviousCurrent(request: carriers.ViewState_GetPreviousCurrentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;

    /**
     * Returns the previous current item. If no item exists a default value is returned. This is usually the first item in the table representing the history list.
     * @param historyName - Name of the history list, e.g. contact, project
     * @param id - Id of the history element, e.g. Contact id
     * @returns The current value.
     */
    public async GetPreviousCurrent(historyName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History >;

    public async GetPreviousCurrent(historyName:string|carriers.ViewState_GetPreviousCurrentRequest, id?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History > {
        let _request : carriers.ViewState_GetPreviousCurrentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = historyName;
        if( typeof( first ) === "object" && first && ( typeof(first.HistoryName)!='undefined' || typeof(first.Id)!='undefined' ) )
        {
            _request = historyName as carriers.ViewState_GetPreviousCurrentRequest;
            _options = id as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       HistoryName: historyName as string,
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviousCurrent( _request, _options );
    }


    private async _DeleteHistory(request: carriers.ViewState_DeleteHistoryRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteHistory", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes the history element
     * @param request - HistoryName, Id
     * @returns 
     */
    public async DeleteHistory(request: carriers.ViewState_DeleteHistoryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes the history element
     * @param historyName - Name of the history list, e.g. contact, project
     * @param id - Id of the history element, e.g. Contact id
     * @returns 
     */
    public async DeleteHistory(historyName: string, id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteHistory(historyName:string|carriers.ViewState_DeleteHistoryRequest, id?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.ViewState_DeleteHistoryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = historyName;
        if( typeof( first ) === "object" && first && ( typeof(first.HistoryName)!='undefined' || typeof(first.Id)!='undefined' ) )
        {
            _request = historyName as carriers.ViewState_DeleteHistoryRequest;
            _options = id as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       HistoryName: historyName as string,
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteHistory( _request, _options );
    }


    private async _GetHistories( options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHistories", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History[] = converters.Create_HistoryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns all history items that belong to the currently logged in user
     * @returns Array of History items
     */
    public async GetHistories(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >
    {
        return this._GetHistories(webapi_options);
    }


    private async _GetHistoriesByName(request: carriers.ViewState_GetHistoriesByNameRequest, options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHistoriesByName", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History[] = converters.Create_HistoryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the named history list that belong to the currently logged in user
     * @param request - HistoryName
     * @returns Array of History items
     */
    public async GetHistoriesByName(request: carriers.ViewState_GetHistoriesByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    /**
     * Returns the named history list that belong to the currently logged in user
     * @param historyName - Name of the history list
     * @returns Array of History items
     */
    public async GetHistoriesByName(historyName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    public async GetHistoriesByName(historyName:string|carriers.ViewState_GetHistoriesByNameRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        let _request : carriers.ViewState_GetHistoriesByNameRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = historyName;
        if( typeof( first ) === "object" && first && ( typeof(first.HistoryName)!='undefined' ) )
        {
            _request = historyName as carriers.ViewState_GetHistoriesByNameRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       HistoryName: historyName as string,
                       };   
            _options = webapi_options;
        }
        return this._GetHistoriesByName( _request, _options );
    }


    private async _GetHistoriesByNames(request: carriers.ViewState_GetHistoriesByNamesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHistoriesByNames", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History[] = converters.Create_HistoryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the named history lists that belong to the currently logged in user
     * @param request - HistoryNames
     * @returns Array of History items
     */
    public async GetHistoriesByNames(request: carriers.ViewState_GetHistoriesByNamesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    /**
     * Returns the named history lists that belong to the currently logged in user
     * @param historyNames - String array of list names
     * @returns Array of History items
     */
    public async GetHistoriesByNames(historyNames: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    public async GetHistoriesByNames(historyNames:string[]|carriers.ViewState_GetHistoriesByNamesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        let _request : carriers.ViewState_GetHistoriesByNamesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = historyNames;
        if( typeof( first ) === "object" && first && ( typeof(first.HistoryNames)!='undefined' ) )
        {
            _request = historyNames as carriers.ViewState_GetHistoriesByNamesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       HistoryNames: historyNames as string[],
                       };   
            _options = webapi_options;
        }
        return this._GetHistoriesByNames( _request, _options );
    }


    private async _SaveHistories(request: carriers.ViewState_SaveHistoriesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHistories", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History[] = converters.Create_HistoryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Replaces the existing history-list for the currently logged in user. All elements must belong to the same history list. If not they are ignored.
     * @param request - HistoryName, History
     * @returns Array of the saved History items
     */
    public async SaveHistories(request: carriers.ViewState_SaveHistoriesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    /**
     * Replaces the existing history-list for the currently logged in user. All elements must belong to the same history list. If not they are ignored.
     * @param historyName - 
     * @param history - Array of new history items to save.
     * @returns Array of the saved History items
     */
    public async SaveHistories(historyName: string, history: carriers.History[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    public async SaveHistories(historyName:string|carriers.ViewState_SaveHistoriesRequest, history?:carriers.History[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        let _request : carriers.ViewState_SaveHistoriesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = historyName;
        if( typeof( first ) === "object" && first && ( typeof(first.HistoryName)!='undefined' || typeof(first.History)!='undefined' ) )
        {
            _request = historyName as carriers.ViewState_SaveHistoriesRequest;
            _options = history as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       HistoryName: historyName as string,
                       History: history as carriers.History[],
                       };   
            _options = webapi_options;
        }
        return this._SaveHistories( _request, _options );
    }


    private async _GetHistoryLengthPrefValue( options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHistoryLengthPrefValue", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the logged on user&apos;s preferred history list length. Will return the system preference if no user preferences are available.
     * @returns The history list lenght
     */
    public async GetHistoryLengthPrefValue(webapi_options?:base.WebApiRequestOptions) : Promise< number >
    {
        return this._GetHistoryLengthPrefValue(webapi_options);
    }


    private async _SetHistoryLengthPrefValue(request: carriers.ViewState_SetHistoryLengthPrefValueRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetHistoryLengthPrefValue", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the logged on user&apos;s preferred history list length.
     * @param request - Length
     * @returns 
     */
    public async SetHistoryLengthPrefValue(request: carriers.ViewState_SetHistoryLengthPrefValueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set the logged on user&apos;s preferred history list length.
     * @param length - The new history list lenght
     * @returns 
     */
    public async SetHistoryLengthPrefValue(length: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetHistoryLengthPrefValue(length:number|carriers.ViewState_SetHistoryLengthPrefValueRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.ViewState_SetHistoryLengthPrefValueRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = length;
        if( typeof( first ) === "object" && first && ( typeof(first.Length)!='undefined' ) )
        {
            _request = length as carriers.ViewState_SetHistoryLengthPrefValueRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Length: length as number,
                       };   
            _options = webapi_options;
        }
        return this._SetHistoryLengthPrefValue( _request, _options );
    }


    private async _SaveCurrents(request: carriers.ViewState_SaveCurrentsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveCurrents", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History[] = converters.Create_HistoryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the history elements as the current value for their respective lists. If more than one item is submitted for the same list, they are added sequently, meaning that the last one is the most current.
     * @param request - Currents
     * @returns Array of the saved History items
     */
    public async SaveCurrents(request: carriers.ViewState_SaveCurrentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    /**
     * Saves the history elements as the current value for their respective lists. If more than one item is submitted for the same list, they are added sequently, meaning that the last one is the most current.
     * @param currents - Array of new history items to save.
     * @returns Array of the saved History items
     */
    public async SaveCurrents(currents: carriers.History[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    public async SaveCurrents(currents:carriers.History[]|carriers.ViewState_SaveCurrentsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        let _request : carriers.ViewState_SaveCurrentsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = currents;
        if( typeof( first ) === "object" && first && ( typeof(first.Currents)!='undefined' ) )
        {
            _request = currents as carriers.ViewState_SaveCurrentsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Currents: currents as carriers.History[],
                       };   
            _options = webapi_options;
        }
        return this._SaveCurrents( _request, _options );
    }


    private async _GetHistoriesByNamesAndIds(request: carriers.ViewState_GetHistoriesByNamesAndIdsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.History[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHistoriesByNamesAndIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.History[] = converters.Create_HistoryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns history data for the named entities and the given ids - which may not directly correspond to the current history records in the database.&lt;para/&gt;Use this method if you know exactly which items you need, regardless of whether they are in the current history or not.&lt;para/&gt;The history in the database is not changed or even looked at by this method.
     * @param request - Requests
     * @returns On history item for each history name/id pair specified, in exactly the same order as specified.<para/>If a specified item cannot be found in the database, its Id will be 0 and its name will be blank in the return array.
     */
    public async GetHistoriesByNamesAndIds(request: carriers.ViewState_GetHistoriesByNamesAndIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    /**
     * Returns history data for the named entities and the given ids - which may not directly correspond to the current history records in the database.&lt;para/&gt;Use this method if you know exactly which items you need, regardless of whether they are in the current history or not.&lt;para/&gt;The history in the database is not changed or even looked at by this method.
     * @param requests - Array of request objects that define what entities we are requesting history information for
     * @returns On history item for each history name/id pair specified, in exactly the same order as specified.<para/>If a specified item cannot be found in the database, its Id will be 0 and its name will be blank in the return array.
     */
    public async GetHistoriesByNamesAndIds(requests: carriers.HistoryRequest[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] >;

    public async GetHistoriesByNamesAndIds(requests:carriers.HistoryRequest[]|carriers.ViewState_GetHistoriesByNamesAndIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.History[] > {
        let _request : carriers.ViewState_GetHistoriesByNamesAndIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = requests;
        if( typeof( first ) === "object" && first && ( typeof(first.Requests)!='undefined' ) )
        {
            _request = requests as carriers.ViewState_GetHistoriesByNamesAndIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Requests: requests as carriers.HistoryRequest[],
                       };   
            _options = webapi_options;
        }
        return this._GetHistoriesByNamesAndIds( _request, _options );
    }


    private async _PublishAndRetrieveUiEvents(request: carriers.ViewState_PublishAndRetrieveUiEventsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UiEvent[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UiEvent[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PublishAndRetrieveUiEvents", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UiEvent[] = converters.Create_UiEventArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Publish zero or more events, and return any new events since the given event id. The initial implementation is in-memory only; applies solely to the front-end web server; and anything older than 20 minutes is discarded
     * @param request - LatestKnownEventId, PublishEvents, Metrics
     * @returns Array of events since the given event ID; within the time span kept by the event mechanism. Event/primarykey combinations are not guaranteed to be unique, and events in the PublishEvents parameter are echoed back to the client
     */
    public async PublishAndRetrieveUiEvents(request: carriers.ViewState_PublishAndRetrieveUiEventsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UiEvent[] >;

    /**
     * Publish zero or more events, and return any new events since the given event id. The initial implementation is in-memory only; applies solely to the front-end web server; and anything older than 20 minutes is discarded
     * @param latestKnownEventId - The last event ID that this client knows about. The return value will be any events occurring /after/ that point, numbered by the server. Clients need to keep track themselves of this number between calls
     * @param publishEvents - Array of events to publish. This can be empty if the client only wants to retrieve information
     * @param metrics - Optional statistical and performance metrics collected by the frontend. Can be null or empty. Metrics are sum-accumulated and reported once a minute; please do not report the same logical event twice
     * @returns Array of events since the given event ID; within the time span kept by the event mechanism. Event/primarykey combinations are not guaranteed to be unique, and events in the PublishEvents parameter are echoed back to the client
     */
    public async PublishAndRetrieveUiEvents(latestKnownEventId: number, publishEvents: carriers.UiEvent[], metrics: carriers.MetricPair[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UiEvent[] >;

    public async PublishAndRetrieveUiEvents(latestKnownEventId:number|carriers.ViewState_PublishAndRetrieveUiEventsRequest, publishEvents?:carriers.UiEvent[]|base.WebApiRequestOptions, metrics?:carriers.MetricPair[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UiEvent[] > {
        let _request : carriers.ViewState_PublishAndRetrieveUiEventsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = latestKnownEventId;
        if( typeof( first ) === "object" && first && ( typeof(first.LatestKnownEventId)!='undefined' || typeof(first.PublishEvents)!='undefined' || typeof(first.Metrics)!='undefined' ) )
        {
            _request = latestKnownEventId as carriers.ViewState_PublishAndRetrieveUiEventsRequest;
            _options = publishEvents as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       LatestKnownEventId: latestKnownEventId as number,
                       PublishEvents: publishEvents as carriers.UiEvent[],
                       Metrics: metrics as carriers.MetricPair[],
                       };   
            _options = webapi_options;
        }
        return this._PublishAndRetrieveUiEvents( _request, _options );
    }

    } // class v1ViewStateAgentController 



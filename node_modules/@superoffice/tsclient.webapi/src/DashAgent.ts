// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/DashAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Agent that lets you configure dashboard tiles and retrieve dashboard data
 */
export interface IDashAgent {
    CreateDefaultDash(): Promise< carriers.Dash >;
    SaveDash(entity: carriers.Dash) : Promise< carriers.Dash >;
    DeleteDash(DashId: number) : Promise<void>;
    CreateDefaultDashCollection(): Promise< carriers.DashCollection >;
    CreateDefaultDashTheme(): Promise< carriers.DashTheme >;
    SaveDashTheme(entity: carriers.DashTheme) : Promise< carriers.DashTheme >;
    DeleteDashTheme(DashThemeId: number) : Promise<void>;
    CreateDefaultDashTile(): Promise< carriers.DashTile >;
    SaveDashTile(entity: carriers.DashTile) : Promise< carriers.DashTile >;
    DeleteDashTile(DashTileId: number) : Promise<void>;
    CreateDefaultDashTileDefinition(): Promise< carriers.DashTileDefinition >;
    SaveDashTileDefinition(entity: carriers.DashTileDefinition) : Promise< carriers.DashTileDefinition >;
    DeleteDashTileDefinition(DashTileDefinitionId: number) : Promise<void>;
    CreateDefaultPreviewDash(): Promise< carriers.PreviewDash >;
    CreateDefaultPreviewDashTile(): Promise< carriers.PreviewDashTile >;
    GetDash(dashId: number) :  Promise< carriers.Dash >;
    AddTileToDashboard(request: carriers.Dash_AddTileToDashboardRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;
    AddTileToDashboard(dashboardId: number, dashTileDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;
    AddNewTileToDashboard(request: carriers.Dash_AddNewTileToDashboardRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;
    AddNewTileToDashboard(dashboardId: number, dashTileDefinition: carriers.DashTileDefinition, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;
    DuplicateDashboard(request: carriers.Dash_DuplicateDashboardRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash >;
    DuplicateDashboard(dashboardId: number, name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash >;
    GetDashList(request: carriers.Dash_GetDashListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash[] >;
    GetDashList(dashboards: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash[] >;
    GetDashCollection(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashCollection >;
    GetDashTheme(dashThemeId: number) :  Promise< carriers.DashTheme >;
    GetDashTile(dashTileId: number) :  Promise< carriers.DashTile >;
    GetDashTiles(request: carriers.Dash_GetDashTilesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile[] >;
    GetDashTiles(dashboardId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile[] >;
    SaveDashTiles(request: carriers.Dash_SaveDashTilesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SaveDashTiles(dashboardId: number, dashTiles: carriers.DashTile[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateDashTileSelectionFromEntity(request: carriers.Dash_CreateDashTileSelectionFromEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CreateDashTileSelectionFromEntity(entityName: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CopyTileSelection(request: carriers.Dash_CopyTileSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CopyTileSelection(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetTempTileSelection(request: carriers.Dash_GetTempTileSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetTempTileSelection(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetSecondaryTempTileSelection(request: carriers.Dash_GetSecondaryTempTileSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    GetSecondaryTempTileSelection(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CreateDefaultTileForEntity(request: carriers.Dash_CreateDefaultTileForEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;
    CreateDefaultTileForEntity(entityName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;
    DuplicateTile(request: carriers.Dash_DuplicateTileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;
    DuplicateTile(dashTileId: number, name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;
    GetDashTileDefinition(dashTileDefinitionId: number) :  Promise< carriers.DashTileDefinition >;
    CreateDefaultTileDefinitionForEntity(request: carriers.Dash_CreateDefaultTileDefinitionForEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileDefinition >;
    CreateDefaultTileDefinitionForEntity(entityName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileDefinition >;
    GetDashTileHtml(request: carriers.Dash_GetDashTileHtmlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml >;
    GetDashTileHtml(dashboardTileDefinitionId: number, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml >;
    GetDashTileHtmlList(request: carriers.Dash_GetDashTileHtmlListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] >;
    GetDashTileHtmlList(dashboardTileDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] >;
    SaveDashTileHtmlList(request: carriers.Dash_SaveDashTileHtmlListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] >;
    SaveDashTileHtmlList(dashboardTileDefinitionId: number, languages: carriers.DashTileHtml[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] >;
    GetPreviewDash(request: carriers.Dash_GetPreviewDashRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewDash >;
    GetPreviewDash(dashboardId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewDash >;
} // interface IDashAgent




/**
 * Agent that lets you configure dashboard tiles and retrieve dashboard data
 */
export class DashAgent extends base.WebApiBase implements IDashAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Dash/";
        super(options);
    }



    /**
     * Set default values into a new Dash.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDash(options?:base.WebApiRequestOptions) : Promise< carriers.Dash > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dash >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDash", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Dash = converters.Create_Dash_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing Dash or creates a new Dash if the id parameter is empty
     * @param entity - The Dash to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated Dash
     */
    public async SaveDash(entity: carriers.Dash, options?:base.WebApiRequestOptions) : Promise< carriers.Dash > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dash >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDash", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Dash = converters.Create_Dash_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the Dash
     * @param DashId - The id of the Dash to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteDash(DashId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDash?DashId=" + DashId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new DashCollection.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDashCollection(options?:base.WebApiRequestOptions) : Promise< carriers.DashCollection > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashCollection >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashCollection", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashCollection = converters.Create_DashCollection_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new DashTheme.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDashTheme(options?:base.WebApiRequestOptions) : Promise< carriers.DashTheme > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTheme >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashTheme", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTheme = converters.Create_DashTheme_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DashTheme or creates a new DashTheme if the id parameter is empty
     * @param entity - The DashTheme to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DashTheme
     */
    public async SaveDashTheme(entity: carriers.DashTheme, options?:base.WebApiRequestOptions) : Promise< carriers.DashTheme > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTheme >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDashTheme", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTheme = converters.Create_DashTheme_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the DashTheme
     * @param DashThemeId - The id of the DashTheme to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteDashTheme(DashThemeId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDashTheme?DashThemeId=" + DashThemeId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new DashTile.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDashTile(options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTile >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashTile", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTile = converters.Create_DashTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DashTile or creates a new DashTile if the id parameter is empty
     * @param entity - The DashTile to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DashTile
     */
    public async SaveDashTile(entity: carriers.DashTile, options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTile >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDashTile", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTile = converters.Create_DashTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the DashTile
     * @param DashTileId - The id of the DashTile to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteDashTile(DashTileId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDashTile?DashTileId=" + DashTileId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new DashTileDefinition.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultDashTileDefinition(options?:base.WebApiRequestOptions) : Promise< carriers.DashTileDefinition > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTileDefinition >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashTileDefinition", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTileDefinition = converters.Create_DashTileDefinition_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DashTileDefinition or creates a new DashTileDefinition if the id parameter is empty
     * @param entity - The DashTileDefinition to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DashTileDefinition
     */
    public async SaveDashTileDefinition(entity: carriers.DashTileDefinition, options?:base.WebApiRequestOptions) : Promise< carriers.DashTileDefinition > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTileDefinition >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDashTileDefinition", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTileDefinition = converters.Create_DashTileDefinition_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the DashTileDefinition
     * @param DashTileDefinitionId - The id of the DashTileDefinition to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteDashTileDefinition(DashTileDefinitionId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDashTileDefinition?DashTileDefinitionId=" + DashTileDefinitionId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new PreviewDash.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultPreviewDash(options?:base.WebApiRequestOptions) : Promise< carriers.PreviewDash > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreviewDash >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreviewDash", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreviewDash = converters.Create_PreviewDash_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new PreviewDashTile.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultPreviewDashTile(options?:base.WebApiRequestOptions) : Promise< carriers.PreviewDashTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreviewDashTile >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreviewDashTile", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreviewDashTile = converters.Create_PreviewDashTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Dash object.
     * @param dashId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Dash
     */
    public async GetDash(dashId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Dash > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dash >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDash?dashId=" + dashId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Dash_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _AddTileToDashboard(request: carriers.Dash_AddTileToDashboardRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTile >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddTileToDashboard", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTile = converters.Create_DashTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add a tile to a dashboard with next rank
     * @param request - DashboardId, DashTileDefinitionId
     * @returns The newly added tile
     */
    public async AddTileToDashboard(request: carriers.Dash_AddTileToDashboardRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;

    /**
     * Add a tile to a dashboard with next rank
     * @param dashboardId - The id of the dashboard to add the tile to
     * @param dashTileDefinitionId - The id of the dashboard tile definition
     * @returns The newly added tile
     */
    public async AddTileToDashboard(dashboardId: number, dashTileDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;

    public async AddTileToDashboard(dashboardId:number|carriers.Dash_AddTileToDashboardRequest, dashTileDefinitionId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        let _request : carriers.Dash_AddTileToDashboardRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardId)!='undefined' || typeof(first.DashTileDefinitionId)!='undefined' ) )
        {
            _request = dashboardId as carriers.Dash_AddTileToDashboardRequest;
            _options = dashTileDefinitionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardId: dashboardId as number,
                       DashTileDefinitionId: dashTileDefinitionId as number,
                       };   
            _options = webapi_options;
        }
        return this._AddTileToDashboard( _request, _options );
    }


    private async _AddNewTileToDashboard(request: carriers.Dash_AddNewTileToDashboardRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTile >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddNewTileToDashboard", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTile = converters.Create_DashTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add a new tile to a dashboard with next rank
     * @param request - DashboardId, DashTileDefinition
     * @returns The newly added tile
     */
    public async AddNewTileToDashboard(request: carriers.Dash_AddNewTileToDashboardRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;

    /**
     * Add a new tile to a dashboard with next rank
     * @param dashboardId - The id of the dashboard to add the tile to
     * @param dashTileDefinition - The tile definition data to add to the dashboard
     * @returns The newly added tile
     */
    public async AddNewTileToDashboard(dashboardId: number, dashTileDefinition: carriers.DashTileDefinition, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;

    public async AddNewTileToDashboard(dashboardId:number|carriers.Dash_AddNewTileToDashboardRequest, dashTileDefinition?:carriers.DashTileDefinition|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        let _request : carriers.Dash_AddNewTileToDashboardRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardId)!='undefined' || typeof(first.DashTileDefinition)!='undefined' ) )
        {
            _request = dashboardId as carriers.Dash_AddNewTileToDashboardRequest;
            _options = dashTileDefinition as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardId: dashboardId as number,
                       DashTileDefinition: dashTileDefinition as carriers.DashTileDefinition,
                       };   
            _options = webapi_options;
        }
        return this._AddNewTileToDashboard( _request, _options );
    }


    private async _DuplicateDashboard(request: carriers.Dash_DuplicateDashboardRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Dash > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dash >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DuplicateDashboard", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Dash = converters.Create_Dash_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Duplicate for the dashboard and all the sub elements
     * @param request - DashboardId, Name
     * @returns New dashboard
     */
    public async DuplicateDashboard(request: carriers.Dash_DuplicateDashboardRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash >;

    /**
     * Duplicate for the dashboard and all the sub elements
     * @param dashboardId - The id of the dashboard to add the tile to
     * @param name - The name of the new dashboard
     * @returns New dashboard
     */
    public async DuplicateDashboard(dashboardId: number, name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash >;

    public async DuplicateDashboard(dashboardId:number|carriers.Dash_DuplicateDashboardRequest, name?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash > {
        let _request : carriers.Dash_DuplicateDashboardRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardId)!='undefined' || typeof(first.Name)!='undefined' ) )
        {
            _request = dashboardId as carriers.Dash_DuplicateDashboardRequest;
            _options = name as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardId: dashboardId as number,
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._DuplicateDashboard( _request, _options );
    }


    private async _GetDashList(request: carriers.Dash_GetDashListRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Dash[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Dash[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Dash[] = converters.Create_DashArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the ordered list of dashboards
     * @param request - Dashboards
     * @returns List of dashboards
     */
    public async GetDashList(request: carriers.Dash_GetDashListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash[] >;

    /**
     * Gets the ordered list of dashboards
     * @param dashboards - List of dashboardIds
     * @returns List of dashboards
     */
    public async GetDashList(dashboards: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash[] >;

    public async GetDashList(dashboards:number[]|carriers.Dash_GetDashListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Dash[] > {
        let _request : carriers.Dash_GetDashListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboards;
        if( typeof( first ) === "object" && first && ( typeof(first.Dashboards)!='undefined' ) )
        {
            _request = dashboards as carriers.Dash_GetDashListRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Dashboards: dashboards as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetDashList( _request, _options );
    }


    private async _GetDashCollection( options?:base.WebApiRequestOptions) : Promise< carriers.DashCollection > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashCollection >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashCollection", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashCollection = converters.Create_DashCollection_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets a collection of dashboards for the current associate
     * @returns Dashboard collection
     */
    public async GetDashCollection(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashCollection >
    {
        return this._GetDashCollection(webapi_options);
    }

    /*
     * Gets a DashTheme object.
     * @param dashThemeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DashTheme
     */
    public async GetDashTheme(dashThemeId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DashTheme > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTheme >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDashTheme?dashThemeId=" + dashThemeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTheme_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a DashTile object.
     * @param dashTileId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DashTile
     */
    public async GetDashTile(dashTileId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTile >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDashTile?dashTileId=" + dashTileId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTile_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetDashTiles(request: carriers.Dash_GetDashTilesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashTile[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTile[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashTiles", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTile[] = converters.Create_DashTileArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the ordered list of tiles for a dashboard
     * @param request - DashboardId
     * @returns Ordered list of dashboard tiles
     */
    public async GetDashTiles(request: carriers.Dash_GetDashTilesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile[] >;

    /**
     * Gets the ordered list of tiles for a dashboard
     * @param dashboardId - The id of the dashboard
     * @returns Ordered list of dashboard tiles
     */
    public async GetDashTiles(dashboardId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile[] >;

    public async GetDashTiles(dashboardId:number|carriers.Dash_GetDashTilesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile[] > {
        let _request : carriers.Dash_GetDashTilesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardId)!='undefined' ) )
        {
            _request = dashboardId as carriers.Dash_GetDashTilesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardId: dashboardId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDashTiles( _request, _options );
    }


    private async _SaveDashTiles(request: carriers.Dash_SaveDashTilesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDashTiles", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Saves the ordered list of tiles for a dashboard
     * @param request - DashboardId, DashTiles
     * @returns 
     */
    public async SaveDashTiles(request: carriers.Dash_SaveDashTilesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Saves the ordered list of tiles for a dashboard
     * @param dashboardId - The id of the dashboard
     * @param dashTiles - The tiles in order
     * @returns 
     */
    public async SaveDashTiles(dashboardId: number, dashTiles: carriers.DashTile[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SaveDashTiles(dashboardId:number|carriers.Dash_SaveDashTilesRequest, dashTiles?:carriers.DashTile[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Dash_SaveDashTilesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardId)!='undefined' || typeof(first.DashTiles)!='undefined' ) )
        {
            _request = dashboardId as carriers.Dash_SaveDashTilesRequest;
            _options = dashTiles as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardId: dashboardId as number,
                       DashTiles: dashTiles as carriers.DashTile[],
                       };   
            _options = webapi_options;
        }
        return this._SaveDashTiles( _request, _options );
    }


    private async _CreateDashTileSelectionFromEntity(request: carriers.Dash_CreateDashTileSelectionFromEntityRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDashTileSelectionFromEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the id to a dashboard tile selection
     * @param request - EntityName
     * @returns Selection Id
     */
    public async CreateDashTileSelectionFromEntity(request: carriers.Dash_CreateDashTileSelectionFromEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Returns the id to a dashboard tile selection
     * @param entityName - The name of the entity to create a default selection for
     * @returns Selection Id
     */
    public async CreateDashTileSelectionFromEntity(entityName: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async CreateDashTileSelectionFromEntity(entityName:string|carriers.Dash_CreateDashTileSelectionFromEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Dash_CreateDashTileSelectionFromEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = entityName;
        if( typeof( first ) === "object" && first && ( typeof(first.EntityName)!='undefined' ) )
        {
            _request = entityName as carriers.Dash_CreateDashTileSelectionFromEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EntityName: entityName as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateDashTileSelectionFromEntity( _request, _options );
    }


    private async _CopyTileSelection(request: carriers.Dash_CopyTileSelectionRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyTileSelection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Copy Tile Selection for the dashboard
     * @param request - SelectionId
     * @returns Selection Id
     */
    public async CopyTileSelection(request: carriers.Dash_CopyTileSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Copy Tile Selection for the dashboard
     * @param selectionId - The id of the selection to copy from
     * @returns Selection Id
     */
    public async CopyTileSelection(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async CopyTileSelection(selectionId:number|carriers.Dash_CopyTileSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Dash_CopyTileSelectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Dash_CopyTileSelectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._CopyTileSelection( _request, _options );
    }


    private async _GetTempTileSelection(request: carriers.Dash_GetTempTileSelectionRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTempTileSelection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Copy selection to temporary personal tile selection
     * @param request - SelectionId
     * @returns Selection Id
     */
    public async GetTempTileSelection(request: carriers.Dash_GetTempTileSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Copy selection to temporary personal tile selection
     * @param selectionId - The id of the selection to copy from
     * @returns Selection Id
     */
    public async GetTempTileSelection(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async GetTempTileSelection(selectionId:number|carriers.Dash_GetTempTileSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Dash_GetTempTileSelectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Dash_GetTempTileSelectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetTempTileSelection( _request, _options );
    }


    private async _GetSecondaryTempTileSelection(request: carriers.Dash_GetSecondaryTempTileSelectionRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSecondaryTempTileSelection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Copy selection to secondary temporary personal tile selection
     * @param request - SelectionId
     * @returns Selection Id
     */
    public async GetSecondaryTempTileSelection(request: carriers.Dash_GetSecondaryTempTileSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Copy selection to secondary temporary personal tile selection
     * @param selectionId - The id of the selection to copy from
     * @returns Selection Id
     */
    public async GetSecondaryTempTileSelection(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async GetSecondaryTempTileSelection(selectionId:number|carriers.Dash_GetSecondaryTempTileSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Dash_GetSecondaryTempTileSelectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Dash_GetSecondaryTempTileSelectionRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetSecondaryTempTileSelection( _request, _options );
    }


    private async _CreateDefaultTileForEntity(request: carriers.Dash_CreateDefaultTileForEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTile >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTileForEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTile = converters.Create_DashTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set Measure to CountAll and MeasureField to primary key field
     * @param request - EntityName
     * @returns Default
     */
    public async CreateDefaultTileForEntity(request: carriers.Dash_CreateDefaultTileForEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;

    /**
     * Set Measure to CountAll and MeasureField to primary key field
     * @param entityName - Name of entity to use for primary key
     * @returns Default
     */
    public async CreateDefaultTileForEntity(entityName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;

    public async CreateDefaultTileForEntity(entityName:string|carriers.Dash_CreateDefaultTileForEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        let _request : carriers.Dash_CreateDefaultTileForEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = entityName;
        if( typeof( first ) === "object" && first && ( typeof(first.EntityName)!='undefined' ) )
        {
            _request = entityName as carriers.Dash_CreateDefaultTileForEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EntityName: entityName as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultTileForEntity( _request, _options );
    }


    private async _DuplicateTile(request: carriers.Dash_DuplicateTileRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTile >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DuplicateTile", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTile = converters.Create_DashTile_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Duplicate for the tile and all the sub elements
     * @param request - DashTileId, Name
     * @returns New tile
     */
    public async DuplicateTile(request: carriers.Dash_DuplicateTileRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;

    /**
     * Duplicate for the tile and all the sub elements
     * @param dashTileId - The id of the tile to copy
     * @param name - The name of the new tile
     * @returns New tile
     */
    public async DuplicateTile(dashTileId: number, name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile >;

    public async DuplicateTile(dashTileId:number|carriers.Dash_DuplicateTileRequest, name?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTile > {
        let _request : carriers.Dash_DuplicateTileRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashTileId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashTileId)!='undefined' || typeof(first.Name)!='undefined' ) )
        {
            _request = dashTileId as carriers.Dash_DuplicateTileRequest;
            _options = name as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashTileId: dashTileId as number,
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._DuplicateTile( _request, _options );
    }

    /*
     * Gets a DashTileDefinition object.
     * @param dashTileDefinitionId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DashTileDefinition
     */
    public async GetDashTileDefinition(dashTileDefinitionId: number, options?:base.WebApiRequestOptions) : Promise< carriers.DashTileDefinition > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTileDefinition >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDashTileDefinition?dashTileDefinitionId=" + dashTileDefinitionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTileDefinition_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _CreateDefaultTileDefinitionForEntity(request: carriers.Dash_CreateDefaultTileDefinitionForEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashTileDefinition > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTileDefinition >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTileDefinitionForEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTileDefinition = converters.Create_DashTileDefinition_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set Measure to CountAll and MeasureField to primary key field
     * @param request - EntityName
     * @returns Default
     */
    public async CreateDefaultTileDefinitionForEntity(request: carriers.Dash_CreateDefaultTileDefinitionForEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileDefinition >;

    /**
     * Set Measure to CountAll and MeasureField to primary key field
     * @param entityName - Name of entity to use for primary key
     * @returns Default
     */
    public async CreateDefaultTileDefinitionForEntity(entityName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileDefinition >;

    public async CreateDefaultTileDefinitionForEntity(entityName:string|carriers.Dash_CreateDefaultTileDefinitionForEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileDefinition > {
        let _request : carriers.Dash_CreateDefaultTileDefinitionForEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = entityName;
        if( typeof( first ) === "object" && first && ( typeof(first.EntityName)!='undefined' ) )
        {
            _request = entityName as carriers.Dash_CreateDefaultTileDefinitionForEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EntityName: entityName as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultTileDefinitionForEntity( _request, _options );
    }


    private async _GetDashTileHtml(request: carriers.Dash_GetDashTileHtmlRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTileHtml >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashTileHtml", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTileHtml = converters.Create_DashTileHtml_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get HTML for a dashboard tile definition with TileType = HTML
     * @param request - DashboardTileDefinitionId, LanguageCode
     * @returns HTML data
     */
    public async GetDashTileHtml(request: carriers.Dash_GetDashTileHtmlRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml >;

    /**
     * Get HTML for a dashboard tile definition with TileType = HTML
     * @param dashboardTileDefinitionId - The id of the dashboard tile definition
     * @param languageCode - Preferred language code.
     * @returns HTML data
     */
    public async GetDashTileHtml(dashboardTileDefinitionId: number, languageCode: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml >;

    public async GetDashTileHtml(dashboardTileDefinitionId:number|carriers.Dash_GetDashTileHtmlRequest, languageCode?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml > {
        let _request : carriers.Dash_GetDashTileHtmlRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardTileDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardTileDefinitionId)!='undefined' || typeof(first.LanguageCode)!='undefined' ) )
        {
            _request = dashboardTileDefinitionId as carriers.Dash_GetDashTileHtmlRequest;
            _options = languageCode as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardTileDefinitionId: dashboardTileDefinitionId as number,
                       LanguageCode: languageCode as string,
                       };   
            _options = webapi_options;
        }
        return this._GetDashTileHtml( _request, _options );
    }


    private async _GetDashTileHtmlList(request: carriers.Dash_GetDashTileHtmlListRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTileHtml[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashTileHtmlList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTileHtml[] = converters.Create_DashTileHtmlArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get HTML for a dashboard tile definition with TileType = HTML. Retrieve a list with all registered languages.
     * @param request - DashboardTileDefinitionId
     * @returns 
     */
    public async GetDashTileHtmlList(request: carriers.Dash_GetDashTileHtmlListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] >;

    /**
     * Get HTML for a dashboard tile definition with TileType = HTML. Retrieve a list with all registered languages.
     * @param dashboardTileDefinitionId - The id of the dashboard tile definition
     * @returns 
     */
    public async GetDashTileHtmlList(dashboardTileDefinitionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] >;

    public async GetDashTileHtmlList(dashboardTileDefinitionId:number|carriers.Dash_GetDashTileHtmlListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] > {
        let _request : carriers.Dash_GetDashTileHtmlListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardTileDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardTileDefinitionId)!='undefined' ) )
        {
            _request = dashboardTileDefinitionId as carriers.Dash_GetDashTileHtmlListRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardTileDefinitionId: dashboardTileDefinitionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDashTileHtmlList( _request, _options );
    }


    private async _SaveDashTileHtmlList(request: carriers.Dash_SaveDashTileHtmlListRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DashTileHtml[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDashTileHtmlList", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DashTileHtml[] = converters.Create_DashTileHtmlArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set the HTML data for a tile with TileType = HTML.
     * @param request - DashboardTileDefinitionId, Languages
     * @returns 
     */
    public async SaveDashTileHtmlList(request: carriers.Dash_SaveDashTileHtmlListRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] >;

    /**
     * Set the HTML data for a tile with TileType = HTML.
     * @param dashboardTileDefinitionId - The id of the dashboard tile definition
     * @param languages - List of HTML content per language
     * @returns 
     */
    public async SaveDashTileHtmlList(dashboardTileDefinitionId: number, languages: carriers.DashTileHtml[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] >;

    public async SaveDashTileHtmlList(dashboardTileDefinitionId:number|carriers.Dash_SaveDashTileHtmlListRequest, languages?:carriers.DashTileHtml[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DashTileHtml[] > {
        let _request : carriers.Dash_SaveDashTileHtmlListRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardTileDefinitionId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardTileDefinitionId)!='undefined' || typeof(first.Languages)!='undefined' ) )
        {
            _request = dashboardTileDefinitionId as carriers.Dash_SaveDashTileHtmlListRequest;
            _options = languages as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardTileDefinitionId: dashboardTileDefinitionId as number,
                       Languages: languages as carriers.DashTileHtml[],
                       };   
            _options = webapi_options;
        }
        return this._SaveDashTileHtmlList( _request, _options );
    }


    private async _GetPreviewDash(request: carriers.Dash_GetPreviewDashRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PreviewDash > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PreviewDash >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewDash", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PreviewDash = converters.Create_PreviewDash_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a dashboard from its id
     * @param request - DashboardId
     * @returns Dashboard suitable for preview
     */
    public async GetPreviewDash(request: carriers.Dash_GetPreviewDashRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewDash >;

    /**
     * Get a dashboard from its id
     * @param dashboardId - Dashboard ID
     * @returns Dashboard suitable for preview
     */
    public async GetPreviewDash(dashboardId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewDash >;

    public async GetPreviewDash(dashboardId:number|carriers.Dash_GetPreviewDashRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PreviewDash > {
        let _request : carriers.Dash_GetPreviewDashRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = dashboardId;
        if( typeof( first ) === "object" && first && ( typeof(first.DashboardId)!='undefined' ) )
        {
            _request = dashboardId as carriers.Dash_GetPreviewDashRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DashboardId: dashboardId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPreviewDash( _request, _options );
    }

    } // class v1DashAgentController 



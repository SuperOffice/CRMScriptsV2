// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/PersonAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Person data services.
 */
export interface IPersonAgent {
    CreateDefaultConsentPerson(): Promise< carriers.ConsentPerson >;
    SaveConsentPerson(entity: carriers.ConsentPerson) : Promise< carriers.ConsentPerson >;
    DeleteConsentPerson(ConsentPersonId: number) : Promise<void>;
    CreateDefaultPersonEntity(): Promise< carriers.PersonEntity >;
    SavePersonEntity(entity: carriers.PersonEntity) : Promise< carriers.PersonEntity >;
    DeletePersonEntity(PersonEntityId: number) : Promise<void>;
    CreateDefaultPersonImage(): Promise< carriers.PersonImage >;
    GetConsentPerson(consentPersonId: number) :  Promise< carriers.ConsentPerson >;
    GetPerson(personId: number) :  Promise< carriers.Person >;
    GetPersonEntity(personEntityId: number) :  Promise< carriers.PersonEntity >;
    Undelete(request: carriers.Person_UndeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Undelete(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetMyPerson(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    GetSalesRep(request: carriers.Person_GetSalesRepRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    GetSalesRep(contactName: string, personFirstname: string, personLastname: string, emailAddress: string, phoneNumber: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    GetPhones(request: carriers.Person_GetPhonesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EntityElement[] >;
    GetPhones(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EntityElement[] >;
    ChangeCountry(request: carriers.Person_ChangeCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    ChangeCountry(personEntity: carriers.PersonEntity, toCountryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    GetAddress(request: carriers.Person_GetAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    GetAddress(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    GetAddressByCountry(request: carriers.Person_GetAddressByCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    GetAddressByCountry(personId: number, countryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;
    GetPersonImage(request: carriers.Person_GetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    GetPersonImage(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;
    SetPersonImage(request: carriers.Person_SetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetPersonImage(personId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateDefaultByContactId(request: carriers.Person_CreateDefaultByContactIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    CreateDefaultByContactId(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    Move(request: carriers.Person_MoveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Move(personId: number, destinationContactId: number, moveAfterDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Merge(request: carriers.Person_MergeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    Merge(sourcePersonId: number, destinationPersonId: number, moveAfterDate: Date, deleteSource: boolean, replaceEmptyFieldsOnDestination: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateDefaultFromCredential(request: carriers.Person_CreateDefaultFromCredentialRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    CreateDefaultFromCredential(contactId: number, credentialType: string, credentialValue: string, credentialDisplayValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;
    IsNumberValid(request: carriers.Person_IsNumberValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    IsNumberValid(contactId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SetConsent(request: carriers.Person_SetConsentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetConsent(personId: number, purpose: string, source: string, legalBase: string, comment: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveConsent(request: carriers.Person_RemoveConsentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveConsent(personId: number, purpose: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    HasConsent(request: carriers.Person_HasConsentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    HasConsent(personId: number, purpose: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    GetConsentInfos(request: carriers.Person_GetConsentInfosRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentInfo[] >;
    GetConsentInfos(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentInfo[] >;
    SendConsentConfirmationEmail(request: carriers.Person_SendConsentConfirmationEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SendConsentConfirmationEmail(personId: number, emailAddress: string, emailTemplateId: number, cultureLcidId: number, subject: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ResolvePersonFromInfo(request: carriers.Person_ResolvePersonFromInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedPerson >;
    ResolvePersonFromInfo(contactId: number, personName: string, phoneNumbers: string[], emails: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedPerson >;
    AddEmailAddressToPerson(request: carriers.Person_AddEmailAddressToPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddEmailAddressToPerson(personId: number, emailAddress: string, setAsPrimaryEmail: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateTemporaryKey(request: carriers.Person_CreateTemporaryKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    CreateTemporaryKey(domain: enums.TemporaryKeyDomain, targetId: number, personId: number, expires: Date, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    CheckTemporaryKey(request: carriers.Person_CheckTemporaryKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemporaryKeyInfo >;
    CheckTemporaryKey(temporaryKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemporaryKeyInfo >;
    DeleteTemporaryKeysOfDomain(request: carriers.Person_DeleteTemporaryKeysOfDomainRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteTemporaryKeysOfDomain(domain: enums.TemporaryKeyDomain, personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteExpired(webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPersonSummary(request: carriers.Person_GetPersonSummaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonSummary >;
    GetPersonSummary(personId: number, limit: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonSummary >;
    AddBounce(request: carriers.Person_AddBounceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddBounce(emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ValidatePersonEntity(request: carriers.Person_ValidatePersonEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    ValidatePersonEntity(personEntity: carriers.PersonEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;
    AddBounceWithCount(request: carriers.Person_AddBounceWithCountRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddBounceWithCount(emailAddress: string, counts: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetBestSoLanguageForTemplate(request: carriers.Person_GetBestSoLanguageForTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    GetBestSoLanguageForTemplate(personId: number, templateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    AddBounceWithDetails(request: carriers.Person_AddBounceWithDetailsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddBounceWithDetails(emailAddress: string, counts: number, code: number, reason: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPersonImages(request: carriers.Person_GetPersonImagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonImage[] >;
    GetPersonImages(personIds: number[], scaledWidth: number, scaledHeight: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonImage[] >;
    CreateOrUpdateUserCandidate(request: carriers.Person_CreateOrUpdateUserCandidateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate >;
    CreateOrUpdateUserCandidate(personId: number, username: string, accessAllRequests: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate >;
    GetUserCandidateByPerson(request: carriers.Person_GetUserCandidateByPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate >;
    GetUserCandidateByPerson(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate >;
    GetCustomerCentrePasswordReplyTemplate(request: carriers.Person_GetCustomerCentrePasswordReplyTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;
    GetCustomerCentrePasswordReplyTemplate(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;
    SendEmail(request: carriers.Person_SendEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SendEmail(from: string, to: string, subject: string, plainBody: string, htmlBody: string, attachmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetPersonList(personIds: number[]) :  Promise< carriers.Person[] >;
    GetPersonsFromContact(request: carriers.Person_GetPersonsFromContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetPersonsFromContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetPersonsFromProject(request: carriers.Person_GetPersonsFromProjectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetPersonsFromProject(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetColleagues(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetColleaguesByDepartment(request: carriers.Person_GetColleaguesByDepartmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetColleaguesByDepartment(departmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetColleaguesBySource(request: carriers.Person_GetColleaguesBySourceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetColleaguesBySource(sourceType: enums.AssociateSourceType, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;
    GetMyOwner(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >;
    GetOwnerOnPersonId(request: carriers.Person_GetOwnerOnPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >;
    GetOwnerOnPersonId(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >;
    ChangePersonRank(request: carriers.Person_ChangePersonRankRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    ChangePersonRank(personId: number, moveUp: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    SetPersonRank(request: carriers.Person_SetPersonRankRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    SetPersonRank(personId: number, desiredRank: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    NormalizeRanks(request: carriers.Person_NormalizeRanksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
    NormalizeRanks(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;
} // interface IPersonAgent




/**
 * Person data services.
 */
export class PersonAgent extends base.WebApiBase implements IPersonAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Person/";
        super(options);
    }



    /**
     * Set default values into a new ConsentPerson.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultConsentPerson(options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPerson > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentPerson >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultConsentPerson", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConsentPerson = converters.Create_ConsentPerson_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ConsentPerson or creates a new ConsentPerson if the id parameter is empty
     * @param entity - The ConsentPerson to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ConsentPerson
     */
    public async SaveConsentPerson(entity: carriers.ConsentPerson, options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPerson > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentPerson >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveConsentPerson", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConsentPerson = converters.Create_ConsentPerson_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the ConsentPerson
     * @param ConsentPersonId - The id of the ConsentPerson to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteConsentPerson(ConsentPersonId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteConsentPerson?ConsentPersonId=" + ConsentPersonId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new PersonEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultPersonEntity(options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPersonEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonEntity = converters.Create_PersonEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing PersonEntity or creates a new PersonEntity if the id parameter is empty
     * @param entity - The PersonEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated PersonEntity
     */
    public async SavePersonEntity(entity: carriers.PersonEntity, options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SavePersonEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonEntity = converters.Create_PersonEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the PersonEntity
     * @param PersonEntityId - The id of the PersonEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeletePersonEntity(PersonEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeletePersonEntity?PersonEntityId=" + PersonEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new PersonImage.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultPersonImage(options?:base.WebApiRequestOptions) : Promise< carriers.PersonImage > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonImage >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPersonImage", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonImage = converters.Create_PersonImage_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ConsentPerson object.
     * @param consentPersonId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ConsentPerson
     */
    public async GetConsentPerson(consentPersonId: number, options?:base.WebApiRequestOptions) : Promise< carriers.ConsentPerson > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentPerson >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentPerson?consentPersonId=" + consentPersonId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPerson_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a Person object.
     * @param personId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Person
     */
    public async GetPerson(personId: number, options?:base.WebApiRequestOptions) : Promise< carriers.Person > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPerson?personId=" + personId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Person_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Gets a PersonEntity object.
     * @param personEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PersonEntity
     */
    public async GetPersonEntity(personEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPersonEntity?personEntityId=" + personEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _Undelete(request: carriers.Person_UndeleteRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Undelete", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * This entity supports Soft Delete. Call this method to Undelete a previously soft-deleted record
     * @param request - Id
     * @returns This method has no return value
     */
    public async Undelete(request: carriers.Person_UndeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * This entity supports Soft Delete. Call this method to Undelete a previously soft-deleted record
     * @param id - The primary key of the entity to undelete
     * @returns This method has no return value
     */
    public async Undelete(id: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Undelete(id:number|carriers.Person_UndeleteRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_UndeleteRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = id;
        if( typeof( first ) === "object" && first && ( typeof(first.Id)!='undefined' ) )
        {
            _request = id as carriers.Person_UndeleteRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Id: id as number,
                       };   
            _options = webapi_options;
        }
        return this._Undelete( _request, _options );
    }


    private async _GetMyPerson( options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyPerson", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonEntity = converters.Create_PersonEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets the person info belonging to the currently logged on user.
     * @returns The PersonEntity
     */
    public async GetMyPerson(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >
    {
        return this._GetMyPerson(webapi_options);
    }


    private async _GetSalesRep(request: carriers.Person_GetSalesRepRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSalesRep", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonEntity = converters.Create_PersonEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the sales representative for an external user. If this method is accessed with anonymous authentication the external user is recognized by contact and name, or by email, or phone number. If the external user is recognized as an CRM5 user (internal or external) the input fields can be left blank.
     * @param request - ContactName, PersonFirstname, PersonLastname, EmailAddress, PhoneNumber
     * @returns The PersonEntity of the sales rep.
     */
    public async GetSalesRep(request: carriers.Person_GetSalesRepRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    /**
     * Returns the sales representative for an external user. If this method is accessed with anonymous authentication the external user is recognized by contact and name, or by email, or phone number. If the external user is recognized as an CRM5 user (internal or external) the input fields can be left blank.
     * @param contactName - The company name of the person requesting his sales representative. May be empty if email or phone is provided.
     * @param personFirstname - The firstname of the person requesting his sales representative. May be empty if email or phone is provided.
     * @param personLastname - The lastname of the person requesting his sales representative. May be empty if email or phone is provided.
     * @param emailAddress - The email address of the person requesting his sales representative. May be empty if phone, or contact and person name is provided.
     * @param phoneNumber - The phone number of the person requesting his sales representative. May be empty if email, or contact and person name is provided.
     * @returns The PersonEntity of the sales rep.
     */
    public async GetSalesRep(contactName: string, personFirstname: string, personLastname: string, emailAddress: string, phoneNumber: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    public async GetSalesRep(contactName:string|carriers.Person_GetSalesRepRequest, personFirstname?:string|base.WebApiRequestOptions, personLastname?:string, emailAddress?:string, phoneNumber?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        let _request : carriers.Person_GetSalesRepRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactName;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactName)!='undefined' || typeof(first.PersonFirstname)!='undefined' || typeof(first.PersonLastname)!='undefined' || typeof(first.EmailAddress)!='undefined' || typeof(first.PhoneNumber)!='undefined' ) )
        {
            _request = contactName as carriers.Person_GetSalesRepRequest;
            _options = personFirstname as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactName: contactName as string,
                       PersonFirstname: personFirstname as string,
                       PersonLastname: personLastname as string,
                       EmailAddress: emailAddress as string,
                       PhoneNumber: phoneNumber as string,
                       };   
            _options = webapi_options;
        }
        return this._GetSalesRep( _request, _options );
    }


    private async _GetPhones(request: carriers.Person_GetPhonesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.EntityElement[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.EntityElement[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPhones", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.EntityElement[] = converters.Create_EntityElementArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returning all phones that belong to a person, ordered by the phone type.
     * @param request - PersonId
     * @returns An array of Phones
     */
    public async GetPhones(request: carriers.Person_GetPhonesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EntityElement[] >;

    /**
     * Returning all phones that belong to a person, ordered by the phone type.
     * @param personId - The person id
     * @returns An array of Phones
     */
    public async GetPhones(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EntityElement[] >;

    public async GetPhones(personId:number|carriers.Person_GetPhonesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.EntityElement[] > {
        let _request : carriers.Person_GetPhonesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetPhonesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPhones( _request, _options );
    }


    private async _ChangeCountry(request: carriers.Person_ChangeCountryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeCountry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonEntity = converters.Create_PersonEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Change country regenerates the default values and localized information such as phone number and address format for this entity.
     * @param request - PersonEntity, ToCountryId
     * @returns The PersonEntity
     */
    public async ChangeCountry(request: carriers.Person_ChangeCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    /**
     * Change country regenerates the default values and localized information such as phone number and address format for this entity.
     * @param personEntity - The PersonEntity to change country on
     * @param toCountryId - The country to switch to
     * @returns The PersonEntity
     */
    public async ChangeCountry(personEntity: carriers.PersonEntity, toCountryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    public async ChangeCountry(personEntity:carriers.PersonEntity|carriers.Person_ChangeCountryRequest, toCountryId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        let _request : carriers.Person_ChangeCountryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonEntity)!='undefined' || typeof(first.ToCountryId)!='undefined' ) )
        {
            _request = personEntity as carriers.Person_ChangeCountryRequest;
            _options = toCountryId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonEntity: personEntity as carriers.PersonEntity,
                       ToCountryId: toCountryId as number,
                       };   
            _options = webapi_options;
        }
        return this._ChangeCountry( _request, _options );
    }


    private async _GetAddress(request: carriers.Person_GetAddressRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Address >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAddress", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Address = converters.Create_Address_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the person&apos;s localized address.
     * @param request - PersonId
     * @returns The address as LocalizedField[][].
     */
    public async GetAddress(request: carriers.Person_GetAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    /**
     * Gets the person&apos;s localized address.
     * @param personId - The person id
     * @returns The address as LocalizedField[][].
     */
    public async GetAddress(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    public async GetAddress(personId:number|carriers.Person_GetAddressRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        let _request : carriers.Person_GetAddressRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetAddressRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAddress( _request, _options );
    }


    private async _GetAddressByCountry(request: carriers.Person_GetAddressByCountryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Address >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAddressByCountry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Address = converters.Create_Address_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the person&apos;s localized address.
     * @param request - PersonId, CountryId
     * @returns The address as LocalizedField[][].
     */
    public async GetAddressByCountry(request: carriers.Person_GetAddressByCountryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    /**
     * Gets the person&apos;s localized address.
     * @param personId - The person id
     * @param countryId - 
     * @returns The address as LocalizedField[][].
     */
    public async GetAddressByCountry(personId: number, countryId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address >;

    public async GetAddressByCountry(personId:number|carriers.Person_GetAddressByCountryRequest, countryId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Address > {
        let _request : carriers.Person_GetAddressByCountryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.CountryId)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetAddressByCountryRequest;
            _options = countryId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       CountryId: countryId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetAddressByCountry( _request, _options );
    }


    private async _GetPersonImage(request: carriers.Person_GetPersonImageRequest, options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise< ArrayBuffer|string >(async (resolve, reject) => {
            try {
                if( ! options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer ) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonImage", request , config);
                base.WebApiBase.SetCompleted(options);
                let res : ArrayBuffer | string = null;
                if( options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer )
                {
                    res = response.data as string;
                    if( options.returnBlobAs == base.ReturnBlobType.AsString )
                    {
                        res = FromBase64ToString(res);
                    }
                } 
                else 
                {
                    res = response.data as ArrayBuffer;
                }

                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the person image that is displayed in the CRM application.
     * @param request - PersonId
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetPersonImage(request: carriers.Person_GetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    /**
     * Returns the person image that is displayed in the CRM application.
     * @param personId - The person id of the person the image belongs to.
     * @returns The image as a System.Drawing.Image. (If the the image is returned over webservices, the stream is returned as a Base64 encoded string.)
     */
    public async GetPersonImage(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string >;

    public async GetPersonImage(personId:number|carriers.Person_GetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< ArrayBuffer|string > {
        let _request : carriers.Person_GetPersonImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetPersonImageRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonImage( _request, _options );
    }


    private async _SetPersonImage(request: carriers.Person_SetPersonImageRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPersonImage", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Stores the person image that is displayed in the CRM application.
     * @param request - PersonId, Image
     * @returns 
     */
    public async SetPersonImage(request: carriers.Person_SetPersonImageRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Stores the person image that is displayed in the CRM application.
     * @param personId - The person id of the person the image belongs to.
     * @param image - The image that is stored on the person (System.Drawing.Image)
     * @returns 
     */
    public async SetPersonImage(personId: number, image: ArrayBuffer|string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetPersonImage(personId:number|carriers.Person_SetPersonImageRequest, image?:ArrayBuffer|string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_SetPersonImageRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.Image)!='undefined' ) )
        {
            _request = personId as carriers.Person_SetPersonImageRequest;
            _options = image as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       Image: image as ArrayBuffer|string,
                       };   
            _options = webapi_options;
        }
         _request.Image = ToBase64(_request.Image);
        return this._SetPersonImage( _request, _options );
    }


    private async _CreateDefaultByContactId(request: carriers.Person_CreateDefaultByContactIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultByContactId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonEntity = converters.Create_PersonEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a PersonEntity with default values based on the contactId.
     * @param request - ContactId
     * @returns 
     */
    public async CreateDefaultByContactId(request: carriers.Person_CreateDefaultByContactIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    /**
     * Creates a PersonEntity with default values based on the contactId.
     * @param contactId - Contact id of the person
     * @returns 
     */
    public async CreateDefaultByContactId(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    public async CreateDefaultByContactId(contactId:number|carriers.Person_CreateDefaultByContactIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        let _request : carriers.Person_CreateDefaultByContactIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.Person_CreateDefaultByContactIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultByContactId( _request, _options );
    }


    private async _Move(request: carriers.Person_MoveRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Move", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Move a person to a specified contact. You must specify the date after which activities will be moved along with the person.
     * @param request - PersonId, DestinationContactId, MoveAfterDate
     * @returns 
     */
    public async Move(request: carriers.Person_MoveRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Move a person to a specified contact. You must specify the date after which activities will be moved along with the person.
     * @param personId - The identifier for the person
     * @param destinationContactId - The identifier for the contact which the person will be moved to
     * @param moveAfterDate - Move activites after this date. Activities before this date are left alone.
     * @returns 
     */
    public async Move(personId: number, destinationContactId: number, moveAfterDate: Date, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Move(personId:number|carriers.Person_MoveRequest, destinationContactId?:number|base.WebApiRequestOptions, moveAfterDate?:Date, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_MoveRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.DestinationContactId)!='undefined' || typeof(first.MoveAfterDate)!='undefined' ) )
        {
            _request = personId as carriers.Person_MoveRequest;
            _options = destinationContactId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       DestinationContactId: destinationContactId as number,
                       MoveAfterDate: moveAfterDate as Date,
                       };   
            _options = webapi_options;
        }
        return this._Move( _request, _options );
    }


    private async _Merge(request: carriers.Person_MergeRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Merge", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Merge two persons. The destination person will remain. You must specify the date after which activities will be moved along with the person.
     * @param request - SourcePersonId, DestinationPersonId, MoveAfterDate, DeleteSource, ReplaceEmptyFieldsOnDestination
     * @returns 
     */
    public async Merge(request: carriers.Person_MergeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Merge two persons. The destination person will remain. You must specify the date after which activities will be moved along with the person.
     * @param sourcePersonId - The identifier for the person which will be merged into the destination person. The source person is deleted/marked retired after the merge.
     * @param destinationPersonId - The identifier for the person which will remain after the merge. The target person is updated.
     * @param moveAfterDate - Merge activites after this date. Activities before this date are left alone.
     * @param deleteSource - If true, the source person will be deleted after the merge. If false, it will have its retired flag set
     * @param replaceEmptyFieldsOnDestination - If true, empty fields on destination will be replaced by values from source.
     * @returns 
     */
    public async Merge(sourcePersonId: number, destinationPersonId: number, moveAfterDate: Date, deleteSource: boolean, replaceEmptyFieldsOnDestination: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async Merge(sourcePersonId:number|carriers.Person_MergeRequest, destinationPersonId?:number|base.WebApiRequestOptions, moveAfterDate?:Date, deleteSource?:boolean, replaceEmptyFieldsOnDestination?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_MergeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourcePersonId;
        if( typeof( first ) === "object" && first && ( typeof(first.SourcePersonId)!='undefined' || typeof(first.DestinationPersonId)!='undefined' || typeof(first.MoveAfterDate)!='undefined' || typeof(first.DeleteSource)!='undefined' || typeof(first.ReplaceEmptyFieldsOnDestination)!='undefined' ) )
        {
            _request = sourcePersonId as carriers.Person_MergeRequest;
            _options = destinationPersonId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourcePersonId: sourcePersonId as number,
                       DestinationPersonId: destinationPersonId as number,
                       MoveAfterDate: moveAfterDate as Date,
                       DeleteSource: deleteSource as boolean,
                       ReplaceEmptyFieldsOnDestination: replaceEmptyFieldsOnDestination as boolean,
                       };   
            _options = webapi_options;
        }
        return this._Merge( _request, _options );
    }


    private async _CreateDefaultFromCredential(request: carriers.Person_CreateDefaultFromCredentialRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultFromCredential", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonEntity = converters.Create_PersonEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a PersonEntity with default values based on the contactId and credentials.
     * @param request - ContactId, CredentialType, CredentialValue, CredentialDisplayValue
     * @returns 
     */
    public async CreateDefaultFromCredential(request: carriers.Person_CreateDefaultFromCredentialRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    /**
     * Creates a PersonEntity with default values based on the contactId and credentials.
     * @param contactId - Contact id of the person
     * @param credentialType - Type of credentials, corresponding to name of plugin and type in the credentials table.
     * @param credentialValue - This is the actuall value of the credentials.  This will typically be the password or teh users SID in active directory
     * @param credentialDisplayValue - The value displayed to the user. this will typically be the users login name in active directory.
     * @returns 
     */
    public async CreateDefaultFromCredential(contactId: number, credentialType: string, credentialValue: string, credentialDisplayValue: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity >;

    public async CreateDefaultFromCredential(contactId:number|carriers.Person_CreateDefaultFromCredentialRequest, credentialType?:string|base.WebApiRequestOptions, credentialValue?:string, credentialDisplayValue?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonEntity > {
        let _request : carriers.Person_CreateDefaultFromCredentialRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.CredentialType)!='undefined' || typeof(first.CredentialValue)!='undefined' || typeof(first.CredentialDisplayValue)!='undefined' ) )
        {
            _request = contactId as carriers.Person_CreateDefaultFromCredentialRequest;
            _options = credentialType as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       CredentialType: credentialType as string,
                       CredentialValue: credentialValue as string,
                       CredentialDisplayValue: credentialDisplayValue as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateDefaultFromCredential( _request, _options );
    }


    private async _IsNumberValid(request: carriers.Person_IsNumberValidRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNumberValid", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Checks if the number is unique or required.  The setting is configured from admin under system options.
     * @param request - ContactId, Number
     * @returns True if number is ok (passes uniqueness/required checks)
     */
    public async IsNumberValid(request: carriers.Person_IsNumberValidRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Checks if the number is unique or required.  The setting is configured from admin under system options.
     * @param contactId - 
     * @param number - Number to check.
     * @returns True if number is ok (passes uniqueness/required checks)
     */
    public async IsNumberValid(contactId: number, number: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async IsNumberValid(contactId:number|carriers.Person_IsNumberValidRequest, number?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Person_IsNumberValidRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.Number)!='undefined' ) )
        {
            _request = contactId as carriers.Person_IsNumberValidRequest;
            _options = number as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       Number: number as string,
                       };   
            _options = webapi_options;
        }
        return this._IsNumberValid( _request, _options );
    }


    private async _SetConsent(request: carriers.Person_SetConsentRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetConsent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set a specified type of consent on the person.
     * @param request - PersonId, Purpose, Source, LegalBase, Comment
     * @returns 
     */
    public async SetConsent(request: carriers.Person_SetConsentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set a specified type of consent on the person.
     * @param personId - The person id
     * @param purpose - The Key of the purpose this affects. e.g. 'STORE' or 'EMARKETING'.
     * @param source - The Key of the source of this consent. e.g. 'USER', 'WEBFORM' or 'API'.
     * @param legalBase - The Key of the legal base for this consent. e.g. '61A', '61B', '61F'
     * @param comment - A comment regarding this consent. May be null or empty.
     * @returns 
     */
    public async SetConsent(personId: number, purpose: string, source: string, legalBase: string, comment: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetConsent(personId:number|carriers.Person_SetConsentRequest, purpose?:string|base.WebApiRequestOptions, source?:string, legalBase?:string, comment?:string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_SetConsentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.Purpose)!='undefined' || typeof(first.Source)!='undefined' || typeof(first.LegalBase)!='undefined' || typeof(first.Comment)!='undefined' ) )
        {
            _request = personId as carriers.Person_SetConsentRequest;
            _options = purpose as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       Purpose: purpose as string,
                       Source: source as string,
                       LegalBase: legalBase as string,
                       Comment: comment as string,
                       };   
            _options = webapi_options;
        }
        return this._SetConsent( _request, _options );
    }


    private async _RemoveConsent(request: carriers.Person_RemoveConsentRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveConsent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Turn off consent for a specified person and purpose.
     * @param request - PersonId, Purpose
     * @returns 
     */
    public async RemoveConsent(request: carriers.Person_RemoveConsentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Turn off consent for a specified person and purpose.
     * @param personId - The person id
     * @param purpose - The key of the purpose to remove. (e.g. 'STORE' or 'EMARKETING')
     * @returns 
     */
    public async RemoveConsent(personId: number, purpose: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveConsent(personId:number|carriers.Person_RemoveConsentRequest, purpose?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_RemoveConsentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.Purpose)!='undefined' ) )
        {
            _request = personId as carriers.Person_RemoveConsentRequest;
            _options = purpose as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       Purpose: purpose as string,
                       };   
            _options = webapi_options;
        }
        return this._RemoveConsent( _request, _options );
    }


    private async _HasConsent(request: carriers.Person_HasConsentRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasConsent", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check if consent has been given by a specified person, for a specific purpose. Withdraw consents return FALSE.
     * @param request - PersonId, Purpose
     * @returns True if the person has consented to the given purpose.
     */
    public async HasConsent(request: carriers.Person_HasConsentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Check if consent has been given by a specified person, for a specific purpose. Withdraw consents return FALSE.
     * @param personId - The person id
     * @param purpose - The key of the purpose to check. (e.g. 'STORE' or 'EMARKETING')
     * @returns True if the person has consented to the given purpose.
     */
    public async HasConsent(personId: number, purpose: string, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async HasConsent(personId:number|carriers.Person_HasConsentRequest, purpose?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Person_HasConsentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.Purpose)!='undefined' ) )
        {
            _request = personId as carriers.Person_HasConsentRequest;
            _options = purpose as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       Purpose: purpose as string,
                       };   
            _options = webapi_options;
        }
        return this._HasConsent( _request, _options );
    }


    private async _GetConsentInfos(request: carriers.Person_GetConsentInfosRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ConsentInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ConsentInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConsentInfos", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ConsentInfo[] = converters.Create_ConsentInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get all consent information for a given person. May include withdrawn consents (check 
     * @param request - PersonId
     * @returns List of consents recorded on this person
     */
    public async GetConsentInfos(request: carriers.Person_GetConsentInfosRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentInfo[] >;

    /**
     * Get all consent information for a given person. May include withdrawn consents (check 
     * @param personId - The person id to get consents for
     * @returns List of consents recorded on this person
     */
    public async GetConsentInfos(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentInfo[] >;

    public async GetConsentInfos(personId:number|carriers.Person_GetConsentInfosRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ConsentInfo[] > {
        let _request : carriers.Person_GetConsentInfosRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetConsentInfosRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetConsentInfos( _request, _options );
    }


    private async _SendConsentConfirmationEmail(request: carriers.Person_SendConsentConfirmationEmailRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendConsentConfirmationEmail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Send confirmation email to the provided person, email address (id), using the document template
     * @param request - PersonId, EmailAddress, EmailTemplateId, CultureLcidId, Subject
     * @returns 
     */
    public async SendConsentConfirmationEmail(request: carriers.Person_SendConsentConfirmationEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Send confirmation email to the provided person, email address (id), using the document template
     * @param personId - The person id
     * @param emailAddress - The email address to send to.
     * @param emailTemplateId - The id of the email template (doctmpl_id)
     * @param cultureLcidId - The id of the culture (LCID)
     * @param subject - Optional email subject
     * @returns 
     */
    public async SendConsentConfirmationEmail(personId: number, emailAddress: string, emailTemplateId: number, cultureLcidId: number, subject: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SendConsentConfirmationEmail(personId:number|carriers.Person_SendConsentConfirmationEmailRequest, emailAddress?:string|base.WebApiRequestOptions, emailTemplateId?:number, cultureLcidId?:number, subject?:string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_SendConsentConfirmationEmailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.EmailAddress)!='undefined' || typeof(first.EmailTemplateId)!='undefined' || typeof(first.CultureLcidId)!='undefined' || typeof(first.Subject)!='undefined' ) )
        {
            _request = personId as carriers.Person_SendConsentConfirmationEmailRequest;
            _options = emailAddress as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       EmailAddress: emailAddress as string,
                       EmailTemplateId: emailTemplateId as number,
                       CultureLcidId: cultureLcidId as number,
                       Subject: subject as string,
                       };   
            _options = webapi_options;
        }
        return this._SendConsentConfirmationEmail( _request, _options );
    }


    private async _ResolvePersonFromInfo(request: carriers.Person_ResolvePersonFromInfoRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedPerson > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ResolvedPerson >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResolvePersonFromInfo", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ResolvedPerson = converters.Create_ResolvedPerson_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a person from the provided information. If the person does not exist, it will be created on demand.
     * @param request - ContactId, PersonName, PhoneNumbers, Emails
     * @returns The results of the resolve-operation.
     */
    public async ResolvePersonFromInfo(request: carriers.Person_ResolvePersonFromInfoRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedPerson >;

    /**
     * Get a person from the provided information. If the person does not exist, it will be created on demand.
     * @param contactId - The contact Id of the contact which the person belongs to. Cannot be 0.
     * @param personName - The full name of the person to be resolved. Optional.
     * @param phoneNumbers - Phone numbers registered on the person. Optional.
     * @param emails - Email-addresses registered on the person. Optional.
     * @returns The results of the resolve-operation.
     */
    public async ResolvePersonFromInfo(contactId: number, personName: string, phoneNumbers: string[], emails: string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedPerson >;

    public async ResolvePersonFromInfo(contactId:number|carriers.Person_ResolvePersonFromInfoRequest, personName?:string|base.WebApiRequestOptions, phoneNumbers?:string[], emails?:string[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ResolvedPerson > {
        let _request : carriers.Person_ResolvePersonFromInfoRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' || typeof(first.PersonName)!='undefined' || typeof(first.PhoneNumbers)!='undefined' || typeof(first.Emails)!='undefined' ) )
        {
            _request = contactId as carriers.Person_ResolvePersonFromInfoRequest;
            _options = personName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       PersonName: personName as string,
                       PhoneNumbers: phoneNumbers as string[],
                       Emails: emails as string[],
                       };   
            _options = webapi_options;
        }
        return this._ResolvePersonFromInfo( _request, _options );
    }


    private async _AddEmailAddressToPerson(request: carriers.Person_AddEmailAddressToPersonRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddEmailAddressToPerson", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets the primary email address on person, possibly re-ranking email addresses accordingly.
     * @param request - PersonId, EmailAddress, SetAsPrimaryEmail
     * @returns 
     */
    public async AddEmailAddressToPerson(request: carriers.Person_AddEmailAddressToPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sets the primary email address on person, possibly re-ranking email addresses accordingly.
     * @param personId - Person id of the person
     * @param emailAddress - The email address to set as primary email address
     * @param setAsPrimaryEmail - True if the address shall be primary email address (have rank == 1)
     * @returns 
     */
    public async AddEmailAddressToPerson(personId: number, emailAddress: string, setAsPrimaryEmail: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddEmailAddressToPerson(personId:number|carriers.Person_AddEmailAddressToPersonRequest, emailAddress?:string|base.WebApiRequestOptions, setAsPrimaryEmail?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_AddEmailAddressToPersonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.EmailAddress)!='undefined' || typeof(first.SetAsPrimaryEmail)!='undefined' ) )
        {
            _request = personId as carriers.Person_AddEmailAddressToPersonRequest;
            _options = emailAddress as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       EmailAddress: emailAddress as string,
                       SetAsPrimaryEmail: setAsPrimaryEmail as boolean,
                       };   
            _options = webapi_options;
        }
        return this._AddEmailAddressToPerson( _request, _options );
    }


    private async _CreateTemporaryKey(request: carriers.Person_CreateTemporaryKeyRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryKey", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create a temporary key in the database from the given parameters and return the key string. Used for temporary keys for accessing customer centric functionality, such as UpdateSubscriptions.
     * @param request - Domain, TargetId, PersonId, Expires
     * @returns The key as base64, ready to be used e.g. in a URL
     */
    public async CreateTemporaryKey(request: carriers.Person_CreateTemporaryKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Create a temporary key in the database from the given parameters and return the key string. Used for temporary keys for accessing customer centric functionality, such as UpdateSubscriptions.
     * @param domain - The domain this key is for
     * @param targetId - The primary key of the entity this is for. Depends on domain.
     * @param personId - The person this key is for. May be null.
     * @param expires - When the key will expire (servers local time)
     * @returns The key as base64, ready to be used e.g. in a URL
     */
    public async CreateTemporaryKey(domain: enums.TemporaryKeyDomain, targetId: number, personId: number, expires: Date, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async CreateTemporaryKey(domain:enums.TemporaryKeyDomain|carriers.Person_CreateTemporaryKeyRequest, targetId?:number|base.WebApiRequestOptions, personId?:number, expires?:Date, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Person_CreateTemporaryKeyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = domain;
        if( typeof( first ) === "object" && first && ( typeof(first.Domain)!='undefined' || typeof(first.TargetId)!='undefined' || typeof(first.PersonId)!='undefined' || typeof(first.Expires)!='undefined' ) )
        {
            _request = domain as carriers.Person_CreateTemporaryKeyRequest;
            _options = targetId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Domain: domain as enums.TemporaryKeyDomain,
                       TargetId: targetId as number,
                       PersonId: personId as number,
                       Expires: expires as Date,
                       };   
            _options = webapi_options;
        }
        return this._CreateTemporaryKey( _request, _options );
    }


    private async _CheckTemporaryKey(request: carriers.Person_CheckTemporaryKeyRequest, options?:base.WebApiRequestOptions) : Promise< carriers.TemporaryKeyInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.TemporaryKeyInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckTemporaryKey", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.TemporaryKeyInfo = converters.Create_TemporaryKeyInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check a temporary key for validity, and in case it is valid, return its domain, targetId and personId
     * @param request - TemporaryKey
     * @returns The info about the temporary key. Domain will be Unknown if key is not valid.
     */
    public async CheckTemporaryKey(request: carriers.Person_CheckTemporaryKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemporaryKeyInfo >;

    /**
     * Check a temporary key for validity, and in case it is valid, return its domain, targetId and personId
     * @param temporaryKey - The base64 encoded key value, as returned by CreateTemporaryKey
     * @returns The info about the temporary key. Domain will be Unknown if key is not valid.
     */
    public async CheckTemporaryKey(temporaryKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemporaryKeyInfo >;

    public async CheckTemporaryKey(temporaryKey:string|carriers.Person_CheckTemporaryKeyRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.TemporaryKeyInfo > {
        let _request : carriers.Person_CheckTemporaryKeyRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = temporaryKey;
        if( typeof( first ) === "object" && first && ( typeof(first.TemporaryKey)!='undefined' ) )
        {
            _request = temporaryKey as carriers.Person_CheckTemporaryKeyRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TemporaryKey: temporaryKey as string,
                       };   
            _options = webapi_options;
        }
        return this._CheckTemporaryKey( _request, _options );
    }


    private async _DeleteTemporaryKeysOfDomain(request: carriers.Person_DeleteTemporaryKeysOfDomainRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteTemporaryKeysOfDomain", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete all temporary keys for a given domain and person
     * @param request - Domain, PersonId
     * @returns 
     */
    public async DeleteTemporaryKeysOfDomain(request: carriers.Person_DeleteTemporaryKeysOfDomainRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete all temporary keys for a given domain and person
     * @param domain - The domain type to delete
     * @param personId - The person for which to delete the keys
     * @returns 
     */
    public async DeleteTemporaryKeysOfDomain(domain: enums.TemporaryKeyDomain, personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteTemporaryKeysOfDomain(domain:enums.TemporaryKeyDomain|carriers.Person_DeleteTemporaryKeysOfDomainRequest, personId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_DeleteTemporaryKeysOfDomainRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = domain;
        if( typeof( first ) === "object" && first && ( typeof(first.Domain)!='undefined' || typeof(first.PersonId)!='undefined' ) )
        {
            _request = domain as carriers.Person_DeleteTemporaryKeysOfDomainRequest;
            _options = personId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Domain: domain as enums.TemporaryKeyDomain,
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteTemporaryKeysOfDomain( _request, _options );
    }


    private async _DeleteExpired( options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteExpired", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Trigger deletion of persons that has been (soft) deleted and have timed out the expiry period (the SoftDeleteRetention preference).
     * @returns 
     */
    public async DeleteExpired(webapi_options?:base.WebApiRequestOptions) : Promise< void >
    {
        return this._DeleteExpired(webapi_options);
    }


    private async _GetPersonSummary(request: carriers.Person_GetPersonSummaryRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PersonSummary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonSummary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonSummary", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonSummary = converters.Create_PersonSummary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get summary of person and recent activity.
     * @param request - PersonId, Limit
     * @returns Summary of person, with recent requests, sales, follow-ups, chats.
     */
    public async GetPersonSummary(request: carriers.Person_GetPersonSummaryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonSummary >;

    /**
     * Get summary of person and recent activity.
     * @param personId - The person id to summarize.
     * @param limit - Max number of items to include in summary lists.
     * @returns Summary of person, with recent requests, sales, follow-ups, chats.
     */
    public async GetPersonSummary(personId: number, limit: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonSummary >;

    public async GetPersonSummary(personId:number|carriers.Person_GetPersonSummaryRequest, limit?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonSummary > {
        let _request : carriers.Person_GetPersonSummaryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.Limit)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetPersonSummaryRequest;
            _options = limit as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       Limit: limit as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonSummary( _request, _options );
    }


    private async _AddBounce(request: carriers.Person_AddBounceRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddBounce", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add a bounce count on the email address if it exists
     * @param request - EmailAddress
     * @returns 
     */
    public async AddBounce(request: carriers.Person_AddBounceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Add a bounce count on the email address if it exists
     * @param emailAddress - The email address which we want to add a bounce count to
     * @returns 
     */
    public async AddBounce(emailAddress: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddBounce(emailAddress:string|carriers.Person_AddBounceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_AddBounceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailAddress;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailAddress)!='undefined' ) )
        {
            _request = emailAddress as carriers.Person_AddBounceRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailAddress: emailAddress as string,
                       };   
            _options = webapi_options;
        }
        return this._AddBounce( _request, _options );
    }


    private async _ValidatePersonEntity(request: carriers.Person_ValidatePersonEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.StringDictionary >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidatePersonEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.StringDictionary = converters.Create_StringDictionary_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param request - PersonEntity
     * @returns Error messages tagged by field.
     */
    public async ValidatePersonEntity(request: carriers.Person_ValidatePersonEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param personEntity - Entity to be checked for errors.
     * @returns Error messages tagged by field.
     */
    public async ValidatePersonEntity(personEntity: carriers.PersonEntity, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary >;

    public async ValidatePersonEntity(personEntity:carriers.PersonEntity|carriers.Person_ValidatePersonEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.StringDictionary > {
        let _request : carriers.Person_ValidatePersonEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personEntity;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonEntity)!='undefined' ) )
        {
            _request = personEntity as carriers.Person_ValidatePersonEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonEntity: personEntity as carriers.PersonEntity,
                       };   
            _options = webapi_options;
        }
        return this._ValidatePersonEntity( _request, _options );
    }


    private async _AddBounceWithCount(request: carriers.Person_AddBounceWithCountRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddBounceWithCount", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add a number of bounce counts on the email address if it exists
     * @param request - EmailAddress, Counts
     * @returns 
     */
    public async AddBounceWithCount(request: carriers.Person_AddBounceWithCountRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Add a number of bounce counts on the email address if it exists
     * @param emailAddress - The email address which we want to add bounce counts to
     * @param counts - The number of bounce counts to add
     * @returns 
     */
    public async AddBounceWithCount(emailAddress: string, counts: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddBounceWithCount(emailAddress:string|carriers.Person_AddBounceWithCountRequest, counts?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_AddBounceWithCountRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailAddress;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailAddress)!='undefined' || typeof(first.Counts)!='undefined' ) )
        {
            _request = emailAddress as carriers.Person_AddBounceWithCountRequest;
            _options = counts as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailAddress: emailAddress as string,
                       Counts: counts as number,
                       };   
            _options = webapi_options;
        }
        return this._AddBounceWithCount( _request, _options );
    }


    private async _GetBestSoLanguageForTemplate(request: carriers.Person_GetBestSoLanguageForTemplateRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBestSoLanguageForTemplate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the best language for this person on this template
     * @param request - PersonId, TemplateId
     * @returns The solang code for best language, empty string if no best language found
     */
    public async GetBestSoLanguageForTemplate(request: carriers.Person_GetBestSoLanguageForTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Get the best language for this person on this template
     * @param personId - The id of the person
     * @param templateId - The id of the template to find languages on
     * @returns The solang code for best language, empty string if no best language found
     */
    public async GetBestSoLanguageForTemplate(personId: number, templateId: number, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async GetBestSoLanguageForTemplate(personId:number|carriers.Person_GetBestSoLanguageForTemplateRequest, templateId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Person_GetBestSoLanguageForTemplateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.TemplateId)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetBestSoLanguageForTemplateRequest;
            _options = templateId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       TemplateId: templateId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetBestSoLanguageForTemplate( _request, _options );
    }


    private async _AddBounceWithDetails(request: carriers.Person_AddBounceWithDetailsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddBounceWithDetails", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add a number of bounce counts on the email address if it exists, and with possible bounce code and reason
     * @param request - EmailAddress, Counts, Code, Reason
     * @returns 
     */
    public async AddBounceWithDetails(request: carriers.Person_AddBounceWithDetailsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Add a number of bounce counts on the email address if it exists, and with possible bounce code and reason
     * @param emailAddress - The email address which we want to add bounce counts to
     * @param counts - The number of bounce counts to add
     * @param code - A numeric code representing the bounce reason
     * @param reason - A textual tag representing the bounce reason
     * @returns 
     */
    public async AddBounceWithDetails(emailAddress: string, counts: number, code: number, reason: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddBounceWithDetails(emailAddress:string|carriers.Person_AddBounceWithDetailsRequest, counts?:number|base.WebApiRequestOptions, code?:number, reason?:string, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_AddBounceWithDetailsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = emailAddress;
        if( typeof( first ) === "object" && first && ( typeof(first.EmailAddress)!='undefined' || typeof(first.Counts)!='undefined' || typeof(first.Code)!='undefined' || typeof(first.Reason)!='undefined' ) )
        {
            _request = emailAddress as carriers.Person_AddBounceWithDetailsRequest;
            _options = counts as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EmailAddress: emailAddress as string,
                       Counts: counts as number,
                       Code: code as number,
                       Reason: reason as string,
                       };   
            _options = webapi_options;
        }
        return this._AddBounceWithDetails( _request, _options );
    }


    private async _GetPersonImages(request: carriers.Person_GetPersonImagesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.PersonImage[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.PersonImage[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonImages", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.PersonImage[] = converters.Create_PersonImageArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the image for a set of persons scaled to a specific size. Returned images are in PNG format.
     * @param request - PersonIds, ScaledWidth, ScaledHeight
     * @returns List of person images. Persons without an image are not present in this list.
     */
    public async GetPersonImages(request: carriers.Person_GetPersonImagesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonImage[] >;

    /**
     * Get the image for a set of persons scaled to a specific size. Returned images are in PNG format.
     * @param personIds - List of persons to get images for.
     * @param scaledWidth - Returned images are scaled to this width
     * @param scaledHeight - Returned images are scaled to this height
     * @returns List of person images. Persons without an image are not present in this list.
     */
    public async GetPersonImages(personIds: number[], scaledWidth: number, scaledHeight: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonImage[] >;

    public async GetPersonImages(personIds:number[]|carriers.Person_GetPersonImagesRequest, scaledWidth?:number|base.WebApiRequestOptions, scaledHeight?:number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.PersonImage[] > {
        let _request : carriers.Person_GetPersonImagesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personIds;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonIds)!='undefined' || typeof(first.ScaledWidth)!='undefined' || typeof(first.ScaledHeight)!='undefined' ) )
        {
            _request = personIds as carriers.Person_GetPersonImagesRequest;
            _options = scaledWidth as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonIds: personIds as number[],
                       ScaledWidth: scaledWidth as number,
                       ScaledHeight: scaledHeight as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonImages( _request, _options );
    }


    private async _CreateOrUpdateUserCandidate(request: carriers.Person_CreateOrUpdateUserCandidateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserCandidate >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateOrUpdateUserCandidate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UserCandidate = converters.Create_UserCandidate_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a Customer Centre User (UserCandidate) for a given Contact (personId) with the supplied parameters. If the Customer Centre User already exists for a given Contact, the user is updated with the supplied parameters.
     * @param request - PersonId, Username, AccessAllRequests
     * @returns UserCandidate created or updated.
     */
    public async CreateOrUpdateUserCandidate(request: carriers.Person_CreateOrUpdateUserCandidateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate >;

    /**
     * Creates a Customer Centre User (UserCandidate) for a given Contact (personId) with the supplied parameters. If the Customer Centre User already exists for a given Contact, the user is updated with the supplied parameters.
     * @param personId - Person to create UserCandidate for.
     * @param username - Desired username. Username must be unique. If the username is not unique, method will throw an error.
     * @param accessAllRequests - Determines if Custom Center User has access to all requests created for all Contacts in the company.
     * @returns UserCandidate created or updated.
     */
    public async CreateOrUpdateUserCandidate(personId: number, username: string, accessAllRequests: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate >;

    public async CreateOrUpdateUserCandidate(personId:number|carriers.Person_CreateOrUpdateUserCandidateRequest, username?:string|base.WebApiRequestOptions, accessAllRequests?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate > {
        let _request : carriers.Person_CreateOrUpdateUserCandidateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.Username)!='undefined' || typeof(first.AccessAllRequests)!='undefined' ) )
        {
            _request = personId as carriers.Person_CreateOrUpdateUserCandidateRequest;
            _options = username as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       Username: username as string,
                       AccessAllRequests: accessAllRequests as boolean,
                       };   
            _options = webapi_options;
        }
        return this._CreateOrUpdateUserCandidate( _request, _options );
    }


    private async _GetUserCandidateByPerson(request: carriers.Person_GetUserCandidateByPersonRequest, options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.UserCandidate >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserCandidateByPerson", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.UserCandidate = converters.Create_UserCandidate_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets user candidate linked to a person.
     * @param request - PersonId
     * @returns UserCandidate linked to a person.
     */
    public async GetUserCandidateByPerson(request: carriers.Person_GetUserCandidateByPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate >;

    /**
     * Gets user candidate linked to a person.
     * @param personId - Person related to requested UserCandidate.
     * @returns UserCandidate linked to a person.
     */
    public async GetUserCandidateByPerson(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate >;

    public async GetUserCandidateByPerson(personId:number|carriers.Person_GetUserCandidateByPersonRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.UserCandidate > {
        let _request : carriers.Person_GetUserCandidateByPersonRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetUserCandidateByPersonRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetUserCandidateByPerson( _request, _options );
    }


    private async _GetCustomerCentrePasswordReplyTemplate(request: carriers.Person_GetCustomerCentrePasswordReplyTemplateRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ReplyTemplateParsed >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCustomerCentrePasswordReplyTemplate", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ReplyTemplateParsed = converters.Create_ReplyTemplateParsed_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets a parsed Customer Centre password reply template for a particular customer
     * @param request - PersonId
     * @returns A parsed Customer Centre password reply template.
     */
    public async GetCustomerCentrePasswordReplyTemplate(request: carriers.Person_GetCustomerCentrePasswordReplyTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;

    /**
     * Gets a parsed Customer Centre password reply template for a particular customer
     * @param personId - Person/customer id to get the template for.
     * @returns A parsed Customer Centre password reply template.
     */
    public async GetCustomerCentrePasswordReplyTemplate(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed >;

    public async GetCustomerCentrePasswordReplyTemplate(personId:number|carriers.Person_GetCustomerCentrePasswordReplyTemplateRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ReplyTemplateParsed > {
        let _request : carriers.Person_GetCustomerCentrePasswordReplyTemplateRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetCustomerCentrePasswordReplyTemplateRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetCustomerCentrePasswordReplyTemplate( _request, _options );
    }


    private async _SendEmail(request: carriers.Person_SendEmailRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendEmail", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Inserts into outbox an email with specified details.
     * @param request - From, To, Subject, PlainBody, HtmlBody, AttachmentIds
     * @returns This method has no return value
     */
    public async SendEmail(request: carriers.Person_SendEmailRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Inserts into outbox an email with specified details.
     * @param from - Sender's email address.
     * @param to - Recipient's email address.
     * @param subject - Email's subject.
     * @param plainBody - Email's plain body.
     * @param htmlBody - Email's html body.
     * @param attachmentIds - Ids of email's attachments.
     * @returns This method has no return value
     */
    public async SendEmail(from: string, to: string, subject: string, plainBody: string, htmlBody: string, attachmentIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SendEmail(from:string|carriers.Person_SendEmailRequest, to?:string|base.WebApiRequestOptions, subject?:string, plainBody?:string, htmlBody?:string, attachmentIds?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Person_SendEmailRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = from;
        if( typeof( first ) === "object" && first && ( typeof(first.From)!='undefined' || typeof(first.To)!='undefined' || typeof(first.Subject)!='undefined' || typeof(first.PlainBody)!='undefined' || typeof(first.HtmlBody)!='undefined' || typeof(first.AttachmentIds)!='undefined' ) )
        {
            _request = from as carriers.Person_SendEmailRequest;
            _options = to as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       From: from as string,
                       To: to as string,
                       Subject: subject as string,
                       PlainBody: plainBody as string,
                       HtmlBody: htmlBody as string,
                       AttachmentIds: attachmentIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._SendEmail( _request, _options );
    }

    /*
     * Gets an array of Person objects.
     * @param personIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Person
     */
    public async GetPersonList(personIds: number[], options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person[] >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPersonList", personIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonArray_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _GetPersonsFromContact(request: carriers.Person_GetPersonsFromContactRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonsFromContact", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person[] = converters.Create_PersonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all the persons belonging to a contact.
     * @param request - ContactId
     * @returns The persons belonging to a contact.
     */
    public async GetPersonsFromContact(request: carriers.Person_GetPersonsFromContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    /**
     * Returns all the persons belonging to a contact.
     * @param contactId - The project id
     * @returns The persons belonging to a contact.
     */
    public async GetPersonsFromContact(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    public async GetPersonsFromContact(contactId:number|carriers.Person_GetPersonsFromContactRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        let _request : carriers.Person_GetPersonsFromContactRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.Person_GetPersonsFromContactRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonsFromContact( _request, _options );
    }


    private async _GetPersonsFromProject(request: carriers.Person_GetPersonsFromProjectRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonsFromProject", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person[] = converters.Create_PersonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns all the persons belonging to a project.
     * @param request - ProjectId
     * @returns The persons belonging to a project.
     */
    public async GetPersonsFromProject(request: carriers.Person_GetPersonsFromProjectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    /**
     * Returns all the persons belonging to a project.
     * @param projectId - The project id
     * @returns The persons belonging to a project.
     */
    public async GetPersonsFromProject(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    public async GetPersonsFromProject(projectId:number|carriers.Person_GetPersonsFromProjectRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        let _request : carriers.Person_GetPersonsFromProjectRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Person_GetPersonsFromProjectRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetPersonsFromProject( _request, _options );
    }


    private async _GetColleagues( options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetColleagues", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person[] = converters.Create_PersonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Gets the persons working in the same company as the logged on user.
     * @returns Colleagues.
     */
    public async GetColleagues(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >
    {
        return this._GetColleagues(webapi_options);
    }


    private async _GetColleaguesByDepartment(request: carriers.Person_GetColleaguesByDepartmentRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetColleaguesByDepartment", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person[] = converters.Create_PersonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the persons working in a specific department in the same company as the logged on user. Departments can be retrieved with the PhoneList.DepartmentList service.
     * @param request - DepartmentId
     * @returns PersonList with colleagues.
     */
    public async GetColleaguesByDepartment(request: carriers.Person_GetColleaguesByDepartmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    /**
     * Gets the persons working in a specific department in the same company as the logged on user. Departments can be retrieved with the PhoneList.DepartmentList service.
     * @param departmentId - The department id.
     * @returns PersonList with colleagues.
     */
    public async GetColleaguesByDepartment(departmentId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    public async GetColleaguesByDepartment(departmentId:number|carriers.Person_GetColleaguesByDepartmentRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        let _request : carriers.Person_GetColleaguesByDepartmentRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = departmentId;
        if( typeof( first ) === "object" && first && ( typeof(first.DepartmentId)!='undefined' ) )
        {
            _request = departmentId as carriers.Person_GetColleaguesByDepartmentRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       DepartmentId: departmentId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetColleaguesByDepartment( _request, _options );
    }


    private async _GetColleaguesBySource(request: carriers.Person_GetColleaguesBySourceRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetColleaguesBySource", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person[] = converters.Create_PersonArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Gets the persons working in the same company as the logged on user. The list of person could be retrieved from the history list, the diary view list, or from all sources.
     * @param request - SourceType, Count
     * @returns Colleagues.
     */
    public async GetColleaguesBySource(request: carriers.Person_GetColleaguesBySourceRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    /**
     * Gets the persons working in the same company as the logged on user. The list of person could be retrieved from the history list, the diary view list, or from all sources.
     * @param sourceType - The “source” the colleagues should be retrieved from. <see cref="AssociateSourceType"/> for more information.
     * @param count - 
     * @returns Colleagues.
     */
    public async GetColleaguesBySource(sourceType: enums.AssociateSourceType, count: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] >;

    public async GetColleaguesBySource(sourceType:enums.AssociateSourceType|carriers.Person_GetColleaguesBySourceRequest, count?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person[] > {
        let _request : carriers.Person_GetColleaguesBySourceRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = sourceType;
        if( typeof( first ) === "object" && first && ( typeof(first.SourceType)!='undefined' || typeof(first.Count)!='undefined' ) )
        {
            _request = sourceType as carriers.Person_GetColleaguesBySourceRequest;
            _options = count as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SourceType: sourceType as enums.AssociateSourceType,
                       Count: count as number,
                       };   
            _options = webapi_options;
        }
        return this._GetColleaguesBySource( _request, _options );
    }


    private async _GetMyOwner( options?:base.WebApiRequestOptions) : Promise< carriers.Person > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyOwner", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person = converters.Create_Person_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Get the owner of the logged in person.
     * @returns Person
     */
    public async GetMyOwner(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >
    {
        return this._GetMyOwner(webapi_options);
    }


    private async _GetOwnerOnPersonId(request: carriers.Person_GetOwnerOnPersonIdRequest, options?:base.WebApiRequestOptions) : Promise< carriers.Person > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.Person >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOwnerOnPersonId", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.Person = converters.Create_Person_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the owner of the person by id.
     * @param request - PersonId
     * @returns Person
     */
    public async GetOwnerOnPersonId(request: carriers.Person_GetOwnerOnPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >;

    /**
     * Get the owner of the person by id.
     * @param personId - 
     * @returns Person
     */
    public async GetOwnerOnPersonId(personId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person >;

    public async GetOwnerOnPersonId(personId:number|carriers.Person_GetOwnerOnPersonIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.Person > {
        let _request : carriers.Person_GetOwnerOnPersonIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' ) )
        {
            _request = personId as carriers.Person_GetOwnerOnPersonIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetOwnerOnPersonId( _request, _options );
    }


    private async _ChangePersonRank(request: carriers.Person_ChangePersonRankRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangePersonRank", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Move one person up or down in the ranking in the Person Archive, if possible.&lt;para/&gt;The person record that has rank = 1 is the primary contact for a company, and is the one used in situations where no person has been explicitly chosen (such as in selections).&lt;para/&gt;This method corresponds to the move up/move down functions in the person archive in the contact panel.&lt;para/&gt;This method always affects two records.
     * @param request - PersonId, MoveUp
     * @returns If movement occurred, the return value will be the ID of the OTHER person that got moved. A GUI should switch the positions of the original person ID and this return value.<para/>If no movement occurred, for any reason,  0 is returned.
     */
    public async ChangePersonRank(request: carriers.Person_ChangePersonRankRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Move one person up or down in the ranking in the Person Archive, if possible.&lt;para/&gt;The person record that has rank = 1 is the primary contact for a company, and is the one used in situations where no person has been explicitly chosen (such as in selections).&lt;para/&gt;This method corresponds to the move up/move down functions in the person archive in the contact panel.&lt;para/&gt;This method always affects two records.
     * @param personId - Primary key of person record to move up or down. You must have write access both to this record AND to whatever record is adjacent in the direction you want to move.
     * @param moveUp - If true, the given person is moved to an earlier rank (lower numeric rank value, down to a limit of 1; up in the GUI if sorted by ascending rank). If false, movement is to later priority (higher numeric rank value).
     * @returns If movement occurred, the return value will be the ID of the OTHER person that got moved. A GUI should switch the positions of the original person ID and this return value.<para/>If no movement occurred, for any reason,  0 is returned.
     */
    public async ChangePersonRank(personId: number, moveUp: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async ChangePersonRank(personId:number|carriers.Person_ChangePersonRankRequest, moveUp?:boolean|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Person_ChangePersonRankRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.MoveUp)!='undefined' ) )
        {
            _request = personId as carriers.Person_ChangePersonRankRequest;
            _options = moveUp as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       MoveUp: moveUp as boolean,
                       };   
            _options = webapi_options;
        }
        return this._ChangePersonRank( _request, _options );
    }


    private async _SetPersonRank(request: carriers.Person_SetPersonRankRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPersonRank", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Directly set the rank field of a person record, adjusting all other person records under the same contact as needed.&lt;para/&gt;This call may affect multiple records, potentially all person records belonging to one contact.&lt;para/&gt;You must have write access for to affected records for this method to succeed.
     * @param request - PersonId, DesiredRank
     * @returns If movement occurred, or the person already had exactly the desired rank value, then the return value will be true. If movement did not occur, for any other reason, the return value is false. 
     */
    public async SetPersonRank(request: carriers.Person_SetPersonRankRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Directly set the rank field of a person record, adjusting all other person records under the same contact as needed.&lt;para/&gt;This call may affect multiple records, potentially all person records belonging to one contact.&lt;para/&gt;You must have write access for to affected records for this method to succeed.
     * @param personId - Id of person to change
     * @param desiredRank - Desired rank to set, legal values are from 1 to the number of person records on this contact. Out of range values will be moved to the closest valid value and processed.
     * @returns If movement occurred, or the person already had exactly the desired rank value, then the return value will be true. If movement did not occur, for any other reason, the return value is false. 
     */
    public async SetPersonRank(personId: number, desiredRank: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async SetPersonRank(personId:number|carriers.Person_SetPersonRankRequest, desiredRank?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Person_SetPersonRankRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = personId;
        if( typeof( first ) === "object" && first && ( typeof(first.PersonId)!='undefined' || typeof(first.DesiredRank)!='undefined' ) )
        {
            _request = personId as carriers.Person_SetPersonRankRequest;
            _options = desiredRank as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       PersonId: personId as number,
                       DesiredRank: desiredRank as number,
                       };   
            _options = webapi_options;
        }
        return this._SetPersonRank( _request, _options );
    }


    private async _NormalizeRanks(request: carriers.Person_NormalizeRanksRequest, options?:base.WebApiRequestOptions) : Promise< boolean > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< boolean >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NormalizeRanks", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : boolean = response.data as boolean;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Nomralize the ranks for all persons that belong to a contact. This means that the persons will be sorted according to their current rank values, and the ranks will be made monotonically increasing from 1.
     * @param request - ContactId
     * @returns The reutrn value is true if the operation suceeded, either because all persons were already normalized, or because normalization was done. It is false if Sentry blocks any required changes.
     */
    public async NormalizeRanks(request: carriers.Person_NormalizeRanksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    /**
     * Nomralize the ranks for all persons that belong to a contact. This means that the persons will be sorted according to their current rank values, and the ranks will be made monotonically increasing from 1.
     * @param contactId - Id of contact whose persons are to be rank normalized
     * @returns The reutrn value is true if the operation suceeded, either because all persons were already normalized, or because normalization was done. It is false if Sentry blocks any required changes.
     */
    public async NormalizeRanks(contactId: number, webapi_options?:base.WebApiRequestOptions) : Promise< boolean >;

    public async NormalizeRanks(contactId:number|carriers.Person_NormalizeRanksRequest, webapi_options?:base.WebApiRequestOptions) : Promise< boolean > {
        let _request : carriers.Person_NormalizeRanksRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactId;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactId)!='undefined' ) )
        {
            _request = contactId as carriers.Person_NormalizeRanksRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactId: contactId as number,
                       };   
            _options = webapi_options;
        }
        return this._NormalizeRanks( _request, _options );
    }

    } // class v1PersonAgentController 



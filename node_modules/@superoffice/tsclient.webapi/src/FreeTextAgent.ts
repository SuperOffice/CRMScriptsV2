// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/FreeTextAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * This agent can be used to manage the free text system
 */
export interface IFreeTextAgent {
    GetStatus(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FreeText >;
    SetEnabled(request: carriers.FreeText_SetEnabledRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetEnabled(enabled: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetAutoEnableTravelAreas(request: carriers.FreeText_SetAutoEnableTravelAreasRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetAutoEnableTravelAreas(autoEnable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetSingleWordOperator(request: carriers.FreeText_SetSingleWordOperatorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetSingleWordOperator(freeTextOperator: enums.FreeTextOperator, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetMultiWordOperator(request: carriers.FreeText_SetMultiWordOperatorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetMultiWordOperator(freeTextOperator: enums.FreeTextOperator, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetStopWordList(webapi_options?:base.WebApiRequestOptions) : Promise< string[] >;
    AddWords(request: carriers.FreeText_AddWordsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddWords(stopWords: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteStopWordsById(request: carriers.FreeText_DeleteStopWordsByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteStopWordsById(stopWordIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetSuggestedStopWords(request: carriers.FreeText_GetSuggestedStopWordsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    GetSuggestedStopWords(countWords: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;
    RegenerateIndex(request: carriers.FreeText_RegenerateIndexRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    RegenerateIndex(runAsBatch: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;
    FreetextIndexRows(request: carriers.FreeText_FreetextIndexRowsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    FreetextIndexRows(tableName: string, iDs: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
} // interface IFreeTextAgent




/**
 * This agent can be used to manage the free text system
 */
export class FreeTextAgent extends base.WebApiBase implements IFreeTextAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/FreeText/";
        super(options);
    }



    private async _GetStatus( options?:base.WebApiRequestOptions) : Promise< carriers.FreeText > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.FreeText >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetStatus", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.FreeText = converters.Create_FreeText_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns status for the freetext search words
     * @returns The freetext status
     */
    public async GetStatus(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.FreeText >
    {
        return this._GetStatus(webapi_options);
    }


    private async _SetEnabled(request: carriers.FreeText_SetEnabledRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetEnabled", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets freetext search to enabled (true) or disabled (false)
     * @param request - Enabled
     * @returns This method has no return value
     */
    public async SetEnabled(request: carriers.FreeText_SetEnabledRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sets freetext search to enabled (true) or disabled (false)
     * @param enabled - If enabled true, else false
     * @returns This method has no return value
     */
    public async SetEnabled(enabled: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetEnabled(enabled:boolean|carriers.FreeText_SetEnabledRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.FreeText_SetEnabledRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = enabled;
        if( typeof( first ) === "object" && first && ( typeof(first.Enabled)!='undefined' ) )
        {
            _request = enabled as carriers.FreeText_SetEnabledRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Enabled: enabled as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetEnabled( _request, _options );
    }


    private async _SetAutoEnableTravelAreas(request: carriers.FreeText_SetAutoEnableTravelAreasRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetAutoEnableTravelAreas", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Automatically enable freetext search for new travel areas? true or false
     * @param request - AutoEnable
     * @returns This method has no return value
     */
    public async SetAutoEnableTravelAreas(request: carriers.FreeText_SetAutoEnableTravelAreasRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Automatically enable freetext search for new travel areas? true or false
     * @param autoEnable - If true, auto enable
     * @returns This method has no return value
     */
    public async SetAutoEnableTravelAreas(autoEnable: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetAutoEnableTravelAreas(autoEnable:boolean|carriers.FreeText_SetAutoEnableTravelAreasRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.FreeText_SetAutoEnableTravelAreasRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = autoEnable;
        if( typeof( first ) === "object" && first && ( typeof(first.AutoEnable)!='undefined' ) )
        {
            _request = autoEnable as carriers.FreeText_SetAutoEnableTravelAreasRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       AutoEnable: autoEnable as boolean,
                       };   
            _options = webapi_options;
        }
        return this._SetAutoEnableTravelAreas( _request, _options );
    }


    private async _SetSingleWordOperator(request: carriers.FreeText_SetSingleWordOperatorRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetSingleWordOperator", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets the operator used when matching single words
     * @param request - FreeTextOperator
     * @returns This method has no return value
     */
    public async SetSingleWordOperator(request: carriers.FreeText_SetSingleWordOperatorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sets the operator used when matching single words
     * @param freeTextOperator - The operator
     * @returns This method has no return value
     */
    public async SetSingleWordOperator(freeTextOperator: enums.FreeTextOperator, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetSingleWordOperator(freeTextOperator:enums.FreeTextOperator|carriers.FreeText_SetSingleWordOperatorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.FreeText_SetSingleWordOperatorRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = freeTextOperator;
        if( typeof( first ) === "object" && first && ( typeof(first.FreeTextOperator)!='undefined' ) )
        {
            _request = freeTextOperator as carriers.FreeText_SetSingleWordOperatorRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FreeTextOperator: freeTextOperator as enums.FreeTextOperator,
                       };   
            _options = webapi_options;
        }
        return this._SetSingleWordOperator( _request, _options );
    }


    private async _SetMultiWordOperator(request: carriers.FreeText_SetMultiWordOperatorRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetMultiWordOperator", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Sets the operator used when matching multiple words
     * @param request - FreeTextOperator
     * @returns No return value
     */
    public async SetMultiWordOperator(request: carriers.FreeText_SetMultiWordOperatorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Sets the operator used when matching multiple words
     * @param freeTextOperator - The operator
     * @returns No return value
     */
    public async SetMultiWordOperator(freeTextOperator: enums.FreeTextOperator, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetMultiWordOperator(freeTextOperator:enums.FreeTextOperator|carriers.FreeText_SetMultiWordOperatorRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.FreeText_SetMultiWordOperatorRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = freeTextOperator;
        if( typeof( first ) === "object" && first && ( typeof(first.FreeTextOperator)!='undefined' ) )
        {
            _request = freeTextOperator as carriers.FreeText_SetMultiWordOperatorRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FreeTextOperator: freeTextOperator as enums.FreeTextOperator,
                       };   
            _options = webapi_options;
        }
        return this._SetMultiWordOperator( _request, _options );
    }


    private async _GetStopWordList( options?:base.WebApiRequestOptions) : Promise< string[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetStopWordList", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : string[] = response.data as string[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Returns the list of stop words
     * @returns The list of stop words
     */
    public async GetStopWordList(webapi_options?:base.WebApiRequestOptions) : Promise< string[] >
    {
        return this._GetStopWordList(webapi_options);
    }


    private async _AddWords(request: carriers.FreeText_AddWordsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddWords", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Adds the words in the string to the stop word list
     * @param request - StopWords
     * @returns This method has no return value
     */
    public async AddWords(request: carriers.FreeText_AddWordsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Adds the words in the string to the stop word list
     * @param stopWords - The stop words to add
     * @returns This method has no return value
     */
    public async AddWords(stopWords: string, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddWords(stopWords:string|carriers.FreeText_AddWordsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.FreeText_AddWordsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = stopWords;
        if( typeof( first ) === "object" && first && ( typeof(first.StopWords)!='undefined' ) )
        {
            _request = stopWords as carriers.FreeText_AddWordsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StopWords: stopWords as string,
                       };   
            _options = webapi_options;
        }
        return this._AddWords( _request, _options );
    }


    private async _DeleteStopWordsById(request: carriers.FreeText_DeleteStopWordsByIdRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteStopWordsById", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Delete the stop words with these ids
     * @param request - StopWordIds
     * @returns This method has no return value
     */
    public async DeleteStopWordsById(request: carriers.FreeText_DeleteStopWordsByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Delete the stop words with these ids
     * @param stopWordIds - The ids of the stopwords to delete
     * @returns This method has no return value
     */
    public async DeleteStopWordsById(stopWordIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteStopWordsById(stopWordIds:number[]|carriers.FreeText_DeleteStopWordsByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.FreeText_DeleteStopWordsByIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = stopWordIds;
        if( typeof( first ) === "object" && first && ( typeof(first.StopWordIds)!='undefined' ) )
        {
            _request = stopWordIds as carriers.FreeText_DeleteStopWordsByIdRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       StopWordIds: stopWordIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._DeleteStopWordsById( _request, _options );
    }


    private async _GetSuggestedStopWords(request: carriers.FreeText_GetSuggestedStopWordsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MDOListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSuggestedStopWords", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MDOListItem[] = converters.Create_MDOListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns the top used words in the freetext index table, sorted as most used first
     * @param request - CountWords
     * @returns The most used words
     */
    public async GetSuggestedStopWords(request: carriers.FreeText_GetSuggestedStopWordsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    /**
     * Returns the top used words in the freetext index table, sorted as most used first
     * @param countWords - The count of words that will be returned
     * @returns The most used words
     */
    public async GetSuggestedStopWords(countWords: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] >;

    public async GetSuggestedStopWords(countWords:number|carriers.FreeText_GetSuggestedStopWordsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.MDOListItem[] > {
        let _request : carriers.FreeText_GetSuggestedStopWordsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = countWords;
        if( typeof( first ) === "object" && first && ( typeof(first.CountWords)!='undefined' ) )
        {
            _request = countWords as carriers.FreeText_GetSuggestedStopWordsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       CountWords: countWords as number,
                       };   
            _options = webapi_options;
        }
        return this._GetSuggestedStopWords( _request, _options );
    }


    private async _RegenerateIndex(request: carriers.FreeText_RegenerateIndexRequest, options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.BatchTaskInfo >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RegenerateIndex", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.BatchTaskInfo = converters.Create_BatchTaskInfo_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Wipe and regenerate the freetext index by scanning the database (freetext search will be unavailable while this operation runs
     * @param request - RunAsBatch
     * @returns Information about the batch task, if batch execution was requested. Otherwise null
     */
    public async RegenerateIndex(request: carriers.FreeText_RegenerateIndexRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    /**
     * Wipe and regenerate the freetext index by scanning the database (freetext search will be unavailable while this operation runs
     * @param runAsBatch - If true, then execute the regeneration as a Batch Task; the service call will return immediately. Otherwise wait until the task completes, may cause a timeout if called as a Web Service
     * @returns Information about the batch task, if batch execution was requested. Otherwise null
     */
    public async RegenerateIndex(runAsBatch: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo >;

    public async RegenerateIndex(runAsBatch:boolean|carriers.FreeText_RegenerateIndexRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.BatchTaskInfo > {
        let _request : carriers.FreeText_RegenerateIndexRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = runAsBatch;
        if( typeof( first ) === "object" && first && ( typeof(first.RunAsBatch)!='undefined' ) )
        {
            _request = runAsBatch as carriers.FreeText_RegenerateIndexRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       RunAsBatch: runAsBatch as boolean,
                       };   
            _options = webapi_options;
        }
        return this._RegenerateIndex( _request, _options );
    }


    private async _FreetextIndexRows(request: carriers.FreeText_FreetextIndexRowsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FreetextIndexRows", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update the freetext index for one or more rows from the same table
     * @param request - TableName, IDs
     * @returns This method has no return value
     */
    public async FreetextIndexRows(request: carriers.FreeText_FreetextIndexRowsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Update the freetext index for one or more rows from the same table
     * @param tableName - The name of the table the rows come from; this table should have at least one freetext-indexable field
     * @param iDs - One or more primary keys, identifying records to be (re)indexed. It doesn't matter if they have been indexed before or not
     * @returns This method has no return value
     */
    public async FreetextIndexRows(tableName: string, iDs: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async FreetextIndexRows(tableName:string|carriers.FreeText_FreetextIndexRowsRequest, iDs?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.FreeText_FreetextIndexRowsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = tableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TableName)!='undefined' || typeof(first.IDs)!='undefined' ) )
        {
            _request = tableName as carriers.FreeText_FreetextIndexRowsRequest;
            _options = iDs as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TableName: tableName as string,
                       IDs: iDs as number[],
                       };   
            _options = webapi_options;
        }
        return this._FreetextIndexRows( _request, _options );
    }

    } // class v1FreeTextAgentController 



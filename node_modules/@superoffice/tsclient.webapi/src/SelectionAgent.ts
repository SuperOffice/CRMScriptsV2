// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>


/* tslint:disable */
//----------------------------------------------------------------------------
// G E N E R A T E D   F I L E !                       D O   N O T   E D I T !
//----------------------------------------------------------------------------
//
// File:          WebApi/SelectionAgent.ts
//
//----------------------------------------------------------------------------
//                                                Copyright (C) SuperOffice AS
//----------------------------------------------------------------------------

import { AxiosRequestConfig } from 'axios';
import * as moment from 'moment';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
import * as converters from './Converters';
import { FromBase64ToString, ToBase64 } from './Base64';

/**
 * Selections, entities, members and tasks
 */
export interface ISelectionAgent {
    CreateDefaultMailMergeSettings(): Promise< carriers.MailMergeSettings >;
    CreateDefaultMailMergeTask(): Promise< carriers.MailMergeTask >;
    CreateDefaultSelectionEntity(): Promise< carriers.SelectionEntity >;
    SaveSelectionEntity(entity: carriers.SelectionEntity) : Promise< carriers.SelectionEntity >;
    DeleteSelectionEntity(SelectionEntityId: number) : Promise<void>;
    GetSelectionEntity(selectionEntityId: number) :  Promise< carriers.SelectionEntity >;
    CreateSelectionEntity(request: carriers.Selection_CreateSelectionEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateSelectionEntity(targetTableName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateContactSelectionFromSelection(request: carriers.Selection_CreateContactSelectionFromSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateContactSelectionFromSelection(selectionId: number, name: string, targetSelectionType: enums.SelectionType, copyMembers: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateTemporaryContactSelectionFromContactPersonIds(request: carriers.Selection_CreateTemporaryContactSelectionFromContactPersonIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateTemporaryContactSelectionFromContactPersonIds(contactPersonIds: carriers.ContactPersonId[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateTemporaryContactSelectionFromProjectMembers(request: carriers.Selection_CreateTemporaryContactSelectionFromProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateTemporaryContactSelectionFromProjectMembers(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CopyContactSelectionMembers(request: carriers.Selection_CopyContactSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CopyContactSelectionMembers(fromSelectionId: number, toSelectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetRecipientStatistics(request: carriers.Selection_GetRecipientStatisticsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;
    GetRecipientStatistics(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;
    GetRecipientStatisticsFromProjectMembers(request: carriers.Selection_GetRecipientStatisticsFromProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;
    GetRecipientStatisticsFromProjectMembers(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;
    GetRecipientStatisticsFromContactPersonIds(request: carriers.Selection_GetRecipientStatisticsFromContactPersonIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;
    GetRecipientStatisticsFromContactPersonIds(contactPersonIds: carriers.ContactPersonId[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;
    AddContactSelectionMembers(request: carriers.Selection_AddContactSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddContactSelectionMembers(selectionId: number, contactPersonIds: carriers.ContactPersonId[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveContactSelectionMembers(request: carriers.Selection_RemoveContactSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveContactSelectionMembers(selectionId: number, contactPersonIds: carriers.ContactPersonId[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveContactSelectionMembersFromIds(request: carriers.Selection_RemoveContactSelectionMembersFromIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveContactSelectionMembersFromIds(selectionId: number, selectionMembersIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddContactSelectionMembersFromSearch(request: carriers.Selection_AddContactSelectionMembersFromSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    AddContactSelectionMembersFromSearch(selectionId: number, storageKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    RemoveContactSelectionMembersFromSearch(request: carriers.Selection_RemoveContactSelectionMembersFromSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    RemoveContactSelectionMembersFromSearch(selectionId: number, storageKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CreateTemporaryContactSelection(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateTemporaryContactSelectionFromSelectionMemberIds(request: carriers.Selection_CreateTemporaryContactSelectionFromSelectionMemberIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateTemporaryContactSelectionFromSelectionMemberIds(selectionId: number, selectionMemberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    AddRemoveContactSelectionMemberInterests(request: carriers.Selection_AddRemoveContactSelectionMemberInterestsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddRemoveContactSelectionMemberInterests(selectionId: number, addCompanyInterests: number[], removeCompanyInterests: number[], addContactInterests: number[], removeContactInterests: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    EditContactSelectionMemberDetails(request: carriers.Selection_EditContactSelectionMemberDetailsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    EditContactSelectionMemberDetails(selectionId: number, selectionMemberEditValues: carriers.SelectionMemberEditValues, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GenerateFollowUps(request: carriers.Selection_GenerateFollowUpsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GenerateFollowUps(selectionId: number, appointmentEntity: carriers.AppointmentEntity, associateId: number, saveOnContactOwner: boolean, uniqueContact: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    ExportSelectionMembers(request: carriers.Selection_ExportSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    ExportSelectionMembers(selectionId: number, templateName: string, useContacts: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    ExportSelectionMembersWithOrderBy(request: carriers.Selection_ExportSelectionMembersWithOrderByRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    ExportSelectionMembersWithOrderBy(selectionId: number, templateName: string, useContacts: boolean, orderBy: string, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    StartMailMerge(request: carriers.Selection_StartMailMergeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    StartMailMerge(settings: carriers.MailMergeSettings, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetDuplicateRulesStatus(request: carriers.Selection_SetDuplicateRulesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    SetDuplicateRulesStatus(rules: carriers.DuplicateRule[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetDuplicates(request: carriers.Selection_GetDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;
    GetDuplicates(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;
    GetDuplicateRules(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateRule[] >;
    CreateNewEntry(request: carriers.Selection_CreateNewEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CreateNewEntry(duplicate: carriers.DuplicateEntry, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    DeleteContacts(request: carriers.Selection_DeleteContactsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteContacts(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddSelectionMembers(request: carriers.Selection_AddSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    AddSelectionMembers(selectionId: number, ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    RemoveSelectionMembers(request: carriers.Selection_RemoveSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveSelectionMembers(selectionId: number, selectionMemberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveSelectionMembersById(request: carriers.Selection_RemoveSelectionMembersByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    RemoveSelectionMembersById(selectionId: number, ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    AddSelectionMembersFromSearch(request: carriers.Selection_AddSelectionMembersFromSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    AddSelectionMembersFromSearch(selectionId: number, storageKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    RemoveSelectionMembersFromSearch(request: carriers.Selection_RemoveSelectionMembersFromSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    RemoveSelectionMembersFromSearch(selectionId: number, storageKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;
    CopySelectionMembers(request: carriers.Selection_CopySelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CopySelectionMembers(fromSelectionId: number, toSelectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    CreateTemporarySelectionFromIds(request: carriers.Selection_CreateTemporarySelectionFromIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateTemporarySelectionFromIds(ids: number[], targetTableNumber: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateSelectionFromSelection(request: carriers.Selection_CreateSelectionFromSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateSelectionFromSelection(selectionId: number, name: string, targetSelectionType: enums.SelectionType, copyMembers: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateContactSelectionFromShadowSelection(request: carriers.Selection_CreateContactSelectionFromShadowSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    CreateContactSelectionFromShadowSelection(selectionId: number, name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;
    DeleteEntities(request: carriers.Selection_DeleteEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeleteEntities(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetParentCombinedSelections(request: carriers.Selection_GetParentCombinedSelectionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    GetParentCombinedSelections(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;
    GetSelectionMembersArchiveRows(request: carriers.Selection_GetSelectionMembersArchiveRowsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetSelectionMembersArchiveRows(selectionId: number, select: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetSelectionShadowMembersArchiveRows(request: carriers.Selection_GetSelectionShadowMembersArchiveRowsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetSelectionShadowMembersArchiveRows(selectionId: number, select: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;
    GetDynamicSelectionCriteria(request: carriers.Selection_GetDynamicSelectionCriteriaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;
    GetDynamicSelectionCriteria(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;
    SetDynamicSelectionCriteria(request: carriers.Selection_SetDynamicSelectionCriteriaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;
    SetDynamicSelectionCriteria(selectionId: number, criteria: carriers.ArchiveRestrictionInfo[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;
    SetDynamicSelectionCriteria2(request: carriers.Selection_SetDynamicSelectionCriteria2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;
    SetDynamicSelectionCriteria2(selectionId: number, filter: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;
    SetDynamicSelectionCriteria3(request: carriers.Selection_SetDynamicSelectionCriteria3Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;
    SetDynamicSelectionCriteria3(selectionId: number, criteria: carriers.ArchiveRestrictionInfo[], filter: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;
    DeletePersons(request: carriers.Selection_DeletePersonsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    DeletePersons(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;
    GetDynamicSelectionCriteriaGroups(request: carriers.Selection_GetDynamicSelectionCriteriaGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] >;
    GetDynamicSelectionCriteriaGroups(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] >;
    SetDynamicSelectionCriteriaGroups(request: carriers.Selection_SetDynamicSelectionCriteriaGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] >;
    SetDynamicSelectionCriteriaGroups(selectionId: number, criteria: carriers.ArchiveRestrictionGroup[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] >;
    GetSelectionForFind(request: carriers.Selection_GetSelectionForFindRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionForFind >;
    GetSelectionForFind(entityName: string, typicalSearchId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionForFind >;
    GetSelectionSummaries(request: carriers.Selection_GetSelectionSummariesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionSummaryItem[] >;
    GetSelectionSummaries(selectionIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionSummaryItem[] >;
    UpdateTypicalSearch(request: carriers.Selection_UpdateTypicalSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
    UpdateTypicalSearch(searches: carriers.TypicalSearches, webapi_options?:base.WebApiRequestOptions) : Promise< string >;
} // interface ISelectionAgent




/**
 * Selections, entities, members and tasks
 */
export class SelectionAgent extends base.WebApiBase implements ISelectionAgent {
    constructor(baseUrl?: string, languageCode?:string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceManager:any);
    constructor(baseUrl: string, config:AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config:AxiosRequestConfig, languageCode?:string, cultureCode?: string);
    constructor(options: base.WebApiOptions);

    constructor(baseUrlOrOptions: string|base.WebApiOptions|undefined,
                langOrconfigOrRM?: string|base.ResourceParsing|AxiosRequestConfig|any, 
                langOrResourceOrRM?:string|base.ResourceParsing|any, 
                cultureCode?: string, 
                ) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Selection/";
        super(options);
    }



    /**
     * Set default values into a new MailMergeSettings.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultMailMergeSettings(options?:base.WebApiRequestOptions) : Promise< carriers.MailMergeSettings > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MailMergeSettings >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultMailMergeSettings", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MailMergeSettings = converters.Create_MailMergeSettings_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new MailMergeTask.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultMailMergeTask(options?:base.WebApiRequestOptions) : Promise< carriers.MailMergeTask > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.MailMergeTask >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultMailMergeTask", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.MailMergeTask = converters.Create_MailMergeTask_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /**
     * Set default values into a new SelectionEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    public async CreateDefaultSelectionEntity(options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSelectionEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SelectionEntity or creates a new SelectionEntity if the id parameter is empty
     * @param entity - The SelectionEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SelectionEntity
     */
    public async SaveSelectionEntity(entity: carriers.SelectionEntity, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSelectionEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }

    /*
     * Deletes the SelectionEntity
     * @param SelectionEntityId - The id of the SelectionEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    public async DeleteSelectionEntity(SelectionEntityId: number, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteSelectionEntity?SelectionEntityId=" + SelectionEntityId, null, config );
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a SelectionEntity object.
     * @param selectionEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SelectionEntity
     */
    public async GetSelectionEntity(selectionEntityId: number, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSelectionEntity?selectionEntityId=" + selectionEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From( response.data );               
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    private async _CreateSelectionEntity(request: carriers.Selection_CreateSelectionEntityRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateSelectionEntity", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Create (but do not save) a new selection entity, for the current user and the given target table; other fields populated as by CreateDefaultSelectionEntity()
     * @param request - TargetTableName
     * @returns The new SelectionEntity, which has not yet been saved
     */
    public async CreateSelectionEntity(request: carriers.Selection_CreateSelectionEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    /**
     * Create (but do not save) a new selection entity, for the current user and the given target table; other fields populated as by CreateDefaultSelectionEntity()
     * @param targetTableName - The name of the target table, such as 'contact' or 'appointment'; any table for which Selection functionality is enabled
     * @returns The new SelectionEntity, which has not yet been saved
     */
    public async CreateSelectionEntity(targetTableName: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    public async CreateSelectionEntity(targetTableName:string|carriers.Selection_CreateSelectionEntityRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        let _request : carriers.Selection_CreateSelectionEntityRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = targetTableName;
        if( typeof( first ) === "object" && first && ( typeof(first.TargetTableName)!='undefined' ) )
        {
            _request = targetTableName as carriers.Selection_CreateSelectionEntityRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       TargetTableName: targetTableName as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateSelectionEntity( _request, _options );
    }


    private async _CreateContactSelectionFromSelection(request: carriers.Selection_CreateContactSelectionFromSelectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateContactSelectionFromSelection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a new selection based on selection members from an existing selection.
     * @param request - SelectionId, Name, TargetSelectionType, CopyMembers
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateContactSelectionFromSelection(request: carriers.Selection_CreateContactSelectionFromSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    /**
     * Creates a new selection based on selection members from an existing selection.
     * @param selectionId - The id of the selection to copy members from.
     * @param name - The name of the new selection.
     * @param targetSelectionType - The type of ContactSelection to create. The type can be static or dynamic. If the original selection to copy from is static, the SelectionType can only be static. If the original selection is dynamic, both a static and dynamic selection can be created.
     * @param copyMembers - If true, the members from the original selection will be added to the newly created selection.
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateContactSelectionFromSelection(selectionId: number, name: string, targetSelectionType: enums.SelectionType, copyMembers: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    public async CreateContactSelectionFromSelection(selectionId:number|carriers.Selection_CreateContactSelectionFromSelectionRequest, name?:string|base.WebApiRequestOptions, targetSelectionType?:enums.SelectionType, copyMembers?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        let _request : carriers.Selection_CreateContactSelectionFromSelectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Name)!='undefined' || typeof(first.TargetSelectionType)!='undefined' || typeof(first.CopyMembers)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_CreateContactSelectionFromSelectionRequest;
            _options = name as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Name: name as string,
                       TargetSelectionType: targetSelectionType as enums.SelectionType,
                       CopyMembers: copyMembers as boolean,
                       };   
            _options = webapi_options;
        }
        return this._CreateContactSelectionFromSelection( _request, _options );
    }


    private async _CreateTemporaryContactSelectionFromContactPersonIds(request: carriers.Selection_CreateTemporaryContactSelectionFromContactPersonIdsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryContactSelectionFromContactPersonIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a temporary selection with members from a collection of ContactPerson id&apos;s.
     * @param request - ContactPersonIds
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateTemporaryContactSelectionFromContactPersonIds(request: carriers.Selection_CreateTemporaryContactSelectionFromContactPersonIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    /**
     * Creates a temporary selection with members from a collection of ContactPerson id&apos;s.
     * @param contactPersonIds - A collection of ContactPersonId to copy into the temporary contact selection as members.
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateTemporaryContactSelectionFromContactPersonIds(contactPersonIds: carriers.ContactPersonId[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    public async CreateTemporaryContactSelectionFromContactPersonIds(contactPersonIds:carriers.ContactPersonId[]|carriers.Selection_CreateTemporaryContactSelectionFromContactPersonIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        let _request : carriers.Selection_CreateTemporaryContactSelectionFromContactPersonIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactPersonIds;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactPersonIds)!='undefined' ) )
        {
            _request = contactPersonIds as carriers.Selection_CreateTemporaryContactSelectionFromContactPersonIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactPersonIds: contactPersonIds as carriers.ContactPersonId[],
                       };   
            _options = webapi_options;
        }
        return this._CreateTemporaryContactSelectionFromContactPersonIds( _request, _options );
    }


    private async _CreateTemporaryContactSelectionFromProjectMembers(request: carriers.Selection_CreateTemporaryContactSelectionFromProjectMembersRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryContactSelectionFromProjectMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a temporary selection with members from an existing project.
     * @param request - ProjectId
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateTemporaryContactSelectionFromProjectMembers(request: carriers.Selection_CreateTemporaryContactSelectionFromProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    /**
     * Creates a temporary selection with members from an existing project.
     * @param projectId - The id of the project to add members from.
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateTemporaryContactSelectionFromProjectMembers(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    public async CreateTemporaryContactSelectionFromProjectMembers(projectId:number|carriers.Selection_CreateTemporaryContactSelectionFromProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        let _request : carriers.Selection_CreateTemporaryContactSelectionFromProjectMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Selection_CreateTemporaryContactSelectionFromProjectMembersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateTemporaryContactSelectionFromProjectMembers( _request, _options );
    }


    private async _CopyContactSelectionMembers(request: carriers.Selection_CopyContactSelectionMembersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyContactSelectionMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Copy contact selection members from selection into an existing selection.
     * @param request - FromSelectionId, ToSelectionId
     * @returns 
     */
    public async CopyContactSelectionMembers(request: carriers.Selection_CopyContactSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Copy contact selection members from selection into an existing selection.
     * @param fromSelectionId - The id of the selection to copy members from.
     * @param toSelectionId - The id of the selection to copy members to.
     * @returns 
     */
    public async CopyContactSelectionMembers(fromSelectionId: number, toSelectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async CopyContactSelectionMembers(fromSelectionId:number|carriers.Selection_CopyContactSelectionMembersRequest, toSelectionId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_CopyContactSelectionMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = fromSelectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.FromSelectionId)!='undefined' || typeof(first.ToSelectionId)!='undefined' ) )
        {
            _request = fromSelectionId as carriers.Selection_CopyContactSelectionMembersRequest;
            _options = toSelectionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FromSelectionId: fromSelectionId as number,
                       ToSelectionId: toSelectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._CopyContactSelectionMembers( _request, _options );
    }


    private async _GetRecipientStatistics(request: carriers.Selection_GetRecipientStatisticsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RecipientStatistics >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecipientStatistics", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RecipientStatistics = converters.Create_RecipientStatistics_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns a RecipientStatistics object with a count of addresses, emailaddresses and emailaddresses.
     * @param request - SelectionId
     * @returns Returns a RecipientStatistics object.
     */
    public async GetRecipientStatistics(request: carriers.Selection_GetRecipientStatisticsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;

    /**
     * Returns a RecipientStatistics object with a count of addresses, emailaddresses and emailaddresses.
     * @param selectionId - The id of the selection to get the statistics for.
     * @returns Returns a RecipientStatistics object.
     */
    public async GetRecipientStatistics(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;

    public async GetRecipientStatistics(selectionId:number|carriers.Selection_GetRecipientStatisticsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics > {
        let _request : carriers.Selection_GetRecipientStatisticsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_GetRecipientStatisticsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetRecipientStatistics( _request, _options );
    }


    private async _GetRecipientStatisticsFromProjectMembers(request: carriers.Selection_GetRecipientStatisticsFromProjectMembersRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RecipientStatistics >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecipientStatisticsFromProjectMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RecipientStatistics = converters.Create_RecipientStatistics_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns a RecipientStatistics object with a count of addresses, emailaddresses and emailaddresses based on members in a project.
     * @param request - ProjectId
     * @returns Returns a RecipientStatistics object.
     */
    public async GetRecipientStatisticsFromProjectMembers(request: carriers.Selection_GetRecipientStatisticsFromProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;

    /**
     * Returns a RecipientStatistics object with a count of addresses, emailaddresses and emailaddresses based on members in a project.
     * @param projectId - The id of the project to get the member statistics for.
     * @returns Returns a RecipientStatistics object.
     */
    public async GetRecipientStatisticsFromProjectMembers(projectId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;

    public async GetRecipientStatisticsFromProjectMembers(projectId:number|carriers.Selection_GetRecipientStatisticsFromProjectMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics > {
        let _request : carriers.Selection_GetRecipientStatisticsFromProjectMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = projectId;
        if( typeof( first ) === "object" && first && ( typeof(first.ProjectId)!='undefined' ) )
        {
            _request = projectId as carriers.Selection_GetRecipientStatisticsFromProjectMembersRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ProjectId: projectId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetRecipientStatisticsFromProjectMembers( _request, _options );
    }


    private async _GetRecipientStatisticsFromContactPersonIds(request: carriers.Selection_GetRecipientStatisticsFromContactPersonIdsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.RecipientStatistics >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecipientStatisticsFromContactPersonIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.RecipientStatistics = converters.Create_RecipientStatistics_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Returns a RecipientStatistics object with a count of addresses, emailaddresses and emailaddresses based on contact and persons in a collection of ContactPersonId.
     * @param request - ContactPersonIds
     * @returns Returns a RecipientStatistics object.
     */
    public async GetRecipientStatisticsFromContactPersonIds(request: carriers.Selection_GetRecipientStatisticsFromContactPersonIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;

    /**
     * Returns a RecipientStatistics object with a count of addresses, emailaddresses and emailaddresses based on contact and persons in a collection of ContactPersonId.
     * @param contactPersonIds - A collection of ContactPersonId to get the statistics for.
     * @returns Returns a RecipientStatistics object.
     */
    public async GetRecipientStatisticsFromContactPersonIds(contactPersonIds: carriers.ContactPersonId[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics >;

    public async GetRecipientStatisticsFromContactPersonIds(contactPersonIds:carriers.ContactPersonId[]|carriers.Selection_GetRecipientStatisticsFromContactPersonIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.RecipientStatistics > {
        let _request : carriers.Selection_GetRecipientStatisticsFromContactPersonIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = contactPersonIds;
        if( typeof( first ) === "object" && first && ( typeof(first.ContactPersonIds)!='undefined' ) )
        {
            _request = contactPersonIds as carriers.Selection_GetRecipientStatisticsFromContactPersonIdsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       ContactPersonIds: contactPersonIds as carriers.ContactPersonId[],
                       };   
            _options = webapi_options;
        }
        return this._GetRecipientStatisticsFromContactPersonIds( _request, _options );
    }


    private async _AddContactSelectionMembers(request: carriers.Selection_AddContactSelectionMembersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddContactSelectionMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Adds the collection of ContactPersonId as members to the static selection
     * @param request - SelectionId, ContactPersonIds
     * @returns 
     */
    public async AddContactSelectionMembers(request: carriers.Selection_AddContactSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Adds the collection of ContactPersonId as members to the static selection
     * @param selectionId - The id of the selection where to members will be added to.
     * @param contactPersonIds - A collection of ContactPersonId to add to the selection.
     * @returns 
     */
    public async AddContactSelectionMembers(selectionId: number, contactPersonIds: carriers.ContactPersonId[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddContactSelectionMembers(selectionId:number|carriers.Selection_AddContactSelectionMembersRequest, contactPersonIds?:carriers.ContactPersonId[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_AddContactSelectionMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.ContactPersonIds)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_AddContactSelectionMembersRequest;
            _options = contactPersonIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       ContactPersonIds: contactPersonIds as carriers.ContactPersonId[],
                       };   
            _options = webapi_options;
        }
        return this._AddContactSelectionMembers( _request, _options );
    }


    private async _RemoveContactSelectionMembers(request: carriers.Selection_RemoveContactSelectionMembersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveContactSelectionMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes members from the selection as  specified in the collection of ContactPersonId.
     * @param request - SelectionId, ContactPersonIds
     * @returns 
     */
    public async RemoveContactSelectionMembers(request: carriers.Selection_RemoveContactSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Removes members from the selection as  specified in the collection of ContactPersonId.
     * @param selectionId - The id of the selection where to members will be removed.
     * @param contactPersonIds - A collection of ContactPersonId to remove from the static selection.
     * @returns 
     */
    public async RemoveContactSelectionMembers(selectionId: number, contactPersonIds: carriers.ContactPersonId[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveContactSelectionMembers(selectionId:number|carriers.Selection_RemoveContactSelectionMembersRequest, contactPersonIds?:carriers.ContactPersonId[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_RemoveContactSelectionMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.ContactPersonIds)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_RemoveContactSelectionMembersRequest;
            _options = contactPersonIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       ContactPersonIds: contactPersonIds as carriers.ContactPersonId[],
                       };   
            _options = webapi_options;
        }
        return this._RemoveContactSelectionMembers( _request, _options );
    }


    private async _RemoveContactSelectionMembersFromIds(request: carriers.Selection_RemoveContactSelectionMembersFromIdsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveContactSelectionMembersFromIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes members from the selection using a collection a selectionmember id&apos;s. Members can only be removed from single selection.
     * @param request - SelectionId, SelectionMembersIds
     * @returns 
     */
    public async RemoveContactSelectionMembersFromIds(request: carriers.Selection_RemoveContactSelectionMembersFromIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Removes members from the selection using a collection a selectionmember id&apos;s. Members can only be removed from single selection.
     * @param selectionId - The id of the selection where to members will be removed.
     * @param selectionMembersIds - An array of selectionmember id's to remove from the selection.
     * @returns 
     */
    public async RemoveContactSelectionMembersFromIds(selectionId: number, selectionMembersIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveContactSelectionMembersFromIds(selectionId:number|carriers.Selection_RemoveContactSelectionMembersFromIdsRequest, selectionMembersIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_RemoveContactSelectionMembersFromIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.SelectionMembersIds)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_RemoveContactSelectionMembersFromIdsRequest;
            _options = selectionMembersIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       SelectionMembersIds: selectionMembersIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._RemoveContactSelectionMembersFromIds( _request, _options );
    }


    private async _AddContactSelectionMembersFromSearch(request: carriers.Selection_AddContactSelectionMembersFromSearchRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddContactSelectionMembersFromSearch", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Adds members to the selection from the search result.
     * @param request - SelectionId, StorageKey
     * @returns Number of members added
     */
    public async AddContactSelectionMembersFromSearch(request: carriers.Selection_AddContactSelectionMembersFromSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Adds members to the selection from the search result.
     * @param selectionId - The id of the selection to add members
     * @param storageKey - Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     * @returns Number of members added
     */
    public async AddContactSelectionMembersFromSearch(selectionId: number, storageKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async AddContactSelectionMembersFromSearch(selectionId:number|carriers.Selection_AddContactSelectionMembersFromSearchRequest, storageKey?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Selection_AddContactSelectionMembersFromSearchRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.StorageKey)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_AddContactSelectionMembersFromSearchRequest;
            _options = storageKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       StorageKey: storageKey as string,
                       };   
            _options = webapi_options;
        }
        return this._AddContactSelectionMembersFromSearch( _request, _options );
    }


    private async _RemoveContactSelectionMembersFromSearch(request: carriers.Selection_RemoveContactSelectionMembersFromSearchRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveContactSelectionMembersFromSearch", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes members from the selection using the search result.
     * @param request - SelectionId, StorageKey
     * @returns Number of members removed
     */
    public async RemoveContactSelectionMembersFromSearch(request: carriers.Selection_RemoveContactSelectionMembersFromSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Removes members from the selection using the search result.
     * @param selectionId - The id of the selection to remove members.
     * @param storageKey - Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search.
     * @returns Number of members removed
     */
    public async RemoveContactSelectionMembersFromSearch(selectionId: number, storageKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async RemoveContactSelectionMembersFromSearch(selectionId:number|carriers.Selection_RemoveContactSelectionMembersFromSearchRequest, storageKey?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Selection_RemoveContactSelectionMembersFromSearchRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.StorageKey)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_RemoveContactSelectionMembersFromSearchRequest;
            _options = storageKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       StorageKey: storageKey as string,
                       };   
            _options = webapi_options;
        }
        return this._RemoveContactSelectionMembersFromSearch( _request, _options );
    }


    private async _CreateTemporaryContactSelection( options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryContactSelection", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Creates a temporary selection.
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateTemporaryContactSelection(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >
    {
        return this._CreateTemporaryContactSelection(webapi_options);
    }


    private async _CreateTemporaryContactSelectionFromSelectionMemberIds(request: carriers.Selection_CreateTemporaryContactSelectionFromSelectionMemberIdsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryContactSelectionFromSelectionMemberIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a temporary selection with members from a collection of selectionmember id&apos;s.
     * @param request - SelectionId, SelectionMemberIds
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateTemporaryContactSelectionFromSelectionMemberIds(request: carriers.Selection_CreateTemporaryContactSelectionFromSelectionMemberIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    /**
     * Creates a temporary selection with members from a collection of selectionmember id&apos;s.
     * @param selectionId - The selectionId the selectionmembers is a part of.
     * @param selectionMemberIds - A collection of int ids to copy into the temporary contact selection as members.
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateTemporaryContactSelectionFromSelectionMemberIds(selectionId: number, selectionMemberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    public async CreateTemporaryContactSelectionFromSelectionMemberIds(selectionId:number|carriers.Selection_CreateTemporaryContactSelectionFromSelectionMemberIdsRequest, selectionMemberIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        let _request : carriers.Selection_CreateTemporaryContactSelectionFromSelectionMemberIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.SelectionMemberIds)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_CreateTemporaryContactSelectionFromSelectionMemberIdsRequest;
            _options = selectionMemberIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       SelectionMemberIds: selectionMemberIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._CreateTemporaryContactSelectionFromSelectionMemberIds( _request, _options );
    }


    private async _AddRemoveContactSelectionMemberInterests(request: carriers.Selection_AddRemoveContactSelectionMemberInterestsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddRemoveContactSelectionMemberInterests", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Adds or removes interests on companies and persons in a selection.
     * @param request - SelectionId, AddCompanyInterests, RemoveCompanyInterests, AddContactInterests, RemoveContactInterests
     * @returns 
     */
    public async AddRemoveContactSelectionMemberInterests(request: carriers.Selection_AddRemoveContactSelectionMemberInterestsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Adds or removes interests on companies and persons in a selection.
     * @param selectionId - The id of the selection to add or remove interests members from.
     * @param addCompanyInterests - Array of int containing the id's of the interests to add to the company.
     * @param removeCompanyInterests - Array of int containing the id's of the interests to remove from the company.
     * @param addContactInterests - Array of int containing the id's of the interests to add to the contact.
     * @param removeContactInterests - Array of int containing the id's of the interests to remove from the contact.
     * @returns 
     */
    public async AddRemoveContactSelectionMemberInterests(selectionId: number, addCompanyInterests: number[], removeCompanyInterests: number[], addContactInterests: number[], removeContactInterests: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async AddRemoveContactSelectionMemberInterests(selectionId:number|carriers.Selection_AddRemoveContactSelectionMemberInterestsRequest, addCompanyInterests?:number[]|base.WebApiRequestOptions, removeCompanyInterests?:number[], addContactInterests?:number[], removeContactInterests?:number[], webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_AddRemoveContactSelectionMemberInterestsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.AddCompanyInterests)!='undefined' || typeof(first.RemoveCompanyInterests)!='undefined' || typeof(first.AddContactInterests)!='undefined' || typeof(first.RemoveContactInterests)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_AddRemoveContactSelectionMemberInterestsRequest;
            _options = addCompanyInterests as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       AddCompanyInterests: addCompanyInterests as number[],
                       RemoveCompanyInterests: removeCompanyInterests as number[],
                       AddContactInterests: addContactInterests as number[],
                       RemoveContactInterests: removeContactInterests as number[],
                       };   
            _options = webapi_options;
        }
        return this._AddRemoveContactSelectionMemberInterests( _request, _options );
    }


    private async _EditContactSelectionMemberDetails(request: carriers.Selection_EditContactSelectionMemberDetailsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("EditContactSelectionMemberDetails", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Edit company and contact details in a selection based on contents in selectionMemberEditValues.
     * @param request - SelectionId, SelectionMemberEditValues
     * @returns 
     */
    public async EditContactSelectionMemberDetails(request: carriers.Selection_EditContactSelectionMemberDetailsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Edit company and contact details in a selection based on contents in selectionMemberEditValues.
     * @param selectionId - The id of the selection to edit members from.
     * @param selectionMemberEditValues - An object of <see cref="SelectionMemberEditValues"/> describing what should be changed for companys and contacts.
     * @returns 
     */
    public async EditContactSelectionMemberDetails(selectionId: number, selectionMemberEditValues: carriers.SelectionMemberEditValues, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async EditContactSelectionMemberDetails(selectionId:number|carriers.Selection_EditContactSelectionMemberDetailsRequest, selectionMemberEditValues?:carriers.SelectionMemberEditValues|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_EditContactSelectionMemberDetailsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.SelectionMemberEditValues)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_EditContactSelectionMemberDetailsRequest;
            _options = selectionMemberEditValues as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       SelectionMemberEditValues: selectionMemberEditValues as carriers.SelectionMemberEditValues,
                       };   
            _options = webapi_options;
        }
        return this._EditContactSelectionMemberDetails( _request, _options );
    }


    private async _GenerateFollowUps(request: carriers.Selection_GenerateFollowUpsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateFollowUps", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Generate follow-ups for members in the selection.
     * @param request - SelectionId, AppointmentEntity, AssociateId, SaveOnContactOwner, UniqueContact
     * @returns 
     */
    public async GenerateFollowUps(request: carriers.Selection_GenerateFollowUpsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Generate follow-ups for members in the selection.
     * @param selectionId - The id of the selection to generate the follow-ups for.
     * @param appointmentEntity - The AppointmentEntity with information about the appointment.
     * @param associateId - The associate to save the appointments on. If saveOnContactOwner is true, this id will be ignored. Appointments wil be saved on current user if associateId = 0.
     * @param saveOnContactOwner - If true, the appointments will be saved on contact owner (Our contact). This parameter will override associateId if true.
     * @param uniqueContact - If true, only one appointment will be created for each contact.
     * @returns 
     */
    public async GenerateFollowUps(selectionId: number, appointmentEntity: carriers.AppointmentEntity, associateId: number, saveOnContactOwner: boolean, uniqueContact: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async GenerateFollowUps(selectionId:number|carriers.Selection_GenerateFollowUpsRequest, appointmentEntity?:carriers.AppointmentEntity|base.WebApiRequestOptions, associateId?:number, saveOnContactOwner?:boolean, uniqueContact?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_GenerateFollowUpsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.AppointmentEntity)!='undefined' || typeof(first.AssociateId)!='undefined' || typeof(first.SaveOnContactOwner)!='undefined' || typeof(first.UniqueContact)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_GenerateFollowUpsRequest;
            _options = appointmentEntity as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       AppointmentEntity: appointmentEntity as carriers.AppointmentEntity,
                       AssociateId: associateId as number,
                       SaveOnContactOwner: saveOnContactOwner as boolean,
                       UniqueContact: uniqueContact as boolean,
                       };   
            _options = webapi_options;
        }
        return this._GenerateFollowUps( _request, _options );
    }


    private async _ExportSelectionMembers(request: carriers.Selection_ExportSelectionMembersRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExportSelectionMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * ExportSelectionMembers will generate a string that is the result of substituting the template variables with values from selectionmembers.
     * @param request - SelectionId, TemplateName, UseContacts
     * @returns Returns a unicode byte array with the file to export to the user.
     */
    public async ExportSelectionMembers(request: carriers.Selection_ExportSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * ExportSelectionMembers will generate a string that is the result of substituting the template variables with values from selectionmembers.
     * @param selectionId - The id of the selection to generate the exported file.
     * @param templateName - The templateName parameter is the relative path of a .sxf file template. The .sxf files can be found in \template or in the user folder of the so archive.
     * @param useContacts - If the selection contains other members than contacts, setting this to true will export the contact archive of the selection.
     * @returns Returns a unicode byte array with the file to export to the user.
     */
    public async ExportSelectionMembers(selectionId: number, templateName: string, useContacts: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async ExportSelectionMembers(selectionId:number|carriers.Selection_ExportSelectionMembersRequest, templateName?:string|base.WebApiRequestOptions, useContacts?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.Selection_ExportSelectionMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.TemplateName)!='undefined' || typeof(first.UseContacts)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_ExportSelectionMembersRequest;
            _options = templateName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       TemplateName: templateName as string,
                       UseContacts: useContacts as boolean,
                       };   
            _options = webapi_options;
        }
        return this._ExportSelectionMembers( _request, _options );
    }


    private async _ExportSelectionMembersWithOrderBy(request: carriers.Selection_ExportSelectionMembersWithOrderByRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExportSelectionMembersWithOrderBy", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * ExportSelectionMembers will generate a string that is the result of substituting the template variables with values from selectionmembers.
     * @param request - SelectionId, TemplateName, UseContacts, OrderBy
     * @returns Returns a unicode byte array with the file to export to the user.
     */
    public async ExportSelectionMembersWithOrderBy(request: carriers.Selection_ExportSelectionMembersWithOrderByRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * ExportSelectionMembers will generate a string that is the result of substituting the template variables with values from selectionmembers.
     * @param selectionId - The id of the selection to generate the exported file.
     * @param templateName - The templateName parameter is the relative path of a .sxf file template. The .sxf files can be found in \template or in the user folder of the so archive.
     * @param useContacts - If the selection contains other members than contacts, setting this to true will export the contact archive of the selection.
     * @param orderBy - OrderBy. <Column,OrderBySortType>
     * @returns Returns a unicode byte array with the file to export to the user.
     */
    public async ExportSelectionMembersWithOrderBy(selectionId: number, templateName: string, useContacts: boolean, orderBy: string, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async ExportSelectionMembersWithOrderBy(selectionId:number|carriers.Selection_ExportSelectionMembersWithOrderByRequest, templateName?:string|base.WebApiRequestOptions, useContacts?:boolean, orderBy?:string, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.Selection_ExportSelectionMembersWithOrderByRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.TemplateName)!='undefined' || typeof(first.UseContacts)!='undefined' || typeof(first.OrderBy)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_ExportSelectionMembersWithOrderByRequest;
            _options = templateName as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       TemplateName: templateName as string,
                       UseContacts: useContacts as boolean,
                       OrderBy: orderBy as string,
                       };   
            _options = webapi_options;
        }
        return this._ExportSelectionMembersWithOrderBy( _request, _options );
    }


    private async _StartMailMerge(request: carriers.Selection_StartMailMergeRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("StartMailMerge", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Start a mailmerge operation with specified settings.
     * @param request - Settings
     * @returns 
     */
    public async StartMailMerge(request: carriers.Selection_StartMailMergeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Start a mailmerge operation with specified settings.
     * @param settings - All settings needed to perform the mailmerge operation.
     * @returns 
     */
    public async StartMailMerge(settings: carriers.MailMergeSettings, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async StartMailMerge(settings:carriers.MailMergeSettings|carriers.Selection_StartMailMergeRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_StartMailMergeRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = settings;
        if( typeof( first ) === "object" && first && ( typeof(first.Settings)!='undefined' ) )
        {
            _request = settings as carriers.Selection_StartMailMergeRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Settings: settings as carriers.MailMergeSettings,
                       };   
            _options = webapi_options;
        }
        return this._StartMailMerge( _request, _options );
    }


    private async _SetDuplicateRulesStatus(request: carriers.Selection_SetDuplicateRulesStatusRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDuplicateRulesStatus", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Set which duplicate rules should be active or not
     * @param request - Rules
     * @returns 
     */
    public async SetDuplicateRulesStatus(request: carriers.Selection_SetDuplicateRulesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Set which duplicate rules should be active or not
     * @param rules - Duplicate rules to update active status for
     * @returns 
     */
    public async SetDuplicateRulesStatus(rules: carriers.DuplicateRule[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async SetDuplicateRulesStatus(rules:carriers.DuplicateRule[]|carriers.Selection_SetDuplicateRulesStatusRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_SetDuplicateRulesStatusRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = rules;
        if( typeof( first ) === "object" && first && ( typeof(first.Rules)!='undefined' ) )
        {
            _request = rules as carriers.Selection_SetDuplicateRulesStatusRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Rules: rules as carriers.DuplicateRule[],
                       };   
            _options = webapi_options;
        }
        return this._SetDuplicateRulesStatus( _request, _options );
    }


    private async _GetDuplicates(request: carriers.Selection_GetDuplicatesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DuplicateEntry[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicates", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DuplicateEntry[] = converters.Create_DuplicateEntryArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get duplicates(exact or similar in the database) based on the name
     * @param request - Name
     * @returns Any records matching the specified name
     */
    public async GetDuplicates(request: carriers.Selection_GetDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;

    /**
     * Get duplicates(exact or similar in the database) based on the name
     * @param name - Name used for lookup
     * @returns Any records matching the specified name
     */
    public async GetDuplicates(name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] >;

    public async GetDuplicates(name:string|carriers.Selection_GetDuplicatesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateEntry[] > {
        let _request : carriers.Selection_GetDuplicatesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = name;
        if( typeof( first ) === "object" && first && ( typeof(first.Name)!='undefined' ) )
        {
            _request = name as carriers.Selection_GetDuplicatesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._GetDuplicates( _request, _options );
    }


    private async _GetDuplicateRules( options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateRule[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.DuplicateRule[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicateRules", undefined , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.DuplicateRule[] = converters.Create_DuplicateRuleArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }


    /**
     * Retrieve all available duplicate rules for selection
     * @returns All available duplicate rules
     */
    public async GetDuplicateRules(webapi_options?:base.WebApiRequestOptions) : Promise< carriers.DuplicateRule[] >
    {
        return this._GetDuplicateRules(webapi_options);
    }


    private async _CreateNewEntry(request: carriers.Selection_CreateNewEntryRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewEntry", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a new selection based on external duplicate
     * @param request - Duplicate
     * @returns The database identity of the newly created entry
     */
    public async CreateNewEntry(request: carriers.Selection_CreateNewEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Creates a new selection based on external duplicate
     * @param duplicate - The duplicate to create a new entry based upon
     * @returns The database identity of the newly created entry
     */
    public async CreateNewEntry(duplicate: carriers.DuplicateEntry, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async CreateNewEntry(duplicate:carriers.DuplicateEntry|carriers.Selection_CreateNewEntryRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Selection_CreateNewEntryRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = duplicate;
        if( typeof( first ) === "object" && first && ( typeof(first.Duplicate)!='undefined' ) )
        {
            _request = duplicate as carriers.Selection_CreateNewEntryRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Duplicate: duplicate as carriers.DuplicateEntry,
                       };   
            _options = webapi_options;
        }
        return this._CreateNewEntry( _request, _options );
    }


    private async _DeleteContacts(request: carriers.Selection_DeleteContactsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteContacts", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes all contacts from a selection. If a contact does not have delete rights, it will be skipped.
     * @param request - SelectionId
     * @returns 
     */
    public async DeleteContacts(request: carriers.Selection_DeleteContactsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes all contacts from a selection. If a contact does not have delete rights, it will be skipped.
     * @param selectionId - Id of the selection the delete operation will be performed.
     * @returns 
     */
    public async DeleteContacts(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteContacts(selectionId:number|carriers.Selection_DeleteContactsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_DeleteContactsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_DeleteContactsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteContacts( _request, _options );
    }


    private async _AddSelectionMembers(request: carriers.Selection_AddSelectionMembersRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddSelectionMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Add selection members to a static selection of type others than contacts.
     * @param request - SelectionId, Ids
     * @returns Returns number of members added to the selection.
     */
    public async AddSelectionMembers(request: carriers.Selection_AddSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Add selection members to a static selection of type others than contacts.
     * @param selectionId - The selection id to add the members to.
     * @param ids - Collection of ids to add to the selection.
     * @returns Returns number of members added to the selection.
     */
    public async AddSelectionMembers(selectionId: number, ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async AddSelectionMembers(selectionId:number|carriers.Selection_AddSelectionMembersRequest, ids?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Selection_AddSelectionMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Ids)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_AddSelectionMembersRequest;
            _options = ids as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Ids: ids as number[],
                       };   
            _options = webapi_options;
        }
        return this._AddSelectionMembers( _request, _options );
    }


    private async _RemoveSelectionMembers(request: carriers.Selection_RemoveSelectionMembersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveSelectionMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes members from the selection as  specified in the collection of entity ids. The ids are selection member ids (selection member primary key)
     * @param request - SelectionId, SelectionMemberIds
     * @returns 
     */
    public async RemoveSelectionMembers(request: carriers.Selection_RemoveSelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Removes members from the selection as  specified in the collection of entity ids. The ids are selection member ids (selection member primary key)
     * @param selectionId - The id of the selection where to members will be removed.
     * @param selectionMemberIds - Selection member primary keys
     * @returns 
     */
    public async RemoveSelectionMembers(selectionId: number, selectionMemberIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveSelectionMembers(selectionId:number|carriers.Selection_RemoveSelectionMembersRequest, selectionMemberIds?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_RemoveSelectionMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.SelectionMemberIds)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_RemoveSelectionMembersRequest;
            _options = selectionMemberIds as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       SelectionMemberIds: selectionMemberIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._RemoveSelectionMembers( _request, _options );
    }


    private async _RemoveSelectionMembersById(request: carriers.Selection_RemoveSelectionMembersByIdRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveSelectionMembersById", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes members from the selection as specified in the collection of entity ids. The ids can be a collection of sale ids, or other supported types.
     * @param request - SelectionId, Ids
     * @returns 
     */
    public async RemoveSelectionMembersById(request: carriers.Selection_RemoveSelectionMembersByIdRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Removes members from the selection as specified in the collection of entity ids. The ids can be a collection of sale ids, or other supported types.
     * @param selectionId - The id of the selection where to members will be removed.
     * @param ids - A collection of sale/project/contact ids to remove from the selection. The ids can be a collection of sale ids, or other supported types.
     * @returns 
     */
    public async RemoveSelectionMembersById(selectionId: number, ids: number[], webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async RemoveSelectionMembersById(selectionId:number|carriers.Selection_RemoveSelectionMembersByIdRequest, ids?:number[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_RemoveSelectionMembersByIdRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Ids)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_RemoveSelectionMembersByIdRequest;
            _options = ids as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Ids: ids as number[],
                       };   
            _options = webapi_options;
        }
        return this._RemoveSelectionMembersById( _request, _options );
    }


    private async _AddSelectionMembersFromSearch(request: carriers.Selection_AddSelectionMembersFromSearchRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddSelectionMembersFromSearch", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Adds members from the selection using the search result.
     * @param request - SelectionId, StorageKey
     * @returns Number of members added.
     */
    public async AddSelectionMembersFromSearch(request: carriers.Selection_AddSelectionMembersFromSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Adds members from the selection using the search result.
     * @param selectionId - The id of the selection to add members
     * @param storageKey - Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     * @returns Number of members added.
     */
    public async AddSelectionMembersFromSearch(selectionId: number, storageKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async AddSelectionMembersFromSearch(selectionId:number|carriers.Selection_AddSelectionMembersFromSearchRequest, storageKey?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Selection_AddSelectionMembersFromSearchRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.StorageKey)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_AddSelectionMembersFromSearchRequest;
            _options = storageKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       StorageKey: storageKey as string,
                       };   
            _options = webapi_options;
        }
        return this._AddSelectionMembersFromSearch( _request, _options );
    }


    private async _RemoveSelectionMembersFromSearch(request: carriers.Selection_RemoveSelectionMembersFromSearchRequest, options?:base.WebApiRequestOptions) : Promise< number > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveSelectionMembersFromSearch", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number = response.data as number;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Removes members from the selection using the search result.
     * @param request - SelectionId, StorageKey
     * @returns Number of members removed
     */
    public async RemoveSelectionMembersFromSearch(request: carriers.Selection_RemoveSelectionMembersFromSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    /**
     * Removes members from the selection using the search result.
     * @param selectionId - The id of the selection to remove members.
     * @param storageKey - Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search.
     * @returns Number of members removed
     */
    public async RemoveSelectionMembersFromSearch(selectionId: number, storageKey: string, webapi_options?:base.WebApiRequestOptions) : Promise< number >;

    public async RemoveSelectionMembersFromSearch(selectionId:number|carriers.Selection_RemoveSelectionMembersFromSearchRequest, storageKey?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< number > {
        let _request : carriers.Selection_RemoveSelectionMembersFromSearchRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.StorageKey)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_RemoveSelectionMembersFromSearchRequest;
            _options = storageKey as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       StorageKey: storageKey as string,
                       };   
            _options = webapi_options;
        }
        return this._RemoveSelectionMembersFromSearch( _request, _options );
    }


    private async _CopySelectionMembers(request: carriers.Selection_CopySelectionMembersRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopySelectionMembers", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Copy selection members from selection into an existing selection.
     * @param request - FromSelectionId, ToSelectionId
     * @returns 
     */
    public async CopySelectionMembers(request: carriers.Selection_CopySelectionMembersRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Copy selection members from selection into an existing selection.
     * @param fromSelectionId - The id of the selection to copy members from.
     * @param toSelectionId - The id of the selection to copy members to.
     * @returns 
     */
    public async CopySelectionMembers(fromSelectionId: number, toSelectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async CopySelectionMembers(fromSelectionId:number|carriers.Selection_CopySelectionMembersRequest, toSelectionId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_CopySelectionMembersRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = fromSelectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.FromSelectionId)!='undefined' || typeof(first.ToSelectionId)!='undefined' ) )
        {
            _request = fromSelectionId as carriers.Selection_CopySelectionMembersRequest;
            _options = toSelectionId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       FromSelectionId: fromSelectionId as number,
                       ToSelectionId: toSelectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._CopySelectionMembers( _request, _options );
    }


    private async _CreateTemporarySelectionFromIds(request: carriers.Selection_CreateTemporarySelectionFromIdsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporarySelectionFromIds", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a temporary selection with members from a collection of entity id&apos;s.
     * @param request - Ids, TargetTableNumber
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateTemporarySelectionFromIds(request: carriers.Selection_CreateTemporarySelectionFromIdsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    /**
     * Creates a temporary selection with members from a collection of entity id&apos;s.
     * @param ids - A collection of Ids to copy into the temporary selection as members. The ids are primary keys of entities defined by the targetTableNumber parameter.
     * @param targetTableNumber - The type of selection to create.
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateTemporarySelectionFromIds(ids: number[], targetTableNumber: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    public async CreateTemporarySelectionFromIds(ids:number[]|carriers.Selection_CreateTemporarySelectionFromIdsRequest, targetTableNumber?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        let _request : carriers.Selection_CreateTemporarySelectionFromIdsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = ids;
        if( typeof( first ) === "object" && first && ( typeof(first.Ids)!='undefined' || typeof(first.TargetTableNumber)!='undefined' ) )
        {
            _request = ids as carriers.Selection_CreateTemporarySelectionFromIdsRequest;
            _options = targetTableNumber as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Ids: ids as number[],
                       TargetTableNumber: targetTableNumber as number,
                       };   
            _options = webapi_options;
        }
        return this._CreateTemporarySelectionFromIds( _request, _options );
    }


    private async _CreateSelectionFromSelection(request: carriers.Selection_CreateSelectionFromSelectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateSelectionFromSelection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a new selection based on selection members from an existing selection.
     * @param request - SelectionId, Name, TargetSelectionType, CopyMembers
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateSelectionFromSelection(request: carriers.Selection_CreateSelectionFromSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    /**
     * Creates a new selection based on selection members from an existing selection.
     * @param selectionId - The id of the selection to copy members from.
     * @param name - The name of the new selection.
     * @param targetSelectionType - The type of Selection to create. The type can be static or dynamic. If the original selection to copy from is static, the SelectionType can only be static. If the original selection is dynamic, both a static and dynamic selection can be created.
     * @param copyMembers - If true, the members from the original selection will be added to the newly created selection.
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateSelectionFromSelection(selectionId: number, name: string, targetSelectionType: enums.SelectionType, copyMembers: boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    public async CreateSelectionFromSelection(selectionId:number|carriers.Selection_CreateSelectionFromSelectionRequest, name?:string|base.WebApiRequestOptions, targetSelectionType?:enums.SelectionType, copyMembers?:boolean, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        let _request : carriers.Selection_CreateSelectionFromSelectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Name)!='undefined' || typeof(first.TargetSelectionType)!='undefined' || typeof(first.CopyMembers)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_CreateSelectionFromSelectionRequest;
            _options = name as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Name: name as string,
                       TargetSelectionType: targetSelectionType as enums.SelectionType,
                       CopyMembers: copyMembers as boolean,
                       };   
            _options = webapi_options;
        }
        return this._CreateSelectionFromSelection( _request, _options );
    }


    private async _CreateContactSelectionFromShadowSelection(request: carriers.Selection_CreateContactSelectionFromShadowSelectionRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionEntity >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateContactSelectionFromShadowSelection", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionEntity = converters.Create_SelectionEntity_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Creates a new contact selection based on contact selection members from an existing shadow sale, appointment, project or document selection. The new selection will always be static even if the original selection is dynamic.
     * @param request - SelectionId, Name
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateContactSelectionFromShadowSelection(request: carriers.Selection_CreateContactSelectionFromShadowSelectionRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    /**
     * Creates a new contact selection based on contact selection members from an existing shadow sale, appointment, project or document selection. The new selection will always be static even if the original selection is dynamic.
     * @param selectionId - The id of the selection to copy members from.
     * @param name - The name of the new selection.
     * @returns Returns the newly created SelectionEntity.
     */
    public async CreateContactSelectionFromShadowSelection(selectionId: number, name: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity >;

    public async CreateContactSelectionFromShadowSelection(selectionId:number|carriers.Selection_CreateContactSelectionFromShadowSelectionRequest, name?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionEntity > {
        let _request : carriers.Selection_CreateContactSelectionFromShadowSelectionRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Name)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_CreateContactSelectionFromShadowSelectionRequest;
            _options = name as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Name: name as string,
                       };   
            _options = webapi_options;
        }
        return this._CreateContactSelectionFromShadowSelection( _request, _options );
    }


    private async _DeleteEntities(request: carriers.Selection_DeleteEntitiesRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteEntities", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes all entities from a selection. If an entity does not have delete rights, it will be skipped.
     * @param request - SelectionId
     * @returns 
     */
    public async DeleteEntities(request: carriers.Selection_DeleteEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes all entities from a selection. If an entity does not have delete rights, it will be skipped.
     * @param selectionId - Id of the selection the delete operation will be performed.
     * @returns 
     */
    public async DeleteEntities(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeleteEntities(selectionId:number|carriers.Selection_DeleteEntitiesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_DeleteEntitiesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_DeleteEntitiesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeleteEntities( _request, _options );
    }


    private async _GetParentCombinedSelections(request: carriers.Selection_GetParentCombinedSelectionsRequest, options?:base.WebApiRequestOptions) : Promise< number[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< number[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetParentCombinedSelections", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : number[] = response.data as number[];
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get a list of all selection ids where the given selection is used to create a combined selection.
     * @param request - SelectionId
     * @returns Array of selectionIds.
     */
    public async GetParentCombinedSelections(request: carriers.Selection_GetParentCombinedSelectionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    /**
     * Get a list of all selection ids where the given selection is used to create a combined selection.
     * @param selectionId - The selectionId to query for.
     * @returns Array of selectionIds.
     */
    public async GetParentCombinedSelections(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< number[] >;

    public async GetParentCombinedSelections(selectionId:number|carriers.Selection_GetParentCombinedSelectionsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< number[] > {
        let _request : carriers.Selection_GetParentCombinedSelectionsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_GetParentCombinedSelectionsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetParentCombinedSelections( _request, _options );
    }


    private async _GetSelectionMembersArchiveRows(request: carriers.Selection_GetSelectionMembersArchiveRowsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectionMembersArchiveRows", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the list of members in this selection. The type of members depends on the target table of the selection.
     * @param request - SelectionId, Select
     * @returns Array of archive rows, where each item represents one row of data (row level data + the requested columns). NULL if selection does not exist.
     */
    public async GetSelectionMembersArchiveRows(request: carriers.Selection_GetSelectionMembersArchiveRowsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get the list of members in this selection. The type of members depends on the target table of the selection.
     * @param selectionId - The selectionId we want selection members for.
     * @param select - (optional) Comma separated Column names to include in result. List of columns varies depending on the selection's TargetTable. e.g. 'name', 'firstname', 'startTime'
     * @returns Array of archive rows, where each item represents one row of data (row level data + the requested columns). NULL if selection does not exist.
     */
    public async GetSelectionMembersArchiveRows(selectionId: number, select: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetSelectionMembersArchiveRows(selectionId:number|carriers.Selection_GetSelectionMembersArchiveRowsRequest, select?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Selection_GetSelectionMembersArchiveRowsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Select)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_GetSelectionMembersArchiveRowsRequest;
            _options = select as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Select: select as string,
                       };   
            _options = webapi_options;
        }
        return this._GetSelectionMembersArchiveRows( _request, _options );
    }


    private async _GetSelectionShadowMembersArchiveRows(request: carriers.Selection_GetSelectionShadowMembersArchiveRowsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveListItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectionShadowMembersArchiveRows", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveListItem[] = converters.Create_ArchiveListItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the list of members in this selection&apos;s shadow (i.e. the list of contacts + persons referenced in the main selection).
     * @param request - SelectionId, Select
     * @returns Array of archive rows, where each item represents one row of data (row level data + the requested columns). NULL if selection does not exist.
     */
    public async GetSelectionShadowMembersArchiveRows(request: carriers.Selection_GetSelectionShadowMembersArchiveRowsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    /**
     * Get the list of members in this selection&apos;s shadow (i.e. the list of contacts + persons referenced in the main selection).
     * @param selectionId - The selectionId we want selection members for.
     * @param select - (optional) Comma separated Column names to include in result. List of columns varies depending on the selection's TargetTable. e.g. 'name', 'firstname,name', 'startTime,firstname,name'
     * @returns Array of archive rows, where each item represents one row of data (row level data + the requested columns). NULL if selection does not exist.
     */
    public async GetSelectionShadowMembersArchiveRows(selectionId: number, select: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] >;

    public async GetSelectionShadowMembersArchiveRows(selectionId:number|carriers.Selection_GetSelectionShadowMembersArchiveRowsRequest, select?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveListItem[] > {
        let _request : carriers.Selection_GetSelectionShadowMembersArchiveRowsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Select)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_GetSelectionShadowMembersArchiveRowsRequest;
            _options = select as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Select: select as string,
                       };   
            _options = webapi_options;
        }
        return this._GetSelectionShadowMembersArchiveRows( _request, _options );
    }


    private async _GetDynamicSelectionCriteria(request: carriers.Selection_GetDynamicSelectionCriteriaRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveRestrictionInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDynamicSelectionCriteria", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveRestrictionInfo[] = converters.Create_ArchiveRestrictionInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the criteria for this dynamic selection.
     * @param request - SelectionId
     * @returns Criteria defining the selection result. NULL if selection does not exist, or if this is not a dynamic selection.
     */
    public async GetDynamicSelectionCriteria(request: carriers.Selection_GetDynamicSelectionCriteriaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;

    /**
     * Get the criteria for this dynamic selection.
     * @param selectionId - The id of the selection to add members
     * @returns Criteria defining the selection result. NULL if selection does not exist, or if this is not a dynamic selection.
     */
    public async GetDynamicSelectionCriteria(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;

    public async GetDynamicSelectionCriteria(selectionId:number|carriers.Selection_GetDynamicSelectionCriteriaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] > {
        let _request : carriers.Selection_GetDynamicSelectionCriteriaRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_GetDynamicSelectionCriteriaRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDynamicSelectionCriteria( _request, _options );
    }


    private async _SetDynamicSelectionCriteria(request: carriers.Selection_SetDynamicSelectionCriteriaRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveRestrictionInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDynamicSelectionCriteria", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveRestrictionInfo[] = converters.Create_ArchiveRestrictionInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update the criteria for this dynamic selection. Replaces existing criteria with the new values.
     * @param request - SelectionId, Criteria
     * @returns Criteria defining the selection result. NULL if this is not a dynamic selection.
     */
    public async SetDynamicSelectionCriteria(request: carriers.Selection_SetDynamicSelectionCriteriaRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;

    /**
     * Update the criteria for this dynamic selection. Replaces existing criteria with the new values.
     * @param selectionId - The id of the selection to add members
     * @param criteria - Criteria defining the selection result.
     * @returns Criteria defining the selection result. NULL if this is not a dynamic selection.
     */
    public async SetDynamicSelectionCriteria(selectionId: number, criteria: carriers.ArchiveRestrictionInfo[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;

    public async SetDynamicSelectionCriteria(selectionId:number|carriers.Selection_SetDynamicSelectionCriteriaRequest, criteria?:carriers.ArchiveRestrictionInfo[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] > {
        let _request : carriers.Selection_SetDynamicSelectionCriteriaRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Criteria)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_SetDynamicSelectionCriteriaRequest;
            _options = criteria as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Criteria: criteria as carriers.ArchiveRestrictionInfo[],
                       };   
            _options = webapi_options;
        }
        return this._SetDynamicSelectionCriteria( _request, _options );
    }


    private async _SetDynamicSelectionCriteria2(request: carriers.Selection_SetDynamicSelectionCriteria2Request, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveRestrictionInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDynamicSelectionCriteria2", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveRestrictionInfo[] = converters.Create_ArchiveRestrictionInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update the criteria for this dynamic selection using string. Criteria are parsed from the OData filter form: &apos;&apos;name startswith &apos;foo&apos; and category in (1,2,3)&apos;&apos;
     * @param request - SelectionId, Filter
     * @returns Criteria defining the selection result. NULL if this is not a dynamic selection.
     */
    public async SetDynamicSelectionCriteria2(request: carriers.Selection_SetDynamicSelectionCriteria2Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;

    /**
     * Update the criteria for this dynamic selection using string. Criteria are parsed from the OData filter form: &apos;&apos;name startswith &apos;foo&apos; and category in (1,2,3)&apos;&apos;
     * @param selectionId - The id of the selection to add members
     * @param filter - Criteria defining the selection result in OData filter form: `category in (1,2,3) and name = 'foo'` 
     * @returns Criteria defining the selection result. NULL if this is not a dynamic selection.
     */
    public async SetDynamicSelectionCriteria2(selectionId: number, filter: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;

    public async SetDynamicSelectionCriteria2(selectionId:number|carriers.Selection_SetDynamicSelectionCriteria2Request, filter?:string|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] > {
        let _request : carriers.Selection_SetDynamicSelectionCriteria2Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Filter)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_SetDynamicSelectionCriteria2Request;
            _options = filter as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Filter: filter as string,
                       };   
            _options = webapi_options;
        }
        return this._SetDynamicSelectionCriteria2( _request, _options );
    }


    private async _SetDynamicSelectionCriteria3(request: carriers.Selection_SetDynamicSelectionCriteria3Request, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveRestrictionInfo[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDynamicSelectionCriteria3", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveRestrictionInfo[] = converters.Create_ArchiveRestrictionInfoArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update the criteria for this dynamic selection. Use criteria as either restriction objects or OData string format. Criteria are parsed from the OData filter form: &apos;&apos;name startswith &apos;foo&apos; and category in (1,2,3)&apos;&apos;
     * @param request - SelectionId, Criteria, Filter
     * @returns Criteria defining the selection result. NULL if this is not a dynamic selection.
     */
    public async SetDynamicSelectionCriteria3(request: carriers.Selection_SetDynamicSelectionCriteria3Request, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;

    /**
     * Update the criteria for this dynamic selection. Use criteria as either restriction objects or OData string format. Criteria are parsed from the OData filter form: &apos;&apos;name startswith &apos;foo&apos; and category in (1,2,3)&apos;&apos;
     * @param selectionId - The id of the selection to add members
     * @param criteria - Criteria defining the selection result. Pass NULL if using the filter string instead.
     * @param filter - Criteria defining the selection result in OData filter form: `category in (1,2,3) and name = 'foo'`. Pass NULL or empty string '' if using the criteria objects.
     * @returns Criteria defining the selection result. NULL if this is not a dynamic selection.
     */
    public async SetDynamicSelectionCriteria3(selectionId: number, criteria: carriers.ArchiveRestrictionInfo[], filter: string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] >;

    public async SetDynamicSelectionCriteria3(selectionId:number|carriers.Selection_SetDynamicSelectionCriteria3Request, criteria?:carriers.ArchiveRestrictionInfo[]|base.WebApiRequestOptions, filter?:string, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionInfo[] > {
        let _request : carriers.Selection_SetDynamicSelectionCriteria3Request = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Criteria)!='undefined' || typeof(first.Filter)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_SetDynamicSelectionCriteria3Request;
            _options = criteria as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Criteria: criteria as carriers.ArchiveRestrictionInfo[],
                       Filter: filter as string,
                       };   
            _options = webapi_options;
        }
        return this._SetDynamicSelectionCriteria3( _request, _options );
    }


    private async _DeletePersons(request: carriers.Selection_DeletePersonsRequest, options?:base.WebApiRequestOptions) : Promise< void > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< void >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePersons", request , config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Deletes all persons from a selection. If a person does not have delete rights, it will be skipped.
     * @param request - SelectionId
     * @returns 
     */
    public async DeletePersons(request: carriers.Selection_DeletePersonsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    /**
     * Deletes all persons from a selection. If a person does not have delete rights, it will be skipped.
     * @param selectionId - Id of the selection the delete operation will be performed.
     * @returns 
     */
    public async DeletePersons(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< void >;

    public async DeletePersons(selectionId:number|carriers.Selection_DeletePersonsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< void > {
        let _request : carriers.Selection_DeletePersonsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_DeletePersonsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._DeletePersons( _request, _options );
    }


    private async _GetDynamicSelectionCriteriaGroups(request: carriers.Selection_GetDynamicSelectionCriteriaGroupsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveRestrictionGroup[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDynamicSelectionCriteriaGroups", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveRestrictionGroup[] = converters.Create_ArchiveRestrictionGroupArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get the criteria for this dynamic selection. This call supports multiple criteria groups.
     * @param request - SelectionId
     * @returns Criteria groups defining the selection result. NULL if selection does not exist, or if this is not a dynamic selection.
     */
    public async GetDynamicSelectionCriteriaGroups(request: carriers.Selection_GetDynamicSelectionCriteriaGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] >;

    /**
     * Get the criteria for this dynamic selection. This call supports multiple criteria groups.
     * @param selectionId - The id of the selection to add members
     * @returns Criteria groups defining the selection result. NULL if selection does not exist, or if this is not a dynamic selection.
     */
    public async GetDynamicSelectionCriteriaGroups(selectionId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] >;

    public async GetDynamicSelectionCriteriaGroups(selectionId:number|carriers.Selection_GetDynamicSelectionCriteriaGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] > {
        let _request : carriers.Selection_GetDynamicSelectionCriteriaGroupsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_GetDynamicSelectionCriteriaGroupsRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetDynamicSelectionCriteriaGroups( _request, _options );
    }


    private async _SetDynamicSelectionCriteriaGroups(request: carriers.Selection_SetDynamicSelectionCriteriaGroupsRequest, options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.ArchiveRestrictionGroup[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDynamicSelectionCriteriaGroups", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.ArchiveRestrictionGroup[] = converters.Create_ArchiveRestrictionGroupArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update the criteria for this dynamic selection. Replaces existing criteria with the new values. This call supports multiple criteria groups.
     * @param request - SelectionId, Criteria
     * @returns Criteria groups defining the selection result. NULL if this is not a dynamic selection.
     */
    public async SetDynamicSelectionCriteriaGroups(request: carriers.Selection_SetDynamicSelectionCriteriaGroupsRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] >;

    /**
     * Update the criteria for this dynamic selection. Replaces existing criteria with the new values. This call supports multiple criteria groups.
     * @param selectionId - The id of the selection to add members
     * @param criteria - Criteria groups defining the selection result. Empty array is legal, simply means no criteria have been set
     * @returns Criteria groups defining the selection result. NULL if this is not a dynamic selection.
     */
    public async SetDynamicSelectionCriteriaGroups(selectionId: number, criteria: carriers.ArchiveRestrictionGroup[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] >;

    public async SetDynamicSelectionCriteriaGroups(selectionId:number|carriers.Selection_SetDynamicSelectionCriteriaGroupsRequest, criteria?:carriers.ArchiveRestrictionGroup[]|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.ArchiveRestrictionGroup[] > {
        let _request : carriers.Selection_SetDynamicSelectionCriteriaGroupsRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionId;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionId)!='undefined' || typeof(first.Criteria)!='undefined' ) )
        {
            _request = selectionId as carriers.Selection_SetDynamicSelectionCriteriaGroupsRequest;
            _options = criteria as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionId: selectionId as number,
                       Criteria: criteria as carriers.ArchiveRestrictionGroup[],
                       };   
            _options = webapi_options;
        }
        return this._SetDynamicSelectionCriteriaGroups( _request, _options );
    }


    private async _GetSelectionForFind(request: carriers.Selection_GetSelectionForFindRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionForFind > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionForFind >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectionForFind", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionForFind = converters.Create_SelectionForFind_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Obtain a selection for the given entity, for the current user, of type WorkingSetForFind. Optionally populate criteria from the TypicalSearches system
     * @param request - EntityName, TypicalSearchId
     * @returns Target selection id and provider name
     */
    public async GetSelectionForFind(request: carriers.Selection_GetSelectionForFindRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionForFind >;

    /**
     * Obtain a selection for the given entity, for the current user, of type WorkingSetForFind. Optionally populate criteria from the TypicalSearches system
     * @param entityName - The name of the entity to make a selection for; examples 'sale', 'project', 'y_equipment'
     * @param typicalSearchId - If 0, keep existing criteria; if -1, reset to entity default; > 0 get criteria from given TypicalSearch
     * @returns Target selection id and provider name
     */
    public async GetSelectionForFind(entityName: string, typicalSearchId: number, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionForFind >;

    public async GetSelectionForFind(entityName:string|carriers.Selection_GetSelectionForFindRequest, typicalSearchId?:number|base.WebApiRequestOptions, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionForFind > {
        let _request : carriers.Selection_GetSelectionForFindRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = entityName;
        if( typeof( first ) === "object" && first && ( typeof(first.EntityName)!='undefined' || typeof(first.TypicalSearchId)!='undefined' ) )
        {
            _request = entityName as carriers.Selection_GetSelectionForFindRequest;
            _options = typicalSearchId as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       EntityName: entityName as string,
                       TypicalSearchId: typicalSearchId as number,
                       };   
            _options = webapi_options;
        }
        return this._GetSelectionForFind( _request, _options );
    }


    private async _GetSelectionSummaries(request: carriers.Selection_GetSelectionSummariesRequest, options?:base.WebApiRequestOptions) : Promise< carriers.SelectionSummaryItem[] > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< carriers.SelectionSummaryItem[] >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectionSummaries", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : carriers.SelectionSummaryItem[] = converters.Create_SelectionSummaryItemArray_From( response.data );
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Get an array of summaryitem for the given selections
     * @param request - SelectionIds
     * @returns Summary items for the given id's, in no particular order
     */
    public async GetSelectionSummaries(request: carriers.Selection_GetSelectionSummariesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionSummaryItem[] >;

    /**
     * Get an array of summaryitem for the given selections
     * @param selectionIds - The selections to fetch summaries for
     * @returns Summary items for the given id's, in no particular order
     */
    public async GetSelectionSummaries(selectionIds: number[], webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionSummaryItem[] >;

    public async GetSelectionSummaries(selectionIds:number[]|carriers.Selection_GetSelectionSummariesRequest, webapi_options?:base.WebApiRequestOptions) : Promise< carriers.SelectionSummaryItem[] > {
        let _request : carriers.Selection_GetSelectionSummariesRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = selectionIds;
        if( typeof( first ) === "object" && first && ( typeof(first.SelectionIds)!='undefined' ) )
        {
            _request = selectionIds as carriers.Selection_GetSelectionSummariesRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       SelectionIds: selectionIds as number[],
                       };   
            _options = webapi_options;
        }
        return this._GetSelectionSummaries( _request, _options );
    }


    private async _UpdateTypicalSearch(request: carriers.Selection_UpdateTypicalSearchRequest, options?:base.WebApiRequestOptions) : Promise< string > {
        const config : AxiosRequestConfig = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise< string >(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateTypicalSearch", request , config);
                base.WebApiBase.SetCompleted(options);
                const res : string = response.data as string;
                resolve(res);
            }
            catch( err ) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }



    /**
     * Update (import) TypicalSearch information in the database
     * @param request - Searches
     * @returns Message that can be shown to the user, summarizing what has been done, if anything.
     */
    public async UpdateTypicalSearch(request: carriers.Selection_UpdateTypicalSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    /**
     * Update (import) TypicalSearch information in the database
     * @param searches - TypicalSearch structures to import. If null, then the fileset is scanned for *TypicalSearch.json files and those are imported instead
     * @returns Message that can be shown to the user, summarizing what has been done, if anything.
     */
    public async UpdateTypicalSearch(searches: carriers.TypicalSearches, webapi_options?:base.WebApiRequestOptions) : Promise< string >;

    public async UpdateTypicalSearch(searches:carriers.TypicalSearches|carriers.Selection_UpdateTypicalSearchRequest, webapi_options?:base.WebApiRequestOptions) : Promise< string > {
        let _request : carriers.Selection_UpdateTypicalSearchRequest = null;
        let _options : base.WebApiRequestOptions = null;
        const first : any = searches;
        if( typeof( first ) === "object" && first && ( typeof(first.Searches)!='undefined' ) )
        {
            _request = searches as carriers.Selection_UpdateTypicalSearchRequest;
            _options = webapi_options as base.WebApiRequestOptions;
        }
        else
        {
            _request = { 
                       Searches: searches as carriers.TypicalSearches,
                       };   
            _options = webapi_options;
        }
        return this._UpdateTypicalSearch( _request, _options );
    }

    } // class v1SelectionAgentController 



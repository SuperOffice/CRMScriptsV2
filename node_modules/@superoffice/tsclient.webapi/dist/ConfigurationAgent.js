"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * User interface configuration - XMLs and other elements such as inter-client URLs
 */
class ConfigurationAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Configuration/";
        super(options);
    }
    /**
     * Set default values into a new ConfigurableScreenDelta.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultConfigurableScreenDelta(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultConfigurableScreenDelta", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConfigurableScreenDelta_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ConfigurableScreenDelta or creates a new ConfigurableScreenDelta if the id parameter is empty
     * @param entity - The ConfigurableScreenDelta to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ConfigurableScreenDelta
     */
    async SaveConfigurableScreenDelta(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveConfigurableScreenDelta", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConfigurableScreenDelta_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ConfigurableScreenDelta
     * @param ConfigurableScreenDeltaId - The id of the ConfigurableScreenDelta to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteConfigurableScreenDelta(ConfigurableScreenDeltaId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteConfigurableScreenDelta?ConfigurableScreenDeltaId=" + ConfigurableScreenDeltaId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new DiaryViewEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultDiaryViewEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDiaryViewEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DiaryViewEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DiaryViewEntity or creates a new DiaryViewEntity if the id parameter is empty
     * @param entity - The DiaryViewEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DiaryViewEntity
     */
    async SaveDiaryViewEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDiaryViewEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DiaryViewEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the DiaryViewEntity
     * @param DiaryViewEntityId - The id of the DiaryViewEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteDiaryViewEntity(DiaryViewEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDiaryViewEntity?DiaryViewEntityId=" + DiaryViewEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new SystemEventEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSystemEventEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSystemEventEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SystemEventEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SystemEventEntity or creates a new SystemEventEntity if the id parameter is empty
     * @param entity - The SystemEventEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SystemEventEntity
     */
    async SaveSystemEventEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSystemEventEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SystemEventEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the SystemEventEntity
     * @param SystemEventEntityId - The id of the SystemEventEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteSystemEventEntity(SystemEventEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteSystemEventEntity?SystemEventEntityId=" + SystemEventEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ConfigurableScreenDelta object.
     * @param configurableScreenDeltaId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ConfigurableScreenDelta
     */
    async GetConfigurableScreenDelta(configurableScreenDeltaId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConfigurableScreenDelta?configurableScreenDeltaId=" + configurableScreenDeltaId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConfigurableScreenDelta_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetScreenConfigurationDeltas(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetScreenConfigurationDeltas", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * This method will return a json with all deltas for screen
     * @returns A string with all recipe deltas in json for logged in associate
     */
    async GetScreenConfigurationDeltas(webapi_options) {
        return this._GetScreenConfigurationDeltas(webapi_options);
    }
    async _GetScreenConfigurationDelta(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetScreenConfigurationDelta", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetScreenConfigurationDelta(deltaType, deltaState, webapi_options) {
        let _request = null;
        let _options = null;
        const first = deltaType;
        if (typeof (first) === "object" && first && (typeof (first.DeltaType) != 'undefined' || typeof (first.DeltaState) != 'undefined')) {
            _request = deltaType;
            _options = deltaState;
        }
        else {
            _request = {
                DeltaType: deltaType,
                DeltaState: deltaState,
            };
            _options = webapi_options;
        }
        return this._GetScreenConfigurationDelta(_request, _options);
    }
    async _GetConfigurableScreenDeltasByDelta(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConfigurableScreenDeltasByDelta", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConfigurableScreenDeltaArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConfigurableScreenDeltasByDelta(configurableScreenDelta, webapi_options) {
        let _request = null;
        let _options = null;
        const first = configurableScreenDelta;
        if (typeof (first) === "object" && first && (typeof (first.ConfigurableScreenDelta) != 'undefined')) {
            _request = configurableScreenDelta;
            _options = webapi_options;
        }
        else {
            _request = {
                ConfigurableScreenDelta: configurableScreenDelta,
            };
            _options = webapi_options;
        }
        return this._GetConfigurableScreenDeltasByDelta(_request, _options);
    }
    async _GetConfigurableScreenDeltasByQuery(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConfigurableScreenDeltasByQuery", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConfigurableScreenDeltaArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConfigurableScreenDeltasByQuery(deltaQuery, webapi_options) {
        let _request = null;
        let _options = null;
        const first = deltaQuery;
        if (typeof (first) === "object" && first && (typeof (first.DeltaQuery) != 'undefined')) {
            _request = deltaQuery;
            _options = webapi_options;
        }
        else {
            _request = {
                DeltaQuery: deltaQuery,
            };
            _options = webapi_options;
        }
        return this._GetConfigurableScreenDeltasByQuery(_request, _options);
    }
    async _RebuildUdefDeltas(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RebuildUdefDeltas", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Flush and rebuild userdefined field deltas. Mostly used after publishing udefs or adding/editing Customer Service extrafields
     * @returns No return value
     */
    async RebuildUdefDeltas(webapi_options) {
        return this._RebuildUdefDeltas(webapi_options);
    }
    async _RebuildWebpanelDeltas(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RebuildWebpanelDeltas", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Flush and rebuild webpanel deltas. Mostly used after adding/editing webpanels or change group visibility of them
     * @returns No return value
     */
    async RebuildWebpanelDeltas(webapi_options) {
        return this._RebuildWebpanelDeltas(webapi_options);
    }
    async _SaveAndPublish(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveAndPublish", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConfigurableScreenDelta_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveAndPublish(configurableScreenDelta, webapi_options) {
        let _request = null;
        let _options = null;
        const first = configurableScreenDelta;
        if (typeof (first) === "object" && first && (typeof (first.ConfigurableScreenDelta) != 'undefined')) {
            _request = configurableScreenDelta;
            _options = webapi_options;
        }
        else {
            _request = {
                ConfigurableScreenDelta: configurableScreenDelta,
            };
            _options = webapi_options;
        }
        return this._SaveAndPublish(_request, _options);
    }
    async _SetAppliesToKey(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetAppliesToKey", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetAppliesToKey(recipeId, appliesToKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = recipeId;
        if (typeof (first) === "object" && first && (typeof (first.RecipeId) != 'undefined' || typeof (first.AppliesToKey) != 'undefined')) {
            _request = recipeId;
            _options = appliesToKey;
        }
        else {
            _request = {
                RecipeId: recipeId,
                AppliesToKey: appliesToKey,
            };
            _options = webapi_options;
        }
        return this._SetAppliesToKey(_request, _options);
    }
    async _GetRecipeAppliesToMappings(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecipeAppliesToMappings", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Return the a  dictionary with recipeId as key, and chosen appliesTo for that recipe, Like projecttype for projectcardrecipe
     * @returns Mapping of recipeId and selected appliesToKey
     */
    async GetRecipeAppliesToMappings(webapi_options) {
        return this._GetRecipeAppliesToMappings(webapi_options);
    }
    async _GetApplicationConfiguration(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetApplicationConfiguration", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetApplicationConfiguration(application, instance, webapi_options) {
        let _request = null;
        let _options = null;
        const first = application;
        if (typeof (first) === "object" && first && (typeof (first.Application) != 'undefined' || typeof (first.Instance) != 'undefined')) {
            _request = application;
            _options = instance;
        }
        else {
            _request = {
                Application: application,
                Instance: instance,
            };
            _options = webapi_options;
        }
        return this._GetApplicationConfiguration(_request, _options);
    }
    async _GetPageConfiguration(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPageConfiguration", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPageConfiguration(application, instance, page, webapi_options) {
        let _request = null;
        let _options = null;
        const first = application;
        if (typeof (first) === "object" && first && (typeof (first.Application) != 'undefined' || typeof (first.Instance) != 'undefined' || typeof (first.Page) != 'undefined')) {
            _request = application;
            _options = instance;
        }
        else {
            _request = {
                Application: application,
                Instance: instance,
                Page: page,
            };
            _options = webapi_options;
        }
        return this._GetPageConfiguration(_request, _options);
    }
    async _GetObjectMapping(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetObjectMapping", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetObjectMapping(application, instance, webapi_options) {
        let _request = null;
        let _options = null;
        const first = application;
        if (typeof (first) === "object" && first && (typeof (first.Application) != 'undefined' || typeof (first.Instance) != 'undefined')) {
            _request = application;
            _options = instance;
        }
        else {
            _request = {
                Application: application,
                Instance: instance,
            };
            _options = webapi_options;
        }
        return this._GetObjectMapping(_request, _options);
    }
    async _GetFilterList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFilterList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFilterList(application, instance, webapi_options) {
        let _request = null;
        let _options = null;
        const first = application;
        if (typeof (first) === "object" && first && (typeof (first.Application) != 'undefined' || typeof (first.Instance) != 'undefined')) {
            _request = application;
            _options = instance;
        }
        else {
            _request = {
                Application: application,
                Instance: instance,
            };
            _options = webapi_options;
        }
        return this._GetFilterList(_request, _options);
    }
    async _ClearConfigurationCache(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ClearConfigurationCache", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ClearConfigurationCache(application, instance, forAllAssociates, webapi_options) {
        let _request = null;
        let _options = null;
        const first = application;
        if (typeof (first) === "object" && first && (typeof (first.Application) != 'undefined' || typeof (first.Instance) != 'undefined' || typeof (first.ForAllAssociates) != 'undefined')) {
            _request = application;
            _options = instance;
        }
        else {
            _request = {
                Application: application,
                Instance: instance,
                ForAllAssociates: forAllAssociates,
            };
            _options = webapi_options;
        }
        return this._ClearConfigurationCache(_request, _options);
    }
    async _GetAnyConfiguration(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAnyConfiguration", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAnyConfiguration(application, instance, item, type, webapi_options) {
        let _request = null;
        let _options = null;
        const first = application;
        if (typeof (first) === "object" && first && (typeof (first.Application) != 'undefined' || typeof (first.Instance) != 'undefined' || typeof (first.Item) != 'undefined' || typeof (first.Type) != 'undefined')) {
            _request = application;
            _options = instance;
        }
        else {
            _request = {
                Application: application,
                Instance: instance,
                Item: item,
                Type: type,
            };
            _options = webapi_options;
        }
        return this._GetAnyConfiguration(_request, _options);
    }
    async _GetEMarketingUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMarketingUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMarketingUrl(language, webapi_options) {
        let _request = null;
        let _options = null;
        const first = language;
        if (typeof (first) === "object" && first && (typeof (first.Language) != 'undefined')) {
            _request = language;
            _options = webapi_options;
        }
        else {
            _request = {
                Language: language,
            };
            _options = webapi_options;
        }
        return this._GetEMarketingUrl(_request, _options);
    }
    async _GetCsProgramUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCsProgramUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCsProgramUrl(language, programName, action, extraParameters, webapi_options) {
        let _request = null;
        let _options = null;
        const first = language;
        if (typeof (first) === "object" && first && (typeof (first.Language) != 'undefined' || typeof (first.ProgramName) != 'undefined' || typeof (first.Action) != 'undefined' || typeof (first.ExtraParameters) != 'undefined')) {
            _request = language;
            _options = programName;
        }
        else {
            _request = {
                Language: language,
                ProgramName: programName,
                Action: action,
                ExtraParameters: extraParameters,
            };
            _options = webapi_options;
        }
        return this._GetCsProgramUrl(_request, _options);
    }
    async _GetCSAuthUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCSAuthUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCSAuthUrl(language, programName, action, extraParameters, webapi_options) {
        let _request = null;
        let _options = null;
        const first = language;
        if (typeof (first) === "object" && first && (typeof (first.Language) != 'undefined' || typeof (first.ProgramName) != 'undefined' || typeof (first.Action) != 'undefined' || typeof (first.ExtraParameters) != 'undefined')) {
            _request = language;
            _options = programName;
        }
        else {
            _request = {
                Language: language,
                ProgramName: programName,
                Action: action,
                ExtraParameters: extraParameters,
            };
            _options = webapi_options;
        }
        return this._GetCSAuthUrl(_request, _options);
    }
    async _GetCSRegistryValue(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCSRegistryValue", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCSRegistryValue(entry, webapi_options) {
        let _request = null;
        let _options = null;
        const first = entry;
        if (typeof (first) === "object" && first && (typeof (first.Entry) != 'undefined')) {
            _request = entry;
            _options = webapi_options;
        }
        else {
            _request = {
                Entry: entry,
            };
            _options = webapi_options;
        }
        return this._GetCSRegistryValue(_request, _options);
    }
    async _GetCSWwwFolder(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCSWwwFolder", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * This method will get the www folder for CS
     * @returns The www folder for CS
     */
    async GetCSWwwFolder(webapi_options) {
        return this._GetCSWwwFolder(webapi_options);
    }
    async _GetRefreshedPageConfiguration(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRefreshedPageConfiguration", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetRefreshedPageConfiguration(application, instance, page, webapi_options) {
        let _request = null;
        let _options = null;
        const first = application;
        if (typeof (first) === "object" && first && (typeof (first.Application) != 'undefined' || typeof (first.Instance) != 'undefined' || typeof (first.Page) != 'undefined')) {
            _request = application;
            _options = instance;
        }
        else {
            _request = {
                Application: application,
                Instance: instance,
                Page: page,
            };
            _options = webapi_options;
        }
        return this._GetRefreshedPageConfiguration(_request, _options);
    }
    async _GetWwwUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWwwUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetWwwUrl(client, webapi_options) {
        let _request = null;
        let _options = null;
        const first = client;
        if (typeof (first) === "object" && first && (typeof (first.Client) != 'undefined')) {
            _request = client;
            _options = webapi_options;
        }
        else {
            _request = {
                Client: client,
            };
            _options = webapi_options;
        }
        return this._GetWwwUrl(_request, _options);
    }
    async _GetHelpDispatcherUrl(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHelpDispatcherUrl", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Will get the GetHelpDispatcherUrl used by the help system
     * @returns URL to be used by the help system
     */
    async GetHelpDispatcherUrl(webapi_options) {
        return this._GetHelpDispatcherUrl(webapi_options);
    }
    async _GetWwwUrlForSMWeb(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWwwUrlForSMWeb", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns the URL used for the logo by the SM.web client. Uses urldispatch.aspx
     * @returns Link to urldispatch.aspx tagged with [SOSITEURL]
     */
    async GetWwwUrlForSMWeb(webapi_options) {
        return this._GetWwwUrlForSMWeb(webapi_options);
    }
    async _GetCsCgiUrlInternal(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCsCgiUrlInternal", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * This method will get the host name for CS
     * @returns Will get the host name for where CS is installed
     */
    async GetCsCgiUrlInternal(webapi_options) {
        return this._GetCsCgiUrlInternal(webapi_options);
    }
    async _GetCRMUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCRMUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCRMUrl(soProtocol, currents, frameless, webapi_options) {
        let _request = null;
        let _options = null;
        const first = soProtocol;
        if (typeof (first) === "object" && first && (typeof (first.SoProtocol) != 'undefined' || typeof (first.Currents) != 'undefined' || typeof (first.Frameless) != 'undefined')) {
            _request = soProtocol;
            _options = currents;
        }
        else {
            _request = {
                SoProtocol: soProtocol,
                Currents: currents,
                Frameless: frameless,
            };
            _options = webapi_options;
        }
        return this._GetCRMUrl(_request, _options);
    }
    async _GetEmailNumberOfDays(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailNumberOfDays", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     *
     * @returns Number of days in the past for which we are fetching email
     */
    async GetEmailNumberOfDays(webapi_options) {
        return this._GetEmailNumberOfDays(webapi_options);
    }
    async _GetCustomerUrl(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCustomerUrl", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * This method will get the URL for the external access to the customer center
     * @returns The URL to the customer center, without any actions
     */
    async GetCustomerUrl(webapi_options) {
        return this._GetCustomerUrl(webapi_options);
    }
    async _GetSpfDomain(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSpfDomain", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the SPF domain defined for the mail cluster for this tenant (Online only)
     * @returns The configured SPF domain. Will return empty for Onsite installations or tenants in Online using custom SMTP
     */
    async GetSpfDomain(webapi_options) {
        return this._GetSpfDomain(webapi_options);
    }
    /*
     * Gets a DiaryViewEntity object.
     * @param diaryViewEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DiaryViewEntity
     */
    async GetDiaryViewEntity(diaryViewEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDiaryViewEntity?diaryViewEntityId=" + diaryViewEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DiaryViewEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a SystemEventEntity object.
     * @param systemEventEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SystemEventEntity
     */
    async GetSystemEventEntity(systemEventEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSystemEventEntity?systemEventEntityId=" + systemEventEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SystemEventEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _ExistsSystemEvent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExistsSystemEvent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ExistsSystemEvent(key, webapi_options) {
        let _request = null;
        let _options = null;
        const first = key;
        if (typeof (first) === "object" && first && (typeof (first.Key) != 'undefined')) {
            _request = key;
            _options = webapi_options;
        }
        else {
            _request = {
                Key: key,
            };
            _options = webapi_options;
        }
        return this._ExistsSystemEvent(_request, _options);
    }
    /*
     * Gets a WindowPosSize object.
     * @param windowPosSizeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single WindowPosSize
     */
    async GetWindowPosSize(windowPosSizeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetWindowPosSize?windowPosSizeId=" + windowPosSizeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WindowPosSize_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SaveWindowPosSize(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveWindowPosSize", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WindowPosSize_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveWindowPosSize(windowPosSize, webapi_options) {
        let _request = null;
        let _options = null;
        const first = windowPosSize;
        if (typeof (first) === "object" && first && (typeof (first.WindowPosSize) != 'undefined')) {
            _request = windowPosSize;
            _options = webapi_options;
        }
        else {
            _request = {
                WindowPosSize: windowPosSize,
            };
            _options = webapi_options;
        }
        return this._SaveWindowPosSize(_request, _options);
    }
    async _DeleteWindowPosSize(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteWindowPosSize", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteWindowPosSize(windowPosSizeId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = windowPosSizeId;
        if (typeof (first) === "object" && first && (typeof (first.WindowPosSizeId) != 'undefined')) {
            _request = windowPosSizeId;
            _options = webapi_options;
        }
        else {
            _request = {
                WindowPosSizeId: windowPosSizeId,
            };
            _options = webapi_options;
        }
        return this._DeleteWindowPosSize(_request, _options);
    }
    /*
     * Gets an array of WindowPosSize objects.
     * @param windowPosSizeIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of WindowPosSize
     */
    async GetWindowPosSizeList(windowPosSizeIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetWindowPosSizeList", windowPosSizeIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WindowPosSizeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetMyWindowPosSizes(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyWindowPosSizes", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WindowPosSizeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets the window and dialog position and size settings belonging to the currently logged on user
     * @returns Array of window and dialog position and size settings
     */
    async GetMyWindowPosSizes(webapi_options) {
        return this._GetMyWindowPosSizes(webapi_options);
    }
    async _GetWindowPosSizesOnPersonId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWindowPosSizesOnPersonId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WindowPosSizeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetWindowPosSizesOnPersonId(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetWindowPosSizesOnPersonId(_request, _options);
    }
    async _GetWindowPosSizesOnAssociateId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWindowPosSizesOnAssociateId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WindowPosSizeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetWindowPosSizesOnAssociateId(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._GetWindowPosSizesOnAssociateId(_request, _options);
    }
    async _SaveWindowPosSizes(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveWindowPosSizes", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WindowPosSizeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveWindowPosSizes(windowPosSizes, webapi_options) {
        let _request = null;
        let _options = null;
        const first = windowPosSizes;
        if (typeof (first) === "object" && first && (typeof (first.WindowPosSizes) != 'undefined')) {
            _request = windowPosSizes;
            _options = webapi_options;
        }
        else {
            _request = {
                WindowPosSizes: windowPosSizes,
            };
            _options = webapi_options;
        }
        return this._SaveWindowPosSizes(_request, _options);
    }
} // class v1ConfigurationAgentController 
exports.ConfigurationAgent = ConfigurationAgent;
//# sourceMappingURL=ConfigurationAgent.js.map
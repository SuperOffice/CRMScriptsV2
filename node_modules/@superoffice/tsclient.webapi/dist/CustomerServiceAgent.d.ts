import { AxiosRequestConfig } from 'axios';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
/**
 * Agent used for Customer Service methods
 */
export interface ICustomerServiceAgent {
    CreateDefaultCustomerCenterConfig(): Promise<carriers.CustomerCenterConfig>;
    SaveCustomerCenterConfig(entity: carriers.CustomerCenterConfig): Promise<carriers.CustomerCenterConfig>;
    DeleteCustomerCenterConfig(CustomerCenterConfigId: number): Promise<void>;
    CreateDefaultMailboxEntity(): Promise<carriers.MailboxEntity>;
    SaveMailboxEntity(entity: carriers.MailboxEntity): Promise<carriers.MailboxEntity>;
    CreateDefaultSmsConfig(): Promise<carriers.SmsConfig>;
    SaveSmsConfig(entity: carriers.SmsConfig): Promise<carriers.SmsConfig>;
    UpdateFeatureToggles(request: carriers.CustomerService_UpdateFeatureTogglesRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    UpdateFeatureToggles(featureToggles: carriers.CsFeatureToggle[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    EventHandlerExists(request: carriers.CustomerService_EventHandlerExistsRequest, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    EventHandlerExists(eventHandlerType: enums.EventHandlerType, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    CreateSession(request: carriers.CustomerService_CreateSessionRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CsSessionKey>;
    CreateSession(remoteIp: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CsSessionKey>;
    RemoveSession(request: carriers.CustomerService_RemoveSessionRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    RemoveSession(loginId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SessionIsValid(request: carriers.CustomerService_SessionIsValidRequest, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    SessionIsValid(csSessionKey: string, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    HasChatNotify(webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    CheckSymmetricEncryption(request: carriers.CustomerService_CheckSymmetricEncryptionRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    CheckSymmetricEncryption(encryptedString: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    ReportSessionActive(request: carriers.CustomerService_ReportSessionActiveRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    ReportSessionActive(sessionKey: string, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    GetCustomerCenterConfig(customerCenterConfigId: number): Promise<carriers.CustomerCenterConfig>;
    GetAllCustomerCenterConfigs(webapi_options?: base.WebApiRequestOptions): Promise<carriers.CustomerCenterConfig[]>;
    SaveAllCustomerCenterConfigs(request: carriers.CustomerService_SaveAllCustomerCenterConfigsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SaveAllCustomerCenterConfigs(custConfigs: carriers.CustomerCenterConfig[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    CheckIfCustomizedTemplates(webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    GetProgramUrl(request: carriers.CustomerService_GetProgramUrlRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetProgramUrl(programName: string, external: boolean, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetFaqForCustomer(request: carriers.CustomerService_GetFaqForCustomerRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetFaqForCustomer(faqEntryId: number, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetCustomerServiceStartup(webapi_options?: base.WebApiRequestOptions): Promise<carriers.CustomerServiceStartup>;
    ExecuteEventHandlers(request: carriers.CustomerService_ExecuteEventHandlersRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.EventData>;
    ExecuteEventHandlers(eventData: carriers.EventData, webapi_options?: base.WebApiRequestOptions): Promise<carriers.EventData>;
    GetMailboxes(webapi_options?: base.WebApiRequestOptions): Promise<carriers.Mailbox[]>;
    GetMailboxEntity(mailboxEntityId: number): Promise<carriers.MailboxEntity>;
    GetPreviewFaqEntry(request: carriers.CustomerService_GetPreviewFaqEntryRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewFaqEntry>;
    GetPreviewFaqEntry(kbEntryId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewFaqEntry>;
    GetPreviewQuickReply(request: carriers.CustomerService_GetPreviewQuickReplyRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewQuickReply>;
    GetPreviewQuickReply(quickReplyId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewQuickReply>;
    GetPreviewReplyTemplate(request: carriers.CustomerService_GetPreviewReplyTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewReplyTemplate>;
    GetPreviewReplyTemplate(replyTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewReplyTemplate>;
    GetParsedTemplate(request: carriers.CustomerService_GetParsedTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReplyTemplateParsed>;
    GetParsedTemplate(replyTemplateId: number, languageId: number, personId: number, ticketId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReplyTemplateParsed>;
    GetUnparsedTemplate(request: carriers.CustomerService_GetUnparsedTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReplyTemplateParsed>;
    GetUnparsedTemplate(replyTemplateId: number, languageId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReplyTemplateParsed>;
    GetSmsConfig(webapi_options?: base.WebApiRequestOptions): Promise<carriers.SmsConfig>;
    TestSmtpServer(request: carriers.CustomerService_TestSmtpServerRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.SmtpTestResult>;
    TestSmtpServer(smtpUri: string, from: string, useStoredPassword: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.SmtpTestResult>;
    GetStatistics(request: carriers.CustomerService_GetStatisticsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StatisticsDataSet[]>;
    GetStatistics(functions: enums.StatusScreenPanelType[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.StatisticsDataSet[]>;
    GetSystemTemplateSettings(webapi_options?: base.WebApiRequestOptions): Promise<carriers.SystemTemplateSettings>;
    SaveSystemTemplateSettings(request: carriers.CustomerService_SaveSystemTemplateSettingsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.SystemTemplateSettings>;
    SaveSystemTemplateSettings(systemTemplateSettings: carriers.SystemTemplateSettings, webapi_options?: base.WebApiRequestOptions): Promise<carriers.SystemTemplateSettings>;
    CreateTicketFromMailData(request: carriers.CustomerService_CreateTicketFromMailDataRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo>;
    CreateTicketFromMailData(mailboxId: number, data: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo>;
    AddMessageFromMailData(request: carriers.CustomerService_AddMessageFromMailDataRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo>;
    AddMessageFromMailData(ticketId: number, data: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo>;
    FindTicketsByTitleOrId(request: carriers.CustomerService_FindTicketsByTitleOrIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo[]>;
    FindTicketsByTitleOrId(titleOrId: string, maxRows: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo[]>;
}
/**
 * Agent used for Customer Service methods
 */
export declare class CustomerServiceAgent extends base.WebApiBase implements ICustomerServiceAgent {
    constructor(baseUrl?: string, languageCode?: string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager: any);
    constructor(baseUrl: string, config: AxiosRequestConfig, resourceManager: any);
    constructor(baseUrl: string, config: AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config: AxiosRequestConfig, languageCode?: string, cultureCode?: string);
    constructor(options: base.WebApiOptions);
    /**
     * Set default values into a new CustomerCenterConfig.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultCustomerCenterConfig(options?: base.WebApiRequestOptions): Promise<carriers.CustomerCenterConfig>;
    SaveCustomerCenterConfig(entity: carriers.CustomerCenterConfig, options?: base.WebApiRequestOptions): Promise<carriers.CustomerCenterConfig>;
    DeleteCustomerCenterConfig(CustomerCenterConfigId: number, options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Set default values into a new MailboxEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultMailboxEntity(options?: base.WebApiRequestOptions): Promise<carriers.MailboxEntity>;
    SaveMailboxEntity(entity: carriers.MailboxEntity, options?: base.WebApiRequestOptions): Promise<carriers.MailboxEntity>;
    /**
     * Set default values into a new SmsConfig.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultSmsConfig(options?: base.WebApiRequestOptions): Promise<carriers.SmsConfig>;
    SaveSmsConfig(entity: carriers.SmsConfig, options?: base.WebApiRequestOptions): Promise<carriers.SmsConfig>;
    private _UpdateFeatureToggles;
    /**
     * Update the cached FeatureToggles for CS
     * @param request - FeatureToggles
     * @returns
     */
    UpdateFeatureToggles(request: carriers.CustomerService_UpdateFeatureTogglesRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Update the cached FeatureToggles for CS
     * @param featureToggles - Feature toggle name / state
     * @returns
     */
    UpdateFeatureToggles(featureToggles: carriers.CsFeatureToggle[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _EventHandlerExists;
    /**
     * Check if an eventhandler exists for a given enum
     * @param request - EventHandlerType
     * @returns True if it exists
     */
    EventHandlerExists(request: carriers.CustomerService_EventHandlerExistsRequest, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    /**
     * Check if an eventhandler exists for a given enum
     * @param eventHandlerType - The EventHandlerType we are checking
     * @returns True if it exists
     */
    EventHandlerExists(eventHandlerType: enums.EventHandlerType, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    private _CreateSession;
    /**
     * Creates a login session for a CS user
     * @param request - RemoteIp
     * @returns The session key information
     */
    CreateSession(request: carriers.CustomerService_CreateSessionRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CsSessionKey>;
    /**
     * Creates a login session for a CS user
     * @param remoteIp - The ip of the client creating the session
     * @returns The session key information
     */
    CreateSession(remoteIp: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CsSessionKey>;
    private _RemoveSession;
    /**
     * Remove a login session for a CS user
     * @param request - LoginId
     * @returns
     */
    RemoveSession(request: carriers.CustomerService_RemoveSessionRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Remove a login session for a CS user
     * @param loginId - The login id to remove
     * @returns
     */
    RemoveSession(loginId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _SessionIsValid;
    /**
     * Check if a CS session is valid
     * @param request - CsSessionKey
     * @returns True if there is a valid CS session based on the session key
     */
    SessionIsValid(request: carriers.CustomerService_SessionIsValidRequest, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    /**
     * Check if a CS session is valid
     * @param csSessionKey - The CS session key to check
     * @returns True if there is a valid CS session based on the session key
     */
    SessionIsValid(csSessionKey: string, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    private _HasChatNotify;
    /**
     * Check if user has any chat notification
     * @returns True if the user has at least one notification setting on
     */
    HasChatNotify(webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    private _CheckSymmetricEncryption;
    /**
     * Do a test to check that we are using the same encryption keys
     * @param request - EncryptedString
     * @returns Encrypted version of the string done by NetServer
     */
    CheckSymmetricEncryption(request: carriers.CustomerService_CheckSymmetricEncryptionRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Do a test to check that we are using the same encryption keys
     * @param encryptedString - An encrypted version of the string
     * @returns Encrypted version of the string done by NetServer
     */
    CheckSymmetricEncryption(encryptedString: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _ReportSessionActive;
    /**
     * Report a session as being &apos;active&apos;; will update the corresponding row in login table, but not more than once per minute/session
     * @param request - SessionKey
     * @returns The ID of the login table row, or 0 if not found
     */
    ReportSessionActive(request: carriers.CustomerService_ReportSessionActiveRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    /**
     * Report a session as being &apos;active&apos;; will update the corresponding row in login table, but not more than once per minute/session
     * @param sessionKey - CS session key, matching the 'login' table
     * @returns The ID of the login table row, or 0 if not found
     */
    ReportSessionActive(sessionKey: string, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    GetCustomerCenterConfig(customerCenterConfigId: number, options?: base.WebApiRequestOptions): Promise<carriers.CustomerCenterConfig>;
    private _GetAllCustomerCenterConfigs;
    /**
     * Get all rows from cust_config as an array of CustomerCenterConfig entities
     * @returns An array of CustomerCenterConfig entities
     */
    GetAllCustomerCenterConfigs(webapi_options?: base.WebApiRequestOptions): Promise<carriers.CustomerCenterConfig[]>;
    private _SaveAllCustomerCenterConfigs;
    /**
     * Save an array of CustomerCenterConfig entities to the database
     * @param request - CustConfigs
     * @returns void
     */
    SaveAllCustomerCenterConfigs(request: carriers.CustomerService_SaveAllCustomerCenterConfigsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Save an array of CustomerCenterConfig entities to the database
     * @param custConfigs - The CustomerCenterConfig entities to be saved. If the id does not exists, a new one will be created. Unknown ids will be skipped
     * @returns void
     */
    SaveAllCustomerCenterConfigs(custConfigs: carriers.CustomerCenterConfig[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _CheckIfCustomizedTemplates;
    /**
     * Checks whether the core html templates are customized
     * @returns True if the templates are customized
     */
    CheckIfCustomizedTemplates(webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    private _GetProgramUrl;
    /**
     * This method will convert a module name into a Service URL.
     * @param request - ProgramName, External
     * @returns Returns a valid Service URL composed of the give parameters.
     */
    GetProgramUrl(request: carriers.CustomerService_GetProgramUrlRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * This method will convert a module name into a Service URL.
     * @param programName - In this parameter you must specify which CS program you want to create an URL for. Valid examples are "ticket", "rms", "spm" etc.
     * @param external - If set to true, this will generate URLs that are accesible from the outside (for example Internet)
     * @returns Returns a valid Service URL composed of the give parameters.
     */
    GetProgramUrl(programName: string, external: boolean, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _GetFaqForCustomer;
    /**
     * Get a FAQ entry, ment to be displayed for a customer. This can either be a link to the FAQ entry on Custom Center, or it can be the answer and question. This is dependent on Registry setting with reg_id=157
     * @param request - FaqEntryId
     * @returns The FAQ to show to the customer. Either a clickable link or the question/answer itself.
     */
    GetFaqForCustomer(request: carriers.CustomerService_GetFaqForCustomerRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Get a FAQ entry, ment to be displayed for a customer. This can either be a link to the FAQ entry on Custom Center, or it can be the answer and question. This is dependent on Registry setting with reg_id=157
     * @param faqEntryId - The id of the FAQ entry to get. Only FAQ entries with access level public (both for unauthenticated and autenticated customer) will be returned
     * @returns The FAQ to show to the customer. Either a clickable link or the question/answer itself.
     */
    GetFaqForCustomer(faqEntryId: number, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _GetCustomerServiceStartup;
    /**
     * Get the carrier with data that Service needs when starting up
     * @returns The carrier containing the startup data
     */
    GetCustomerServiceStartup(webapi_options?: base.WebApiRequestOptions): Promise<carriers.CustomerServiceStartup>;
    private _ExecuteEventHandlers;
    /**
     * This method will execute event handlers in CRMScript for a given event.
     * @param request - EventData
     * @returns The EventData instance after event handler execution
     */
    ExecuteEventHandlers(request: carriers.CustomerService_ExecuteEventHandlersRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.EventData>;
    /**
     * This method will execute event handlers in CRMScript for a given event.
     * @param eventData - The EventData instance sent to the event handler
     * @returns The EventData instance after event handler execution
     */
    ExecuteEventHandlers(eventData: carriers.EventData, webapi_options?: base.WebApiRequestOptions): Promise<carriers.EventData>;
    private _GetMailboxes;
    /**
     * This method will get all registered mailboxes in Service
     * @returns An array of Mailbox objects
     */
    GetMailboxes(webapi_options?: base.WebApiRequestOptions): Promise<carriers.Mailbox[]>;
    GetMailboxEntity(mailboxEntityId: number, options?: base.WebApiRequestOptions): Promise<carriers.MailboxEntity>;
    private _GetPreviewFaqEntry;
    /**
     * Get a faq entry from its faq entry id
     * @param request - KbEntryId
     * @returns FAQ entry suitable for preview
     */
    GetPreviewFaqEntry(request: carriers.CustomerService_GetPreviewFaqEntryRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewFaqEntry>;
    /**
     * Get a faq entry from its faq entry id
     * @param kbEntryId - FAQ entry ID
     * @returns FAQ entry suitable for preview
     */
    GetPreviewFaqEntry(kbEntryId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewFaqEntry>;
    private _GetPreviewQuickReply;
    /**
     * Get a quick reply from its quick reply id
     * @param request - QuickReplyId
     * @returns Quick reply suitable for preview
     */
    GetPreviewQuickReply(request: carriers.CustomerService_GetPreviewQuickReplyRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewQuickReply>;
    /**
     * Get a quick reply from its quick reply id
     * @param quickReplyId - Quick reply ID
     * @returns Quick reply suitable for preview
     */
    GetPreviewQuickReply(quickReplyId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewQuickReply>;
    private _GetPreviewReplyTemplate;
    /**
     * Get a reply template from its reply template id
     * @param request - ReplyTemplateId
     * @returns Reply template suitable for preview
     */
    GetPreviewReplyTemplate(request: carriers.CustomerService_GetPreviewReplyTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewReplyTemplate>;
    /**
     * Get a reply template from its reply template id
     * @param replyTemplateId - Reply template ID
     * @returns Reply template suitable for preview
     */
    GetPreviewReplyTemplate(replyTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.PreviewReplyTemplate>;
    private _GetParsedTemplate;
    /**
     * Get a specific langauge version of the reply template, and run this trough the parser
     * @param request - ReplyTemplateId, LanguageId, PersonId, TicketId
     * @returns The parsed reply template
     */
    GetParsedTemplate(request: carriers.CustomerService_GetParsedTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReplyTemplateParsed>;
    /**
     * Get a specific langauge version of the reply template, and run this trough the parser
     * @param replyTemplateId - The id of the reply template
     * @param languageId - The language id (prefered language). If 0 is given, the language of the person will be used
     * @param personId - The id of the person that will be populated into the parser
     * @param ticketId - The id of the ticket that will be populated into the parser
     * @returns The parsed reply template
     */
    GetParsedTemplate(replyTemplateId: number, languageId: number, personId: number, ticketId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReplyTemplateParsed>;
    private _GetUnparsedTemplate;
    /**
     * Get a specific langauge version of the reply template. No parsing is performed.
     * @param request - ReplyTemplateId, LanguageId
     * @returns The unparsed reply template, but using the same return data structure
     */
    GetUnparsedTemplate(request: carriers.CustomerService_GetUnparsedTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReplyTemplateParsed>;
    /**
     * Get a specific langauge version of the reply template. No parsing is performed.
     * @param replyTemplateId - The id of the reply template
     * @param languageId - The language id (prefered language). If 0 is given, the language of the person will be used
     * @returns The unparsed reply template, but using the same return data structure
     */
    GetUnparsedTemplate(replyTemplateId: number, languageId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReplyTemplateParsed>;
    private _GetSmsConfig;
    /**
     * Get the SmsConfig settings for Customer Service sms providers.
     * @returns Current SMS configuration.
     */
    GetSmsConfig(webapi_options?: base.WebApiRequestOptions): Promise<carriers.SmsConfig>;
    private _TestSmtpServer;
    /**
     * This method will do a test of a SMTP account, by sending an email to a special @superoffice.com account
     * @param request - SmtpUri, From, UseStoredPassword
     * @returns Contains the result of the test
     */
    TestSmtpServer(request: carriers.CustomerService_TestSmtpServerRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.SmtpTestResult>;
    /**
     * This method will do a test of a SMTP account, by sending an email to a special @superoffice.com account
     * @param smtpUri - An URI containing information to connect to the SMTP server, eg. smtps://myuser:mypassword@smtp.myserver.com:465. Note that username and password must be url encoded
     * @param from - The from-address used in the test
     * @param useStoredPassword - Use database persisted password
     * @returns Contains the result of the test
     */
    TestSmtpServer(smtpUri: string, from: string, useStoredPassword: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.SmtpTestResult>;
    private _GetStatistics;
    /**
     * Returns the calculated results for the required statistics for the Customer Service Status Page
     * @param request - Functions
     * @returns Array of StatisticsDataSet
     */
    GetStatistics(request: carriers.CustomerService_GetStatisticsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StatisticsDataSet[]>;
    /**
     * Returns the calculated results for the required statistics for the Customer Service Status Page
     * @param functions - List of functions to calculate and return
     * @returns Array of StatisticsDataSet
     */
    GetStatistics(functions: enums.StatusScreenPanelType[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.StatisticsDataSet[]>;
    private _GetSystemTemplateSettings;
    /**
     * Returns system template settings
     * @returns System template settings item
     */
    GetSystemTemplateSettings(webapi_options?: base.WebApiRequestOptions): Promise<carriers.SystemTemplateSettings>;
    private _SaveSystemTemplateSettings;
    /**
     * Saves and validates updated system templates. Throws exception if validation fails
     * @param request - SystemTemplateSettings
     * @returns Updated system template settings
     */
    SaveSystemTemplateSettings(request: carriers.CustomerService_SaveSystemTemplateSettingsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.SystemTemplateSettings>;
    /**
     * Saves and validates updated system templates. Throws exception if validation fails
     * @param systemTemplateSettings - System template settings item with updated values
     * @returns Updated system template settings
     */
    SaveSystemTemplateSettings(systemTemplateSettings: carriers.SystemTemplateSettings, webapi_options?: base.WebApiRequestOptions): Promise<carriers.SystemTemplateSettings>;
    private _CreateTicketFromMailData;
    /**
     * This method create a new ticket in the same way as importMail would import an email. It accepts RFC822 formatted data
     * @param request - MailboxId, Data
     * @returns An object containing some meta data for the created ticket
     */
    CreateTicketFromMailData(request: carriers.CustomerService_CreateTicketFromMailDataRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo>;
    /**
     * This method create a new ticket in the same way as importMail would import an email. It accepts RFC822 formatted data
     * @param mailboxId - The id of the Service mailbox
     * @param data - RFC822 formatted data to import as a ticket
     * @returns An object containing some meta data for the created ticket
     */
    CreateTicketFromMailData(mailboxId: number, data: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo>;
    private _AddMessageFromMailData;
    /**
     * This method will add a message to an existing request in the sam way as importMail would do it from an email. It accepts RFC822 formatted data
     * @param request - TicketId, Data
     * @returns An object containing some meta data for the ticket
     */
    AddMessageFromMailData(request: carriers.CustomerService_AddMessageFromMailDataRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo>;
    /**
     * This method will add a message to an existing request in the sam way as importMail would do it from an email. It accepts RFC822 formatted data
     * @param ticketId - The id of the ticket to add a message
     * @param data - RFC822 formatted data to import as a message
     * @returns An object containing some meta data for the ticket
     */
    AddMessageFromMailData(ticketId: number, data: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo>;
    private _FindTicketsByTitleOrId;
    /**
     * This method wil search for tickets matching title or id
     * @param request - TitleOrId, MaxRows
     * @returns An array of objects containing some meta data for matching tickets
     */
    FindTicketsByTitleOrId(request: carriers.CustomerService_FindTicketsByTitleOrIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo[]>;
    /**
     * This method wil search for tickets matching title or id
     * @param titleOrId - The search string. If this is a number, it will also search for a matching ticket id
     * @param maxRows - The maximum number of rows to be returned
     * @returns An array of objects containing some meta data for matching tickets
     */
    FindTicketsByTitleOrId(titleOrId: string, maxRows: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketInfo[]>;
}
//# sourceMappingURL=CustomerServiceAgent.d.ts.map
"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.PocketAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Agent with Pocket specific functionality
 */
class PocketAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Pocket/";
        super(options);
    }
    async _GetMyCallerIDs(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyCallerIDs", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CallerIDCollection_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMyCallerIDs(lastHash, minDate, maxDate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = lastHash;
        if (typeof (first) === "object" && first && (typeof (first.LastHash) != 'undefined' || typeof (first.MinDate) != 'undefined' || typeof (first.MaxDate) != 'undefined')) {
            _request = lastHash;
            _options = minDate;
        }
        else {
            _request = {
                LastHash: lastHash,
                MinDate: minDate,
                MaxDate: maxDate,
            };
            _options = webapi_options;
        }
        return this._GetMyCallerIDs(_request, _options);
    }
    async _GetCallerIDsFromSelection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCallerIDsFromSelection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CallerIDCollection_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCallerIDsFromSelection(selectionId, lastHash, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.LastHash) != 'undefined')) {
            _request = selectionId;
            _options = lastHash;
        }
        else {
            _request = {
                SelectionId: selectionId,
                LastHash: lastHash,
            };
            _options = webapi_options;
        }
        return this._GetCallerIDsFromSelection(_request, _options);
    }
    async _GetPocketStartupData(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPocketStartupData", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PocketStartupData_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPocketStartupData(tables, currentClientTime, webapi_options) {
        let _request = null;
        let _options = null;
        const first = tables;
        if (typeof (first) === "object" && first && (typeof (first.Tables) != 'undefined' || typeof (first.CurrentClientTime) != 'undefined')) {
            _request = tables;
            _options = currentClientTime;
        }
        else {
            _request = {
                Tables: tables,
                CurrentClientTime: currentClientTime,
            };
            _options = webapi_options;
        }
        return this._GetPocketStartupData(_request, _options);
    }
    async _RegisterDeviceForPushNotification(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RegisterDeviceForPushNotification", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RegisterDeviceForPushNotification(deviceInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = deviceInfo;
        if (typeof (first) === "object" && first && (typeof (first.DeviceInfo) != 'undefined')) {
            _request = deviceInfo;
            _options = webapi_options;
        }
        else {
            _request = {
                DeviceInfo: deviceInfo,
            };
            _options = webapi_options;
        }
        return this._RegisterDeviceForPushNotification(_request, _options);
    }
    async _GetRegisteredDevices(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRegisteredDevices", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PocketDeviceInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetRegisteredDevices(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._GetRegisteredDevices(_request, _options);
    }
    async _SetPushNotificationTagsForDevice(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPushNotificationTagsForDevice", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetPushNotificationTagsForDevice(deviceIdentifier, tags, webapi_options) {
        let _request = null;
        let _options = null;
        const first = deviceIdentifier;
        if (typeof (first) === "object" && first && (typeof (first.DeviceIdentifier) != 'undefined' || typeof (first.Tags) != 'undefined')) {
            _request = deviceIdentifier;
            _options = tags;
        }
        else {
            _request = {
                DeviceIdentifier: deviceIdentifier,
                Tags: tags,
            };
            _options = webapi_options;
        }
        return this._SetPushNotificationTagsForDevice(_request, _options);
    }
    async _SetPushNotificationTagsForUser(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPushNotificationTagsForUser", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetPushNotificationTagsForUser(associateId, tags, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Tags) != 'undefined')) {
            _request = associateId;
            _options = tags;
        }
        else {
            _request = {
                AssociateId: associateId,
                Tags: tags,
            };
            _options = webapi_options;
        }
        return this._SetPushNotificationTagsForUser(_request, _options);
    }
    async _GetPushNotificationTagsForDevice(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPushNotificationTagsForDevice", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPushNotificationTagsForDevice(deviceIdentifier, webapi_options) {
        let _request = null;
        let _options = null;
        const first = deviceIdentifier;
        if (typeof (first) === "object" && first && (typeof (first.DeviceIdentifier) != 'undefined')) {
            _request = deviceIdentifier;
            _options = webapi_options;
        }
        else {
            _request = {
                DeviceIdentifier: deviceIdentifier,
            };
            _options = webapi_options;
        }
        return this._GetPushNotificationTagsForDevice(_request, _options);
    }
    async _SendPushNotification(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendPushNotification", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SendPushNotification(associateIds, message, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateIds;
        if (typeof (first) === "object" && first && (typeof (first.AssociateIds) != 'undefined' || typeof (first.Message) != 'undefined')) {
            _request = associateIds;
            _options = message;
        }
        else {
            _request = {
                AssociateIds: associateIds,
                Message: message,
            };
            _options = webapi_options;
        }
        return this._SendPushNotification(_request, _options);
    }
    async _RunAppointmentAlarmBroker(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RunAppointmentAlarmBroker", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Execute the AppointmentAlarmBroker once
     * @returns This method has no return value
     */
    async RunAppointmentAlarmBroker(webapi_options) {
        return this._RunAppointmentAlarmBroker(webapi_options);
    }
    async _NotifyUsers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotifyUsers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async NotifyUsers(notificationEventType, id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = notificationEventType;
        if (typeof (first) === "object" && first && (typeof (first.NotificationEventType) != 'undefined' || typeof (first.Id) != 'undefined')) {
            _request = notificationEventType;
            _options = id;
        }
        else {
            _request = {
                NotificationEventType: notificationEventType,
                Id: id,
            };
            _options = webapi_options;
        }
        return this._NotifyUsers(_request, _options);
    }
    async _NotificationHandled(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotificationHandled", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async NotificationHandled(notificationEventType, id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = notificationEventType;
        if (typeof (first) === "object" && first && (typeof (first.NotificationEventType) != 'undefined' || typeof (first.Id) != 'undefined')) {
            _request = notificationEventType;
            _options = id;
        }
        else {
            _request = {
                NotificationEventType: notificationEventType,
                Id: id,
            };
            _options = webapi_options;
        }
        return this._NotificationHandled(_request, _options);
    }
    async _NotificationsHandled(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotificationsHandled", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async NotificationsHandled(notificationEvents, webapi_options) {
        let _request = null;
        let _options = null;
        const first = notificationEvents;
        if (typeof (first) === "object" && first && (typeof (first.NotificationEvents) != 'undefined')) {
            _request = notificationEvents;
            _options = webapi_options;
        }
        else {
            _request = {
                NotificationEvents: notificationEvents,
            };
            _options = webapi_options;
        }
        return this._NotificationsHandled(_request, _options);
    }
} // class v1PocketAgentController 
exports.PocketAgent = PocketAgent;
//# sourceMappingURL=PocketAgent.js.map
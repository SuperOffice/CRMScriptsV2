"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.EMailAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
const Base64_1 = require("./Base64");
/**
 * Email connection, reading, sending
 */
class EMailAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/EMail/";
        super(options);
    }
    /**
     * Set default values into a new EMailAccount.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailAccount(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailAccount", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAccount_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing EMailAccount or creates a new EMailAccount if the id parameter is empty
     * @param entity - The EMailAccount to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated EMailAccount
     */
    async SaveEMailAccount(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveEMailAccount", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAccount_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the EMailAccount
     * @param EMailAccountId - The id of the EMailAccount to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteEMailAccount(EMailAccountId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteEMailAccount?EMailAccountId=" + EMailAccountId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailAddress.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailAddress(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailAddress", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAddress_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailAppointment.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailAppointment(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailAppointment", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAppointment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailAttachment.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailAttachment(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailAttachment", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAttachment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailConnectionInfo.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailConnectionInfo(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailConnectionInfo", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailConnectionInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailConnectionInfoExtended.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailConnectionInfoExtended(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailConnectionInfoExtended", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailConnectionInfoExtended_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailCustomHeader.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailCustomHeader(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailCustomHeader", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailCustomHeader_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailEnvelope.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailEnvelope(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailEnvelope", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEnvelope_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailFolder.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailFolder(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailFolder", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailFolder_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new EMailSOInfo.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultEMailSOInfo(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultEMailSOInfo", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailSOInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a EMailAccount object.
     * @param eMailAccountId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single EMailAccount
     */
    async GetEMailAccount(eMailAccountId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetEMailAccount?eMailAccountId=" + eMailAccountId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAccount_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetEMailAccountFromEMailAddress(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailAccountFromEMailAddress", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAccount_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailAccountFromEMailAddress(fromAddress, webapi_options) {
        let _request = null;
        let _options = null;
        const first = fromAddress;
        if (typeof (first) === "object" && first && (typeof (first.FromAddress) != 'undefined')) {
            _request = fromAddress;
            _options = webapi_options;
        }
        else {
            _request = {
                FromAddress: fromAddress,
            };
            _options = webapi_options;
        }
        return this._GetEMailAccountFromEMailAddress(_request, _options);
    }
    async _GetCurrentAccountId(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCurrentAccountId", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get current accountId (last logged into should normally be current) for logged in associate
     * @returns Id of current account
     */
    async GetCurrentAccountId(webapi_options) {
        return this._GetCurrentAccountId(webapi_options);
    }
    async _GetCurrentAccount(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCurrentAccount", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAccount_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get current account (last logged into should normally be current) for logged in associate
     * @returns Id of current account
     */
    async GetCurrentAccount(webapi_options) {
        return this._GetCurrentAccount(webapi_options);
    }
    async _GetPersonEntitiesFromEmailAddress(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonEntitiesFromEmailAddress", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonEntitiesFromEmailAddress(emailAddress, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailAddress;
        if (typeof (first) === "object" && first && (typeof (first.EmailAddress) != 'undefined')) {
            _request = emailAddress;
            _options = webapi_options;
        }
        else {
            _request = {
                EmailAddress: emailAddress,
            };
            _options = webapi_options;
        }
        return this._GetPersonEntitiesFromEmailAddress(_request, _options);
    }
    async _GetPersonsFromEmailAddress(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonsFromEmailAddress", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonsFromEmailAddress(emailAddress, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailAddress;
        if (typeof (first) === "object" && first && (typeof (first.EmailAddress) != 'undefined')) {
            _request = emailAddress;
            _options = webapi_options;
        }
        else {
            _request = {
                EmailAddress: emailAddress,
            };
            _options = webapi_options;
        }
        return this._GetPersonsFromEmailAddress(_request, _options);
    }
    async _HasMXRecord(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasMXRecord", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async HasMXRecord(mailDomain, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mailDomain;
        if (typeof (first) === "object" && first && (typeof (first.MailDomain) != 'undefined')) {
            _request = mailDomain;
            _options = webapi_options;
        }
        else {
            _request = {
                MailDomain: mailDomain,
            };
            _options = webapi_options;
        }
        return this._HasMXRecord(_request, _options);
    }
    async _HasSPFRecord(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasSPFRecord", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async HasSPFRecord(sourceSpf, targetDomain, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourceSpf;
        if (typeof (first) === "object" && first && (typeof (first.SourceSpf) != 'undefined' || typeof (first.TargetDomain) != 'undefined')) {
            _request = sourceSpf;
            _options = targetDomain;
        }
        else {
            _request = {
                SourceSpf: sourceSpf,
                TargetDomain: targetDomain,
            };
            _options = webapi_options;
        }
        return this._HasSPFRecord(_request, _options);
    }
    async _ResolveEMailRecipients(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResolveEMailRecipients", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAddressArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ResolveEMailRecipients(emailAddress, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailAddress;
        if (typeof (first) === "object" && first && (typeof (first.EmailAddress) != 'undefined')) {
            _request = emailAddress;
            _options = webapi_options;
        }
        else {
            _request = {
                EmailAddress: emailAddress,
            };
            _options = webapi_options;
        }
        return this._ResolveEMailRecipients(_request, _options);
    }
    async _GetEMailFromId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailFromId(connectionInfo, messageServerId, lookupAddresses, flags, includeAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.MessageServerId) != 'undefined' || typeof (first.LookupAddresses) != 'undefined' || typeof (first.Flags) != 'undefined' || typeof (first.IncludeAttachments) != 'undefined')) {
            _request = connectionInfo;
            _options = messageServerId;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                MessageServerId: messageServerId,
                LookupAddresses: lookupAddresses,
                Flags: flags,
                IncludeAttachments: includeAttachments,
            };
            _options = webapi_options;
        }
        return this._GetEMailFromId(_request, _options);
    }
    async _SendEMails(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendEMails", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SendEMails(outgoingConnectionInfo, emails, sentItemsConnectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = outgoingConnectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.OutgoingConnectionInfo) != 'undefined' || typeof (first.Emails) != 'undefined' || typeof (first.SentItemsConnectionInfo) != 'undefined')) {
            _request = outgoingConnectionInfo;
            _options = emails;
        }
        else {
            _request = {
                OutgoingConnectionInfo: outgoingConnectionInfo,
                Emails: emails,
                SentItemsConnectionInfo: sentItemsConnectionInfo,
            };
            _options = webapi_options;
        }
        return this._SendEMails(_request, _options);
    }
    async _SaveEMail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveEMail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveEMail(connectionInfo, email, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.Email) != 'undefined')) {
            _request = connectionInfo;
            _options = email;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                Email: email,
            };
            _options = webapi_options;
        }
        return this._SaveEMail(_request, _options);
    }
    async _AuthenticateIncoming(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AuthenticateIncoming", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AuthenticateIncoming(connectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined')) {
            _request = connectionInfo;
            _options = webapi_options;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
            };
            _options = webapi_options;
        }
        return this._AuthenticateIncoming(_request, _options);
    }
    async _AuthenticateOutgoing(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AuthenticateOutgoing", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AuthenticateOutgoing(connectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined')) {
            _request = connectionInfo;
            _options = webapi_options;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
            };
            _options = webapi_options;
        }
        return this._AuthenticateOutgoing(_request, _options);
    }
    async _GetFolderList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFolderList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFolderList(connectionInfo, includeItemCount, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.IncludeItemCount) != 'undefined')) {
            _request = connectionInfo;
            _options = includeItemCount;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                IncludeItemCount: includeItemCount,
            };
            _options = webapi_options;
        }
        return this._GetFolderList(_request, _options);
    }
    async _GetAttachment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAttachment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAttachment(connectionInfo, messageServerId, attachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.MessageServerId) != 'undefined' || typeof (first.AttachmentId) != 'undefined')) {
            _request = connectionInfo;
            _options = messageServerId;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                MessageServerId: messageServerId,
                AttachmentId: attachmentId,
            };
            _options = webapi_options;
        }
        return this._GetAttachment(_request, _options);
    }
    async _MarkAsRead(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MarkAsRead", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MarkAsRead(connectionInfo, messageServerIds, read, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.MessageServerIds) != 'undefined' || typeof (first.Read) != 'undefined')) {
            _request = connectionInfo;
            _options = messageServerIds;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                MessageServerIds: messageServerIds,
                Read: read,
            };
            _options = webapi_options;
        }
        return this._MarkAsRead(_request, _options);
    }
    async _GetFolderEMailCount(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFolderEMailCount", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFolderEMailCount(connectionInfo, onlyUnread, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.OnlyUnread) != 'undefined')) {
            _request = connectionInfo;
            _options = onlyUnread;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                OnlyUnread: onlyUnread,
            };
            _options = webapi_options;
        }
        return this._GetFolderEMailCount(_request, _options);
    }
    async _Delete(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Delete", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Delete(connectionInfo, messageServerIds, moveToFolder, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.MessageServerIds) != 'undefined' || typeof (first.MoveToFolder) != 'undefined')) {
            _request = connectionInfo;
            _options = messageServerIds;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                MessageServerIds: messageServerIds,
                MoveToFolder: moveToFolder,
            };
            _options = webapi_options;
        }
        return this._Delete(_request, _options);
    }
    async _MoveToFolder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveToFolder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MoveToFolder(connectionInfo, messageServerIds, targetFolder, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.MessageServerIds) != 'undefined' || typeof (first.TargetFolder) != 'undefined')) {
            _request = connectionInfo;
            _options = messageServerIds;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                MessageServerIds: messageServerIds,
                TargetFolder: targetFolder,
            };
            _options = webapi_options;
        }
        return this._MoveToFolder(_request, _options);
    }
    async _EmptyFolder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("EmptyFolder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async EmptyFolder(connectionInfo, moveToFolder, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.MoveToFolder) != 'undefined')) {
            _request = connectionInfo;
            _options = moveToFolder;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                MoveToFolder: moveToFolder,
            };
            _options = webapi_options;
        }
        return this._EmptyFolder(_request, _options);
    }
    async _GetEMailAsStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailAsStream", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailAsStream(connectionInfo, messageServerId, stripAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.MessageServerId) != 'undefined' || typeof (first.StripAttachments) != 'undefined')) {
            _request = connectionInfo;
            _options = messageServerId;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                MessageServerId: messageServerId,
                StripAttachments: stripAttachments,
            };
            _options = webapi_options;
        }
        return this._GetEMailAsStream(_request, _options);
    }
    async _FindAddress(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindAddress", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAddressArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindAddress(address, webapi_options) {
        let _request = null;
        let _options = null;
        const first = address;
        if (typeof (first) === "object" && first && (typeof (first.Address) != 'undefined')) {
            _request = address;
            _options = webapi_options;
        }
        else {
            _request = {
                Address: address,
            };
            _options = webapi_options;
        }
        return this._FindAddress(_request, _options);
    }
    async _GetEMailFromDocumentId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromDocumentId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailFromDocumentId(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetEMailFromDocumentId(_request, _options);
    }
    async _GetUnsanitizedEMailFromDocumentId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMailFromDocumentId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUnsanitizedEMailFromDocumentId(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMailFromDocumentId(_request, _options);
    }
    async _GetEMailFromAttachmentId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromAttachmentId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailFromAttachmentId(emailId, attachmentIds, includeAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailId;
        if (typeof (first) === "object" && first && (typeof (first.EmailId) != 'undefined' || typeof (first.AttachmentIds) != 'undefined' || typeof (first.IncludeAttachments) != 'undefined')) {
            _request = emailId;
            _options = attachmentIds;
        }
        else {
            _request = {
                EmailId: emailId,
                AttachmentIds: attachmentIds,
                IncludeAttachments: includeAttachments,
            };
            _options = webapi_options;
        }
        return this._GetEMailFromAttachmentId(_request, _options);
    }
    async _GetUnsanitizedEMailFromAttachmentId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMailFromAttachmentId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUnsanitizedEMailFromAttachmentId(emailId, attachmentIds, includeAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailId;
        if (typeof (first) === "object" && first && (typeof (first.EmailId) != 'undefined' || typeof (first.AttachmentIds) != 'undefined' || typeof (first.IncludeAttachments) != 'undefined')) {
            _request = emailId;
            _options = attachmentIds;
        }
        else {
            _request = {
                EmailId: emailId,
                AttachmentIds: attachmentIds,
                IncludeAttachments: includeAttachments,
            };
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMailFromAttachmentId(_request, _options);
    }
    async _GetEMailFromDocumentAttachmentId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromDocumentAttachmentId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailFromDocumentAttachmentId(docId, attachmentIds, includeAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = docId;
        if (typeof (first) === "object" && first && (typeof (first.DocId) != 'undefined' || typeof (first.AttachmentIds) != 'undefined' || typeof (first.IncludeAttachments) != 'undefined')) {
            _request = docId;
            _options = attachmentIds;
        }
        else {
            _request = {
                DocId: docId,
                AttachmentIds: attachmentIds,
                IncludeAttachments: includeAttachments,
            };
            _options = webapi_options;
        }
        return this._GetEMailFromDocumentAttachmentId(_request, _options);
    }
    async _GetUnsanitizedEMailFromDocumentAttachmentId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMailFromDocumentAttachmentId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUnsanitizedEMailFromDocumentAttachmentId(docId, attachmentIds, includeAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = docId;
        if (typeof (first) === "object" && first && (typeof (first.DocId) != 'undefined' || typeof (first.AttachmentIds) != 'undefined' || typeof (first.IncludeAttachments) != 'undefined')) {
            _request = docId;
            _options = attachmentIds;
        }
        else {
            _request = {
                DocId: docId,
                AttachmentIds: attachmentIds,
                IncludeAttachments: includeAttachments,
            };
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMailFromDocumentAttachmentId(_request, _options);
    }
    async _GetEMailEnvelopes(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailEnvelopes", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEnvelopeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailEnvelopes(connectionInfo, messageServerIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.MessageServerIds) != 'undefined')) {
            _request = connectionInfo;
            _options = messageServerIds;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                MessageServerIds: messageServerIds,
            };
            _options = webapi_options;
        }
        return this._GetEMailEnvelopes(_request, _options);
    }
    async _SetSubscription(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetSubscription", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetSubscription(connectionInfo, folders, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.Folders) != 'undefined')) {
            _request = connectionInfo;
            _options = folders;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                Folders: folders,
            };
            _options = webapi_options;
        }
        return this._SetSubscription(_request, _options);
    }
    async _CreateFolder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateFolder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateFolder(connectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined')) {
            _request = connectionInfo;
            _options = webapi_options;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
            };
            _options = webapi_options;
        }
        return this._CreateFolder(_request, _options);
    }
    async _DeleteFolder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteFolder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteFolder(connectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined')) {
            _request = connectionInfo;
            _options = webapi_options;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
            };
            _options = webapi_options;
        }
        return this._DeleteFolder(_request, _options);
    }
    async _CreateEMailFromDocumentEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateEMailFromDocumentEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateEMailFromDocumentEntity(documentEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentEntity;
        if (typeof (first) === "object" && first && (typeof (first.DocumentEntity) != 'undefined')) {
            _request = documentEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentEntity: documentEntity,
            };
            _options = webapi_options;
        }
        return this._CreateEMailFromDocumentEntity(_request, _options);
    }
    async _CreateEMailFromMimeMessage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateEMailFromMimeMessage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateEMailFromMimeMessage(mimeMessage, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mimeMessage;
        if (typeof (first) === "object" && first && (typeof (first.MimeMessage) != 'undefined')) {
            _request = mimeMessage;
            _options = webapi_options;
        }
        else {
            _request = {
                MimeMessage: mimeMessage,
            };
            _options = webapi_options;
        }
        return this._CreateEMailFromMimeMessage(_request, _options);
    }
    async _GetFolderInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFolderInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailFolderArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFolderInfo(connectionInfo, folders, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.Folders) != 'undefined')) {
            _request = connectionInfo;
            _options = folders;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                Folders: folders,
            };
            _options = webapi_options;
        }
        return this._GetFolderInfo(_request, _options);
    }
    async _GetFolderHasNewEMail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFolderHasNewEMail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFolderHasNewEMail(connectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined')) {
            _request = connectionInfo;
            _options = webapi_options;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
            };
            _options = webapi_options;
        }
        return this._GetFolderHasNewEMail(_request, _options);
    }
    async _GetEMailAddresses(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailAddresses", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAddressArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailAddresses(emailIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailIds;
        if (typeof (first) === "object" && first && (typeof (first.EmailIds) != 'undefined')) {
            _request = emailIds;
            _options = webapi_options;
        }
        else {
            _request = {
                EmailIds: emailIds,
            };
            _options = webapi_options;
        }
        return this._GetEMailAddresses(_request, _options);
    }
    async _RefreshFolder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RefreshFolder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RefreshFolder(connectionInfo, folders, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfo;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfo) != 'undefined' || typeof (first.Folders) != 'undefined')) {
            _request = connectionInfo;
            _options = folders;
        }
        else {
            _request = {
                ConnectionInfo: connectionInfo,
                Folders: folders,
            };
            _options = webapi_options;
        }
        return this._RefreshFolder(_request, _options);
    }
    async _GetEMailFromTemp(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromTemp", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailFromTemp(fileName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = fileName;
        if (typeof (first) === "object" && first && (typeof (first.FileName) != 'undefined')) {
            _request = fileName;
            _options = webapi_options;
        }
        else {
            _request = {
                FileName: fileName,
            };
            _options = webapi_options;
        }
        return this._GetEMailFromTemp(_request, _options);
    }
    async _Authenticate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Authenticate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Authenticate(connectionInfoExtended, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfoExtended;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfoExtended) != 'undefined')) {
            _request = connectionInfoExtended;
            _options = webapi_options;
        }
        else {
            _request = {
                ConnectionInfoExtended: connectionInfoExtended,
            };
            _options = webapi_options;
        }
        return this._Authenticate(_request, _options);
    }
    async _GetEmailMessageIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailMessageIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEmailMessageIds(connectionInfoExtended, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfoExtended;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfoExtended) != 'undefined')) {
            _request = connectionInfoExtended;
            _options = webapi_options;
        }
        else {
            _request = {
                ConnectionInfoExtended: connectionInfoExtended,
            };
            _options = webapi_options;
        }
        return this._GetEmailMessageIds(_request, _options);
    }
    async _GetExtendedEmailMessageIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetExtendedEmailMessageIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetExtendedEmailMessageIds(connectionInfoExtended, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfoExtended;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfoExtended) != 'undefined')) {
            _request = connectionInfoExtended;
            _options = webapi_options;
        }
        else {
            _request = {
                ConnectionInfoExtended: connectionInfoExtended,
            };
            _options = webapi_options;
        }
        return this._GetExtendedEmailMessageIds(_request, _options);
    }
    async _GetEmailsAsString(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailsAsString", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEmailsAsString(connectionInfoExtended, messageIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfoExtended;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfoExtended) != 'undefined' || typeof (first.MessageIds) != 'undefined')) {
            _request = connectionInfoExtended;
            _options = messageIds;
        }
        else {
            _request = {
                ConnectionInfoExtended: connectionInfoExtended,
                MessageIds: messageIds,
            };
            _options = webapi_options;
        }
        return this._GetEmailsAsString(_request, _options);
    }
    async _DeleteExtended(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteExtended", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteExtended(connectionInfoExtended, messageIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfoExtended;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfoExtended) != 'undefined' || typeof (first.MessageIds) != 'undefined')) {
            _request = connectionInfoExtended;
            _options = messageIds;
        }
        else {
            _request = {
                ConnectionInfoExtended: connectionInfoExtended,
                MessageIds: messageIds,
            };
            _options = webapi_options;
        }
        return this._DeleteExtended(_request, _options);
    }
    async _RelayMessage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RelayMessage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RelayMessage(connectionInfoExtended, rfc822, from, recipients, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionInfoExtended;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionInfoExtended) != 'undefined' || typeof (first.Rfc822) != 'undefined' || typeof (first.From) != 'undefined' || typeof (first.Recipients) != 'undefined')) {
            _request = connectionInfoExtended;
            _options = rfc822;
        }
        else {
            _request = {
                ConnectionInfoExtended: connectionInfoExtended,
                Rfc822: rfc822,
                From: from,
                Recipients: recipients,
            };
            _options = webapi_options;
        }
        return this._RelayMessage(_request, _options);
    }
    async _GetEMail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMail(id, includeAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.IncludeAttachments) != 'undefined')) {
            _request = id;
            _options = includeAttachments;
        }
        else {
            _request = {
                Id: id,
                IncludeAttachments: includeAttachments,
            };
            _options = webapi_options;
        }
        return this._GetEMail(_request, _options);
    }
    async _GetUnsanitizedEMail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUnsanitizedEMail(id, includeAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.IncludeAttachments) != 'undefined')) {
            _request = id;
            _options = includeAttachments;
        }
        else {
            _request = {
                Id: id,
                IncludeAttachments: includeAttachments,
            };
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMail(_request, _options);
    }
    async _MarkEmailsAsRead(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MarkEmailsAsRead", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MarkEmailsAsRead(ids, read, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ids;
        if (typeof (first) === "object" && first && (typeof (first.Ids) != 'undefined' || typeof (first.Read) != 'undefined')) {
            _request = ids;
            _options = read;
        }
        else {
            _request = {
                Ids: ids,
                Read: read,
            };
            _options = webapi_options;
        }
        return this._MarkEmailsAsRead(_request, _options);
    }
    async _DeleteEmails(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteEmails", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteEmails(ids, moveToFolder, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ids;
        if (typeof (first) === "object" && first && (typeof (first.Ids) != 'undefined' || typeof (first.MoveToFolder) != 'undefined')) {
            _request = ids;
            _options = moveToFolder;
        }
        else {
            _request = {
                Ids: ids,
                MoveToFolder: moveToFolder,
            };
            _options = webapi_options;
        }
        return this._DeleteEmails(_request, _options);
    }
    async _MoveEmailsToTrash(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveEmailsToTrash", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MoveEmailsToTrash(ids, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ids;
        if (typeof (first) === "object" && first && (typeof (first.Ids) != 'undefined')) {
            _request = ids;
            _options = webapi_options;
        }
        else {
            _request = {
                Ids: ids,
            };
            _options = webapi_options;
        }
        return this._MoveEmailsToTrash(_request, _options);
    }
    async _Save(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Save", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Save(email, webapi_options) {
        let _request = null;
        let _options = null;
        const first = email;
        if (typeof (first) === "object" && first && (typeof (first.Email) != 'undefined')) {
            _request = email;
            _options = webapi_options;
        }
        else {
            _request = {
                Email: email,
            };
            _options = webapi_options;
        }
        return this._Save(_request, _options);
    }
    async _SaveToMailServer(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveToMailServer", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveToMailServer(email, webapi_options) {
        let _request = null;
        let _options = null;
        const first = email;
        if (typeof (first) === "object" && first && (typeof (first.Email) != 'undefined')) {
            _request = email;
            _options = webapi_options;
        }
        else {
            _request = {
                Email: email,
            };
            _options = webapi_options;
        }
        return this._SaveToMailServer(_request, _options);
    }
    async _Send(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Send", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Send(emails, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emails;
        if (typeof (first) === "object" && first && (typeof (first.Emails) != 'undefined')) {
            _request = emails;
            _options = webapi_options;
        }
        else {
            _request = {
                Emails: emails,
            };
            _options = webapi_options;
        }
        return this._Send(_request, _options);
    }
    async _CreateForwardEmail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateForwardEmail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateForwardEmail(email, webapi_options) {
        let _request = null;
        let _options = null;
        const first = email;
        if (typeof (first) === "object" && first && (typeof (first.Email) != 'undefined')) {
            _request = email;
            _options = webapi_options;
        }
        else {
            _request = {
                Email: email,
            };
            _options = webapi_options;
        }
        return this._CreateForwardEmail(_request, _options);
    }
    async _FindContactOrPersonByEmailName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindContactOrPersonByEmailName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactOrPersonFromEmailArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindContactOrPersonByEmailName(name, emailAddress, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.EmailAddress) != 'undefined')) {
            _request = name;
            _options = emailAddress;
        }
        else {
            _request = {
                Name: name,
                EmailAddress: emailAddress,
            };
            _options = webapi_options;
        }
        return this._FindContactOrPersonByEmailName(_request, _options);
    }
    async _FindContactOrPersonByEmailNameWithLimit(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindContactOrPersonByEmailNameWithLimit", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactOrPersonFromEmailArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindContactOrPersonByEmailNameWithLimit(name, emailAddress, numberOfContacts, numberOfPersons, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.EmailAddress) != 'undefined' || typeof (first.NumberOfContacts) != 'undefined' || typeof (first.NumberOfPersons) != 'undefined')) {
            _request = name;
            _options = emailAddress;
        }
        else {
            _request = {
                Name: name,
                EmailAddress: emailAddress,
                NumberOfContacts: numberOfContacts,
                NumberOfPersons: numberOfPersons,
            };
            _options = webapi_options;
        }
        return this._FindContactOrPersonByEmailNameWithLimit(_request, _options);
    }
    async _RefreshFolderForAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RefreshFolderForAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RefreshFolderForAssociate(folders, webapi_options) {
        let _request = null;
        let _options = null;
        const first = folders;
        if (typeof (first) === "object" && first && (typeof (first.Folders) != 'undefined')) {
            _request = folders;
            _options = webapi_options;
        }
        else {
            _request = {
                Folders: folders,
            };
            _options = webapi_options;
        }
        return this._RefreshFolderForAssociate(_request, _options);
    }
    async _GetNewMail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNewMail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEnvelopeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetNewMail(folders, webapi_options) {
        let _request = null;
        let _options = null;
        const first = folders;
        if (typeof (first) === "object" && first && (typeof (first.Folders) != 'undefined')) {
            _request = folders;
            _options = webapi_options;
        }
        else {
            _request = {
                Folders: folders,
            };
            _options = webapi_options;
        }
        return this._GetNewMail(_request, _options);
    }
    async _CacheFolderList(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CacheFolderList", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailFolderArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Fetch list of folders from email server for the current account, and cache in DB
     * @returns List of folders from mail server
     */
    async CacheFolderList(webapi_options) {
        return this._CacheFolderList(webapi_options);
    }
    async _MoveEmailsToFolder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveEmailsToFolder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MoveEmailsToFolder(folderId, emailItemIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = folderId;
        if (typeof (first) === "object" && first && (typeof (first.FolderId) != 'undefined' || typeof (first.EmailItemIds) != 'undefined')) {
            _request = folderId;
            _options = emailItemIds;
        }
        else {
            _request = {
                FolderId: folderId,
                EmailItemIds: emailItemIds,
            };
            _options = webapi_options;
        }
        return this._MoveEmailsToFolder(_request, _options);
    }
    async _GetMailFromMessageId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMailFromMessageId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMailFromMessageId(messageId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = messageId;
        if (typeof (first) === "object" && first && (typeof (first.MessageId) != 'undefined')) {
            _request = messageId;
            _options = webapi_options;
        }
        else {
            _request = {
                MessageId: messageId,
            };
            _options = webapi_options;
        }
        return this._GetMailFromMessageId(_request, _options);
    }
    async _GetMailFromInReplyTo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMailFromInReplyTo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMailFromInReplyTo(messageId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = messageId;
        if (typeof (first) === "object" && first && (typeof (first.MessageId) != 'undefined')) {
            _request = messageId;
            _options = webapi_options;
        }
        else {
            _request = {
                MessageId: messageId,
            };
            _options = webapi_options;
        }
        return this._GetMailFromInReplyTo(_request, _options);
    }
    async _SendAndSaveEmailToTmpDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendAndSaveEmailToTmpDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SendAndSaveEmailToTmpDocument(email, stripAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = email;
        if (typeof (first) === "object" && first && (typeof (first.Email) != 'undefined' || typeof (first.StripAttachments) != 'undefined')) {
            _request = email;
            _options = stripAttachments;
        }
        else {
            _request = {
                Email: email,
                StripAttachments: stripAttachments,
            };
            _options = webapi_options;
        }
        return this._SendAndSaveEmailToTmpDocument(_request, _options);
    }
    async _SaveEmailToTmpDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveEmailToTmpDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveEmailToTmpDocument(email, folderId, stripAttachments, webapi_options) {
        let _request = null;
        let _options = null;
        const first = email;
        if (typeof (first) === "object" && first && (typeof (first.Email) != 'undefined' || typeof (first.FolderId) != 'undefined' || typeof (first.StripAttachments) != 'undefined')) {
            _request = email;
            _options = folderId;
        }
        else {
            _request = {
                Email: email,
                FolderId: folderId,
                StripAttachments: stripAttachments,
            };
            _options = webapi_options;
        }
        return this._SaveEmailToTmpDocument(_request, _options);
    }
    async _SaveDraft(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDraft", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveDraft(entity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = entity;
        if (typeof (first) === "object" && first && (typeof (first.Entity) != 'undefined')) {
            _request = entity;
            _options = webapi_options;
        }
        else {
            _request = {
                Entity: entity,
            };
            _options = webapi_options;
        }
        return this._SaveDraft(_request, _options);
    }
    async _SetRepliedAt(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRepliedAt", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetRepliedAt(messageId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = messageId;
        if (typeof (first) === "object" && first && (typeof (first.MessageId) != 'undefined')) {
            _request = messageId;
            _options = webapi_options;
        }
        else {
            _request = {
                MessageId: messageId,
            };
            _options = webapi_options;
        }
        return this._SetRepliedAt(_request, _options);
    }
    async _GetEMailFromDocumentIdWithoutAttachmentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEMailFromDocumentIdWithoutAttachmentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEMailFromDocumentIdWithoutAttachmentStream(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetEMailFromDocumentIdWithoutAttachmentStream(_request, _options);
    }
    async _GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStream(_request, _options);
    }
    async _GetAttachmentFromId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachmentFromId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAttachment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAttachmentFromId(mailItemId, attachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mailItemId;
        if (typeof (first) === "object" && first && (typeof (first.MailItemId) != 'undefined' || typeof (first.AttachmentId) != 'undefined')) {
            _request = mailItemId;
            _options = attachmentId;
        }
        else {
            _request = {
                MailItemId: mailItemId,
                AttachmentId: attachmentId,
            };
            _options = webapi_options;
        }
        return this._GetAttachmentFromId(_request, _options);
    }
    async _GetPreviewAttachmentFromId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewAttachmentFromId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAttachment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreviewAttachmentFromId(mailItemId, attachmentId, attachmentType, attachmentFilename, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mailItemId;
        if (typeof (first) === "object" && first && (typeof (first.MailItemId) != 'undefined' || typeof (first.AttachmentId) != 'undefined' || typeof (first.AttachmentType) != 'undefined' || typeof (first.AttachmentFilename) != 'undefined')) {
            _request = mailItemId;
            _options = attachmentId;
        }
        else {
            _request = {
                MailItemId: mailItemId,
                AttachmentId: attachmentId,
                AttachmentType: attachmentType,
                AttachmentFilename: attachmentFilename,
            };
            _options = webapi_options;
        }
        return this._GetPreviewAttachmentFromId(_request, _options);
    }
    async _GetUnsanitizedPreviewAttachmentFromId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedPreviewAttachmentFromId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAttachment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUnsanitizedPreviewAttachmentFromId(mailItemId, attachmentId, attachmentType, attachmentFilename, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mailItemId;
        if (typeof (first) === "object" && first && (typeof (first.MailItemId) != 'undefined' || typeof (first.AttachmentId) != 'undefined' || typeof (first.AttachmentType) != 'undefined' || typeof (first.AttachmentFilename) != 'undefined')) {
            _request = mailItemId;
            _options = attachmentId;
        }
        else {
            _request = {
                MailItemId: mailItemId,
                AttachmentId: attachmentId,
                AttachmentType: attachmentType,
                AttachmentFilename: attachmentFilename,
            };
            _options = webapi_options;
        }
        return this._GetUnsanitizedPreviewAttachmentFromId(_request, _options);
    }
    async _GetPreviewAttachmentFromDocId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewAttachmentFromDocId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAttachment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreviewAttachmentFromDocId(docId, attachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = docId;
        if (typeof (first) === "object" && first && (typeof (first.DocId) != 'undefined' || typeof (first.AttachmentId) != 'undefined')) {
            _request = docId;
            _options = attachmentId;
        }
        else {
            _request = {
                DocId: docId,
                AttachmentId: attachmentId,
            };
            _options = webapi_options;
        }
        return this._GetPreviewAttachmentFromDocId(_request, _options);
    }
    async _GetUnsanitizedPreviewAttachmentFromDocId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedPreviewAttachmentFromDocId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAttachment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUnsanitizedPreviewAttachmentFromDocId(docId, attachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = docId;
        if (typeof (first) === "object" && first && (typeof (first.DocId) != 'undefined' || typeof (first.AttachmentId) != 'undefined')) {
            _request = docId;
            _options = attachmentId;
        }
        else {
            _request = {
                DocId: docId,
                AttachmentId: attachmentId,
            };
            _options = webapi_options;
        }
        return this._GetUnsanitizedPreviewAttachmentFromDocId(_request, _options);
    }
    async _TestAuthenticate(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestAuthenticate", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Test if logged-in user has a working mail account
     * @returns
     */
    async TestAuthenticate(webapi_options) {
        return this._TestAuthenticate(webapi_options);
    }
    async _ToggleSubscription(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleSubscription", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleSubscription(folderId, subscriptionStatus, webapi_options) {
        let _request = null;
        let _options = null;
        const first = folderId;
        if (typeof (first) === "object" && first && (typeof (first.FolderId) != 'undefined' || typeof (first.SubscriptionStatus) != 'undefined')) {
            _request = folderId;
            _options = subscriptionStatus;
        }
        else {
            _request = {
                FolderId: folderId,
                SubscriptionStatus: subscriptionStatus,
            };
            _options = webapi_options;
        }
        return this._ToggleSubscription(_request, _options);
    }
    async _HasNewMail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasNewMail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async HasNewMail(mailItemId, folderId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mailItemId;
        if (typeof (first) === "object" && first && (typeof (first.MailItemId) != 'undefined' || typeof (first.FolderId) != 'undefined')) {
            _request = mailItemId;
            _options = folderId;
        }
        else {
            _request = {
                MailItemId: mailItemId,
                FolderId: folderId,
            };
            _options = webapi_options;
        }
        return this._HasNewMail(_request, _options);
    }
    async _LatestItemIdByFolder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("LatestItemIdByFolder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async LatestItemIdByFolder(folderId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = folderId;
        if (typeof (first) === "object" && first && (typeof (first.FolderId) != 'undefined')) {
            _request = folderId;
            _options = webapi_options;
        }
        else {
            _request = {
                FolderId: folderId,
            };
            _options = webapi_options;
        }
        return this._LatestItemIdByFolder(_request, _options);
    }
    async _CreateInlineHtmlHeader(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateInlineHtmlHeader", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateInlineHtmlHeader(email, webapi_options) {
        let _request = null;
        let _options = null;
        const first = email;
        if (typeof (first) === "object" && first && (typeof (first.Email) != 'undefined')) {
            _request = email;
            _options = webapi_options;
        }
        else {
            _request = {
                Email: email,
            };
            _options = webapi_options;
        }
        return this._CreateInlineHtmlHeader(_request, _options);
    }
    async _GetEmailAppointment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailAppointment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailAppointment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEmailAppointment(mailItemId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mailItemId;
        if (typeof (first) === "object" && first && (typeof (first.MailItemId) != 'undefined')) {
            _request = mailItemId;
            _options = webapi_options;
        }
        else {
            _request = {
                MailItemId: mailItemId,
            };
            _options = webapi_options;
        }
        return this._GetEmailAppointment(_request, _options);
    }
    async _GetEmailAppointmentRecurrence(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailAppointmentRecurrence", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RecurrenceInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEmailAppointmentRecurrence(mailItemId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mailItemId;
        if (typeof (first) === "object" && first && (typeof (first.MailItemId) != 'undefined')) {
            _request = mailItemId;
            _options = webapi_options;
        }
        else {
            _request = {
                MailItemId: mailItemId,
            };
            _options = webapi_options;
        }
        return this._GetEmailAppointmentRecurrence(_request, _options);
    }
    async _GetParticipantInfoFromEmailAddress(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetParticipantInfoFromEmailAddress", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Person_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetParticipantInfoFromEmailAddress(emailAddress, appointmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailAddress;
        if (typeof (first) === "object" && first && (typeof (first.EmailAddress) != 'undefined' || typeof (first.AppointmentId) != 'undefined')) {
            _request = emailAddress;
            _options = appointmentId;
        }
        else {
            _request = {
                EmailAddress: emailAddress,
                AppointmentId: appointmentId,
            };
            _options = webapi_options;
        }
        return this._GetParticipantInfoFromEmailAddress(_request, _options);
    }
    async _GetEmailDocumentAsMimeStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmailDocumentAsMimeStream", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetEmailDocumentAsMimeStream(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetEmailDocumentAsMimeStream(_request, _options);
    }
    /*
     * Gets a EMailSOInfo object.
     * @param eMailSOInfoId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single EMailSOInfo
     */
    async GetEMailSOInfo(eMailSOInfoId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetEMailSOInfo?eMailSOInfoId=" + eMailSOInfoId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EMailSOInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetReadySyncEmailAccounts(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetReadySyncEmailAccounts", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SyncUserAccountArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets the list of SyncUserAccounts that should be synced.
     * @returns List of accounts to sync
     */
    async GetReadySyncEmailAccounts(webapi_options) {
        return this._GetReadySyncEmailAccounts(webapi_options);
    }
    async _SyncEmailAccount(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SyncEmailAccount", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SyncEmailAccount(syncUserAccount, webapi_options) {
        let _request = null;
        let _options = null;
        const first = syncUserAccount;
        if (typeof (first) === "object" && first && (typeof (first.SyncUserAccount) != 'undefined')) {
            _request = syncUserAccount;
            _options = webapi_options;
        }
        else {
            _request = {
                SyncUserAccount: syncUserAccount,
            };
            _options = webapi_options;
        }
        return this._SyncEmailAccount(_request, _options);
    }
    async _SyncEmailAccounts(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SyncEmailAccounts", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SyncEmailAccounts(syncUserAccounts, webapi_options) {
        let _request = null;
        let _options = null;
        const first = syncUserAccounts;
        if (typeof (first) === "object" && first && (typeof (first.SyncUserAccounts) != 'undefined')) {
            _request = syncUserAccounts;
            _options = webapi_options;
        }
        else {
            _request = {
                SyncUserAccounts: syncUserAccounts,
            };
            _options = webapi_options;
        }
        return this._SyncEmailAccounts(_request, _options);
    }
} // class v1EMailAgentController 
exports.EMailAgent = EMailAgent;
//# sourceMappingURL=EMailAgent.js.map
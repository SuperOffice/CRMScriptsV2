"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetsAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Agent lets you configure targets, and retrieve targets
 */
class TargetsAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Targets/";
        super(options);
    }
    /**
     * Set default values into a new TargetAssignment.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTargetAssignment(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTargetAssignment", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetAssignment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TargetDimension.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTargetDimension(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTargetDimension", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetDimension_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TargetDimension or creates a new TargetDimension if the id parameter is empty
     * @param entity - The TargetDimension to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TargetDimension
     */
    async SaveTargetDimension(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTargetDimension", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetDimension_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the TargetDimension
     * @param TargetDimensionId - The id of the TargetDimension to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteTargetDimension(TargetDimensionId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTargetDimension?TargetDimensionId=" + TargetDimensionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TargetGroup.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTargetGroup(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTargetGroup", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TargetGroup or creates a new TargetGroup if the id parameter is empty
     * @param entity - The TargetGroup to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TargetGroup
     */
    async SaveTargetGroup(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTargetGroup", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the TargetGroup
     * @param TargetGroupId - The id of the TargetGroup to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteTargetGroup(TargetGroupId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTargetGroup?TargetGroupId=" + TargetGroupId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TargetRevision.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTargetRevision(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTargetRevision", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetRevision_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TargetRevisionHistory.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTargetRevisionHistory(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTargetRevisionHistory", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetRevisionHistory_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _CreateDefaultTargetAssignmentForCompany(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTargetAssignmentForCompany", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetAssignment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns a default target assignment for the owner company.
     * @returns Default target assignment for the owner company.
     */
    async CreateDefaultTargetAssignmentForCompany(webapi_options) {
        return this._CreateDefaultTargetAssignmentForCompany(webapi_options);
    }
    async _CreateDefaultTargetAssignmentForUserGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTargetAssignmentForUserGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetAssignmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultTargetAssignmentForUserGroup(userGroupId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userGroupId;
        if (typeof (first) === "object" && first && (typeof (first.UserGroupId) != 'undefined')) {
            _request = userGroupId;
            _options = webapi_options;
        }
        else {
            _request = {
                UserGroupId: userGroupId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultTargetAssignmentForUserGroup(_request, _options);
    }
    async _GetTargetAssignmentForYear(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTargetAssignmentForYear", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetAssignment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTargetAssignmentForYear(targetYear, entityType, targetLevel, id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = targetYear;
        if (typeof (first) === "object" && first && (typeof (first.TargetYear) != 'undefined' || typeof (first.EntityType) != 'undefined' || typeof (first.TargetLevel) != 'undefined' || typeof (first.Id) != 'undefined')) {
            _request = targetYear;
            _options = entityType;
        }
        else {
            _request = {
                TargetYear: targetYear,
                EntityType: entityType,
                TargetLevel: targetLevel,
                Id: id,
            };
            _options = webapi_options;
        }
        return this._GetTargetAssignmentForYear(_request, _options);
    }
    async _CreateDefaultTargetAssignmentForCompanyWithDimension(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTargetAssignmentForCompanyWithDimension", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetAssignmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultTargetAssignmentForCompanyWithDimension(targetDimensionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = targetDimensionId;
        if (typeof (first) === "object" && first && (typeof (first.TargetDimensionId) != 'undefined')) {
            _request = targetDimensionId;
            _options = webapi_options;
        }
        else {
            _request = {
                TargetDimensionId: targetDimensionId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultTargetAssignmentForCompanyWithDimension(_request, _options);
    }
    async _CreateDefaultTargetAssignmentForUserGroupWithDimension(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTargetAssignmentForUserGroupWithDimension", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetAssignmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultTargetAssignmentForUserGroupWithDimension(userGroupId, targetDimensionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userGroupId;
        if (typeof (first) === "object" && first && (typeof (first.UserGroupId) != 'undefined' || typeof (first.TargetDimensionId) != 'undefined')) {
            _request = userGroupId;
            _options = targetDimensionId;
        }
        else {
            _request = {
                UserGroupId: userGroupId,
                TargetDimensionId: targetDimensionId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultTargetAssignmentForUserGroupWithDimension(_request, _options);
    }
    async _GetTargetAssignmentForYearAndDimension(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTargetAssignmentForYearAndDimension", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetAssignment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTargetAssignmentForYearAndDimension(targetYear, entityType, targetLevel, id, dimensionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = targetYear;
        if (typeof (first) === "object" && first && (typeof (first.TargetYear) != 'undefined' || typeof (first.EntityType) != 'undefined' || typeof (first.TargetLevel) != 'undefined' || typeof (first.Id) != 'undefined' || typeof (first.DimensionId) != 'undefined')) {
            _request = targetYear;
            _options = entityType;
        }
        else {
            _request = {
                TargetYear: targetYear,
                EntityType: entityType,
                TargetLevel: targetLevel,
                Id: id,
                DimensionId: dimensionId,
            };
            _options = webapi_options;
        }
        return this._GetTargetAssignmentForYearAndDimension(_request, _options);
    }
    async _CreateDefaultTargetAssignmentForCompanyWithYearAndDimension(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTargetAssignmentForCompanyWithYearAndDimension", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetAssignmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultTargetAssignmentForCompanyWithYearAndDimension(year, targetDimensionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = year;
        if (typeof (first) === "object" && first && (typeof (first.Year) != 'undefined' || typeof (first.TargetDimensionId) != 'undefined')) {
            _request = year;
            _options = targetDimensionId;
        }
        else {
            _request = {
                Year: year,
                TargetDimensionId: targetDimensionId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultTargetAssignmentForCompanyWithYearAndDimension(_request, _options);
    }
    async _CreateDefaultTargetAssignmentForUserGroupWithYearAndDimension(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTargetAssignmentForUserGroupWithYearAndDimension", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetAssignmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultTargetAssignmentForUserGroupWithYearAndDimension(userGroupId, year, targetDimensionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userGroupId;
        if (typeof (first) === "object" && first && (typeof (first.UserGroupId) != 'undefined' || typeof (first.Year) != 'undefined' || typeof (first.TargetDimensionId) != 'undefined')) {
            _request = userGroupId;
            _options = year;
        }
        else {
            _request = {
                UserGroupId: userGroupId,
                Year: year,
                TargetDimensionId: targetDimensionId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultTargetAssignmentForUserGroupWithYearAndDimension(_request, _options);
    }
    /*
     * Gets a TargetDimension object.
     * @param targetDimensionId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TargetDimension
     */
    async GetTargetDimension(targetDimensionId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTargetDimension?targetDimensionId=" + targetDimensionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetDimension_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetTargetDimensionsForEntityType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTargetDimensionsForEntityType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetDimensionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTargetDimensionsForEntityType(entityType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = entityType;
        if (typeof (first) === "object" && first && (typeof (first.EntityType) != 'undefined')) {
            _request = entityType;
            _options = webapi_options;
        }
        else {
            _request = {
                EntityType: entityType,
            };
            _options = webapi_options;
        }
        return this._GetTargetDimensionsForEntityType(_request, _options);
    }
    async _GetTargetGroupIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTargetGroupIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTargetGroupIds(targetDimensionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = targetDimensionId;
        if (typeof (first) === "object" && first && (typeof (first.TargetDimensionId) != 'undefined')) {
            _request = targetDimensionId;
            _options = webapi_options;
        }
        else {
            _request = {
                TargetDimensionId: targetDimensionId,
            };
            _options = webapi_options;
        }
        return this._GetTargetGroupIds(_request, _options);
    }
    /*
     * Gets a TargetGroup object.
     * @param targetGroupId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TargetGroup
     */
    async GetTargetGroup(targetGroupId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTargetGroup?targetGroupId=" + targetGroupId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetTargetGroupForYear(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTargetGroupForYear", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTargetGroupForYear(targetYear, entityType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = targetYear;
        if (typeof (first) === "object" && first && (typeof (first.TargetYear) != 'undefined' || typeof (first.EntityType) != 'undefined')) {
            _request = targetYear;
            _options = entityType;
        }
        else {
            _request = {
                TargetYear: targetYear,
                EntityType: entityType,
            };
            _options = webapi_options;
        }
        return this._GetTargetGroupForYear(_request, _options);
    }
    async _ExportTargetGroupToExcel(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExportTargetGroupToExcel", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ExportArchiveResult_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ExportTargetGroupToExcel(targetGroupId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = targetGroupId;
        if (typeof (first) === "object" && first && (typeof (first.TargetGroupId) != 'undefined')) {
            _request = targetGroupId;
            _options = webapi_options;
        }
        else {
            _request = {
                TargetGroupId: targetGroupId,
            };
            _options = webapi_options;
        }
        return this._ExportTargetGroupToExcel(_request, _options);
    }
    async _GetTargetGroupForYearAndDimension(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTargetGroupForYearAndDimension", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTargetGroupForYearAndDimension(targetYear, dimensionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = targetYear;
        if (typeof (first) === "object" && first && (typeof (first.TargetYear) != 'undefined' || typeof (first.DimensionId) != 'undefined')) {
            _request = targetYear;
            _options = dimensionId;
        }
        else {
            _request = {
                TargetYear: targetYear,
                DimensionId: dimensionId,
            };
            _options = webapi_options;
        }
        return this._GetTargetGroupForYearAndDimension(_request, _options);
    }
    async _GetTargetRevisionHistory(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTargetRevisionHistory", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TargetRevisionHistory_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTargetRevisionHistory(targetAssignmentInfoId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = targetAssignmentInfoId;
        if (typeof (first) === "object" && first && (typeof (first.TargetAssignmentInfoId) != 'undefined')) {
            _request = targetAssignmentInfoId;
            _options = webapi_options;
        }
        else {
            _request = {
                TargetAssignmentInfoId: targetAssignmentInfoId,
            };
            _options = webapi_options;
        }
        return this._GetTargetRevisionHistory(_request, _options);
    }
} // class v1TargetsAgentController 
exports.TargetsAgent = TargetsAgent;
//# sourceMappingURL=TargetsAgent.js.map
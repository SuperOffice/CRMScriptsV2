"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreferenceAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Preferences, user interface tab configuration
 */
class PreferenceAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Preference/";
        super(options);
    }
    /**
     * Set default values into a new Preference.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultPreference(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreference", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Preference_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new PreferenceDescription.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultPreferenceDescription(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreferenceDescription", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescription_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing PreferenceDescription or creates a new PreferenceDescription if the id parameter is empty
     * @param entity - The PreferenceDescription to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated PreferenceDescription
     */
    async SavePreferenceDescription(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SavePreferenceDescription", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescription_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the PreferenceDescription
     * @param PreferenceDescriptionId - The id of the PreferenceDescription to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeletePreferenceDescription(PreferenceDescriptionId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeletePreferenceDescription?PreferenceDescriptionId=" + PreferenceDescriptionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new PreferenceDescriptionLine.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultPreferenceDescriptionLine(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreferenceDescriptionLine", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescriptionLine_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing PreferenceDescriptionLine or creates a new PreferenceDescriptionLine if the id parameter is empty
     * @param entity - The PreferenceDescriptionLine to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated PreferenceDescriptionLine
     */
    async SavePreferenceDescriptionLine(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SavePreferenceDescriptionLine", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescriptionLine_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the PreferenceDescriptionLine
     * @param PreferenceDescriptionLineId - The id of the PreferenceDescriptionLine to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeletePreferenceDescriptionLine(PreferenceDescriptionLineId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeletePreferenceDescriptionLine?PreferenceDescriptionLineId=" + PreferenceDescriptionLineId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SavePreference(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreference", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SavePreference(preference, webapi_options) {
        let _request = null;
        let _options = null;
        const first = preference;
        if (typeof (first) === "object" && first && (typeof (first.Preference) != 'undefined')) {
            _request = preference;
            _options = webapi_options;
        }
        else {
            _request = {
                Preference: preference,
            };
            _options = webapi_options;
        }
        return this._SavePreference(_request, _options);
    }
    async _SaveTabOrder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTabOrder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveTabOrder(tabOrder, webapi_options) {
        let _request = null;
        let _options = null;
        const first = tabOrder;
        if (typeof (first) === "object" && first && (typeof (first.TabOrder) != 'undefined')) {
            _request = tabOrder;
            _options = webapi_options;
        }
        else {
            _request = {
                TabOrder: tabOrder,
            };
            _options = webapi_options;
        }
        return this._SaveTabOrder(_request, _options);
    }
    async _GetTabOrder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTabOrder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TabOrder_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTabOrder(tabName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = tabName;
        if (typeof (first) === "object" && first && (typeof (first.TabName) != 'undefined')) {
            _request = tabName;
            _options = webapi_options;
        }
        else {
            _request = {
                TabName: tabName,
            };
            _options = webapi_options;
        }
        return this._GetTabOrder(_request, _options);
    }
    async _GetPreference(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreference", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Preference_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreference(id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined')) {
            _request = id;
            _options = webapi_options;
        }
        else {
            _request = {
                Id: id,
            };
            _options = webapi_options;
        }
        return this._GetPreference(_request, _options);
    }
    async _SavePreferenceEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreferenceEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Preference_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SavePreferenceEntity(preference, removeLowerLevels, webapi_options) {
        let _request = null;
        let _options = null;
        const first = preference;
        if (typeof (first) === "object" && first && (typeof (first.Preference) != 'undefined' || typeof (first.RemoveLowerLevels) != 'undefined')) {
            _request = preference;
            _options = removeLowerLevels;
        }
        else {
            _request = {
                Preference: preference,
                RemoveLowerLevels: removeLowerLevels,
            };
            _options = webapi_options;
        }
        return this._SavePreferenceEntity(_request, _options);
    }
    async _DeletePreference(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePreference", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeletePreference(id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined')) {
            _request = id;
            _options = webapi_options;
        }
        else {
            _request = {
                Id: id,
            };
            _options = webapi_options;
        }
        return this._DeletePreference(_request, _options);
    }
    async _DeletePreferences(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePreferences", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeletePreferences(ids, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ids;
        if (typeof (first) === "object" && first && (typeof (first.Ids) != 'undefined')) {
            _request = ids;
            _options = webapi_options;
        }
        else {
            _request = {
                Ids: ids,
            };
            _options = webapi_options;
        }
        return this._DeletePreferences(_request, _options);
    }
    async _GetPreferenceByName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferenceByName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Preference_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreferenceByName(prefSection, prefKey, prefLevel, webapi_options) {
        let _request = null;
        let _options = null;
        const first = prefSection;
        if (typeof (first) === "object" && first && (typeof (first.PrefSection) != 'undefined' || typeof (first.PrefKey) != 'undefined' || typeof (first.PrefLevel) != 'undefined')) {
            _request = prefSection;
            _options = prefKey;
        }
        else {
            _request = {
                PrefSection: prefSection,
                PrefKey: prefKey,
                PrefLevel: prefLevel,
            };
            _options = webapi_options;
        }
        return this._GetPreferenceByName(_request, _options);
    }
    async _GetPreferenceByNameAndId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferenceByNameAndId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Preference_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreferenceByNameAndId(prefSection, prefKey, prefLevel, ownerId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = prefSection;
        if (typeof (first) === "object" && first && (typeof (first.PrefSection) != 'undefined' || typeof (first.PrefKey) != 'undefined' || typeof (first.PrefLevel) != 'undefined' || typeof (first.OwnerId) != 'undefined')) {
            _request = prefSection;
            _options = prefKey;
        }
        else {
            _request = {
                PrefSection: prefSection,
                PrefKey: prefKey,
                PrefLevel: prefLevel,
                OwnerId: ownerId,
            };
            _options = webapi_options;
        }
        return this._GetPreferenceByNameAndId(_request, _options);
    }
    async _GetNetServicesStatusUrl(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNetServicesStatusUrl", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns URL to status service. e.g. &apos;https://help.superoffice.com/sodispatcher/v1/status&apos; Returns NULL if status does not need to be checked yet.
     * @returns NULL or URL of the status service that returns an XML or JSON block.
     */
    async GetNetServicesStatusUrl(webapi_options) {
        return this._GetNetServicesStatusUrl(webapi_options);
    }
    async _UpdateNetServicesStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateNetServicesStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateNetServicesStatus(xmlOrJson, webapi_options) {
        let _request = null;
        let _options = null;
        const first = xmlOrJson;
        if (typeof (first) === "object" && first && (typeof (first.XmlOrJson) != 'undefined')) {
            _request = xmlOrJson;
            _options = webapi_options;
        }
        else {
            _request = {
                XmlOrJson: xmlOrJson,
            };
            _options = webapi_options;
        }
        return this._UpdateNetServicesStatus(_request, _options);
    }
    async _GetXsrfPaths(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetXsrfPaths", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetXsrfPaths(hostname, webapi_options) {
        let _request = null;
        let _options = null;
        const first = hostname;
        if (typeof (first) === "object" && first && (typeof (first.Hostname) != 'undefined')) {
            _request = hostname;
            _options = webapi_options;
        }
        else {
            _request = {
                Hostname: hostname,
            };
            _options = webapi_options;
        }
        return this._GetXsrfPaths(_request, _options);
    }
    async _SetXsrfPaths(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetXsrfPaths", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetXsrfPaths(hostname, paths, webapi_options) {
        let _request = null;
        let _options = null;
        const first = hostname;
        if (typeof (first) === "object" && first && (typeof (first.Hostname) != 'undefined' || typeof (first.Paths) != 'undefined')) {
            _request = hostname;
            _options = paths;
        }
        else {
            _request = {
                Hostname: hostname,
                Paths: paths,
            };
            _options = webapi_options;
        }
        return this._SetXsrfPaths(_request, _options);
    }
    /*
     * Gets a PreferenceDescription object.
     * @param preferenceDescriptionId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PreferenceDescription
     */
    async GetPreferenceDescription(preferenceDescriptionId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPreferenceDescription?preferenceDescriptionId=" + preferenceDescriptionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescription_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetFromSectionAndKey(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFromSectionAndKey", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescription_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFromSectionAndKey(section, key, webapi_options) {
        let _request = null;
        let _options = null;
        const first = section;
        if (typeof (first) === "object" && first && (typeof (first.Section) != 'undefined' || typeof (first.Key) != 'undefined')) {
            _request = section;
            _options = key;
        }
        else {
            _request = {
                Section: section,
                Key: key,
            };
            _options = webapi_options;
        }
        return this._GetFromSectionAndKey(_request, _options);
    }
    async _GetAll(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAll", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescriptionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets a list of all PreferenceDescriptions in the system.
     * @returns All PreferenceDescriptions in the system
     */
    async GetAll(webapi_options) {
        return this._GetAll(webapi_options);
    }
    async _GetAllFromSection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllFromSection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescriptionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllFromSection(section, webapi_options) {
        let _request = null;
        let _options = null;
        const first = section;
        if (typeof (first) === "object" && first && (typeof (first.Section) != 'undefined')) {
            _request = section;
            _options = webapi_options;
        }
        else {
            _request = {
                Section: section,
            };
            _options = webapi_options;
        }
        return this._GetAllFromSection(_request, _options);
    }
    async _SaveFromSectionAndKey(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveFromSectionAndKey", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescription_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveFromSectionAndKey(section, key, preferenceDescription, webapi_options) {
        let _request = null;
        let _options = null;
        const first = section;
        if (typeof (first) === "object" && first && (typeof (first.Section) != 'undefined' || typeof (first.Key) != 'undefined' || typeof (first.PreferenceDescription) != 'undefined')) {
            _request = section;
            _options = key;
        }
        else {
            _request = {
                Section: section,
                Key: key,
                PreferenceDescription: preferenceDescription,
            };
            _options = webapi_options;
        }
        return this._SaveFromSectionAndKey(_request, _options);
    }
    async _DeleteFromSectionAndKey(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteFromSectionAndKey", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteFromSectionAndKey(section, key, webapi_options) {
        let _request = null;
        let _options = null;
        const first = section;
        if (typeof (first) === "object" && first && (typeof (first.Section) != 'undefined' || typeof (first.Key) != 'undefined')) {
            _request = section;
            _options = key;
        }
        else {
            _request = {
                Section: section,
                Key: key,
            };
            _options = webapi_options;
        }
        return this._DeleteFromSectionAndKey(_request, _options);
    }
    /*
     * Gets a PreferenceDescriptionLine object.
     * @param preferenceDescriptionLineId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PreferenceDescriptionLine
     */
    async GetPreferenceDescriptionLine(preferenceDescriptionLineId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPreferenceDescriptionLine?preferenceDescriptionLineId=" + preferenceDescriptionLineId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescriptionLine_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetPreferenceDescriptionLineFromIdAndValue(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferenceDescriptionLineFromIdAndValue", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescriptionLine_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreferenceDescriptionLineFromIdAndValue(prefDescId, prefValue, webapi_options) {
        let _request = null;
        let _options = null;
        const first = prefDescId;
        if (typeof (first) === "object" && first && (typeof (first.PrefDescId) != 'undefined' || typeof (first.PrefValue) != 'undefined')) {
            _request = prefDescId;
            _options = prefValue;
        }
        else {
            _request = {
                PrefDescId: prefDescId,
                PrefValue: prefValue,
            };
            _options = webapi_options;
        }
        return this._GetPreferenceDescriptionLineFromIdAndValue(_request, _options);
    }
    async _GetPreferenceDescriptionLinesByPrefDescId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferenceDescriptionLinesByPrefDescId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescriptionLineArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreferenceDescriptionLinesByPrefDescId(prefDescId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = prefDescId;
        if (typeof (first) === "object" && first && (typeof (first.PrefDescId) != 'undefined')) {
            _request = prefDescId;
            _options = webapi_options;
        }
        else {
            _request = {
                PrefDescId: prefDescId,
            };
            _options = webapi_options;
        }
        return this._GetPreferenceDescriptionLinesByPrefDescId(_request, _options);
    }
    async _SavePreferenceDescriptionLines(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreferenceDescriptionLines", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceDescriptionLineArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SavePreferenceDescriptionLines(preferenceDescriptionLines, webapi_options) {
        let _request = null;
        let _options = null;
        const first = preferenceDescriptionLines;
        if (typeof (first) === "object" && first && (typeof (first.PreferenceDescriptionLines) != 'undefined')) {
            _request = preferenceDescriptionLines;
            _options = webapi_options;
        }
        else {
            _request = {
                PreferenceDescriptionLines: preferenceDescriptionLines,
            };
            _options = webapi_options;
        }
        return this._SavePreferenceDescriptionLines(_request, _options);
    }
    async _DeletePreferenceDescriptionLines(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePreferenceDescriptionLines", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeletePreferenceDescriptionLines(prefDescLineIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = prefDescLineIds;
        if (typeof (first) === "object" && first && (typeof (first.PrefDescLineIds) != 'undefined')) {
            _request = prefDescLineIds;
            _options = webapi_options;
        }
        else {
            _request = {
                PrefDescLineIds: prefDescLineIds,
            };
            _options = webapi_options;
        }
        return this._DeletePreferenceDescriptionLines(_request, _options);
    }
    async _DeletePrefDescLinesByPrefDescId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePrefDescLinesByPrefDescId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeletePrefDescLinesByPrefDescId(prefDescId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = prefDescId;
        if (typeof (first) === "object" && first && (typeof (first.PrefDescId) != 'undefined')) {
            _request = prefDescId;
            _options = webapi_options;
        }
        else {
            _request = {
                PrefDescId: prefDescId,
            };
            _options = webapi_options;
        }
        return this._DeletePrefDescLinesByPrefDescId(_request, _options);
    }
    async _DeletePrefDescLinesByPrefDescIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePrefDescLinesByPrefDescIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeletePrefDescLinesByPrefDescIds(prefDescIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = prefDescIds;
        if (typeof (first) === "object" && first && (typeof (first.PrefDescIds) != 'undefined')) {
            _request = prefDescIds;
            _options = webapi_options;
        }
        else {
            _request = {
                PrefDescIds: prefDescIds,
            };
            _options = webapi_options;
        }
        return this._DeletePrefDescLinesByPrefDescIds(_request, _options);
    }
    async _GetPreferences(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferences", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreferences(specifications, webapi_options) {
        let _request = null;
        let _options = null;
        const first = specifications;
        if (typeof (first) === "object" && first && (typeof (first.Specifications) != 'undefined')) {
            _request = specifications;
            _options = webapi_options;
        }
        else {
            _request = {
                Specifications: specifications,
            };
            _options = webapi_options;
        }
        return this._GetPreferences(_request, _options);
    }
    async _SavePreferences(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreferences", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SavePreferences(preferences, webapi_options) {
        let _request = null;
        let _options = null;
        const first = preferences;
        if (typeof (first) === "object" && first && (typeof (first.Preferences) != 'undefined')) {
            _request = preferences;
            _options = webapi_options;
        }
        else {
            _request = {
                Preferences: preferences,
            };
            _options = webapi_options;
        }
        return this._SavePreferences(_request, _options);
    }
    async _GetPreferencesWithDisplayValues(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreferencesWithDisplayValues", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferenceArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreferencesWithDisplayValues(specifications, webapi_options) {
        let _request = null;
        let _options = null;
        const first = specifications;
        if (typeof (first) === "object" && first && (typeof (first.Specifications) != 'undefined')) {
            _request = specifications;
            _options = webapi_options;
        }
        else {
            _request = {
                Specifications: specifications,
            };
            _options = webapi_options;
        }
        return this._GetPreferencesWithDisplayValues(_request, _options);
    }
    async _GetTabOrders(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTabOrders", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TabOrderArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     *
     * @returns
     */
    async GetTabOrders(webapi_options) {
        return this._GetTabOrders(webapi_options);
    }
    async _SaveTabOrders(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTabOrders", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveTabOrders(tabOrders, webapi_options) {
        let _request = null;
        let _options = null;
        const first = tabOrders;
        if (typeof (first) === "object" && first && (typeof (first.TabOrders) != 'undefined')) {
            _request = tabOrders;
            _options = webapi_options;
        }
        else {
            _request = {
                TabOrders: tabOrders,
            };
            _options = webapi_options;
        }
        return this._SaveTabOrders(_request, _options);
    }
    async _SavePreferenceEntities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePreferenceEntities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SavePreferenceEntities(preferences, removeLowerLevels, webapi_options) {
        let _request = null;
        let _options = null;
        const first = preferences;
        if (typeof (first) === "object" && first && (typeof (first.Preferences) != 'undefined' || typeof (first.RemoveLowerLevels) != 'undefined')) {
            _request = preferences;
            _options = removeLowerLevels;
        }
        else {
            _request = {
                Preferences: preferences,
                RemoveLowerLevels: removeLowerLevels,
            };
            _options = webapi_options;
        }
        return this._SavePreferenceEntities(_request, _options);
    }
} // class v1PreferenceAgentController 
exports.PreferenceAgent = PreferenceAgent;
//# sourceMappingURL=PreferenceAgent.js.map
"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Agent that lets you configure dashboard tiles and retrieve dashboard data
 */
class DashAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Dash/";
        super(options);
    }
    /**
     * Set default values into a new Dash.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultDash(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDash", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Dash_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing Dash or creates a new Dash if the id parameter is empty
     * @param entity - The Dash to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated Dash
     */
    async SaveDash(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDash", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Dash_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the Dash
     * @param DashId - The id of the Dash to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteDash(DashId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDash?DashId=" + DashId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new DashCollection.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultDashCollection(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashCollection", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashCollection_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new DashTheme.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultDashTheme(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashTheme", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTheme_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DashTheme or creates a new DashTheme if the id parameter is empty
     * @param entity - The DashTheme to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DashTheme
     */
    async SaveDashTheme(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDashTheme", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTheme_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the DashTheme
     * @param DashThemeId - The id of the DashTheme to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteDashTheme(DashThemeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDashTheme?DashThemeId=" + DashThemeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new DashTile.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultDashTile(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashTile", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTile_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DashTile or creates a new DashTile if the id parameter is empty
     * @param entity - The DashTile to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DashTile
     */
    async SaveDashTile(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDashTile", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTile_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the DashTile
     * @param DashTileId - The id of the DashTile to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteDashTile(DashTileId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDashTile?DashTileId=" + DashTileId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new DashTileDefinition.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultDashTileDefinition(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDashTileDefinition", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTileDefinition_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DashTileDefinition or creates a new DashTileDefinition if the id parameter is empty
     * @param entity - The DashTileDefinition to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DashTileDefinition
     */
    async SaveDashTileDefinition(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDashTileDefinition", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTileDefinition_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the DashTileDefinition
     * @param DashTileDefinitionId - The id of the DashTileDefinition to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteDashTileDefinition(DashTileDefinitionId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDashTileDefinition?DashTileDefinitionId=" + DashTileDefinitionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new PreviewDash.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultPreviewDash(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreviewDash", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreviewDash_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new PreviewDashTile.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultPreviewDashTile(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreviewDashTile", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreviewDashTile_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Dash object.
     * @param dashId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Dash
     */
    async GetDash(dashId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDash?dashId=" + dashId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Dash_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _AddTileToDashboard(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddTileToDashboard", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTile_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddTileToDashboard(dashboardId, dashTileDefinitionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboardId;
        if (typeof (first) === "object" && first && (typeof (first.DashboardId) != 'undefined' || typeof (first.DashTileDefinitionId) != 'undefined')) {
            _request = dashboardId;
            _options = dashTileDefinitionId;
        }
        else {
            _request = {
                DashboardId: dashboardId,
                DashTileDefinitionId: dashTileDefinitionId,
            };
            _options = webapi_options;
        }
        return this._AddTileToDashboard(_request, _options);
    }
    async _AddNewTileToDashboard(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddNewTileToDashboard", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTile_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddNewTileToDashboard(dashboardId, dashTileDefinition, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboardId;
        if (typeof (first) === "object" && first && (typeof (first.DashboardId) != 'undefined' || typeof (first.DashTileDefinition) != 'undefined')) {
            _request = dashboardId;
            _options = dashTileDefinition;
        }
        else {
            _request = {
                DashboardId: dashboardId,
                DashTileDefinition: dashTileDefinition,
            };
            _options = webapi_options;
        }
        return this._AddNewTileToDashboard(_request, _options);
    }
    async _DuplicateDashboard(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DuplicateDashboard", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Dash_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DuplicateDashboard(dashboardId, name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboardId;
        if (typeof (first) === "object" && first && (typeof (first.DashboardId) != 'undefined' || typeof (first.Name) != 'undefined')) {
            _request = dashboardId;
            _options = name;
        }
        else {
            _request = {
                DashboardId: dashboardId,
                Name: name,
            };
            _options = webapi_options;
        }
        return this._DuplicateDashboard(_request, _options);
    }
    async _GetDashList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDashList(dashboards, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboards;
        if (typeof (first) === "object" && first && (typeof (first.Dashboards) != 'undefined')) {
            _request = dashboards;
            _options = webapi_options;
        }
        else {
            _request = {
                Dashboards: dashboards,
            };
            _options = webapi_options;
        }
        return this._GetDashList(_request, _options);
    }
    async _GetDashCollection(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashCollection", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashCollection_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets a collection of dashboards for the current associate
     * @returns Dashboard collection
     */
    async GetDashCollection(webapi_options) {
        return this._GetDashCollection(webapi_options);
    }
    /*
     * Gets a DashTheme object.
     * @param dashThemeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DashTheme
     */
    async GetDashTheme(dashThemeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDashTheme?dashThemeId=" + dashThemeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTheme_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a DashTile object.
     * @param dashTileId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DashTile
     */
    async GetDashTile(dashTileId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDashTile?dashTileId=" + dashTileId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTile_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetDashTiles(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashTiles", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTileArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDashTiles(dashboardId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboardId;
        if (typeof (first) === "object" && first && (typeof (first.DashboardId) != 'undefined')) {
            _request = dashboardId;
            _options = webapi_options;
        }
        else {
            _request = {
                DashboardId: dashboardId,
            };
            _options = webapi_options;
        }
        return this._GetDashTiles(_request, _options);
    }
    async _SaveDashTiles(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDashTiles", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveDashTiles(dashboardId, dashTiles, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboardId;
        if (typeof (first) === "object" && first && (typeof (first.DashboardId) != 'undefined' || typeof (first.DashTiles) != 'undefined')) {
            _request = dashboardId;
            _options = dashTiles;
        }
        else {
            _request = {
                DashboardId: dashboardId,
                DashTiles: dashTiles,
            };
            _options = webapi_options;
        }
        return this._SaveDashTiles(_request, _options);
    }
    async _CreateDashTileSelectionFromEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDashTileSelectionFromEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDashTileSelectionFromEntity(entityName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = entityName;
        if (typeof (first) === "object" && first && (typeof (first.EntityName) != 'undefined')) {
            _request = entityName;
            _options = webapi_options;
        }
        else {
            _request = {
                EntityName: entityName,
            };
            _options = webapi_options;
        }
        return this._CreateDashTileSelectionFromEntity(_request, _options);
    }
    async _CopyTileSelection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyTileSelection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CopyTileSelection(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._CopyTileSelection(_request, _options);
    }
    async _GetTempTileSelection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTempTileSelection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTempTileSelection(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._GetTempTileSelection(_request, _options);
    }
    async _GetSecondaryTempTileSelection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSecondaryTempTileSelection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSecondaryTempTileSelection(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._GetSecondaryTempTileSelection(_request, _options);
    }
    async _CreateDefaultTileForEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTileForEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTile_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultTileForEntity(entityName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = entityName;
        if (typeof (first) === "object" && first && (typeof (first.EntityName) != 'undefined')) {
            _request = entityName;
            _options = webapi_options;
        }
        else {
            _request = {
                EntityName: entityName,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultTileForEntity(_request, _options);
    }
    async _DuplicateTile(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DuplicateTile", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTile_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DuplicateTile(dashTileId, name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashTileId;
        if (typeof (first) === "object" && first && (typeof (first.DashTileId) != 'undefined' || typeof (first.Name) != 'undefined')) {
            _request = dashTileId;
            _options = name;
        }
        else {
            _request = {
                DashTileId: dashTileId,
                Name: name,
            };
            _options = webapi_options;
        }
        return this._DuplicateTile(_request, _options);
    }
    /*
     * Gets a DashTileDefinition object.
     * @param dashTileDefinitionId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DashTileDefinition
     */
    async GetDashTileDefinition(dashTileDefinitionId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDashTileDefinition?dashTileDefinitionId=" + dashTileDefinitionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTileDefinition_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _CreateDefaultTileDefinitionForEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultTileDefinitionForEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTileDefinition_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultTileDefinitionForEntity(entityName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = entityName;
        if (typeof (first) === "object" && first && (typeof (first.EntityName) != 'undefined')) {
            _request = entityName;
            _options = webapi_options;
        }
        else {
            _request = {
                EntityName: entityName,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultTileDefinitionForEntity(_request, _options);
    }
    async _GetDashTileHtml(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashTileHtml", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTileHtml_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDashTileHtml(dashboardTileDefinitionId, languageCode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboardTileDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.DashboardTileDefinitionId) != 'undefined' || typeof (first.LanguageCode) != 'undefined')) {
            _request = dashboardTileDefinitionId;
            _options = languageCode;
        }
        else {
            _request = {
                DashboardTileDefinitionId: dashboardTileDefinitionId,
                LanguageCode: languageCode,
            };
            _options = webapi_options;
        }
        return this._GetDashTileHtml(_request, _options);
    }
    async _GetDashTileHtmlList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDashTileHtmlList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTileHtmlArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDashTileHtmlList(dashboardTileDefinitionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboardTileDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.DashboardTileDefinitionId) != 'undefined')) {
            _request = dashboardTileDefinitionId;
            _options = webapi_options;
        }
        else {
            _request = {
                DashboardTileDefinitionId: dashboardTileDefinitionId,
            };
            _options = webapi_options;
        }
        return this._GetDashTileHtmlList(_request, _options);
    }
    async _SaveDashTileHtmlList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDashTileHtmlList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DashTileHtmlArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveDashTileHtmlList(dashboardTileDefinitionId, languages, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboardTileDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.DashboardTileDefinitionId) != 'undefined' || typeof (first.Languages) != 'undefined')) {
            _request = dashboardTileDefinitionId;
            _options = languages;
        }
        else {
            _request = {
                DashboardTileDefinitionId: dashboardTileDefinitionId,
                Languages: languages,
            };
            _options = webapi_options;
        }
        return this._SaveDashTileHtmlList(_request, _options);
    }
    async _GetPreviewDash(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewDash", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreviewDash_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreviewDash(dashboardId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = dashboardId;
        if (typeof (first) === "object" && first && (typeof (first.DashboardId) != 'undefined')) {
            _request = dashboardId;
            _options = webapi_options;
        }
        else {
            _request = {
                DashboardId: dashboardId,
            };
            _options = webapi_options;
        }
        return this._GetPreviewDash(_request, _options);
    }
} // class v1DashAgentController 
exports.DashAgent = DashAgent;
//# sourceMappingURL=DashAgent.js.map
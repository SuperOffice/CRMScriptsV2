"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomerServiceAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Agent used for Customer Service methods
 */
class CustomerServiceAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/CustomerService/";
        super(options);
    }
    /**
     * Set default values into a new CustomerCenterConfig.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultCustomerCenterConfig(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultCustomerCenterConfig", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerCenterConfig_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing CustomerCenterConfig or creates a new CustomerCenterConfig if the id parameter is empty
     * @param entity - The CustomerCenterConfig to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated CustomerCenterConfig
     */
    async SaveCustomerCenterConfig(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveCustomerCenterConfig", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerCenterConfig_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the CustomerCenterConfig
     * @param CustomerCenterConfigId - The id of the CustomerCenterConfig to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteCustomerCenterConfig(CustomerCenterConfigId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteCustomerCenterConfig?CustomerCenterConfigId=" + CustomerCenterConfigId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new MailboxEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultMailboxEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultMailboxEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MailboxEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing MailboxEntity or creates a new MailboxEntity if the id parameter is empty
     * @param entity - The MailboxEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated MailboxEntity
     */
    async SaveMailboxEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveMailboxEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MailboxEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new SmsConfig.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSmsConfig(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSmsConfig", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SmsConfig_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SmsConfig or creates a new SmsConfig if the id parameter is empty
     * @param entity - The SmsConfig to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SmsConfig
     */
    async SaveSmsConfig(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSmsConfig", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SmsConfig_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _UpdateFeatureToggles(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateFeatureToggles", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateFeatureToggles(featureToggles, webapi_options) {
        let _request = null;
        let _options = null;
        const first = featureToggles;
        if (typeof (first) === "object" && first && (typeof (first.FeatureToggles) != 'undefined')) {
            _request = featureToggles;
            _options = webapi_options;
        }
        else {
            _request = {
                FeatureToggles: featureToggles,
            };
            _options = webapi_options;
        }
        return this._UpdateFeatureToggles(_request, _options);
    }
    async _EventHandlerExists(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("EventHandlerExists", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async EventHandlerExists(eventHandlerType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = eventHandlerType;
        if (typeof (first) === "object" && first && (typeof (first.EventHandlerType) != 'undefined')) {
            _request = eventHandlerType;
            _options = webapi_options;
        }
        else {
            _request = {
                EventHandlerType: eventHandlerType,
            };
            _options = webapi_options;
        }
        return this._EventHandlerExists(_request, _options);
    }
    async _CreateSession(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateSession", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CsSessionKey_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateSession(remoteIp, webapi_options) {
        let _request = null;
        let _options = null;
        const first = remoteIp;
        if (typeof (first) === "object" && first && (typeof (first.RemoteIp) != 'undefined')) {
            _request = remoteIp;
            _options = webapi_options;
        }
        else {
            _request = {
                RemoteIp: remoteIp,
            };
            _options = webapi_options;
        }
        return this._CreateSession(_request, _options);
    }
    async _RemoveSession(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveSession", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveSession(loginId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = loginId;
        if (typeof (first) === "object" && first && (typeof (first.LoginId) != 'undefined')) {
            _request = loginId;
            _options = webapi_options;
        }
        else {
            _request = {
                LoginId: loginId,
            };
            _options = webapi_options;
        }
        return this._RemoveSession(_request, _options);
    }
    async _SessionIsValid(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SessionIsValid", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SessionIsValid(csSessionKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = csSessionKey;
        if (typeof (first) === "object" && first && (typeof (first.CsSessionKey) != 'undefined')) {
            _request = csSessionKey;
            _options = webapi_options;
        }
        else {
            _request = {
                CsSessionKey: csSessionKey,
            };
            _options = webapi_options;
        }
        return this._SessionIsValid(_request, _options);
    }
    async _HasChatNotify(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasChatNotify", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Check if user has any chat notification
     * @returns True if the user has at least one notification setting on
     */
    async HasChatNotify(webapi_options) {
        return this._HasChatNotify(webapi_options);
    }
    async _CheckSymmetricEncryption(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckSymmetricEncryption", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CheckSymmetricEncryption(encryptedString, webapi_options) {
        let _request = null;
        let _options = null;
        const first = encryptedString;
        if (typeof (first) === "object" && first && (typeof (first.EncryptedString) != 'undefined')) {
            _request = encryptedString;
            _options = webapi_options;
        }
        else {
            _request = {
                EncryptedString: encryptedString,
            };
            _options = webapi_options;
        }
        return this._CheckSymmetricEncryption(_request, _options);
    }
    async _ReportSessionActive(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ReportSessionActive", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ReportSessionActive(sessionKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sessionKey;
        if (typeof (first) === "object" && first && (typeof (first.SessionKey) != 'undefined')) {
            _request = sessionKey;
            _options = webapi_options;
        }
        else {
            _request = {
                SessionKey: sessionKey,
            };
            _options = webapi_options;
        }
        return this._ReportSessionActive(_request, _options);
    }
    /*
     * Gets a CustomerCenterConfig object.
     * @param customerCenterConfigId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single CustomerCenterConfig
     */
    async GetCustomerCenterConfig(customerCenterConfigId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCustomerCenterConfig?customerCenterConfigId=" + customerCenterConfigId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerCenterConfig_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetAllCustomerCenterConfigs(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllCustomerCenterConfigs", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerCenterConfigArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get all rows from cust_config as an array of CustomerCenterConfig entities
     * @returns An array of CustomerCenterConfig entities
     */
    async GetAllCustomerCenterConfigs(webapi_options) {
        return this._GetAllCustomerCenterConfigs(webapi_options);
    }
    async _SaveAllCustomerCenterConfigs(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveAllCustomerCenterConfigs", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveAllCustomerCenterConfigs(custConfigs, webapi_options) {
        let _request = null;
        let _options = null;
        const first = custConfigs;
        if (typeof (first) === "object" && first && (typeof (first.CustConfigs) != 'undefined')) {
            _request = custConfigs;
            _options = webapi_options;
        }
        else {
            _request = {
                CustConfigs: custConfigs,
            };
            _options = webapi_options;
        }
        return this._SaveAllCustomerCenterConfigs(_request, _options);
    }
    async _CheckIfCustomizedTemplates(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckIfCustomizedTemplates", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Checks whether the core html templates are customized
     * @returns True if the templates are customized
     */
    async CheckIfCustomizedTemplates(webapi_options) {
        return this._CheckIfCustomizedTemplates(webapi_options);
    }
    async _GetProgramUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProgramUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProgramUrl(programName, external, webapi_options) {
        let _request = null;
        let _options = null;
        const first = programName;
        if (typeof (first) === "object" && first && (typeof (first.ProgramName) != 'undefined' || typeof (first.External) != 'undefined')) {
            _request = programName;
            _options = external;
        }
        else {
            _request = {
                ProgramName: programName,
                External: external,
            };
            _options = webapi_options;
        }
        return this._GetProgramUrl(_request, _options);
    }
    async _GetFaqForCustomer(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFaqForCustomer", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFaqForCustomer(faqEntryId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = faqEntryId;
        if (typeof (first) === "object" && first && (typeof (first.FaqEntryId) != 'undefined')) {
            _request = faqEntryId;
            _options = webapi_options;
        }
        else {
            _request = {
                FaqEntryId: faqEntryId,
            };
            _options = webapi_options;
        }
        return this._GetFaqForCustomer(_request, _options);
    }
    async _GetCustomerServiceStartup(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCustomerServiceStartup", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerServiceStartup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the carrier with data that Service needs when starting up
     * @returns The carrier containing the startup data
     */
    async GetCustomerServiceStartup(webapi_options) {
        return this._GetCustomerServiceStartup(webapi_options);
    }
    async _ExecuteEventHandlers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExecuteEventHandlers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EventData_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ExecuteEventHandlers(eventData, webapi_options) {
        let _request = null;
        let _options = null;
        const first = eventData;
        if (typeof (first) === "object" && first && (typeof (first.EventData) != 'undefined')) {
            _request = eventData;
            _options = webapi_options;
        }
        else {
            _request = {
                EventData: eventData,
            };
            _options = webapi_options;
        }
        return this._ExecuteEventHandlers(_request, _options);
    }
    async _GetMailboxes(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMailboxes", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MailboxArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * This method will get all registered mailboxes in Service
     * @returns An array of Mailbox objects
     */
    async GetMailboxes(webapi_options) {
        return this._GetMailboxes(webapi_options);
    }
    /*
     * Gets a MailboxEntity object.
     * @param mailboxEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single MailboxEntity
     */
    async GetMailboxEntity(mailboxEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetMailboxEntity?mailboxEntityId=" + mailboxEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MailboxEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetPreviewFaqEntry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewFaqEntry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreviewFaqEntry_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreviewFaqEntry(kbEntryId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = kbEntryId;
        if (typeof (first) === "object" && first && (typeof (first.KbEntryId) != 'undefined')) {
            _request = kbEntryId;
            _options = webapi_options;
        }
        else {
            _request = {
                KbEntryId: kbEntryId,
            };
            _options = webapi_options;
        }
        return this._GetPreviewFaqEntry(_request, _options);
    }
    async _GetPreviewQuickReply(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewQuickReply", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreviewQuickReply_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreviewQuickReply(quickReplyId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quickReplyId;
        if (typeof (first) === "object" && first && (typeof (first.QuickReplyId) != 'undefined')) {
            _request = quickReplyId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuickReplyId: quickReplyId,
            };
            _options = webapi_options;
        }
        return this._GetPreviewQuickReply(_request, _options);
    }
    async _GetPreviewReplyTemplate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewReplyTemplate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreviewReplyTemplate_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreviewReplyTemplate(replyTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = replyTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.ReplyTemplateId) != 'undefined')) {
            _request = replyTemplateId;
            _options = webapi_options;
        }
        else {
            _request = {
                ReplyTemplateId: replyTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetPreviewReplyTemplate(_request, _options);
    }
    async _GetParsedTemplate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetParsedTemplate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReplyTemplateParsed_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetParsedTemplate(replyTemplateId, languageId, personId, ticketId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = replyTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.ReplyTemplateId) != 'undefined' || typeof (first.LanguageId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.TicketId) != 'undefined')) {
            _request = replyTemplateId;
            _options = languageId;
        }
        else {
            _request = {
                ReplyTemplateId: replyTemplateId,
                LanguageId: languageId,
                PersonId: personId,
                TicketId: ticketId,
            };
            _options = webapi_options;
        }
        return this._GetParsedTemplate(_request, _options);
    }
    async _GetUnparsedTemplate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnparsedTemplate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReplyTemplateParsed_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUnparsedTemplate(replyTemplateId, languageId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = replyTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.ReplyTemplateId) != 'undefined' || typeof (first.LanguageId) != 'undefined')) {
            _request = replyTemplateId;
            _options = languageId;
        }
        else {
            _request = {
                ReplyTemplateId: replyTemplateId,
                LanguageId: languageId,
            };
            _options = webapi_options;
        }
        return this._GetUnparsedTemplate(_request, _options);
    }
    async _GetSmsConfig(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSmsConfig", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SmsConfig_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the SmsConfig settings for Customer Service sms providers.
     * @returns Current SMS configuration.
     */
    async GetSmsConfig(webapi_options) {
        return this._GetSmsConfig(webapi_options);
    }
    async _TestSmtpServer(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestSmtpServer", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SmtpTestResult_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async TestSmtpServer(smtpUri, from, useStoredPassword, webapi_options) {
        let _request = null;
        let _options = null;
        const first = smtpUri;
        if (typeof (first) === "object" && first && (typeof (first.SmtpUri) != 'undefined' || typeof (first.From) != 'undefined' || typeof (first.UseStoredPassword) != 'undefined')) {
            _request = smtpUri;
            _options = from;
        }
        else {
            _request = {
                SmtpUri: smtpUri,
                From: from,
                UseStoredPassword: useStoredPassword,
            };
            _options = webapi_options;
        }
        return this._TestSmtpServer(_request, _options);
    }
    async _GetStatistics(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetStatistics", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StatisticsDataSetArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetStatistics(functions, webapi_options) {
        let _request = null;
        let _options = null;
        const first = functions;
        if (typeof (first) === "object" && first && (typeof (first.Functions) != 'undefined')) {
            _request = functions;
            _options = webapi_options;
        }
        else {
            _request = {
                Functions: functions,
            };
            _options = webapi_options;
        }
        return this._GetStatistics(_request, _options);
    }
    async _GetSystemTemplateSettings(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSystemTemplateSettings", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SystemTemplateSettings_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns system template settings
     * @returns System template settings item
     */
    async GetSystemTemplateSettings(webapi_options) {
        return this._GetSystemTemplateSettings(webapi_options);
    }
    async _SaveSystemTemplateSettings(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveSystemTemplateSettings", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SystemTemplateSettings_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveSystemTemplateSettings(systemTemplateSettings, webapi_options) {
        let _request = null;
        let _options = null;
        const first = systemTemplateSettings;
        if (typeof (first) === "object" && first && (typeof (first.SystemTemplateSettings) != 'undefined')) {
            _request = systemTemplateSettings;
            _options = webapi_options;
        }
        else {
            _request = {
                SystemTemplateSettings: systemTemplateSettings,
            };
            _options = webapi_options;
        }
        return this._SaveSystemTemplateSettings(_request, _options);
    }
    async _CreateTicketFromMailData(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTicketFromMailData", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateTicketFromMailData(mailboxId, data, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mailboxId;
        if (typeof (first) === "object" && first && (typeof (first.MailboxId) != 'undefined' || typeof (first.Data) != 'undefined')) {
            _request = mailboxId;
            _options = data;
        }
        else {
            _request = {
                MailboxId: mailboxId,
                Data: data,
            };
            _options = webapi_options;
        }
        return this._CreateTicketFromMailData(_request, _options);
    }
    async _AddMessageFromMailData(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddMessageFromMailData", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddMessageFromMailData(ticketId, data, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketId;
        if (typeof (first) === "object" && first && (typeof (first.TicketId) != 'undefined' || typeof (first.Data) != 'undefined')) {
            _request = ticketId;
            _options = data;
        }
        else {
            _request = {
                TicketId: ticketId,
                Data: data,
            };
            _options = webapi_options;
        }
        return this._AddMessageFromMailData(_request, _options);
    }
    async _FindTicketsByTitleOrId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindTicketsByTitleOrId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindTicketsByTitleOrId(titleOrId, maxRows, webapi_options) {
        let _request = null;
        let _options = null;
        const first = titleOrId;
        if (typeof (first) === "object" && first && (typeof (first.TitleOrId) != 'undefined' || typeof (first.MaxRows) != 'undefined')) {
            _request = titleOrId;
            _options = maxRows;
        }
        else {
            _request = {
                TitleOrId: titleOrId,
                MaxRows: maxRows,
            };
            _options = webapi_options;
        }
        return this._FindTicketsByTitleOrId(_request, _options);
    }
} // class v1CustomerServiceAgentController 
exports.CustomerServiceAgent = CustomerServiceAgent;
//# sourceMappingURL=CustomerServiceAgent.js.map
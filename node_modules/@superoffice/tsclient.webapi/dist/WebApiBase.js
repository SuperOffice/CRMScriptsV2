"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebApiBase = exports.ResourceParsing = exports.WebApiPatchOp = exports.ReturnBlobType = exports.WebApiStatus = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const AxiosCacheHandler_1 = require("./AxiosCacheHandler");
const SoApiConstants_1 = require("./SoApiConstants");
/** HTTP Request status on options object. Negative values indicate failure or cancellation. */
var WebApiStatus;
(function (WebApiStatus) {
    WebApiStatus[WebApiStatus["Unknown"] = 0] = "Unknown";
    WebApiStatus[WebApiStatus["Pending"] = 1] = "Pending";
    WebApiStatus[WebApiStatus["Completed"] = 10] = "Completed";
    WebApiStatus[WebApiStatus["Failed"] = -1] = "Failed";
    WebApiStatus[WebApiStatus["Cancelled"] = -4] = "Cancelled";
})(WebApiStatus = exports.WebApiStatus || (exports.WebApiStatus = {}));
/** How should Blob objects be returned? */
var ReturnBlobType;
(function (ReturnBlobType) {
    /** Return blob as ArrayBuffer */
    ReturnBlobType[ReturnBlobType["AsArrayBuffer"] = 0] = "AsArrayBuffer";
    /** Return Base64 string */
    ReturnBlobType[ReturnBlobType["AsBase64"] = 1] = "AsBase64";
    /** Return blob as string */
    ReturnBlobType[ReturnBlobType["AsString"] = 2] = "AsString";
})(ReturnBlobType = exports.ReturnBlobType || (exports.ReturnBlobType = {}));
/** RFC6902 patch operations */
var WebApiPatchOp;
(function (WebApiPatchOp) {
    WebApiPatchOp["add"] = "add";
    WebApiPatchOp["remove"] = "remove";
    WebApiPatchOp["replace"] = "replace";
    WebApiPatchOp["test"] = "test";
})(WebApiPatchOp = exports.WebApiPatchOp || (exports.WebApiPatchOp = {}));
/** Should WebAPI decode resource and multilang strings? Sets HTTP Language and Culture request headers to blank. */
var ResourceParsing;
(function (ResourceParsing) {
    /** Enables string substitution in responses. Sends the culture/language header. */
    ResourceParsing[ResourceParsing["Parse"] = 0] = "Parse";
    /** Disables string substitution. Does not send culture/language header. */
    ResourceParsing[ResourceParsing["DoNotParse"] = 1] = "DoNotParse";
})(ResourceParsing = exports.ResourceParsing || (exports.ResourceParsing = {}));
/** Base class for /api/v1/Agents/ clients */
class WebApiBase {
    constructor(options, createAxios = true) {
        var _a;
        const nodejs = typeof process !== "undefined" && process.versions && process.versions.node;
        const isBrowser = !nodejs && (typeof window !== "undefined" || typeof self !== "undefined");
        if (!isBrowser && !options.baseUrl)
            throw new Error("WebAPI: BaseURL is not defined.");
        if (!WebApiBase._global_options)
            WebApiBase._global_options = WebApiBase.CloneOptions(options);
        this.SetBaseUrl(options);
        if (options.resourceManager && options.resourceManager.getCurrentLangCode) {
            options.languageCode = options.resourceManager.getCurrentLangCode();
        }
        if (options.resourceManager && options.resourceManager.getCurrentFormatCode) {
            options.cultureCode = options.resourceManager.getCurrentFormatCode();
        }
        if (!options.axios && createAxios) {
            options.axios = axios_1.default.create(options.axiosConfig);
            // Set UserAgent if not in browser
            if (!isBrowser)
                options.axios.defaults.headers["User-Agent"] = "SO-TS-WebApi/1.0";
            options.axios.defaults.headers["Content-Type"] = "application/json";
            options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_BROWSER_TZ_OFFSET] =
                -new Date().getTimezoneOffset();
            if (options.languageCode)
                options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_LANGUAGE] = options.languageCode;
            if (options.cultureCode)
                options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_CULTURE] = options.cultureCode;
            if (options.timezone)
                options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE] = options.timezone;
            if (options.timezoneInclude) {
                options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE] =
                    (_a = options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE]) !== null && _a !== void 0 ? _a : "";
                if (options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE])
                    options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE] += ",";
                options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE] += "includeTZOffset";
            }
            if (options.resourceParsing === ResourceParsing.DoNotParse) {
                options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_ACCEPT_LANGUAGE] = "";
                options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_LANGUAGE] = "";
                options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_CULTURE] = "";
                delete options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_LANGUAGE];
                delete options.axios.defaults.headers[SoApiConstants_1.HEADER_NAME_CULTURE];
            }
            if (options.cache) {
                options.axios.interceptors.request.use(request => this.requestHandler(request, options.cache));
                options.axios.interceptors.response.use(response => this.responseHandler(response, options.cache), error => this.errorHandler(error));
            }
            else {
                options.axios.interceptors.response.use(undefined, options.errorHandler);
            }
        }
        this._options = options;
        this._axios = options.axios;
    }
    responseHandler(response, cache) {
        if (response.config.url) {
            AxiosCacheHandler_1.AxiosCache.store(response.config["cachekey"], response.data, cache.duration);
        }
        return response;
    }
    //Handler when cache hits in requestHandler
    errorHandler(error) {
        if (error && error.headers && error.headers.cached === "true") {
            return Promise.resolve(error);
        }
        if (this._options.errorHandler) {
            return this._options.errorHandler(error);
        }
        return Promise.reject(error);
    }
    requestHandler(request, cache) {
        //if refresh we do nothing
        if (cache.refresh) {
            return request;
        }
        request["cachekey"] =
            this.hashValue(request.url + JSON.stringify(request.data)) +
                (request.headers.get(SoApiConstants_1.HEADER_NAME_LANGUAGE) ? request.headers.get(SoApiConstants_1.HEADER_NAME_LANGUAGE) : "");
        const checkIsValidResponse = AxiosCacheHandler_1.AxiosCache.isValid(request["cachekey"] || "");
        if (checkIsValidResponse.isValid) {
            request.headers.set("cached", "true");
            request.data = checkIsValidResponse.value || "{}";
            // we 'fail' the request and let the error handler take care of the promise
            return Promise.reject(request);
        }
        return request;
    }
    SetBaseUrl(options) {
        if (options.baseUrl === "")
            options.baseUrl = "/api/";
        if (options.baseUrl.lastIndexOf("/") < options.baseUrl.length - 1)
            options.baseUrl += "/";
        // Move BasePath onto BaseUrl
        if (options.basePath) {
            if (options.baseUrl.lastIndexOf("api/") < options.baseUrl.length - 4)
                options.baseUrl += "api/";
            options.baseUrl += options.basePath;
            options.basePath = undefined;
        }
    }
    hashValue(s) {
        if (!s)
            return "";
        return ("_" +
            s.split("").reduce(function (a, b) {
                a = (a << 5) - a + b.charCodeAt(0);
                return a & a;
            }, 0));
    }
    static CloneOptions(options) {
        const clone = {
            baseUrl: options.baseUrl,
            resourceParsing: options.resourceParsing,
            languageCode: options.languageCode,
            cultureCode: options.cultureCode,
            timezone: options.timezone,
            timezoneInclude: options.timezoneInclude,
            axios: options.axios,
            axiosConfig: options.axiosConfig,
            resourceManager: options.resourceManager,
            cache: options.cache,
            errorHandler: options.errorHandler
        };
        return clone;
    }
    static GetAxiosRequestConfig(options, baseOptions) {
        var _a;
        let config = null;
        if (baseOptions) {
            if (baseOptions.axiosConfig)
                config = Object.assign({}, baseOptions.axiosConfig); // clone axios config
            config = config || {};
            if (baseOptions.baseUrl)
                config.baseURL = baseOptions.baseUrl;
        }
        config = config || {};
        config.params = config.params || {};
        config.headers = config.headers || {};
        config.headers["Accept"] = "application/json";
        if (options) {
            options.requestStatus = WebApiStatus.Pending;
            if (typeof options.languageCode == "string") {
                config.headers[SoApiConstants_1.HEADER_NAME_ACCEPT_LANGUAGE] = options.languageCode;
                config.headers[SoApiConstants_1.HEADER_NAME_LANGUAGE] = options.languageCode;
            }
            if (typeof options.cultureCode == "string") {
                config.headers[SoApiConstants_1.HEADER_NAME_CULTURE] = options.cultureCode;
            }
            if (typeof options.timezone == "string") {
                config.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE] = options.timezone;
            }
            if (options.timezoneInclude) {
                config.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE] = (_a = config.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE]) !== null && _a !== void 0 ? _a : "";
                if (config.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE])
                    config.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE] += ",";
                config.headers[SoApiConstants_1.HEADER_NAME_TIMEZONE] += "includeTZOffset";
            }
            // If we have abortController, do not use cancel token
            if (options.abortController) {
                config.signal = options.abortController.signal;
            }
            else if (options.cancelToken) {
                config.cancelToken = options.cancelToken.token;
            }
            if (options.abortController) {
                config.signal = options.abortController.signal;
            }
            const getOptions = options;
            if (getOptions && getOptions.ifModifiedSince) {
                if (typeof getOptions.ifModifiedSince == "object")
                    config.headers["If-Modified-Since"] = getOptions.ifModifiedSince.toUTCString();
                if (typeof getOptions.ifModifiedSince == "string")
                    config.headers["If-Modified-Since"] = getOptions.ifModifiedSince;
                if (!getOptions.ifNotModifiedThrowError)
                    config.validateStatus = WebApiBase.validateModifiedStatus;
                else
                    config.validateStatus = WebApiBase.validate200Status; // 304 throws error
            }
            if (getOptions && getOptions.ifUnmodifiedSince) {
                if (typeof getOptions.ifUnmodifiedSince == "object")
                    config.headers["If-Unmodified-Since"] = getOptions.ifUnmodifiedSince.toUTCString();
                if (typeof getOptions.ifUnmodifiedSince == "string")
                    config.headers["If-Unmodified-Since"] = getOptions.ifUnmodifiedSince;
            }
            const putOptions = options;
            if (putOptions && putOptions.ifUnmodifiedSince) {
                if (typeof putOptions.ifUnmodifiedSince == "object")
                    config.headers["If-Unmodified-Since"] = putOptions.ifUnmodifiedSince.toUTCString();
                if (typeof putOptions.ifUnmodifiedSince == "string")
                    config.headers["If-Unmodified-Since"] = putOptions.ifUnmodifiedSince;
            }
        }
        WebApiBase.SetXSRFTokenFromHiddenField();
        return config;
    }
    static SetXSRFTokenFromHiddenField() {
        // don't do this if we are not in browser context
        if (typeof window != "undefined" && document && document.cookie) {
            if (document.cookie.indexOf("XSRF-TOKEN") < 0) {
                // no XSRF-TOKEN cookie - see if we can add one from the hidden form field
                let xsrfToken = undefined;
                let msg = undefined;
                const xsrfInput = document.getElementById("XSRF_TOKEN");
                if (xsrfInput) {
                    xsrfToken = xsrfInput.value;
                    msg = "Setting XSRF cookie from INPUT field";
                }
                if (!xsrfToken) {
                    // still no XSRF-TOKEN value
                    msg = "No XSRF cookie found.";
                    if (console)
                        console.log(msg);
                }
                if (xsrfToken) {
                    // Normalize path:
                    // "/crm.web/admin/default.aspx" --> "/crm.web/"
                    // '/crm.web/cs/scripts/ticket.exe' --> '/crm.web/cs/"
                    let path = window.location.pathname;
                    let lowpath = path.toLowerCase();
                    if (lowpath.endsWith("default.aspx"))
                        path = path.substring(0, path.length - 12);
                    lowpath = path.toLowerCase();
                    if (lowpath.endsWith("/"))
                        path = path.substring(0, path.length - 1);
                    lowpath = path.toLowerCase();
                    if (lowpath.endsWith("/admin"))
                        path = path.substring(0, path.length - 6);
                    lowpath = path.toLowerCase();
                    let scriptsPos = lowpath.indexOf("/scripts/");
                    let exePos = lowpath.indexOf(".fcgi");
                    if (exePos < 0)
                        exePos = lowpath.indexOf(".exe");
                    if (scriptsPos > 0 && exePos > 0) {
                        path = path.substring(0, scriptsPos); // /crm.web/cs/scripts/ticket.exe' --> '/crm.web/cs'
                        let slashPos = path.lastIndexOf("/");
                        if (slashPos > 1)
                            path = path.substring(0, slashPos); // '/crm.web/cs' --> ''/crm.web'
                    }
                    document.cookie = "XSRF-TOKEN=" + xsrfToken + ";SameSite=Lax;Secure;path=" + path;
                    if (console)
                        console.log(msg);
                    document.cookie = "XSRF-FROM-INPUT=" + path + ";SameSite=Lax;Secure;"; // path defaults to document location
                }
            }
        }
    }
    // `validateStatus` defines whether to resolve or reject the promise for a given
    // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`
    // or `undefined`), the promise will be resolved; otherwise, the promise will be
    // rejected.
    // validate 304 Unmodified as ok
    static validateModifiedStatus(status) {
        const validate = (status >= 200 && status < 300) || status === 304;
        return validate;
    }
    static validate200Status(status) {
        const validate = status >= 200 && status < 300;
        return validate;
    }
    static FigureOutOptions(baseUrlOrOptions, langOrconfigOrRMOrParse, langOrResourceOrRM, cultureCode) {
        let options = {};
        if (typeof baseUrlOrOptions == "object") {
            // Make a copy so we don't mess up caller's copy of options object
            options = baseUrlOrOptions;
            options = WebApiBase.CloneOptions(options);
        }
        else if (typeof baseUrlOrOptions == "string") {
            options = {
                baseUrl: baseUrlOrOptions
            };
        }
        if (typeof langOrconfigOrRMOrParse == "string") {
            options.languageCode = langOrconfigOrRMOrParse;
        }
        else if (typeof langOrconfigOrRMOrParse == "object") {
            if (langOrconfigOrRMOrParse.getCurrentLangCode && langOrconfigOrRMOrParse.getCurrentLangCode)
                options.resourceManager = langOrconfigOrRMOrParse;
            if (langOrconfigOrRMOrParse.auth ||
                langOrconfigOrRMOrParse.baseURL ||
                langOrconfigOrRMOrParse.url ||
                langOrconfigOrRMOrParse.headers ||
                langOrconfigOrRMOrParse.timeout)
                options.axiosConfig = langOrconfigOrRMOrParse;
        }
        else if (typeof langOrconfigOrRMOrParse == "number") {
            options.resourceParsing = langOrconfigOrRMOrParse;
        }
        if (typeof langOrResourceOrRM == "string") {
            options.languageCode = langOrResourceOrRM;
        }
        else if (typeof langOrResourceOrRM == "number") {
            options.resourceParsing = langOrResourceOrRM;
        }
        else if (typeof langOrResourceOrRM == "object") {
            if (langOrResourceOrRM.getCurrentLangCode && langOrResourceOrRM.getCurrentLangCode)
                options.resourceManager = langOrResourceOrRM;
            if (langOrResourceOrRM.auth ||
                langOrResourceOrRM.baseURL ||
                langOrResourceOrRM.url ||
                langOrResourceOrRM.headers ||
                langOrResourceOrRM.timeout)
                options.axiosConfig = langOrResourceOrRM;
        }
        if (cultureCode)
            options.cultureCode = cultureCode;
        // Check for global defaults for missing properties
        if (WebApiBase._global_options) {
            if (!options.baseUrl)
                options.baseUrl = WebApiBase._global_options.baseUrl;
            if (!options.axios)
                options.axios = WebApiBase._global_options.axios;
            if (!options.axiosConfig)
                options.axiosConfig = WebApiBase._global_options.axiosConfig;
            if (!options.cultureCode)
                options.cultureCode = WebApiBase._global_options.cultureCode;
            if (!options.languageCode)
                options.languageCode = WebApiBase._global_options.languageCode;
            if (!options.timezone)
                options.timezone = WebApiBase._global_options.timezone;
            if (options.timezoneInclude === undefined)
                options.timezoneInclude = WebApiBase._global_options.timezoneInclude;
            if (!options.resourceManager)
                options.resourceManager = WebApiBase._global_options.resourceManager;
            if (!options.errorHandler)
                options.errorHandler = WebApiBase._global_options.errorHandler;
        }
        return options;
    }
    /** @deprecated Make a new cancel token that can be placed in an WebApiRequestOptions object. */
    MakeCancelToken() {
        return axios_1.default.CancelToken.source();
    }
    /** Make a new AbortController that can be placed in an  WebApiRequestOptions object */
    MakeAbortController() {
        return new AbortController();
    }
    /** @deprecated Make a new options object with an cancelToken on it. */
    MakeOptions() {
        const opts = {};
        opts.requestStatus = WebApiStatus.Unknown;
        opts.cancelToken = this.MakeCancelToken();
        return opts;
    }
    /** Make a new options object with an abortController on it */
    MakeAbortableOptions() {
        const opts = {};
        opts.requestStatus = WebApiStatus.Unknown;
        opts.abortController = this.MakeAbortController();
        return opts;
    }
    static SetPending(options) {
        var _a;
        if (options)
            options.requestStatus = WebApiStatus.Pending;
        if (options && options.threshold) {
            options.threshold.timeoutHandler = setTimeout(() => {
                //We do not want successCallback to be call if the threshold is reached
                if (options.threshold.timeout > 0)
                    options.threshold.successCallback = null;
                options.threshold.callback();
            }, options.threshold.timeout);
        }
        if ((_a = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _a === void 0 ? void 0 : _a.token.reason)
            options.requestStatus = WebApiStatus.Cancelled;
    }
    static SetCompleted(options) {
        var _a, _b;
        if (options) {
            if (options === null || options === void 0 ? void 0 : options.threshold) {
                clearTimeout(options.threshold.timeoutHandler);
                if (options.threshold.successCallback)
                    options.threshold.successCallback();
            }
            if ((_b = (_a = options.cancelToken) === null || _a === void 0 ? void 0 : _a.token) === null || _b === void 0 ? void 0 : _b.reason)
                options.requestStatus = WebApiStatus.Cancelled;
            else
                options.requestStatus = WebApiStatus.Completed;
        }
    }
    static HandleError(options, config, err) {
        if (options) {
            if (options && options.threshold) {
                clearTimeout(options.threshold.timeoutHandler);
                if (options.threshold.errorCallback)
                    options.threshold.errorCallback();
            }
            if (((config === null || config === void 0 ? void 0 : config.signal) || (config === null || config === void 0 ? void 0 : config.cancelToken)) && axios_1.default.isCancel(err)) {
                options.requestStatus = WebApiStatus.Cancelled;
            }
            else {
                options.requestStatus = WebApiStatus.Failed;
            }
        }
    }
}
exports.WebApiBase = WebApiBase;
//# sourceMappingURL=WebApiBase.js.map
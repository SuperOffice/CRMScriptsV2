"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.BLOBAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
const Base64_1 = require("./Base64");
/**
 * Collection of all services that works with binary objects (BLOBS), e.g. Images and documents.
 */
class BLOBAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/BLOB/";
        super(options);
    }
    /**
     * Set default values into a new BlobEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultBlobEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultBlobEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BlobEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing BlobEntity or creates a new BlobEntity if the id parameter is empty
     * @param entity - The BlobEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated BlobEntity
     */
    async SaveBlobEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveBlobEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BlobEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the BlobEntity
     * @param BlobEntityId - The id of the BlobEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteBlobEntity(BlobEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteBlobEntity?BlobEntityId=" + BlobEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a BlobEntity object.
     * @param blobEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single BlobEntity
     */
    async GetBlobEntity(blobEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetBlobEntity?blobEntityId=" + blobEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BlobEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SetBlobStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetBlobStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetBlobStream(blobEntityId, stream, webapi_options) {
        let _request = null;
        let _options = null;
        const first = blobEntityId;
        if (typeof (first) === "object" && first && (typeof (first.BlobEntityId) != 'undefined' || typeof (first.Stream) != 'undefined')) {
            _request = blobEntityId;
            _options = stream;
        }
        else {
            _request = {
                BlobEntityId: blobEntityId,
                Stream: stream,
            };
            _options = webapi_options;
        }
        _request.Stream = (0, Base64_1.ToBase64)(_request.Stream);
        return this._SetBlobStream(_request, _options);
    }
    async _GetBlobStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobStream", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetBlobStream(blobEntityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = blobEntityId;
        if (typeof (first) === "object" && first && (typeof (first.BlobEntityId) != 'undefined')) {
            _request = blobEntityId;
            _options = webapi_options;
        }
        else {
            _request = {
                BlobEntityId: blobEntityId,
            };
            _options = webapi_options;
        }
        return this._GetBlobStream(_request, _options);
    }
    async _GetProjectImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectImage", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectImage(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetProjectImage(_request, _options);
    }
    async _GetPersonImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonImage", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonImage(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetPersonImage(_request, _options);
    }
    async _SetProjectImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetProjectImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetProjectImage(projectId, image, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.Image) != 'undefined')) {
            _request = projectId;
            _options = image;
        }
        else {
            _request = {
                ProjectId: projectId,
                Image: image,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SetProjectImage(_request, _options);
    }
    async _SetPersonImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPersonImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetPersonImage(personId, image, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.Image) != 'undefined')) {
            _request = personId;
            _options = image;
        }
        else {
            _request = {
                PersonId: personId,
                Image: image,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SetPersonImage(_request, _options);
    }
    async _ChangeProjectImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeProjectImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeProjectImage(projectId, blobId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.BlobId) != 'undefined')) {
            _request = projectId;
            _options = blobId;
        }
        else {
            _request = {
                ProjectId: projectId,
                BlobId: blobId,
            };
            _options = webapi_options;
        }
        return this._ChangeProjectImage(_request, _options);
    }
    async _SaveProjectImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveProjectImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveProjectImage(description, image, webapi_options) {
        let _request = null;
        let _options = null;
        const first = description;
        if (typeof (first) === "object" && first && (typeof (first.Description) != 'undefined' || typeof (first.Image) != 'undefined')) {
            _request = description;
            _options = image;
        }
        else {
            _request = {
                Description: description,
                Image: image,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SaveProjectImage(_request, _options);
    }
    async _GetBlobEntityOnProject(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnProject", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BlobEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetBlobEntityOnProject(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetBlobEntityOnProject(_request, _options);
    }
    async _GetBlobEntityOnPerson(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnPerson", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BlobEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetBlobEntityOnPerson(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetBlobEntityOnPerson(_request, _options);
    }
    async _GetBlobEntityOnCountry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnCountry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BlobEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetBlobEntityOnCountry(countryId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = countryId;
        if (typeof (first) === "object" && first && (typeof (first.CountryId) != 'undefined')) {
            _request = countryId;
            _options = webapi_options;
        }
        else {
            _request = {
                CountryId: countryId,
            };
            _options = webapi_options;
        }
        return this._GetBlobEntityOnCountry(_request, _options);
    }
    async _GetBlobEntityOnProduct(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnProduct", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BlobEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetBlobEntityOnProduct(productId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = productId;
        if (typeof (first) === "object" && first && (typeof (first.ProductId) != 'undefined')) {
            _request = productId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProductId: productId,
            };
            _options = webapi_options;
        }
        return this._GetBlobEntityOnProduct(_request, _options);
    }
    async _ChangePersonImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangePersonImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangePersonImage(personId, blobId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.BlobId) != 'undefined')) {
            _request = personId;
            _options = blobId;
        }
        else {
            _request = {
                PersonId: personId,
                BlobId: blobId,
            };
            _options = webapi_options;
        }
        return this._ChangePersonImage(_request, _options);
    }
    async _SaveImageStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveImageStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveImageStream(type, image, description, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined' || typeof (first.Image) != 'undefined' || typeof (first.Description) != 'undefined')) {
            _request = type;
            _options = image;
        }
        else {
            _request = {
                Type: type,
                Image: image,
                Description: description,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SaveImageStream(_request, _options);
    }
    async _GetProductImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductImage", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProductImage(productId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = productId;
        if (typeof (first) === "object" && first && (typeof (first.ProductId) != 'undefined')) {
            _request = productId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProductId: productId,
            };
            _options = webapi_options;
        }
        return this._GetProductImage(_request, _options);
    }
    async _SetProductImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetProductImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetProductImage(productId, image, webapi_options) {
        let _request = null;
        let _options = null;
        const first = productId;
        if (typeof (first) === "object" && first && (typeof (first.ProductId) != 'undefined' || typeof (first.Image) != 'undefined')) {
            _request = productId;
            _options = image;
        }
        else {
            _request = {
                ProductId: productId,
                Image: image,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SetProductImage(_request, _options);
    }
    async _GetProductThumbnail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductThumbnail", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProductThumbnail(productId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = productId;
        if (typeof (first) === "object" && first && (typeof (first.ProductId) != 'undefined')) {
            _request = productId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProductId: productId,
            };
            _options = webapi_options;
        }
        return this._GetProductThumbnail(_request, _options);
    }
    async _SetProductThumbnail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetProductThumbnail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetProductThumbnail(productId, image, webapi_options) {
        let _request = null;
        let _options = null;
        const first = productId;
        if (typeof (first) === "object" && first && (typeof (first.ProductId) != 'undefined' || typeof (first.Image) != 'undefined')) {
            _request = productId;
            _options = image;
        }
        else {
            _request = {
                ProductId: productId,
                Image: image,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SetProductThumbnail(_request, _options);
    }
    async _ChangeProductImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeProductImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeProductImage(productId, blobId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = productId;
        if (typeof (first) === "object" && first && (typeof (first.ProductId) != 'undefined' || typeof (first.BlobId) != 'undefined')) {
            _request = productId;
            _options = blobId;
        }
        else {
            _request = {
                ProductId: productId,
                BlobId: blobId,
            };
            _options = webapi_options;
        }
        return this._ChangeProductImage(_request, _options);
    }
    async _GetQuoteLineImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLineImage", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteLineImage(quoteLineId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineId) != 'undefined')) {
            _request = quoteLineId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLineId: quoteLineId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteLineImage(_request, _options);
    }
    async _GetAppData(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppData", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAppData(key, webapi_options) {
        let _request = null;
        let _options = null;
        const first = key;
        if (typeof (first) === "object" && first && (typeof (first.Key) != 'undefined')) {
            _request = key;
            _options = webapi_options;
        }
        else {
            _request = {
                Key: key,
            };
            _options = webapi_options;
        }
        return this._GetAppData(_request, _options);
    }
    async _SetAppData(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetAppData", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetAppData(key, data, webapi_options) {
        let _request = null;
        let _options = null;
        const first = key;
        if (typeof (first) === "object" && first && (typeof (first.Key) != 'undefined' || typeof (first.Data) != 'undefined')) {
            _request = key;
            _options = data;
        }
        else {
            _request = {
                Key: key,
                Data: data,
            };
            _options = webapi_options;
        }
        return this._SetAppData(_request, _options);
    }
    async _GetPersonImageWithSize(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonImageWithSize", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonImageWithSize(personId, width, height, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.Width) != 'undefined' || typeof (first.Height) != 'undefined')) {
            _request = personId;
            _options = width;
        }
        else {
            _request = {
                PersonId: personId,
                Width: width,
                Height: height,
            };
            _options = webapi_options;
        }
        return this._GetPersonImageWithSize(_request, _options);
    }
    async _GetProjectImageWithSize(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectImageWithSize", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectImageWithSize(projectId, width, height, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.Width) != 'undefined' || typeof (first.Height) != 'undefined')) {
            _request = projectId;
            _options = width;
        }
        else {
            _request = {
                ProjectId: projectId,
                Width: width,
                Height: height,
            };
            _options = webapi_options;
        }
        return this._GetProjectImageWithSize(_request, _options);
    }
    async _GetChatImageWithSize(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatImageWithSize", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetChatImageWithSize(chatTopicId, width, height, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatTopicId;
        if (typeof (first) === "object" && first && (typeof (first.ChatTopicId) != 'undefined' || typeof (first.Width) != 'undefined' || typeof (first.Height) != 'undefined')) {
            _request = chatTopicId;
            _options = width;
        }
        else {
            _request = {
                ChatTopicId: chatTopicId,
                Width: width,
                Height: height,
            };
            _options = webapi_options;
        }
        return this._GetChatImageWithSize(_request, _options);
    }
    async _GetContactImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactImage", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactImage(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._GetContactImage(_request, _options);
    }
    async _SetContactImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetContactImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetContactImage(contactId, image, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.Image) != 'undefined')) {
            _request = contactId;
            _options = image;
        }
        else {
            _request = {
                ContactId: contactId,
                Image: image,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SetContactImage(_request, _options);
    }
    async _ChangeContactImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeContactImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeContactImage(contactId, blobId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.BlobId) != 'undefined')) {
            _request = contactId;
            _options = blobId;
        }
        else {
            _request = {
                ContactId: contactId,
                BlobId: blobId,
            };
            _options = webapi_options;
        }
        return this._ChangeContactImage(_request, _options);
    }
    async _GetBlobEntityOnContact(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBlobEntityOnContact", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BlobEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetBlobEntityOnContact(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._GetBlobEntityOnContact(_request, _options);
    }
    async _GetContactImageWithSize(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactImageWithSize", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactImageWithSize(contactId, width, height, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.Width) != 'undefined' || typeof (first.Height) != 'undefined')) {
            _request = contactId;
            _options = width;
        }
        else {
            _request = {
                ContactId: contactId,
                Width: width,
                Height: height,
            };
            _options = webapi_options;
        }
        return this._GetContactImageWithSize(_request, _options);
    }
    async _GetOutputFromBatch(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOutputFromBatch", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetOutputFromBatch(batchTaskId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = batchTaskId;
        if (typeof (first) === "object" && first && (typeof (first.BatchTaskId) != 'undefined')) {
            _request = batchTaskId;
            _options = webapi_options;
        }
        else {
            _request = {
                BatchTaskId: batchTaskId,
            };
            _options = webapi_options;
        }
        return this._GetOutputFromBatch(_request, _options);
    }
    async _CleanupBatchTask(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CleanupBatchTask", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CleanupBatchTask(batchTaskId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = batchTaskId;
        if (typeof (first) === "object" && first && (typeof (first.BatchTaskId) != 'undefined')) {
            _request = batchTaskId;
            _options = webapi_options;
        }
        else {
            _request = {
                BatchTaskId: batchTaskId,
            };
            _options = webapi_options;
        }
        return this._CleanupBatchTask(_request, _options);
    }
} // class v1BLOBAgentController 
exports.BLOBAgent = BLOBAgent;
//# sourceMappingURL=BLOBAgent.js.map
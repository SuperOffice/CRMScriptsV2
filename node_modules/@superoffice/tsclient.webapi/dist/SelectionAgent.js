"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectionAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Selections, entities, members and tasks
 */
class SelectionAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Selection/";
        super(options);
    }
    /**
     * Set default values into a new MailMergeSettings.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultMailMergeSettings(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultMailMergeSettings", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MailMergeSettings_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new MailMergeTask.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultMailMergeTask(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultMailMergeTask", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MailMergeTask_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new SelectionEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSelectionEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSelectionEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SelectionEntity or creates a new SelectionEntity if the id parameter is empty
     * @param entity - The SelectionEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SelectionEntity
     */
    async SaveSelectionEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSelectionEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the SelectionEntity
     * @param SelectionEntityId - The id of the SelectionEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteSelectionEntity(SelectionEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteSelectionEntity?SelectionEntityId=" + SelectionEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a SelectionEntity object.
     * @param selectionEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SelectionEntity
     */
    async GetSelectionEntity(selectionEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSelectionEntity?selectionEntityId=" + selectionEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _CreateSelectionEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateSelectionEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateSelectionEntity(targetTableName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = targetTableName;
        if (typeof (first) === "object" && first && (typeof (first.TargetTableName) != 'undefined')) {
            _request = targetTableName;
            _options = webapi_options;
        }
        else {
            _request = {
                TargetTableName: targetTableName,
            };
            _options = webapi_options;
        }
        return this._CreateSelectionEntity(_request, _options);
    }
    async _CreateContactSelectionFromSelection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateContactSelectionFromSelection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateContactSelectionFromSelection(selectionId, name, targetSelectionType, copyMembers, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Name) != 'undefined' || typeof (first.TargetSelectionType) != 'undefined' || typeof (first.CopyMembers) != 'undefined')) {
            _request = selectionId;
            _options = name;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Name: name,
                TargetSelectionType: targetSelectionType,
                CopyMembers: copyMembers,
            };
            _options = webapi_options;
        }
        return this._CreateContactSelectionFromSelection(_request, _options);
    }
    async _CreateTemporaryContactSelectionFromContactPersonIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryContactSelectionFromContactPersonIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateTemporaryContactSelectionFromContactPersonIds(contactPersonIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactPersonIds;
        if (typeof (first) === "object" && first && (typeof (first.ContactPersonIds) != 'undefined')) {
            _request = contactPersonIds;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactPersonIds: contactPersonIds,
            };
            _options = webapi_options;
        }
        return this._CreateTemporaryContactSelectionFromContactPersonIds(_request, _options);
    }
    async _CreateTemporaryContactSelectionFromProjectMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryContactSelectionFromProjectMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateTemporaryContactSelectionFromProjectMembers(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._CreateTemporaryContactSelectionFromProjectMembers(_request, _options);
    }
    async _CopyContactSelectionMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyContactSelectionMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CopyContactSelectionMembers(fromSelectionId, toSelectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = fromSelectionId;
        if (typeof (first) === "object" && first && (typeof (first.FromSelectionId) != 'undefined' || typeof (first.ToSelectionId) != 'undefined')) {
            _request = fromSelectionId;
            _options = toSelectionId;
        }
        else {
            _request = {
                FromSelectionId: fromSelectionId,
                ToSelectionId: toSelectionId,
            };
            _options = webapi_options;
        }
        return this._CopyContactSelectionMembers(_request, _options);
    }
    async _GetRecipientStatistics(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecipientStatistics", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RecipientStatistics_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetRecipientStatistics(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._GetRecipientStatistics(_request, _options);
    }
    async _GetRecipientStatisticsFromProjectMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecipientStatisticsFromProjectMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RecipientStatistics_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetRecipientStatisticsFromProjectMembers(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetRecipientStatisticsFromProjectMembers(_request, _options);
    }
    async _GetRecipientStatisticsFromContactPersonIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecipientStatisticsFromContactPersonIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RecipientStatistics_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetRecipientStatisticsFromContactPersonIds(contactPersonIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactPersonIds;
        if (typeof (first) === "object" && first && (typeof (first.ContactPersonIds) != 'undefined')) {
            _request = contactPersonIds;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactPersonIds: contactPersonIds,
            };
            _options = webapi_options;
        }
        return this._GetRecipientStatisticsFromContactPersonIds(_request, _options);
    }
    async _AddContactSelectionMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddContactSelectionMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddContactSelectionMembers(selectionId, contactPersonIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.ContactPersonIds) != 'undefined')) {
            _request = selectionId;
            _options = contactPersonIds;
        }
        else {
            _request = {
                SelectionId: selectionId,
                ContactPersonIds: contactPersonIds,
            };
            _options = webapi_options;
        }
        return this._AddContactSelectionMembers(_request, _options);
    }
    async _RemoveContactSelectionMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveContactSelectionMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveContactSelectionMembers(selectionId, contactPersonIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.ContactPersonIds) != 'undefined')) {
            _request = selectionId;
            _options = contactPersonIds;
        }
        else {
            _request = {
                SelectionId: selectionId,
                ContactPersonIds: contactPersonIds,
            };
            _options = webapi_options;
        }
        return this._RemoveContactSelectionMembers(_request, _options);
    }
    async _RemoveContactSelectionMembersFromIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveContactSelectionMembersFromIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveContactSelectionMembersFromIds(selectionId, selectionMembersIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.SelectionMembersIds) != 'undefined')) {
            _request = selectionId;
            _options = selectionMembersIds;
        }
        else {
            _request = {
                SelectionId: selectionId,
                SelectionMembersIds: selectionMembersIds,
            };
            _options = webapi_options;
        }
        return this._RemoveContactSelectionMembersFromIds(_request, _options);
    }
    async _AddContactSelectionMembersFromSearch(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddContactSelectionMembersFromSearch", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddContactSelectionMembersFromSearch(selectionId, storageKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.StorageKey) != 'undefined')) {
            _request = selectionId;
            _options = storageKey;
        }
        else {
            _request = {
                SelectionId: selectionId,
                StorageKey: storageKey,
            };
            _options = webapi_options;
        }
        return this._AddContactSelectionMembersFromSearch(_request, _options);
    }
    async _RemoveContactSelectionMembersFromSearch(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveContactSelectionMembersFromSearch", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveContactSelectionMembersFromSearch(selectionId, storageKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.StorageKey) != 'undefined')) {
            _request = selectionId;
            _options = storageKey;
        }
        else {
            _request = {
                SelectionId: selectionId,
                StorageKey: storageKey,
            };
            _options = webapi_options;
        }
        return this._RemoveContactSelectionMembersFromSearch(_request, _options);
    }
    async _CreateTemporaryContactSelection(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryContactSelection", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Creates a temporary selection.
     * @returns Returns the newly created SelectionEntity.
     */
    async CreateTemporaryContactSelection(webapi_options) {
        return this._CreateTemporaryContactSelection(webapi_options);
    }
    async _CreateTemporaryContactSelectionFromSelectionMemberIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryContactSelectionFromSelectionMemberIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateTemporaryContactSelectionFromSelectionMemberIds(selectionId, selectionMemberIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.SelectionMemberIds) != 'undefined')) {
            _request = selectionId;
            _options = selectionMemberIds;
        }
        else {
            _request = {
                SelectionId: selectionId,
                SelectionMemberIds: selectionMemberIds,
            };
            _options = webapi_options;
        }
        return this._CreateTemporaryContactSelectionFromSelectionMemberIds(_request, _options);
    }
    async _AddRemoveContactSelectionMemberInterests(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddRemoveContactSelectionMemberInterests", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddRemoveContactSelectionMemberInterests(selectionId, addCompanyInterests, removeCompanyInterests, addContactInterests, removeContactInterests, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.AddCompanyInterests) != 'undefined' || typeof (first.RemoveCompanyInterests) != 'undefined' || typeof (first.AddContactInterests) != 'undefined' || typeof (first.RemoveContactInterests) != 'undefined')) {
            _request = selectionId;
            _options = addCompanyInterests;
        }
        else {
            _request = {
                SelectionId: selectionId,
                AddCompanyInterests: addCompanyInterests,
                RemoveCompanyInterests: removeCompanyInterests,
                AddContactInterests: addContactInterests,
                RemoveContactInterests: removeContactInterests,
            };
            _options = webapi_options;
        }
        return this._AddRemoveContactSelectionMemberInterests(_request, _options);
    }
    async _EditContactSelectionMemberDetails(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("EditContactSelectionMemberDetails", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async EditContactSelectionMemberDetails(selectionId, selectionMemberEditValues, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.SelectionMemberEditValues) != 'undefined')) {
            _request = selectionId;
            _options = selectionMemberEditValues;
        }
        else {
            _request = {
                SelectionId: selectionId,
                SelectionMemberEditValues: selectionMemberEditValues,
            };
            _options = webapi_options;
        }
        return this._EditContactSelectionMemberDetails(_request, _options);
    }
    async _GenerateFollowUps(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateFollowUps", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GenerateFollowUps(selectionId, appointmentEntity, associateId, saveOnContactOwner, uniqueContact, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.AppointmentEntity) != 'undefined' || typeof (first.AssociateId) != 'undefined' || typeof (first.SaveOnContactOwner) != 'undefined' || typeof (first.UniqueContact) != 'undefined')) {
            _request = selectionId;
            _options = appointmentEntity;
        }
        else {
            _request = {
                SelectionId: selectionId,
                AppointmentEntity: appointmentEntity,
                AssociateId: associateId,
                SaveOnContactOwner: saveOnContactOwner,
                UniqueContact: uniqueContact,
            };
            _options = webapi_options;
        }
        return this._GenerateFollowUps(_request, _options);
    }
    async _ExportSelectionMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExportSelectionMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ExportSelectionMembers(selectionId, templateName, useContacts, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.TemplateName) != 'undefined' || typeof (first.UseContacts) != 'undefined')) {
            _request = selectionId;
            _options = templateName;
        }
        else {
            _request = {
                SelectionId: selectionId,
                TemplateName: templateName,
                UseContacts: useContacts,
            };
            _options = webapi_options;
        }
        return this._ExportSelectionMembers(_request, _options);
    }
    async _ExportSelectionMembersWithOrderBy(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExportSelectionMembersWithOrderBy", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ExportSelectionMembersWithOrderBy(selectionId, templateName, useContacts, orderBy, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.TemplateName) != 'undefined' || typeof (first.UseContacts) != 'undefined' || typeof (first.OrderBy) != 'undefined')) {
            _request = selectionId;
            _options = templateName;
        }
        else {
            _request = {
                SelectionId: selectionId,
                TemplateName: templateName,
                UseContacts: useContacts,
                OrderBy: orderBy,
            };
            _options = webapi_options;
        }
        return this._ExportSelectionMembersWithOrderBy(_request, _options);
    }
    async _StartMailMerge(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("StartMailMerge", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async StartMailMerge(settings, webapi_options) {
        let _request = null;
        let _options = null;
        const first = settings;
        if (typeof (first) === "object" && first && (typeof (first.Settings) != 'undefined')) {
            _request = settings;
            _options = webapi_options;
        }
        else {
            _request = {
                Settings: settings,
            };
            _options = webapi_options;
        }
        return this._StartMailMerge(_request, _options);
    }
    async _SetDuplicateRulesStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDuplicateRulesStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDuplicateRulesStatus(rules, webapi_options) {
        let _request = null;
        let _options = null;
        const first = rules;
        if (typeof (first) === "object" && first && (typeof (first.Rules) != 'undefined')) {
            _request = rules;
            _options = webapi_options;
        }
        else {
            _request = {
                Rules: rules,
            };
            _options = webapi_options;
        }
        return this._SetDuplicateRulesStatus(_request, _options);
    }
    async _GetDuplicates(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicates", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DuplicateEntryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDuplicates(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._GetDuplicates(_request, _options);
    }
    async _GetDuplicateRules(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicateRules", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DuplicateRuleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Retrieve all available duplicate rules for selection
     * @returns All available duplicate rules
     */
    async GetDuplicateRules(webapi_options) {
        return this._GetDuplicateRules(webapi_options);
    }
    async _CreateNewEntry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewEntry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateNewEntry(duplicate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = duplicate;
        if (typeof (first) === "object" && first && (typeof (first.Duplicate) != 'undefined')) {
            _request = duplicate;
            _options = webapi_options;
        }
        else {
            _request = {
                Duplicate: duplicate,
            };
            _options = webapi_options;
        }
        return this._CreateNewEntry(_request, _options);
    }
    async _DeleteContacts(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteContacts", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteContacts(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._DeleteContacts(_request, _options);
    }
    async _AddSelectionMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddSelectionMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddSelectionMembers(selectionId, ids, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Ids) != 'undefined')) {
            _request = selectionId;
            _options = ids;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Ids: ids,
            };
            _options = webapi_options;
        }
        return this._AddSelectionMembers(_request, _options);
    }
    async _RemoveSelectionMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveSelectionMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveSelectionMembers(selectionId, selectionMemberIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.SelectionMemberIds) != 'undefined')) {
            _request = selectionId;
            _options = selectionMemberIds;
        }
        else {
            _request = {
                SelectionId: selectionId,
                SelectionMemberIds: selectionMemberIds,
            };
            _options = webapi_options;
        }
        return this._RemoveSelectionMembers(_request, _options);
    }
    async _RemoveSelectionMembersById(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveSelectionMembersById", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveSelectionMembersById(selectionId, ids, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Ids) != 'undefined')) {
            _request = selectionId;
            _options = ids;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Ids: ids,
            };
            _options = webapi_options;
        }
        return this._RemoveSelectionMembersById(_request, _options);
    }
    async _AddSelectionMembersFromSearch(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddSelectionMembersFromSearch", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddSelectionMembersFromSearch(selectionId, storageKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.StorageKey) != 'undefined')) {
            _request = selectionId;
            _options = storageKey;
        }
        else {
            _request = {
                SelectionId: selectionId,
                StorageKey: storageKey,
            };
            _options = webapi_options;
        }
        return this._AddSelectionMembersFromSearch(_request, _options);
    }
    async _RemoveSelectionMembersFromSearch(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveSelectionMembersFromSearch", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveSelectionMembersFromSearch(selectionId, storageKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.StorageKey) != 'undefined')) {
            _request = selectionId;
            _options = storageKey;
        }
        else {
            _request = {
                SelectionId: selectionId,
                StorageKey: storageKey,
            };
            _options = webapi_options;
        }
        return this._RemoveSelectionMembersFromSearch(_request, _options);
    }
    async _CopySelectionMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopySelectionMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CopySelectionMembers(fromSelectionId, toSelectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = fromSelectionId;
        if (typeof (first) === "object" && first && (typeof (first.FromSelectionId) != 'undefined' || typeof (first.ToSelectionId) != 'undefined')) {
            _request = fromSelectionId;
            _options = toSelectionId;
        }
        else {
            _request = {
                FromSelectionId: fromSelectionId,
                ToSelectionId: toSelectionId,
            };
            _options = webapi_options;
        }
        return this._CopySelectionMembers(_request, _options);
    }
    async _CreateTemporarySelectionFromIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporarySelectionFromIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateTemporarySelectionFromIds(ids, targetTableNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ids;
        if (typeof (first) === "object" && first && (typeof (first.Ids) != 'undefined' || typeof (first.TargetTableNumber) != 'undefined')) {
            _request = ids;
            _options = targetTableNumber;
        }
        else {
            _request = {
                Ids: ids,
                TargetTableNumber: targetTableNumber,
            };
            _options = webapi_options;
        }
        return this._CreateTemporarySelectionFromIds(_request, _options);
    }
    async _CreateSelectionFromSelection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateSelectionFromSelection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateSelectionFromSelection(selectionId, name, targetSelectionType, copyMembers, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Name) != 'undefined' || typeof (first.TargetSelectionType) != 'undefined' || typeof (first.CopyMembers) != 'undefined')) {
            _request = selectionId;
            _options = name;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Name: name,
                TargetSelectionType: targetSelectionType,
                CopyMembers: copyMembers,
            };
            _options = webapi_options;
        }
        return this._CreateSelectionFromSelection(_request, _options);
    }
    async _CreateContactSelectionFromShadowSelection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateContactSelectionFromShadowSelection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateContactSelectionFromShadowSelection(selectionId, name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Name) != 'undefined')) {
            _request = selectionId;
            _options = name;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Name: name,
            };
            _options = webapi_options;
        }
        return this._CreateContactSelectionFromShadowSelection(_request, _options);
    }
    async _DeleteEntities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteEntities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteEntities(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._DeleteEntities(_request, _options);
    }
    async _GetParentCombinedSelections(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetParentCombinedSelections", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetParentCombinedSelections(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._GetParentCombinedSelections(_request, _options);
    }
    async _GetSelectionMembersArchiveRows(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectionMembersArchiveRows", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSelectionMembersArchiveRows(selectionId, select, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Select) != 'undefined')) {
            _request = selectionId;
            _options = select;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Select: select,
            };
            _options = webapi_options;
        }
        return this._GetSelectionMembersArchiveRows(_request, _options);
    }
    async _GetSelectionShadowMembersArchiveRows(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectionShadowMembersArchiveRows", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSelectionShadowMembersArchiveRows(selectionId, select, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Select) != 'undefined')) {
            _request = selectionId;
            _options = select;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Select: select,
            };
            _options = webapi_options;
        }
        return this._GetSelectionShadowMembersArchiveRows(_request, _options);
    }
    async _GetDynamicSelectionCriteria(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDynamicSelectionCriteria", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDynamicSelectionCriteria(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._GetDynamicSelectionCriteria(_request, _options);
    }
    async _SetDynamicSelectionCriteria(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDynamicSelectionCriteria", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDynamicSelectionCriteria(selectionId, criteria, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Criteria) != 'undefined')) {
            _request = selectionId;
            _options = criteria;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Criteria: criteria,
            };
            _options = webapi_options;
        }
        return this._SetDynamicSelectionCriteria(_request, _options);
    }
    async _SetDynamicSelectionCriteria2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDynamicSelectionCriteria2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDynamicSelectionCriteria2(selectionId, filter, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Filter) != 'undefined')) {
            _request = selectionId;
            _options = filter;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Filter: filter,
            };
            _options = webapi_options;
        }
        return this._SetDynamicSelectionCriteria2(_request, _options);
    }
    async _SetDynamicSelectionCriteria3(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDynamicSelectionCriteria3", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDynamicSelectionCriteria3(selectionId, criteria, filter, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Criteria) != 'undefined' || typeof (first.Filter) != 'undefined')) {
            _request = selectionId;
            _options = criteria;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Criteria: criteria,
                Filter: filter,
            };
            _options = webapi_options;
        }
        return this._SetDynamicSelectionCriteria3(_request, _options);
    }
    async _DeletePersons(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePersons", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeletePersons(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._DeletePersons(_request, _options);
    }
    async _GetDynamicSelectionCriteriaGroups(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDynamicSelectionCriteriaGroups", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionGroupArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDynamicSelectionCriteriaGroups(selectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined')) {
            _request = selectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionId: selectionId,
            };
            _options = webapi_options;
        }
        return this._GetDynamicSelectionCriteriaGroups(_request, _options);
    }
    async _SetDynamicSelectionCriteriaGroups(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDynamicSelectionCriteriaGroups", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionGroupArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDynamicSelectionCriteriaGroups(selectionId, criteria, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.Criteria) != 'undefined')) {
            _request = selectionId;
            _options = criteria;
        }
        else {
            _request = {
                SelectionId: selectionId,
                Criteria: criteria,
            };
            _options = webapi_options;
        }
        return this._SetDynamicSelectionCriteriaGroups(_request, _options);
    }
    async _GetSelectionForFind(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectionForFind", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionForFind_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSelectionForFind(entityName, typicalSearchId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = entityName;
        if (typeof (first) === "object" && first && (typeof (first.EntityName) != 'undefined' || typeof (first.TypicalSearchId) != 'undefined')) {
            _request = entityName;
            _options = typicalSearchId;
        }
        else {
            _request = {
                EntityName: entityName,
                TypicalSearchId: typicalSearchId,
            };
            _options = webapi_options;
        }
        return this._GetSelectionForFind(_request, _options);
    }
    async _GetSelectionSummaries(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectionSummaries", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionSummaryItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSelectionSummaries(selectionIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionIds;
        if (typeof (first) === "object" && first && (typeof (first.SelectionIds) != 'undefined')) {
            _request = selectionIds;
            _options = webapi_options;
        }
        else {
            _request = {
                SelectionIds: selectionIds,
            };
            _options = webapi_options;
        }
        return this._GetSelectionSummaries(_request, _options);
    }
    async _UpdateTypicalSearch(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateTypicalSearch", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateTypicalSearch(searches, webapi_options) {
        let _request = null;
        let _options = null;
        const first = searches;
        if (typeof (first) === "object" && first && (typeof (first.Searches) != 'undefined')) {
            _request = searches;
            _options = webapi_options;
        }
        else {
            _request = {
                Searches: searches,
            };
            _options = webapi_options;
        }
        return this._UpdateTypicalSearch(_request, _options);
    }
} // class v1SelectionAgentController 
exports.SelectionAgent = SelectionAgent;
//# sourceMappingURL=SelectionAgent.js.map
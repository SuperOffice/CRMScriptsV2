"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.FindAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Find functions
 */
class FindAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Find/";
        super(options);
    }
    async _GetCriteriaInformation(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCriteriaInformation", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CriteriaInformation_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCriteriaInformation(storageType, providerName, storageKey, staticColumns, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.StaticColumns) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                StaticColumns: staticColumns,
            };
            _options = webapi_options;
        }
        return this._GetCriteriaInformation(_request, _options);
    }
    async _GetCriteriaInformationWithContext(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCriteriaInformationWithContext", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CriteriaInformation_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCriteriaInformationWithContext(storageType, providerName, storageKey, staticColumns, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.StaticColumns) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                StaticColumns: staticColumns,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._GetCriteriaInformationWithContext(_request, _options);
    }
    async _SaveRestrictions(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveRestrictions", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveRestrictions(storageType, providerName, storageKey, restrictions, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Restrictions) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Restrictions: restrictions,
            };
            _options = webapi_options;
        }
        return this._SaveRestrictions(_request, _options);
    }
    async _SaveRestrictionsWithContext(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveRestrictionsWithContext", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveRestrictionsWithContext(storageType, providerName, storageKey, restrictions, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Restrictions) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Restrictions: restrictions,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._SaveRestrictionsWithContext(_request, _options);
    }
    async _SaveRestrictionGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveRestrictionGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveRestrictionGroup(storageType, providerName, storageKey, restrictionGroup, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.RestrictionGroup) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                RestrictionGroup: restrictionGroup,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._SaveRestrictionGroup(_request, _options);
    }
    async _SaveRestrictionGroups(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveRestrictionGroups", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionGroupArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveRestrictionGroups(storageType, providerName, storageKey, restrictionGroups, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.RestrictionGroups) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                RestrictionGroups: restrictionGroups,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._SaveRestrictionGroups(_request, _options);
    }
    async _GetRestrictionGroups(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRestrictionGroups", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionGroupArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetRestrictionGroups(storageType, providerName, storageKey, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._GetRestrictionGroups(_request, _options);
    }
    async _GetRestrictionGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRestrictionGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetRestrictionGroup(storageType, providerName, storageKey, rank, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Rank) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Rank: rank,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._GetRestrictionGroup(_request, _options);
    }
    async _CreateRestrictionGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateRestrictionGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateRestrictionGroup(storageType, providerName, storageKey, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._CreateRestrictionGroup(_request, _options);
    }
    async _DeleteRestrictionGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteRestrictionGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteRestrictionGroup(storageType, providerName, storageKey, rank, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Rank) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Rank: rank,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._DeleteRestrictionGroup(_request, _options);
    }
    async _SaveRestrictionsAndGetCriteriaInformation(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveRestrictionsAndGetCriteriaInformation", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CriteriaInformation_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveRestrictionsAndGetCriteriaInformation(storageType, providerName, storageKey, restrictions, staticColumns, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Restrictions) != 'undefined' || typeof (first.StaticColumns) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Restrictions: restrictions,
                StaticColumns: staticColumns,
            };
            _options = webapi_options;
        }
        return this._SaveRestrictionsAndGetCriteriaInformation(_request, _options);
    }
    async _Find(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Find", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Find(storageType, providerName, storageKey, pageSize, pageNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                PageSize: pageSize,
                PageNumber: pageNumber,
            };
            _options = webapi_options;
        }
        return this._Find(_request, _options);
    }
    async _FindFromRestrictions(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindFromRestrictions", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindFromRestrictions(restrictions, providerName, pageSize, pageNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = restrictions;
        if (typeof (first) === "object" && first && (typeof (first.Restrictions) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined')) {
            _request = restrictions;
            _options = providerName;
        }
        else {
            _request = {
                Restrictions: restrictions,
                ProviderName: providerName,
                PageSize: pageSize,
                PageNumber: pageNumber,
            };
            _options = webapi_options;
        }
        return this._FindFromRestrictions(_request, _options);
    }
    async _FindFromRestrictionsColumns(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindFromRestrictionsColumns", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindFromRestrictionsColumns(restrictions, providerName, desiredColumns, pageSize, pageNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = restrictions;
        if (typeof (first) === "object" && first && (typeof (first.Restrictions) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.DesiredColumns) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined')) {
            _request = restrictions;
            _options = providerName;
        }
        else {
            _request = {
                Restrictions: restrictions,
                ProviderName: providerName,
                DesiredColumns: desiredColumns,
                PageSize: pageSize,
                PageNumber: pageNumber,
            };
            _options = webapi_options;
        }
        return this._FindFromRestrictionsColumns(_request, _options);
    }
    async _GetAvailableRestrictionColumns(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAvailableRestrictionColumns", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAvailableRestrictionColumns(storageType, providerName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
            };
            _options = webapi_options;
        }
        return this._GetAvailableRestrictionColumns(_request, _options);
    }
    async _GetSpecifiedCriteriaInformationWithDefaults(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSpecifiedCriteriaInformationWithDefaults", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CriteriaInformation_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSpecifiedCriteriaInformationWithDefaults(storageType, providerName, storageKey, desiredColumnNames, staticColumns, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.DesiredColumnNames) != 'undefined' || typeof (first.StaticColumns) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                DesiredColumnNames: desiredColumnNames,
                StaticColumns: staticColumns,
            };
            _options = webapi_options;
        }
        return this._GetSpecifiedCriteriaInformationWithDefaults(_request, _options);
    }
    async _GetSpecifiedCriteriaInformationWithDefaultsWithContext(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSpecifiedCriteriaInformationWithDefaultsWithContext", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CriteriaInformation_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSpecifiedCriteriaInformationWithDefaultsWithContext(storageType, providerName, storageKey, desiredColumnNames, staticColumns, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.DesiredColumnNames) != 'undefined' || typeof (first.StaticColumns) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                DesiredColumnNames: desiredColumnNames,
                StaticColumns: staticColumns,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._GetSpecifiedCriteriaInformationWithDefaultsWithContext(_request, _options);
    }
    async _FindFromRestrictionsColumnsOrderBy(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindFromRestrictionsColumnsOrderBy", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindFromRestrictionsColumnsOrderBy(restrictions, providerName, desiredColumns, orderBy, pageSize, pageNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = restrictions;
        if (typeof (first) === "object" && first && (typeof (first.Restrictions) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.DesiredColumns) != 'undefined' || typeof (first.OrderBy) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined')) {
            _request = restrictions;
            _options = providerName;
        }
        else {
            _request = {
                Restrictions: restrictions,
                ProviderName: providerName,
                DesiredColumns: desiredColumns,
                OrderBy: orderBy,
                PageSize: pageSize,
                PageNumber: pageNumber,
            };
            _options = webapi_options;
        }
        return this._FindFromRestrictionsColumnsOrderBy(_request, _options);
    }
    async _GetDefaultDesiredColumns(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultDesiredColumns", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveColumnInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDefaultDesiredColumns(storageType, providerName, storageKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
            };
            _options = webapi_options;
        }
        return this._GetDefaultDesiredColumns(_request, _options);
    }
    async _GetDefaultOrderBy(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultOrderBy", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveOrderByInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDefaultOrderBy(storageType, providerName, storageKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
            };
            _options = webapi_options;
        }
        return this._GetDefaultOrderBy(_request, _options);
    }
    async _PopulateRestrictions(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PopulateRestrictions", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async PopulateRestrictions(providerName, restrictions, webapi_options) {
        let _request = null;
        let _options = null;
        const first = providerName;
        if (typeof (first) === "object" && first && (typeof (first.ProviderName) != 'undefined' || typeof (first.Restrictions) != 'undefined')) {
            _request = providerName;
            _options = restrictions;
        }
        else {
            _request = {
                ProviderName: providerName,
                Restrictions: restrictions,
            };
            _options = webapi_options;
        }
        return this._PopulateRestrictions(_request, _options);
    }
    async _PopulateRestrictionValues(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PopulateRestrictionValues", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveRestrictionInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async PopulateRestrictionValues(restrictions, webapi_options) {
        let _request = null;
        let _options = null;
        const first = restrictions;
        if (typeof (first) === "object" && first && (typeof (first.Restrictions) != 'undefined')) {
            _request = restrictions;
            _options = webapi_options;
        }
        else {
            _request = {
                Restrictions: restrictions,
            };
            _options = webapi_options;
        }
        return this._PopulateRestrictionValues(_request, _options);
    }
    async _GetDefaultDesiredColumnsFromRestrictions(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultDesiredColumnsFromRestrictions", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveColumnInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDefaultDesiredColumnsFromRestrictions(providerName, restrictions, webapi_options) {
        let _request = null;
        let _options = null;
        const first = providerName;
        if (typeof (first) === "object" && first && (typeof (first.ProviderName) != 'undefined' || typeof (first.Restrictions) != 'undefined')) {
            _request = providerName;
            _options = restrictions;
        }
        else {
            _request = {
                ProviderName: providerName,
                Restrictions: restrictions,
            };
            _options = webapi_options;
        }
        return this._GetDefaultDesiredColumnsFromRestrictions(_request, _options);
    }
    async _GetDefaultOrderByFromDesiredColumns(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultOrderByFromDesiredColumns", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveOrderByInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDefaultOrderByFromDesiredColumns(providerName, desiredColumns, webapi_options) {
        let _request = null;
        let _options = null;
        const first = providerName;
        if (typeof (first) === "object" && first && (typeof (first.ProviderName) != 'undefined' || typeof (first.DesiredColumns) != 'undefined')) {
            _request = providerName;
            _options = desiredColumns;
        }
        else {
            _request = {
                ProviderName: providerName,
                DesiredColumns: desiredColumns,
            };
            _options = webapi_options;
        }
        return this._GetDefaultOrderByFromDesiredColumns(_request, _options);
    }
    async _FindOrderBy(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindOrderBy", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindOrderBy(storageType, providerName, storageKey, pageSize, pageNumber, orderBy, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined' || typeof (first.OrderBy) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                PageSize: pageSize,
                PageNumber: pageNumber,
                OrderBy: orderBy,
            };
            _options = webapi_options;
        }
        return this._FindOrderBy(_request, _options);
    }
    async _FindWithExtraRestrictions(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindWithExtraRestrictions", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindWithExtraRestrictions(storageType, providerName, storageKey, extraRestrictions, orderBy, desiredColumns, pageSize, pageNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.ExtraRestrictions) != 'undefined' || typeof (first.OrderBy) != 'undefined' || typeof (first.DesiredColumns) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                ExtraRestrictions: extraRestrictions,
                OrderBy: orderBy,
                DesiredColumns: desiredColumns,
                PageSize: pageSize,
                PageNumber: pageNumber,
            };
            _options = webapi_options;
        }
        return this._FindWithExtraRestrictions(_request, _options);
    }
    async _FindWithColumns(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindWithColumns", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindWithColumns(storageType, providerName, storageKey, desiredColumns, pageSize, pageNumber, orderBy, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.DesiredColumns) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined' || typeof (first.OrderBy) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                DesiredColumns: desiredColumns,
                PageSize: pageSize,
                PageNumber: pageNumber,
                OrderBy: orderBy,
            };
            _options = webapi_options;
        }
        return this._FindWithColumns(_request, _options);
    }
    async _SaveRestrictions2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveRestrictions2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveRestrictions2(storageType, providerName, storageKey, restrictions, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Restrictions) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Restrictions: restrictions,
            };
            _options = webapi_options;
        }
        return this._SaveRestrictions2(_request, _options);
    }
    async _SaveRestrictionsWithContext2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveRestrictionsWithContext2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveRestrictionsWithContext2(storageType, providerName, storageKey, restrictions, context, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Restrictions) != 'undefined' || typeof (first.Context) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Restrictions: restrictions,
                Context: context,
            };
            _options = webapi_options;
        }
        return this._SaveRestrictionsWithContext2(_request, _options);
    }
    async _SaveRestrictionsAndGetCriteriaInformation2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveRestrictionsAndGetCriteriaInformation2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CriteriaInformation_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveRestrictionsAndGetCriteriaInformation2(storageType, providerName, storageKey, restrictions, staticColumns, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.Restrictions) != 'undefined' || typeof (first.StaticColumns) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                Restrictions: restrictions,
                StaticColumns: staticColumns,
            };
            _options = webapi_options;
        }
        return this._SaveRestrictionsAndGetCriteriaInformation2(_request, _options);
    }
    async _FindFromRestrictions2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindFromRestrictions2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindFromRestrictions2(restrictions, providerName, pageSize, pageNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = restrictions;
        if (typeof (first) === "object" && first && (typeof (first.Restrictions) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined')) {
            _request = restrictions;
            _options = providerName;
        }
        else {
            _request = {
                Restrictions: restrictions,
                ProviderName: providerName,
                PageSize: pageSize,
                PageNumber: pageNumber,
            };
            _options = webapi_options;
        }
        return this._FindFromRestrictions2(_request, _options);
    }
    async _FindFromRestrictionsColumns2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindFromRestrictionsColumns2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindFromRestrictionsColumns2(restrictions, providerName, desiredColumns, pageSize, pageNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = restrictions;
        if (typeof (first) === "object" && first && (typeof (first.Restrictions) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.DesiredColumns) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined')) {
            _request = restrictions;
            _options = providerName;
        }
        else {
            _request = {
                Restrictions: restrictions,
                ProviderName: providerName,
                DesiredColumns: desiredColumns,
                PageSize: pageSize,
                PageNumber: pageNumber,
            };
            _options = webapi_options;
        }
        return this._FindFromRestrictionsColumns2(_request, _options);
    }
    async _FindFromRestrictionsColumnsOrderBy2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindFromRestrictionsColumnsOrderBy2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindFromRestrictionsColumnsOrderBy2(restrictions, providerName, desiredColumns, orderBy, pageSize, pageNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = restrictions;
        if (typeof (first) === "object" && first && (typeof (first.Restrictions) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.DesiredColumns) != 'undefined' || typeof (first.OrderBy) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined')) {
            _request = restrictions;
            _options = providerName;
        }
        else {
            _request = {
                Restrictions: restrictions,
                ProviderName: providerName,
                DesiredColumns: desiredColumns,
                OrderBy: orderBy,
                PageSize: pageSize,
                PageNumber: pageNumber,
            };
            _options = webapi_options;
        }
        return this._FindFromRestrictionsColumnsOrderBy2(_request, _options);
    }
    async _GetDefaultDesiredColumnsFromRestrictions2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultDesiredColumnsFromRestrictions2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ArchiveColumnInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDefaultDesiredColumnsFromRestrictions2(providerName, restrictions, webapi_options) {
        let _request = null;
        let _options = null;
        const first = providerName;
        if (typeof (first) === "object" && first && (typeof (first.ProviderName) != 'undefined' || typeof (first.Restrictions) != 'undefined')) {
            _request = providerName;
            _options = restrictions;
        }
        else {
            _request = {
                ProviderName: providerName,
                Restrictions: restrictions,
            };
            _options = webapi_options;
        }
        return this._GetDefaultDesiredColumnsFromRestrictions2(_request, _options);
    }
    async _FindOrderBy2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindOrderBy2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindOrderBy2(storageType, providerName, storageKey, pageSize, pageNumber, orderBy, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined' || typeof (first.OrderBy) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                PageSize: pageSize,
                PageNumber: pageNumber,
                OrderBy: orderBy,
            };
            _options = webapi_options;
        }
        return this._FindOrderBy2(_request, _options);
    }
    async _FindWithExtraRestrictions2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindWithExtraRestrictions2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FindResults_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindWithExtraRestrictions2(storageType, providerName, storageKey, extraRestrictions, orderBy, desiredColumns, pageSize, pageNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = storageType;
        if (typeof (first) === "object" && first && (typeof (first.StorageType) != 'undefined' || typeof (first.ProviderName) != 'undefined' || typeof (first.StorageKey) != 'undefined' || typeof (first.ExtraRestrictions) != 'undefined' || typeof (first.OrderBy) != 'undefined' || typeof (first.DesiredColumns) != 'undefined' || typeof (first.PageSize) != 'undefined' || typeof (first.PageNumber) != 'undefined')) {
            _request = storageType;
            _options = providerName;
        }
        else {
            _request = {
                StorageType: storageType,
                ProviderName: providerName,
                StorageKey: storageKey,
                ExtraRestrictions: extraRestrictions,
                OrderBy: orderBy,
                DesiredColumns: desiredColumns,
                PageSize: pageSize,
                PageNumber: pageNumber,
            };
            _options = webapi_options;
        }
        return this._FindWithExtraRestrictions2(_request, _options);
    }
} // class v1FindAgentController 
exports.FindAgent = FindAgent;
//# sourceMappingURL=FindAgent.js.map
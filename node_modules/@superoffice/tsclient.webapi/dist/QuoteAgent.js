"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuoteAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
const Base64_1 = require("./Base64");
/**
 * Services for the Quote Management feature, part of the Sale module
 */
class QuoteAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Quote/";
        super(options);
    }
    /**
     * Set default values into a new PriceList.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultPriceList(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPriceList", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriceList_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing PriceList or creates a new PriceList if the id parameter is empty
     * @param entity - The PriceList to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated PriceList
     */
    async SavePriceList(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SavePriceList", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriceList_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the PriceList
     * @param PriceListId - The id of the PriceList to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeletePriceList(PriceListId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeletePriceList?PriceListId=" + PriceListId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new Product.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultProduct(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProduct", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Product_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing Product or creates a new Product if the id parameter is empty
     * @param entity - The Product to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated Product
     */
    async SaveProduct(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProduct", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Product_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the Product
     * @param ProductId - The id of the Product to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteProduct(ProductId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteProduct?ProductId=" + ProductId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new QuoteAlternative.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultQuoteAlternative(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultQuoteAlternative", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteAlternative_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing QuoteAlternative or creates a new QuoteAlternative if the id parameter is empty
     * @param entity - The QuoteAlternative to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated QuoteAlternative
     */
    async SaveQuoteAlternative(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveQuoteAlternative", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteAlternative_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetConfigurationFields(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConfigurationFields", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FieldMetadataDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConfigurationFields(connectionId, connectorName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionId;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionId) != 'undefined' || typeof (first.ConnectorName) != 'undefined')) {
            _request = connectionId;
            _options = connectorName;
        }
        else {
            _request = {
                ConnectionId: connectionId,
                ConnectorName: connectorName,
            };
            _options = webapi_options;
        }
        return this._GetConfigurationFields(_request, _options);
    }
    async _TestConnection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestConnection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async TestConnection(connectorName, connectionData, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectorName;
        if (typeof (first) === "object" && first && (typeof (first.ConnectorName) != 'undefined' || typeof (first.ConnectionData) != 'undefined')) {
            _request = connectorName;
            _options = connectionData;
        }
        else {
            _request = {
                ConnectorName: connectorName,
                ConnectionData: connectionData,
            };
            _options = webapi_options;
        }
        return this._TestConnection(_request, _options);
    }
    /*
     * Gets a PriceList object.
     * @param priceListId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PriceList
     */
    async GetPriceList(priceListId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPriceList?priceListId=" + priceListId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriceList_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _CopySuperOfficePriceList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopySuperOfficePriceList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriceList_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CopySuperOfficePriceList(originalPriceListId, newName, validFrom, validTo, newCurrencyId, convertCurrency, webapi_options) {
        let _request = null;
        let _options = null;
        const first = originalPriceListId;
        if (typeof (first) === "object" && first && (typeof (first.OriginalPriceListId) != 'undefined' || typeof (first.NewName) != 'undefined' || typeof (first.ValidFrom) != 'undefined' || typeof (first.ValidTo) != 'undefined' || typeof (first.NewCurrencyId) != 'undefined' || typeof (first.ConvertCurrency) != 'undefined')) {
            _request = originalPriceListId;
            _options = newName;
        }
        else {
            _request = {
                OriginalPriceListId: originalPriceListId,
                NewName: newName,
                ValidFrom: validFrom,
                ValidTo: validTo,
                NewCurrencyId: newCurrencyId,
                ConvertCurrency: convertCurrency,
            };
            _options = webapi_options;
        }
        return this._CopySuperOfficePriceList(_request, _options);
    }
    async _GetProductImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProductImage(quoteConnectionId, eRPProductKey, rank, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined' || typeof (first.ERPProductKey) != 'undefined' || typeof (first.Rank) != 'undefined')) {
            _request = quoteConnectionId;
            _options = eRPProductKey;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
                ERPProductKey: eRPProductKey,
                Rank: rank,
            };
            _options = webapi_options;
        }
        return this._GetProductImage(_request, _options);
    }
    async _FindProduct(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindProduct", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindProduct(quoteAlternativeId, userInput, priceListKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteAlternativeId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteAlternativeId) != 'undefined' || typeof (first.UserInput) != 'undefined' || typeof (first.PriceListKey) != 'undefined')) {
            _request = quoteAlternativeId;
            _options = userInput;
        }
        else {
            _request = {
                QuoteAlternativeId: quoteAlternativeId,
                UserInput: userInput,
                PriceListKey: priceListKey,
            };
            _options = webapi_options;
        }
        return this._FindProduct(_request, _options);
    }
    async _GetProduct(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProduct", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Product_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProduct(quoteConnectionId, eRPProductKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined' || typeof (first.ERPProductKey) != 'undefined')) {
            _request = quoteConnectionId;
            _options = eRPProductKey;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
                ERPProductKey: eRPProductKey,
            };
            _options = webapi_options;
        }
        return this._GetProduct(_request, _options);
    }
    async _GetProductFromDbId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductFromDbId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Product_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProductFromDbId(productId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = productId;
        if (typeof (first) === "object" && first && (typeof (first.ProductId) != 'undefined')) {
            _request = productId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProductId: productId,
            };
            _options = webapi_options;
        }
        return this._GetProductFromDbId(_request, _options);
    }
    async _RemoveProduct(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveProduct", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveProduct(productId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = productId;
        if (typeof (first) === "object" && first && (typeof (first.ProductId) != 'undefined')) {
            _request = productId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProductId: productId,
            };
            _options = webapi_options;
        }
        return this._RemoveProduct(_request, _options);
    }
    async _ToggleProductInAssortment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleProductInAssortment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleProductInAssortment(productId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = productId;
        if (typeof (first) === "object" && first && (typeof (first.ProductId) != 'undefined')) {
            _request = productId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProductId: productId,
            };
            _options = webapi_options;
        }
        return this._ToggleProductInAssortment(_request, _options);
    }
    async _SaveQuote(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuote", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Quote_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuote(quote, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quote;
        if (typeof (first) === "object" && first && (typeof (first.Quote) != 'undefined')) {
            _request = quote;
            _options = webapi_options;
        }
        else {
            _request = {
                Quote: quote,
            };
            _options = webapi_options;
        }
        return this._SaveQuote(_request, _options);
    }
    async _GetQuote(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuote", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Quote_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuote(quoteId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteId) != 'undefined')) {
            _request = quoteId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteId: quoteId,
            };
            _options = webapi_options;
        }
        return this._GetQuote(_request, _options);
    }
    async _GetQuoteFromSaleId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteFromSaleId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Quote_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteFromSaleId(saleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined')) {
            _request = saleId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleId: saleId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteFromSaleId(_request, _options);
    }
    /*
     * Gets a QuoteAlternative object.
     * @param quoteAlternativeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single QuoteAlternative
     */
    async GetQuoteAlternative(quoteAlternativeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteAlternative?quoteAlternativeId=" + quoteAlternativeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteAlternative_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _RecalculateQuoteAlternative(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RecalculateQuoteAlternative", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteAlternativeRecalculated_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RecalculateQuoteAlternative(quoteAlternative, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteAlternative;
        if (typeof (first) === "object" && first && (typeof (first.QuoteAlternative) != 'undefined')) {
            _request = quoteAlternative;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteAlternative: quoteAlternative,
            };
            _options = webapi_options;
        }
        return this._RecalculateQuoteAlternative(_request, _options);
    }
    async _GetQuoteAlternatives(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteAlternatives", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteAlternativeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteAlternatives(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteAlternatives(_request, _options);
    }
    async _MoveQuoteLine(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveQuoteLine", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MoveQuoteLine(quoteLineId, direction, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineId) != 'undefined' || typeof (first.Direction) != 'undefined')) {
            _request = quoteLineId;
            _options = direction;
        }
        else {
            _request = {
                QuoteLineId: quoteLineId,
                Direction: direction,
            };
            _options = webapi_options;
        }
        return this._MoveQuoteLine(_request, _options);
    }
    async _CreateQuoteAlternative(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateQuoteAlternative", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteAlternative_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateQuoteAlternative(quoteVersionId, quoteAlternativeName, quoteAlternativeDescription, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.QuoteAlternativeName) != 'undefined' || typeof (first.QuoteAlternativeDescription) != 'undefined')) {
            _request = quoteVersionId;
            _options = quoteAlternativeName;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                QuoteAlternativeName: quoteAlternativeName,
                QuoteAlternativeDescription: quoteAlternativeDescription,
            };
            _options = webapi_options;
        }
        return this._CreateQuoteAlternative(_request, _options);
    }
    async _CopyQuoteAlternative(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyQuoteAlternative", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteAlternative_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CopyQuoteAlternative(quoteVersionId, quoteAlternativeId, quoteAlternativeName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.QuoteAlternativeId) != 'undefined' || typeof (first.QuoteAlternativeName) != 'undefined')) {
            _request = quoteVersionId;
            _options = quoteAlternativeId;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                QuoteAlternativeId: quoteAlternativeId,
                QuoteAlternativeName: quoteAlternativeName,
            };
            _options = webapi_options;
        }
        return this._CopyQuoteAlternative(_request, _options);
    }
    async _DeleteQuoteAlternative(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteQuoteAlternative", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteQuoteAlternative(quoteAlternativeId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteAlternativeId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteAlternativeId) != 'undefined')) {
            _request = quoteAlternativeId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteAlternativeId: quoteAlternativeId,
            };
            _options = webapi_options;
        }
        return this._DeleteQuoteAlternative(_request, _options);
    }
    async _HasConnections(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasConnections", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Whether or not the system has any connections available for this user.
     * @returns The response
     */
    async HasConnections(webapi_options) {
        return this._HasConnections(webapi_options);
    }
    async _GetAllInstalledQuoteConnections(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllInstalledQuoteConnections", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteConnectionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get all installed connections. Some installed connections may not be available to the user.
     * @returns List of connections
     */
    async GetAllInstalledQuoteConnections(webapi_options) {
        return this._GetAllInstalledQuoteConnections(webapi_options);
    }
    async _GetAllAvailableQuoteConnections(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllAvailableQuoteConnections", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteConnectionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get all available connections. Some installed connections may not be available to the user. Use GetAllAvailableQuoteConnectionsWithPriceLists if you need the pricelists on the connections as well.
     * @returns List of connections
     */
    async GetAllAvailableQuoteConnections(webapi_options) {
        return this._GetAllAvailableQuoteConnections(webapi_options);
    }
    async _GetAllAvailableQuoteConnectionsWithPriceLists(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllAvailableQuoteConnectionsWithPriceLists", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteConnectionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get all available connections. Some installed connections may not be available to the user. Includes pricelists for the connection. This is a heavy call
     * @returns List of connections
     */
    async GetAllAvailableQuoteConnectionsWithPriceLists(webapi_options) {
        return this._GetAllAvailableQuoteConnectionsWithPriceLists(webapi_options);
    }
    async _CreateConnectionFromConnectorName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateConnectionFromConnectorName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteConnection_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateConnectionFromConnectorName(connectorName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectorName;
        if (typeof (first) === "object" && first && (typeof (first.ConnectorName) != 'undefined')) {
            _request = connectorName;
            _options = webapi_options;
        }
        else {
            _request = {
                ConnectorName: connectorName,
            };
            _options = webapi_options;
        }
        return this._CreateConnectionFromConnectorName(_request, _options);
    }
    async _GetConnection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteConnection_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConnection(quoteConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined')) {
            _request = quoteConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
            };
            _options = webapi_options;
        }
        return this._GetConnection(_request, _options);
    }
    async _SaveConnection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConnection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteConnection_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveConnection(connection, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connection;
        if (typeof (first) === "object" && first && (typeof (first.Connection) != 'undefined')) {
            _request = connection;
            _options = webapi_options;
        }
        else {
            _request = {
                Connection: connection,
            };
            _options = webapi_options;
        }
        return this._SaveConnection(_request, _options);
    }
    async _DeleteConnection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteConnection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteConnection(quoteConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined')) {
            _request = quoteConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
            };
            _options = webapi_options;
        }
        return this._DeleteConnection(_request, _options);
    }
    async _RestoreConnection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RestoreConnection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RestoreConnection(quoteConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined')) {
            _request = quoteConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
            };
            _options = webapi_options;
        }
        return this._RestoreConnection(_request, _options);
    }
    async _GetConnectionsForAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionsForAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteConnectionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConnectionsForAssociate(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._GetConnectionsForAssociate(_request, _options);
    }
    async _GetActivePriceLists(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetActivePriceLists", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriceListArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetActivePriceLists(quoteConnectionId, currency, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined' || typeof (first.Currency) != 'undefined')) {
            _request = quoteConnectionId;
            _options = currency;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
                Currency: currency,
            };
            _options = webapi_options;
        }
        return this._GetActivePriceLists(_request, _options);
    }
    async _GetActivePriceListsByCurrencyId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetActivePriceListsByCurrencyId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriceListArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetActivePriceListsByCurrencyId(quoteConnectionId, currencyId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined' || typeof (first.CurrencyId) != 'undefined')) {
            _request = quoteConnectionId;
            _options = currencyId;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
                CurrencyId: currencyId,
            };
            _options = webapi_options;
        }
        return this._GetActivePriceListsByCurrencyId(_request, _options);
    }
    async _GetAllPriceLists(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllPriceLists", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriceListArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllPriceLists(quoteConnectionId, currency, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined' || typeof (first.Currency) != 'undefined')) {
            _request = quoteConnectionId;
            _options = currency;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
                Currency: currency,
            };
            _options = webapi_options;
        }
        return this._GetAllPriceLists(_request, _options);
    }
    async _GetAllPriceListsByCurrencyId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllPriceListsByCurrencyId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriceListArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllPriceListsByCurrencyId(quoteConnectionId, currencyId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined' || typeof (first.CurrencyId) != 'undefined')) {
            _request = quoteConnectionId;
            _options = currencyId;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
                CurrencyId: currencyId,
            };
            _options = webapi_options;
        }
        return this._GetAllPriceListsByCurrencyId(_request, _options);
    }
    async _GetConnectorCapabilityNames(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectorCapabilityNames", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConnectorCapabilityNames(quoteConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined')) {
            _request = quoteConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
            };
            _options = webapi_options;
        }
        return this._GetConnectorCapabilityNames(_request, _options);
    }
    async _GetConnectorCapabilities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectorCapabilities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConnectorCapabilities(quoteConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined')) {
            _request = quoteConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
            };
            _options = webapi_options;
        }
        return this._GetConnectorCapabilities(_request, _options);
    }
    async _CanConnectorProvideCapability(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanConnectorProvideCapability", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CanConnectorProvideCapability(quoteConnectionId, capabilityName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined' || typeof (first.CapabilityName) != 'undefined')) {
            _request = quoteConnectionId;
            _options = capabilityName;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
                CapabilityName: capabilityName,
            };
            _options = webapi_options;
        }
        return this._CanConnectorProvideCapability(_request, _options);
    }
    async _GetConnectionStartupErrors(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionStartupErrors", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponseArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns an array of PluginResponseInfos for all failed connection initializations.
     * @returns Array of PluginResponseInfos for each failed connection initialization.
     */
    async GetConnectionStartupErrors(webapi_options) {
        return this._GetConnectionStartupErrors(webapi_options);
    }
    async _GetConnectionStartupResponse(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionStartupResponse", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConnectionStartupResponse(quoteConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined')) {
            _request = quoteConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
            };
            _options = webapi_options;
        }
        return this._GetConnectionStartupResponse(_request, _options);
    }
    async _GetConnectionConfigFields(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionConfigFields", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConnectionConfigFields(quoteConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined')) {
            _request = quoteConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
            };
            _options = webapi_options;
        }
        return this._GetConnectionConfigFields(_request, _options);
    }
    async _SaveConnectionConfigFields(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConnectionConfigFields", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveConnectionConfigFields(quoteConnectionId, connectionConfigFields, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteConnectionId) != 'undefined' || typeof (first.ConnectionConfigFields) != 'undefined')) {
            _request = quoteConnectionId;
            _options = connectionConfigFields;
        }
        else {
            _request = {
                QuoteConnectionId: quoteConnectionId,
                ConnectionConfigFields: connectionConfigFields,
            };
            _options = webapi_options;
        }
        return this._SaveConnectionConfigFields(_request, _options);
    }
    async _CreateAndSaveQuote(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndSaveQuote", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateAndSaveQuote(saleId, connectionId, firstAlternativeName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined' || typeof (first.ConnectionId) != 'undefined' || typeof (first.FirstAlternativeName) != 'undefined')) {
            _request = saleId;
            _options = connectionId;
        }
        else {
            _request = {
                SaleId: saleId,
                ConnectionId: connectionId,
                FirstAlternativeName: firstAlternativeName,
            };
            _options = webapi_options;
        }
        return this._CreateAndSaveQuote(_request, _options);
    }
    async _GetQuoteEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteEntity(quoteId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteId) != 'undefined')) {
            _request = quoteId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteId: quoteId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteEntity(_request, _options);
    }
    async _GetQuoteEntityFromSaleId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteEntityFromSaleId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteEntityFromSaleId(saleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined')) {
            _request = saleId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleId: saleId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteEntityFromSaleId(_request, _options);
    }
    async _SaveQuoteEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuoteEntity(quoteEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteEntity;
        if (typeof (first) === "object" && first && (typeof (first.QuoteEntity) != 'undefined')) {
            _request = quoteEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteEntity: quoteEntity,
            };
            _options = webapi_options;
        }
        return this._SaveQuoteEntity(_request, _options);
    }
    async _CreateAndSaveQuoteFromSale(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndSaveQuoteFromSale", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateAndSaveQuoteFromSale(copyFromSaleId, copyToSaleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = copyFromSaleId;
        if (typeof (first) === "object" && first && (typeof (first.CopyFromSaleId) != 'undefined' || typeof (first.CopyToSaleId) != 'undefined')) {
            _request = copyFromSaleId;
            _options = copyToSaleId;
        }
        else {
            _request = {
                CopyFromSaleId: copyFromSaleId,
                CopyToSaleId: copyToSaleId,
            };
            _options = webapi_options;
        }
        return this._CreateAndSaveQuoteFromSale(_request, _options);
    }
    async _PlaceOrder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PlaceOrder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginUrlResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async PlaceOrder(quoteAlternativeId, markSaleAsSold, poNumber, orderComment, culture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteAlternativeId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteAlternativeId) != 'undefined' || typeof (first.MarkSaleAsSold) != 'undefined' || typeof (first.PoNumber) != 'undefined' || typeof (first.OrderComment) != 'undefined' || typeof (first.Culture) != 'undefined')) {
            _request = quoteAlternativeId;
            _options = markSaleAsSold;
        }
        else {
            _request = {
                QuoteAlternativeId: quoteAlternativeId,
                MarkSaleAsSold: markSaleAsSold,
                PoNumber: poNumber,
                OrderComment: orderComment,
                Culture: culture,
            };
            _options = webapi_options;
        }
        return this._PlaceOrder(_request, _options);
    }
    async _GetOrderState(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOrderState", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginUrlResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetOrderState(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._GetOrderState(_request, _options);
    }
    async _DeleteQuote(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteQuote", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteQuote(quoteId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteId) != 'undefined')) {
            _request = quoteId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteId: quoteId,
            };
            _options = webapi_options;
        }
        return this._DeleteQuote(_request, _options);
    }
    async _CreateQuoteLine(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateQuoteLine", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLine_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateQuoteLine(quoteAlternativeId, eRPProductKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteAlternativeId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteAlternativeId) != 'undefined' || typeof (first.ERPProductKey) != 'undefined')) {
            _request = quoteAlternativeId;
            _options = eRPProductKey;
        }
        else {
            _request = {
                QuoteAlternativeId: quoteAlternativeId,
                ERPProductKey: eRPProductKey,
            };
            _options = webapi_options;
        }
        return this._CreateQuoteLine(_request, _options);
    }
    async _CreateQuoteLineFromProduct(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateQuoteLineFromProduct", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLine_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateQuoteLineFromProduct(quoteAlternativeId, product, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteAlternativeId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteAlternativeId) != 'undefined' || typeof (first.Product) != 'undefined')) {
            _request = quoteAlternativeId;
            _options = product;
        }
        else {
            _request = {
                QuoteAlternativeId: quoteAlternativeId,
                Product: product,
            };
            _options = webapi_options;
        }
        return this._CreateQuoteLineFromProduct(_request, _options);
    }
    async _SaveQuoteLine(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLine", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLine_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuoteLine(quoteLine, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLine;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLine) != 'undefined')) {
            _request = quoteLine;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLine: quoteLine,
            };
            _options = webapi_options;
        }
        return this._SaveQuoteLine(_request, _options);
    }
    async _SaveQuoteLines(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLines", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLineArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuoteLines(quoteLines, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLines;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLines) != 'undefined')) {
            _request = quoteLines;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLines: quoteLines,
            };
            _options = webapi_options;
        }
        return this._SaveQuoteLines(_request, _options);
    }
    async _GetQuoteLine(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLine", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLine_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteLine(quoteLineId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineId) != 'undefined')) {
            _request = quoteLineId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLineId: quoteLineId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteLine(_request, _options);
    }
    async _GetQuoteLines(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLines", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLineArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteLines(quoteAlternativeId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteAlternativeId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteAlternativeId) != 'undefined')) {
            _request = quoteAlternativeId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteAlternativeId: quoteAlternativeId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteLines(_request, _options);
    }
    async _DeleteQuoteLine(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteQuoteLine", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteQuoteLine(quoteLineId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineId) != 'undefined')) {
            _request = quoteLineId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLineId: quoteLineId,
            };
            _options = webapi_options;
        }
        return this._DeleteQuoteLine(_request, _options);
    }
    async _DeleteQuoteLines(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteQuoteLines", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteQuoteLines(quoteLineIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineIds;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineIds) != 'undefined')) {
            _request = quoteLineIds;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLineIds: quoteLineIds,
            };
            _options = webapi_options;
        }
        return this._DeleteQuoteLines(_request, _options);
    }
    async _RecalculateQuoteLine(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RecalculateQuoteLine", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLine_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RecalculateQuoteLine(quoteLine, changedFields, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLine;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLine) != 'undefined' || typeof (first.ChangedFields) != 'undefined')) {
            _request = quoteLine;
            _options = changedFields;
        }
        else {
            _request = {
                QuoteLine: quoteLine,
                ChangedFields: changedFields,
            };
            _options = webapi_options;
        }
        return this._RecalculateQuoteLine(_request, _options);
    }
    async _GetQuoteLineImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLineImage", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteLineImage(quoteLineId, rank, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineId) != 'undefined' || typeof (first.Rank) != 'undefined')) {
            _request = quoteLineId;
            _options = rank;
        }
        else {
            _request = {
                QuoteLineId: quoteLineId,
                Rank: rank,
            };
            _options = webapi_options;
        }
        return this._GetQuoteLineImage(_request, _options);
    }
    async _SaveQuoteLineImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLineImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuoteLineImage(quoteLineId, image, rank, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineId) != 'undefined' || typeof (first.Image) != 'undefined' || typeof (first.Rank) != 'undefined')) {
            _request = quoteLineId;
            _options = image;
        }
        else {
            _request = {
                QuoteLineId: quoteLineId,
                Image: image,
                Rank: rank,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SaveQuoteLineImage(_request, _options);
    }
    async _GetExtraInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetExtraInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductExtraDataFieldArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetExtraInfo(quoteLineExtraData, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineExtraData;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineExtraData) != 'undefined')) {
            _request = quoteLineExtraData;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLineExtraData: quoteLineExtraData,
            };
            _options = webapi_options;
        }
        return this._GetExtraInfo(_request, _options);
    }
    async _GetQuoteLineConfiguration(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLineConfiguration", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLineConfiguration_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteLineConfiguration(quoteLineConfigurationId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineConfigurationId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineConfigurationId) != 'undefined')) {
            _request = quoteLineConfigurationId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLineConfigurationId: quoteLineConfigurationId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteLineConfiguration(_request, _options);
    }
    async _GetQuoteLineConfigurationFromFieldName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteLineConfigurationFromFieldName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLineConfiguration_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteLineConfigurationFromFieldName(fieldName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = fieldName;
        if (typeof (first) === "object" && first && (typeof (first.FieldName) != 'undefined')) {
            _request = fieldName;
            _options = webapi_options;
        }
        else {
            _request = {
                FieldName: fieldName,
            };
            _options = webapi_options;
        }
        return this._GetQuoteLineConfigurationFromFieldName(_request, _options);
    }
    async _GetAllQuoteLineConfigurations(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllQuoteLineConfigurations", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLineConfigurationArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all the configuration fields
     * @returns Array of QuoteLineConfigurations
     */
    async GetAllQuoteLineConfigurations(webapi_options) {
        return this._GetAllQuoteLineConfigurations(webapi_options);
    }
    async _GetInUseQuoteLineConfigurations(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetInUseQuoteLineConfigurations", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLineConfigurationArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns the configuration fields that should be visible in the GUI.
     * @returns Array of QuoteLineConfigurations
     */
    async GetInUseQuoteLineConfigurations(webapi_options) {
        return this._GetInUseQuoteLineConfigurations(webapi_options);
    }
    async _SaveQuoteLineConfiguration(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLineConfiguration", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLineConfiguration_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuoteLineConfiguration(quoteLineConfiguration, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineConfiguration;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineConfiguration) != 'undefined')) {
            _request = quoteLineConfiguration;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLineConfiguration: quoteLineConfiguration,
            };
            _options = webapi_options;
        }
        return this._SaveQuoteLineConfiguration(_request, _options);
    }
    async _SaveQuoteLineConfigurations(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteLineConfigurations", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteLineConfigurationArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuoteLineConfigurations(quoteLineConfigurations, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteLineConfigurations;
        if (typeof (first) === "object" && first && (typeof (first.QuoteLineConfigurations) != 'undefined')) {
            _request = quoteLineConfigurations;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteLineConfigurations: quoteLineConfigurations,
            };
            _options = webapi_options;
        }
        return this._SaveQuoteLineConfigurations(_request, _options);
    }
    async _GetQuoteList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteList(quoteListType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteListType;
        if (typeof (first) === "object" && first && (typeof (first.QuoteListType) != 'undefined')) {
            _request = quoteListType;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteListType: quoteListType,
            };
            _options = webapi_options;
        }
        return this._GetQuoteList(_request, _options);
    }
    async _ValidateQuoteVersion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateQuoteVersion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersionValidated_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateQuoteVersion(quoteVersionId, action, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.Action) != 'undefined')) {
            _request = quoteVersionId;
            _options = action;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                Action: action,
            };
            _options = webapi_options;
        }
        return this._ValidateQuoteVersion(_request, _options);
    }
    async _CreateAndSaveQuoteVersion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndSaveQuoteVersion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersion_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateAndSaveQuoteVersion(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._CreateAndSaveQuoteVersion(_request, _options);
    }
    async _GetQuoteVersion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersion_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteVersion(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteVersion(_request, _options);
    }
    async _GetQuoteVersions(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersions", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteVersions(quoteId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteId) != 'undefined')) {
            _request = quoteId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteId: quoteId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteVersions(_request, _options);
    }
    async _SendQuoteVersion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendQuoteVersion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginUrlResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SendQuoteVersion(quoteVersionId, expiryDate, followupDate, followupText, culture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.ExpiryDate) != 'undefined' || typeof (first.FollowupDate) != 'undefined' || typeof (first.FollowupText) != 'undefined' || typeof (first.Culture) != 'undefined')) {
            _request = quoteVersionId;
            _options = expiryDate;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                ExpiryDate: expiryDate,
                FollowupDate: followupDate,
                FollowupText: followupText,
                Culture: culture,
            };
            _options = webapi_options;
        }
        return this._SendQuoteVersion(_request, _options);
    }
    async _SaveQuoteVersion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteVersion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersion_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuoteVersion(quoteVersion, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersion;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersion) != 'undefined')) {
            _request = quoteVersion;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersion: quoteVersion,
            };
            _options = webapi_options;
        }
        return this._SaveQuoteVersion(_request, _options);
    }
    async _ApproveQuoteVersion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ApproveQuoteVersion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ApproveRejectResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ApproveQuoteVersion(quoteVersionId, approvedByText, approvedByAssociateId, approvalText, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.ApprovedByText) != 'undefined' || typeof (first.ApprovedByAssociateId) != 'undefined' || typeof (first.ApprovalText) != 'undefined')) {
            _request = quoteVersionId;
            _options = approvedByText;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                ApprovedByText: approvedByText,
                ApprovedByAssociateId: approvedByAssociateId,
                ApprovalText: approvalText,
            };
            _options = webapi_options;
        }
        return this._ApproveQuoteVersion(_request, _options);
    }
    async _RejectQuoteVersion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RejectQuoteVersion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ApproveRejectResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RejectQuoteVersion(quoteVersionId, rejectedByText, rejectedByAssociateId, rejectionText, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.RejectedByText) != 'undefined' || typeof (first.RejectedByAssociateId) != 'undefined' || typeof (first.RejectionText) != 'undefined')) {
            _request = quoteVersionId;
            _options = rejectedByText;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                RejectedByText: rejectedByText,
                RejectedByAssociateId: rejectedByAssociateId,
                RejectionText: rejectionText,
            };
            _options = webapi_options;
        }
        return this._RejectQuoteVersion(_request, _options);
    }
    async _GenerateQuoteDocuments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateQuoteDocuments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuotePublishDocuments_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GenerateQuoteDocuments(quoteVersionId, emailBodyTemplateId, attachMainDocument, quotedProductsTemplateId, includeAttachments, rawMailSubject, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.EmailBodyTemplateId) != 'undefined' || typeof (first.AttachMainDocument) != 'undefined' || typeof (first.QuotedProductsTemplateId) != 'undefined' || typeof (first.IncludeAttachments) != 'undefined' || typeof (first.RawMailSubject) != 'undefined')) {
            _request = quoteVersionId;
            _options = emailBodyTemplateId;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                EmailBodyTemplateId: emailBodyTemplateId,
                AttachMainDocument: attachMainDocument,
                QuotedProductsTemplateId: quotedProductsTemplateId,
                IncludeAttachments: includeAttachments,
                RawMailSubject: rawMailSubject,
            };
            _options = webapi_options;
        }
        return this._GenerateQuoteDocuments(_request, _options);
    }
    async _GetOrderConfirmation(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOrderConfirmation", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetOrderConfirmation(quoteVersionId, confirmationTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.ConfirmationTemplateId) != 'undefined')) {
            _request = quoteVersionId;
            _options = confirmationTemplateId;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                ConfirmationTemplateId: confirmationTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetOrderConfirmation(_request, _options);
    }
    async _GetQuoteVersionWorkflowState(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionWorkflowState", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersionWorkflowState_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteVersionWorkflowState(quoteVersionId, quoteAlternativeId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.QuoteAlternativeId) != 'undefined')) {
            _request = quoteVersionId;
            _options = quoteAlternativeId;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                QuoteAlternativeId: quoteAlternativeId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteVersionWorkflowState(_request, _options);
    }
    async _UpdateQuoteVersionPrices(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateQuoteVersionPrices", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersionValidated_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateQuoteVersionPrices(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._UpdateQuoteVersionPrices(_request, _options);
    }
    async _SaveQuoteVersionNumber(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteVersionNumber", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuoteVersionNumber(quoteVersionId, number, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.Number) != 'undefined')) {
            _request = quoteVersionId;
            _options = number;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                Number: number,
            };
            _options = webapi_options;
        }
        return this._SaveQuoteVersionNumber(_request, _options);
    }
    async _GetQuoteVersionWorkflowImageState(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionWorkflowImageState", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersionButtonState_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteVersionWorkflowImageState(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteVersionWorkflowImageState(_request, _options);
    }
    async _GetQuoteVersionWorkflowButtonStates(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionWorkflowButtonStates", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersionWorkflowState_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteVersionWorkflowButtonStates(quoteVersionId, quoteAlternativeId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.QuoteAlternativeId) != 'undefined')) {
            _request = quoteVersionId;
            _options = quoteAlternativeId;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                QuoteAlternativeId: quoteAlternativeId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteVersionWorkflowButtonStates(_request, _options);
    }
    async _GetQuoteVersionWorkflowStatusInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionWorkflowStatusInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersionStatusInformation_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteVersionWorkflowStatusInfo(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteVersionWorkflowStatusInfo(_request, _options);
    }
    async _RequestApproval(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RequestApproval", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RequestApproval(quoteVersionId, associateId, comment, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.AssociateId) != 'undefined' || typeof (first.Comment) != 'undefined')) {
            _request = quoteVersionId;
            _options = associateId;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                AssociateId: associateId,
                Comment: comment,
            };
            _options = webapi_options;
        }
        return this._RequestApproval(_request, _options);
    }
    async _CancelApprovalRequest(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CancelApprovalRequest", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CancelApprovalRequest(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._CancelApprovalRequest(_request, _options);
    }
    async _CreateOrUpdateQuoteVersionAttachments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateOrUpdateQuoteVersionAttachments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteVersionAttachmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateOrUpdateQuoteVersionAttachments(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._CreateOrUpdateQuoteVersionAttachments(_request, _options);
    }
    async _IncludeQuoteVersionAttachment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IncludeQuoteVersionAttachment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IncludeQuoteVersionAttachment(quoteVersionId, documentId, include, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.DocumentId) != 'undefined' || typeof (first.Include) != 'undefined')) {
            _request = quoteVersionId;
            _options = documentId;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                DocumentId: documentId,
                Include: include,
            };
            _options = webapi_options;
        }
        return this._IncludeQuoteVersionAttachment(_request, _options);
    }
    async _ToggleSaleTypeQuoteAttachmentDefaultIncluded(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleSaleTypeQuoteAttachmentDefaultIncluded", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleSaleTypeQuoteAttachmentDefaultIncluded(saleTypeQuoteAttachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleTypeQuoteAttachmentId;
        if (typeof (first) === "object" && first && (typeof (first.SaleTypeQuoteAttachmentId) != 'undefined')) {
            _request = saleTypeQuoteAttachmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleTypeQuoteAttachmentId: saleTypeQuoteAttachmentId,
            };
            _options = webapi_options;
        }
        return this._ToggleSaleTypeQuoteAttachmentDefaultIncluded(_request, _options);
    }
    async _AddSaleTypeQuoteAttachment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddSaleTypeQuoteAttachment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddSaleTypeQuoteAttachment(saleTypeId, documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleTypeId;
        if (typeof (first) === "object" && first && (typeof (first.SaleTypeId) != 'undefined' || typeof (first.DocumentId) != 'undefined')) {
            _request = saleTypeId;
            _options = documentId;
        }
        else {
            _request = {
                SaleTypeId: saleTypeId,
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._AddSaleTypeQuoteAttachment(_request, _options);
    }
    async _DeleteSaleTypeQuoteAttachment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteSaleTypeQuoteAttachment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteSaleTypeQuoteAttachment(saleTypeQuoteAttachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleTypeQuoteAttachmentId;
        if (typeof (first) === "object" && first && (typeof (first.SaleTypeQuoteAttachmentId) != 'undefined')) {
            _request = saleTypeQuoteAttachmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleTypeQuoteAttachmentId: saleTypeQuoteAttachmentId,
            };
            _options = webapi_options;
        }
        return this._DeleteSaleTypeQuoteAttachment(_request, _options);
    }
    async _ToggleQuoteVersionAttachmentIncluded(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleQuoteVersionAttachmentIncluded", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleQuoteVersionAttachmentIncluded(quoteVersionAttachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionAttachmentId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionAttachmentId) != 'undefined')) {
            _request = quoteVersionAttachmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionAttachmentId: quoteVersionAttachmentId,
            };
            _options = webapi_options;
        }
        return this._ToggleQuoteVersionAttachmentIncluded(_request, _options);
    }
} // class v1QuoteAgentController 
exports.QuoteAgent = QuoteAgent;
//# sourceMappingURL=QuoteAgent.js.map
"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContactAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Contact (company) data services.
 */
class ContactAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Contact/";
        super(options);
    }
    /**
     * Set default values into a new ContactEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultContactEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultContactEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ContactEntity or creates a new ContactEntity if the id parameter is empty
     * @param entity - The ContactEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ContactEntity
     */
    async SaveContactEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveContactEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ContactEntity
     * @param ContactEntityId - The id of the ContactEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteContactEntity(ContactEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteContactEntity?ContactEntityId=" + ContactEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new PreviewContact.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultPreviewContact(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPreviewContact", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreviewContact_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Contact object.
     * @param contactId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Contact
     */
    async GetContact(contactId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetContact?contactId=" + contactId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Contact_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetMyActiveContacts(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyActiveContacts", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactActivityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMyActiveContacts(activityStartTime, contactCategories, actionType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = activityStartTime;
        if (typeof (first) === "object" && first && (typeof (first.ActivityStartTime) != 'undefined' || typeof (first.ContactCategories) != 'undefined' || typeof (first.ActionType) != 'undefined')) {
            _request = activityStartTime;
            _options = contactCategories;
        }
        else {
            _request = {
                ActivityStartTime: activityStartTime,
                ContactCategories: contactCategories,
                ActionType: actionType,
            };
            _options = webapi_options;
        }
        return this._GetMyActiveContacts(_request, _options);
    }
    /*
     * Gets a ContactEntity object.
     * @param contactEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ContactEntity
     */
    async GetContactEntity(contactEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetContactEntity?contactEntityId=" + contactEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _Undelete(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Undelete", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Undelete(id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined')) {
            _request = id;
            _options = webapi_options;
        }
        else {
            _request = {
                Id: id,
            };
            _options = webapi_options;
        }
        return this._Undelete(_request, _options);
    }
    async _GetPersons(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersons", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersons(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._GetPersons(_request, _options);
    }
    async _GetContactWithPersons(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactWithPersons", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactWithPersons(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._GetContactWithPersons(_request, _options);
    }
    async _GetMyContact(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyContact", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets the contact belonging to the currently logged on user.
     * @returns The Contact
     */
    async GetMyContact(webapi_options) {
        return this._GetMyContact(webapi_options);
    }
    async _GetMyBizCard(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyBizCard", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all data needed to display the logged on person&apos;s business card. That is company, person, and company interest data.
     * @returns The contact object with persons and interests
     */
    async GetMyBizCard(webapi_options) {
        return this._GetMyBizCard(webapi_options);
    }
    async _ChangeCountry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeCountry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeCountry(contactEntity, toCountryId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactEntity;
        if (typeof (first) === "object" && first && (typeof (first.ContactEntity) != 'undefined' || typeof (first.ToCountryId) != 'undefined')) {
            _request = contactEntity;
            _options = toCountryId;
        }
        else {
            _request = {
                ContactEntity: contactEntity,
                ToCountryId: toCountryId,
            };
            _options = webapi_options;
        }
        return this._ChangeCountry(_request, _options);
    }
    async _GetAddress(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAddress", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Address_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAddress(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._GetAddress(_request, _options);
    }
    async _GetAddressByCountry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAddressByCountry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Address_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAddressByCountry(contactId, countryId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.CountryId) != 'undefined')) {
            _request = contactId;
            _options = countryId;
        }
        else {
            _request = {
                ContactId: contactId,
                CountryId: countryId,
            };
            _options = webapi_options;
        }
        return this._GetAddressByCountry(_request, _options);
    }
    async _AddPerson(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddPerson", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddPerson(contactId, newPersonEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.NewPersonEntity) != 'undefined')) {
            _request = contactId;
            _options = newPersonEntity;
        }
        else {
            _request = {
                ContactId: contactId,
                NewPersonEntity: newPersonEntity,
            };
            _options = webapi_options;
        }
        return this._AddPerson(_request, _options);
    }
    async _GetDuplicates(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicates", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DuplicateEntryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDuplicates(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._GetDuplicates(_request, _options);
    }
    async _CreateNewEntry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewEntry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateNewEntry(duplicate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = duplicate;
        if (typeof (first) === "object" && first && (typeof (first.Duplicate) != 'undefined')) {
            _request = duplicate;
            _options = webapi_options;
        }
        else {
            _request = {
                Duplicate: duplicate,
            };
            _options = webapi_options;
        }
        return this._CreateNewEntry(_request, _options);
    }
    async _GetDuplicateRules(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicateRules", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DuplicateRuleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Retrieve all available duplicate rules for contact
     * @returns All available duplicate rules
     */
    async GetDuplicateRules(webapi_options) {
        return this._GetDuplicateRules(webapi_options);
    }
    async _SetDuplicateRulesStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDuplicateRulesStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDuplicateRulesStatus(rules, webapi_options) {
        let _request = null;
        let _options = null;
        const first = rules;
        if (typeof (first) === "object" && first && (typeof (first.Rules) != 'undefined')) {
            _request = rules;
            _options = webapi_options;
        }
        else {
            _request = {
                Rules: rules,
            };
            _options = webapi_options;
        }
        return this._SetDuplicateRulesStatus(_request, _options);
    }
    async _Merge(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Merge", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Merge(sourceContactId, destinationContactId, mergeIdenticalPersons, replaceEmptyFieldsOnDestination, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourceContactId;
        if (typeof (first) === "object" && first && (typeof (first.SourceContactId) != 'undefined' || typeof (first.DestinationContactId) != 'undefined' || typeof (first.MergeIdenticalPersons) != 'undefined' || typeof (first.ReplaceEmptyFieldsOnDestination) != 'undefined')) {
            _request = sourceContactId;
            _options = destinationContactId;
        }
        else {
            _request = {
                SourceContactId: sourceContactId,
                DestinationContactId: destinationContactId,
                MergeIdenticalPersons: mergeIdenticalPersons,
                ReplaceEmptyFieldsOnDestination: replaceEmptyFieldsOnDestination,
            };
            _options = webapi_options;
        }
        return this._Merge(_request, _options);
    }
    async _Copy(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Copy", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Copy(sourceContactId, destinationContactName, destinationContactDepartment, copyPersons, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourceContactId;
        if (typeof (first) === "object" && first && (typeof (first.SourceContactId) != 'undefined' || typeof (first.DestinationContactName) != 'undefined' || typeof (first.DestinationContactDepartment) != 'undefined' || typeof (first.CopyPersons) != 'undefined')) {
            _request = sourceContactId;
            _options = destinationContactName;
        }
        else {
            _request = {
                SourceContactId: sourceContactId,
                DestinationContactName: destinationContactName,
                DestinationContactDepartment: destinationContactDepartment,
                CopyPersons: copyPersons,
            };
            _options = webapi_options;
        }
        return this._Copy(_request, _options);
    }
    async _GetNameDepartmentDuplicates(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNameDepartmentDuplicates", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DuplicateEntryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetNameDepartmentDuplicates(name, department, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.Department) != 'undefined')) {
            _request = name;
            _options = department;
        }
        else {
            _request = {
                Name: name,
                Department: department,
            };
            _options = webapi_options;
        }
        return this._GetNameDepartmentDuplicates(_request, _options);
    }
    async _IsNumberValid(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNumberValid", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsNumberValid(contactId, number, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.Number) != 'undefined')) {
            _request = contactId;
            _options = number;
        }
        else {
            _request = {
                ContactId: contactId,
                Number: number,
            };
            _options = webapi_options;
        }
        return this._IsNumberValid(_request, _options);
    }
    async _GetQuoteVersionAddresses(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteVersionAddresses", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AddressArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetQuoteVersionAddresses(quoteVersionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined')) {
            _request = quoteVersionId;
            _options = webapi_options;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
            };
            _options = webapi_options;
        }
        return this._GetQuoteVersionAddresses(_request, _options);
    }
    async _SaveQuoteVersionAddress(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuoteVersionAddress", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Address_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuoteVersionAddress(quoteVersionId, address, addressType, countryId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quoteVersionId;
        if (typeof (first) === "object" && first && (typeof (first.QuoteVersionId) != 'undefined' || typeof (first.Address) != 'undefined' || typeof (first.AddressType) != 'undefined' || typeof (first.CountryId) != 'undefined')) {
            _request = quoteVersionId;
            _options = address;
        }
        else {
            _request = {
                QuoteVersionId: quoteVersionId,
                Address: address,
                AddressType: addressType,
                CountryId: countryId,
            };
            _options = webapi_options;
        }
        return this._SaveQuoteVersionAddress(_request, _options);
    }
    async _DeleteExpired(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteExpired", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Trigger deletion of contacts (companies) that has been (soft) deleted and have timed out the expiry period (the SoftDeleteRetention preference).
     * @returns
     */
    async DeleteExpired(webapi_options) {
        return this._DeleteExpired(webapi_options);
    }
    async _GetContactSummary(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactSummary", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactSummary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactSummary(contactId, limit, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.Limit) != 'undefined')) {
            _request = contactId;
            _options = limit;
        }
        else {
            _request = {
                ContactId: contactId,
                Limit: limit,
            };
            _options = webapi_options;
        }
        return this._GetContactSummary(_request, _options);
    }
    async _ValidateContactEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateContactEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateContactEntity(contactEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactEntity;
        if (typeof (first) === "object" && first && (typeof (first.ContactEntity) != 'undefined')) {
            _request = contactEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactEntity: contactEntity,
            };
            _options = webapi_options;
        }
        return this._ValidateContactEntity(_request, _options);
    }
    /*
     * Gets an array of Contact objects.
     * @param contactIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Contact
     */
    async GetContactList(contactIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetContactList", contactIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetMyContacts(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyContacts", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Getting the contacts where the user currently logged in is set as contact owner.
     * @returns Array of contacts
     */
    async GetMyContacts(webapi_options) {
        return this._GetMyContacts(webapi_options);
    }
    async _GetMyRecentContacts(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyRecentContacts", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ContactArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMyRecentContacts(sourceType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourceType;
        if (typeof (first) === "object" && first && (typeof (first.SourceType) != 'undefined')) {
            _request = sourceType;
            _options = webapi_options;
        }
        else {
            _request = {
                SourceType: sourceType,
            };
            _options = webapi_options;
        }
        return this._GetMyRecentContacts(_request, _options);
    }
    async _GetPreviewContact(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewContact", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreviewContact_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreviewContact(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._GetPreviewContact(_request, _options);
    }
} // class v1ContactAgentController 
exports.ContactAgent = ContactAgent;
//# sourceMappingURL=ContactAgent.js.map
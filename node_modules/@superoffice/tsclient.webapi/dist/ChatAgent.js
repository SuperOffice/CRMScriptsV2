"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Chat functions. Manage chat channels, sessions and messages.
 */
class ChatAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Chat/";
        super(options);
    }
    /**
     * Set default values into a new ChatSessionEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultChatSessionEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultChatSessionEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ChatSessionEntity or creates a new ChatSessionEntity if the id parameter is empty
     * @param entity - The ChatSessionEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ChatSessionEntity
     */
    async SaveChatSessionEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveChatSessionEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ChatSessionEntity
     * @param ChatSessionEntityId - The id of the ChatSessionEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteChatSessionEntity(ChatSessionEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteChatSessionEntity?ChatSessionEntityId=" + ChatSessionEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ChatTopicAgent.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultChatTopicAgent(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultChatTopicAgent", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicAgent_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ChatTopicEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultChatTopicEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultChatTopicEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ChatTopicEntity or creates a new ChatTopicEntity if the id parameter is empty
     * @param entity - The ChatTopicEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ChatTopicEntity
     */
    async SaveChatTopicEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveChatTopicEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ChatTopicEntity
     * @param ChatTopicEntityId - The id of the ChatTopicEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteChatTopicEntity(ChatTopicEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteChatTopicEntity?ChatTopicEntityId=" + ChatTopicEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetChatPresence(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatPresence", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatPresenceArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the chat presence status for all chat users
     * @returns An array with ChatPresence objects for each user
     */
    async GetChatPresence(webapi_options) {
        return this._GetChatPresence(webapi_options);
    }
    async _SaveChatPresence(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveChatPresence", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveChatPresence(chatPresence, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatPresence;
        if (typeof (first) === "object" && first && (typeof (first.ChatPresence) != 'undefined')) {
            _request = chatPresence;
            _options = webapi_options;
        }
        else {
            _request = {
                ChatPresence: chatPresence,
            };
            _options = webapi_options;
        }
        return this._SaveChatPresence(_request, _options);
    }
    /*
     * Gets a ChatSessionEntity object.
     * @param chatSessionEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ChatSessionEntity
     */
    async GetChatSessionEntity(chatSessionEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetChatSessionEntity?chatSessionEntityId=" + chatSessionEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _ChatSessionsForUser(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChatSessionsForUser", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get all chat sessions which this user is a member of. Members means that you have at least one of: Can Respond, Notifications, Listen or Manager
     * @returns Array of chat sessions the current user can access
     */
    async ChatSessionsForUser(webapi_options) {
        return this._ChatSessionsForUser(webapi_options);
    }
    async _TransferChatSession(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TransferChatSession", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async TransferChatSession(chatSessionId, toAssociate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatSessionId;
        if (typeof (first) === "object" && first && (typeof (first.ChatSessionId) != 'undefined' || typeof (first.ToAssociate) != 'undefined')) {
            _request = chatSessionId;
            _options = toAssociate;
        }
        else {
            _request = {
                ChatSessionId: chatSessionId,
                ToAssociate: toAssociate,
            };
            _options = webapi_options;
        }
        return this._TransferChatSession(_request, _options);
    }
    async _AcceptChatSessionTransfer(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AcceptChatSessionTransfer", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AcceptChatSessionTransfer(chatSessionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatSessionId;
        if (typeof (first) === "object" && first && (typeof (first.ChatSessionId) != 'undefined')) {
            _request = chatSessionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ChatSessionId: chatSessionId,
            };
            _options = webapi_options;
        }
        return this._AcceptChatSessionTransfer(_request, _options);
    }
    async _RejectChatSessionTransfer(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RejectChatSessionTransfer", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RejectChatSessionTransfer(chatSessionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatSessionId;
        if (typeof (first) === "object" && first && (typeof (first.ChatSessionId) != 'undefined')) {
            _request = chatSessionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ChatSessionId: chatSessionId,
            };
            _options = webapi_options;
        }
        return this._RejectChatSessionTransfer(_request, _options);
    }
    async _PickUpChatSession(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PickUpChatSession", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async PickUpChatSession(chatSessionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatSessionId;
        if (typeof (first) === "object" && first && (typeof (first.ChatSessionId) != 'undefined')) {
            _request = chatSessionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ChatSessionId: chatSessionId,
            };
            _options = webapi_options;
        }
        return this._PickUpChatSession(_request, _options);
    }
    async _PickUpFirstChatSession(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PickUpFirstChatSession", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * &apos;answer&apos; the first available session from the queue: assign the session to the user. The welcome message is sent to the customer.
     * @returns The picked-up chat session
     */
    async PickUpFirstChatSession(webapi_options) {
        return this._PickUpFirstChatSession(webapi_options);
    }
    async _ResetChatSession(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResetChatSession", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ResetChatSession(chatSessionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatSessionId;
        if (typeof (first) === "object" && first && (typeof (first.ChatSessionId) != 'undefined')) {
            _request = chatSessionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ChatSessionId: chatSessionId,
            };
            _options = webapi_options;
        }
        return this._ResetChatSession(_request, _options);
    }
    async _GetChatTranscript(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatTranscript", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetChatTranscript(chatSessionId, html, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatSessionId;
        if (typeof (first) === "object" && first && (typeof (first.ChatSessionId) != 'undefined' || typeof (first.Html) != 'undefined')) {
            _request = chatSessionId;
            _options = html;
        }
        else {
            _request = {
                ChatSessionId: chatSessionId,
                Html: html,
            };
            _options = webapi_options;
        }
        return this._GetChatTranscript(_request, _options);
    }
    async _GetChatMessages(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatMessages", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatMessageArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetChatMessages(chatSessionId, after, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatSessionId;
        if (typeof (first) === "object" && first && (typeof (first.ChatSessionId) != 'undefined' || typeof (first.After) != 'undefined')) {
            _request = chatSessionId;
            _options = after;
        }
        else {
            _request = {
                ChatSessionId: chatSessionId,
                After: after,
            };
            _options = webapi_options;
        }
        return this._GetChatMessages(_request, _options);
    }
    async _AddChatMessage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddChatMessage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatMessage_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddChatMessage(chatSessionId, message, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatSessionId;
        if (typeof (first) === "object" && first && (typeof (first.ChatSessionId) != 'undefined' || typeof (first.Message) != 'undefined')) {
            _request = chatSessionId;
            _options = message;
        }
        else {
            _request = {
                ChatSessionId: chatSessionId,
                Message: message,
            };
            _options = webapi_options;
        }
        return this._AddChatMessage(_request, _options);
    }
    /*
     * Gets a ChatTopicEntity object.
     * @param chatTopicEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ChatTopicEntity
     */
    async GetChatTopicEntity(chatTopicEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetChatTopicEntity?chatTopicEntityId=" + chatTopicEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _IsWithinOpeningHours(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsWithinOpeningHours", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsWithinOpeningHours(chatTopicId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatTopicId;
        if (typeof (first) === "object" && first && (typeof (first.ChatTopicId) != 'undefined')) {
            _request = chatTopicId;
            _options = webapi_options;
        }
        else {
            _request = {
                ChatTopicId: chatTopicId,
            };
            _options = webapi_options;
        }
        return this._IsWithinOpeningHours(_request, _options);
    }
    async _ChatTopicsForUser(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChatTopicsForUser", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get all chat topics which this user is a member of. Members means that you have at least one of: Can Respond, Notifications, Listen or Manager
     * @returns Array of chat topics the current user can access
     */
    async ChatTopicsForUser(webapi_options) {
        return this._ChatTopicsForUser(webapi_options);
    }
    async _GetUserAgentList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserAgentList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUserAgentList(flat, onlyPresent, webapi_options) {
        let _request = null;
        let _options = null;
        const first = flat;
        if (typeof (first) === "object" && first && (typeof (first.Flat) != 'undefined' || typeof (first.OnlyPresent) != 'undefined')) {
            _request = flat;
            _options = onlyPresent;
        }
        else {
            _request = {
                Flat: flat,
                OnlyPresent: onlyPresent,
            };
            _options = webapi_options;
        }
        return this._GetUserAgentList(_request, _options);
    }
    async _GetChatTopicUserAgentList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatTopicUserAgentList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicAgentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetChatTopicUserAgentList(chatTopicId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatTopicId;
        if (typeof (first) === "object" && first && (typeof (first.ChatTopicId) != 'undefined')) {
            _request = chatTopicId;
            _options = webapi_options;
        }
        else {
            _request = {
                ChatTopicId: chatTopicId,
            };
            _options = webapi_options;
        }
        return this._GetChatTopicUserAgentList(_request, _options);
    }
    async _GetChatTopicUserAgent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetChatTopicUserAgent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicAgent_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetChatTopicUserAgent(chatTopicId, username, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatTopicId;
        if (typeof (first) === "object" && first && (typeof (first.ChatTopicId) != 'undefined' || typeof (first.Username) != 'undefined')) {
            _request = chatTopicId;
            _options = username;
        }
        else {
            _request = {
                ChatTopicId: chatTopicId,
                Username: username,
            };
            _options = webapi_options;
        }
        return this._GetChatTopicUserAgent(_request, _options);
    }
    async _AddChatTopicUserAgent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddChatTopicUserAgent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicAgent_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddChatTopicUserAgent(chatTopicId, useragent, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatTopicId;
        if (typeof (first) === "object" && first && (typeof (first.ChatTopicId) != 'undefined' || typeof (first.Useragent) != 'undefined')) {
            _request = chatTopicId;
            _options = useragent;
        }
        else {
            _request = {
                ChatTopicId: chatTopicId,
                Useragent: useragent,
            };
            _options = webapi_options;
        }
        return this._AddChatTopicUserAgent(_request, _options);
    }
    async _UpdateChatTopicUserAgent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateChatTopicUserAgent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicAgent_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateChatTopicUserAgent(chatTopicId, username, useragent, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatTopicId;
        if (typeof (first) === "object" && first && (typeof (first.ChatTopicId) != 'undefined' || typeof (first.Username) != 'undefined' || typeof (first.Useragent) != 'undefined')) {
            _request = chatTopicId;
            _options = username;
        }
        else {
            _request = {
                ChatTopicId: chatTopicId,
                Username: username,
                Useragent: useragent,
            };
            _options = webapi_options;
        }
        return this._UpdateChatTopicUserAgent(_request, _options);
    }
    async _UpdateChatTopicUserAgents(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateChatTopicUserAgents", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatTopicAgentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateChatTopicUserAgents(chatTopicId, useragents, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatTopicId;
        if (typeof (first) === "object" && first && (typeof (first.ChatTopicId) != 'undefined' || typeof (first.Useragents) != 'undefined')) {
            _request = chatTopicId;
            _options = useragents;
        }
        else {
            _request = {
                ChatTopicId: chatTopicId,
                Useragents: useragents,
            };
            _options = webapi_options;
        }
        return this._UpdateChatTopicUserAgents(_request, _options);
    }
    async _DeleteChatTopicUserAgent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteChatTopicUserAgent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteChatTopicUserAgent(chatTopicId, username, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatTopicId;
        if (typeof (first) === "object" && first && (typeof (first.ChatTopicId) != 'undefined' || typeof (first.Username) != 'undefined')) {
            _request = chatTopicId;
            _options = username;
        }
        else {
            _request = {
                ChatTopicId: chatTopicId,
                Username: username,
            };
            _options = webapi_options;
        }
        return this._DeleteChatTopicUserAgent(_request, _options);
    }
    async _CreateChatSessionForTopic(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateChatSessionForTopic", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ChatSessionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateChatSessionForTopic(chatTopicId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = chatTopicId;
        if (typeof (first) === "object" && first && (typeof (first.ChatTopicId) != 'undefined')) {
            _request = chatTopicId;
            _options = webapi_options;
        }
        else {
            _request = {
                ChatTopicId: chatTopicId,
            };
            _options = webapi_options;
        }
        return this._CreateChatSessionForTopic(_request, _options);
    }
} // class v1ChatAgentController 
exports.ChatAgent = ChatAgent;
//# sourceMappingURL=ChatAgent.js.map
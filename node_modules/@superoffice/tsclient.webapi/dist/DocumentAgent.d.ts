import { AxiosRequestConfig } from 'axios';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
/**
 * Collection of all services that works with Document data. This is services for the document information, not the physical document themselves. These are handled by the BLOB service methods.
 */
export interface IDocumentAgent {
    CreateDefaultDocumentEntity(): Promise<carriers.DocumentEntity>;
    SaveDocumentEntity(entity: carriers.DocumentEntity): Promise<carriers.DocumentEntity>;
    DeleteDocumentEntity(DocumentEntityId: number): Promise<void>;
    CreateDefaultDocumentPreview(): Promise<carriers.DocumentPreview>;
    CreateDefaultSuggestedDocumentEntity(): Promise<carriers.SuggestedDocumentEntity>;
    SaveSuggestedDocumentEntity(entity: carriers.SuggestedDocumentEntity): Promise<carriers.SuggestedDocumentEntity>;
    CreateDefaultTemplateVariablesParameters(): Promise<carriers.TemplateVariablesParameters>;
    GetDocument(documentId: number): Promise<carriers.Document>;
    GetDocumentEntity(documentEntityId: number): Promise<carriers.DocumentEntity>;
    GetDocumentStreamFromEntity(request: carriers.Document_GetDocumentStreamFromEntityRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetDocumentStreamFromEntity(documentEntity: carriers.DocumentEntity, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    SetDocumentStream(request: carriers.Document_SetDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    SetDocumentStream(documentEntity: carriers.DocumentEntity, stream: ArrayBuffer | string, overwriteExistingData: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    CreateDocumentStream(request: carriers.Document_CreateDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    CreateDocumentStream(documentEntity: carriers.DocumentEntity, overwriteExistingData: boolean, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetTemplateStream(request: carriers.Document_GetTemplateStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetTemplateStream(templateName: string, allowPersonal: boolean, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetSanitizedTemplateStream(request: carriers.Document_GetSanitizedTemplateStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetSanitizedTemplateStream(templateName: string, allowPersonal: boolean, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetTemplateStreamFromId(request: carriers.Document_GetTemplateStreamFromIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetTemplateStreamFromId(templateId: number, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetSanitizedTemplateStreamFromId(request: carriers.Document_GetSanitizedTemplateStreamFromIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetSanitizedTemplateStreamFromId(templateId: number, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetDocumentStream(request: carriers.Document_GetDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetSanitizedDocumentStream(request: carriers.Document_GetSanitizedDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetSanitizedDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetPreviewDocumentStream(request: carriers.Document_GetPreviewDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    GetPreviewDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    GetUnsanitizedPreviewDocumentStream(request: carriers.Document_GetUnsanitizedPreviewDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    GetUnsanitizedPreviewDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    CreateNewPhysicalMailMergeDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalMailMergeDocumentFromTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    CreateNewPhysicalMailMergeDocumentFromTemplate(documentId: number, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    CreateNewPhysicalDocumentFromTemplateWithCustomTags(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTagsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    CreateNewPhysicalDocumentFromTemplateWithCustomTags(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, customTags: string[], customValues: string[], uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    CreateNewPhysicalDocumentFromTemplateWithCustomTags2(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTags2Request, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    CreateNewPhysicalDocumentFromTemplateWithCustomTags2(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, customTags: carriers.StringDictionary, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    SubstituteTemplateVariables(request: carriers.Document_SubstituteTemplateVariablesRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    SubstituteTemplateVariables(source: string, generatorEncoding: enums.GeneratorEncoding, contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    SubstituteTemplateVariablesWithCustomTags(request: carriers.Document_SubstituteTemplateVariablesWithCustomTagsRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    SubstituteTemplateVariablesWithCustomTags(source: string, generatorEncoding: enums.GeneratorEncoding, customTags: string[], customValues: string[], contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    SubstituteTemplateVariablesWithCustomTags2(request: carriers.Document_SubstituteTemplateVariablesWithCustomTags2Request, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    SubstituteTemplateVariablesWithCustomTags2(source: string, generatorEncoding: enums.GeneratorEncoding, customTags: carriers.StringDictionary, contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    CreateTempFile(request: carriers.Document_CreateTempFileRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    CreateTempFile(filename: string, dataStream: ArrayBuffer | string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetTempFile(request: carriers.Document_GetTempFileRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetTempFile(filename: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    DeleteTempFile(request: carriers.Document_DeleteTempFileRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    DeleteTempFile(filename: string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SetTemplateStream(request: carriers.Document_SetTemplateStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SetTemplateStream(filename: string, personal: boolean, stream: ArrayBuffer | string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    CreateNewPhysicalDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    CreateNewPhysicalDocumentFromTemplate(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    SubstituteMergeDocumentTemplateVariables(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    SubstituteMergeDocumentTemplateVariables(documentId: number, associateId: number, customTags: string[], customValues: string[], webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    SubstituteMergeDocumentTemplateVariables2(request: carriers.Document_SubstituteMergeDocumentTemplateVariables2Request, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    SubstituteMergeDocumentTemplateVariables2(documentId: number, associateId: number, customTags: carriers.StringDictionary, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    SubstituteTemplateVariablesEx(request: carriers.Document_SubstituteTemplateVariablesExRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    SubstituteTemplateVariablesEx(parameters: carriers.TemplateVariablesParameters, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    VerifyGetDocumentStream(request: carriers.Document_VerifyGetDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    VerifyGetDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SubstituteMergeDocumentTemplateVariablesEx(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesExRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    SubstituteMergeDocumentTemplateVariablesEx(mergeDocumentId: number, contactId: number, personId: number, projectId: number, selectionId: number, appointmentId: number, documentId: number, saleId: number, customTags: string[], customValues: string[], webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    SubstituteMergeDocumentTemplateVariablesEx2(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesEx2Request, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    SubstituteMergeDocumentTemplateVariablesEx2(mergeDocumentId: number, contactId: number, personId: number, projectId: number, selectionId: number, appointmentId: number, documentId: number, saleId: number, customTags: carriers.StringDictionary, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetDocumentUrl(request: carriers.Document_GetDocumentUrlRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetDocumentUrl(documentId: number, versionId: string, writeableUrl: boolean, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    DeletePhysicalDocument(request: carriers.Document_DeletePhysicalDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    DeletePhysicalDocument(documentId: number, allowedReturnType: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    RenameDocument(request: carriers.Document_RenameDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    RenameDocument(documentId: number, newFilename: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetCheckoutState(request: carriers.Document_GetCheckoutStateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CheckoutInfo>;
    GetCheckoutState(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CheckoutInfo>;
    CheckoutDocument(request: carriers.Document_CheckoutDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    CheckoutDocument(documentId: number, allowedReturnTypes: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    CheckinDocument(request: carriers.Document_CheckinDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    CheckinDocument(documentId: number, allowedReturnTypes: string[], versionDescription: string, versionExtraFields: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    UndoCheckoutDocument(request: carriers.Document_UndoCheckoutDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    UndoCheckoutDocument(documentId: number, allowedReturnTypes: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    GetVersionList(request: carriers.Document_GetVersionListRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.VersionInfo[]>;
    GetVersionList(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.VersionInfo[]>;
    GetPluginList(webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    GetPluginCapabilities(request: carriers.Document_GetPluginCapabilitiesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    GetPluginCapabilities(pluginId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    GetDocumentProperties(request: carriers.Document_GetDocumentPropertiesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    GetDocumentProperties(documentId: number, requestedProperties: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    GetDocumentCommands(request: carriers.Document_GetDocumentCommandsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CommandInfo[]>;
    GetDocumentCommands(documentId: number, allowedReturnTypes: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.CommandInfo[]>;
    ExecuteDocumentCommand(request: carriers.Document_ExecuteDocumentCommandRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    ExecuteDocumentCommand(documentId: number, versionId: string, allowedReturnTypes: string[], command: string, additionalData: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    CreateDefaultDocumentEntityFromSuggestion(request: carriers.Document_CreateDefaultDocumentEntityFromSuggestionRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    CreateDefaultDocumentEntityFromSuggestion(suggestedDocumentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    SaveDocumentTemplateStream(request: carriers.Document_SaveDocumentTemplateStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TemplateInfo>;
    SaveDocumentTemplateStream(documentTemplateId: number, content: ArrayBuffer | string, languageCode: string, pluginId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TemplateInfo>;
    SetDocumentStreamFromId(request: carriers.Document_SetDocumentStreamFromIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    SetDocumentStreamFromId(documentId: number, stream: ArrayBuffer | string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    SavePrivacyReport(request: carriers.Document_SavePrivacyReportRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    SavePrivacyReport(htmlReport: string, title: string, personId: number, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    ValidateDocumentEntity(request: carriers.Document_ValidateDocumentEntityRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    ValidateDocumentEntity(documentEntity: carriers.DocumentEntity, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    GetDocumentLength(request: carriers.Document_GetDocumentLengthRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    GetDocumentLength(documentId: number, versionId: string, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    GetDocumentList(documentIds: number[]): Promise<carriers.Document[]>;
    GetAppointmentDocuments(request: carriers.Document_GetAppointmentDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetAppointmentDocuments(appointmentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetSaleDocuments(request: carriers.Document_GetSaleDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetSaleDocuments(saleId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocuments(request: carriers.Document_GetPersonDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocuments(personId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPublishedDocument(request: carriers.Document_GetPublishedDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document>;
    GetPublishedDocument(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document>;
    GetPublishedDocuments(request: carriers.Document_GetPublishedDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPublishedDocuments(documentIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetMyPublishedDocuments(webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPublishedDocumentsByDate(request: carriers.Document_GetPublishedDocumentsByDateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPublishedDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetContactDocumentsByTemplateTypes(request: carriers.Document_GetContactDocumentsByTemplateTypesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetContactDocumentsByTemplateTypes(contactId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetContactDocumentsByTemplateType(request: carriers.Document_GetContactDocumentsByTemplateTypeRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetContactDocumentsByTemplateType(contactId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetContactDocumentsByTemplateHeading(request: carriers.Document_GetContactDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetContactDocumentsByTemplateHeading(contactId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetContactDocuments(request: carriers.Document_GetContactDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetContactDocuments(contactId: number, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPublishedPersonDocumentsByDate(request: carriers.Document_GetPublishedPersonDocumentsByDateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPublishedPersonDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPublishedProjectDocuments(request: carriers.Document_GetPublishedProjectDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPublishedProjectDocuments(projectId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectMemberDocumentsByTemplateTypes(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectMemberDocumentsByTemplateTypes(personId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectMemberDocumentsByTemplateType(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypeRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectMemberDocumentsByTemplateType(personId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectMemberDocumentsByTemplateHeading(request: carriers.Document_GetProjectMemberDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectMemberDocumentsByTemplateHeading(personId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectMemberDocuments(request: carriers.Document_GetProjectMemberDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectMemberDocuments(personId: number, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectDocumentsByTemplateTypes(request: carriers.Document_GetProjectDocumentsByTemplateTypesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectDocumentsByTemplateTypes(projectId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectDocumentsByTemplateType(request: carriers.Document_GetProjectDocumentsByTemplateTypeRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectDocumentsByTemplateType(projectId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectDocumentsByTemplateHeading(request: carriers.Document_GetProjectDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectDocumentsByTemplateHeading(projectId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectDocuments(request: carriers.Document_GetProjectDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetProjectDocuments(projectId: number, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocumentsByTemplateTypes(request: carriers.Document_GetPersonDocumentsByTemplateTypesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocumentsByTemplateTypes(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocumentsByTemplateType(request: carriers.Document_GetPersonDocumentsByTemplateTypeRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocumentsByTemplateType(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocumentsByTemplateHeading(request: carriers.Document_GetPersonDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocumentsByTemplateHeading(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocumentsByDate(request: carriers.Document_GetPersonDocumentsByDateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetPersonDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetDocumentsByTemplateHeading(request: carriers.Document_GetDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetDocumentsByTemplateHeading(templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetSuggestedDocumentEntity(suggestedDocumentEntityId: number): Promise<carriers.SuggestedDocumentEntity>;
}
/**
 * Collection of all services that works with Document data. This is services for the document information, not the physical document themselves. These are handled by the BLOB service methods.
 */
export declare class DocumentAgent extends base.WebApiBase implements IDocumentAgent {
    constructor(baseUrl?: string, languageCode?: string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager: any);
    constructor(baseUrl: string, config: AxiosRequestConfig, resourceManager: any);
    constructor(baseUrl: string, config: AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config: AxiosRequestConfig, languageCode?: string, cultureCode?: string);
    constructor(options: base.WebApiOptions);
    /**
     * Set default values into a new DocumentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultDocumentEntity(options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    SaveDocumentEntity(entity: carriers.DocumentEntity, options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    DeleteDocumentEntity(DocumentEntityId: number, options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Set default values into a new DocumentPreview.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultDocumentPreview(options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    /**
     * Set default values into a new SuggestedDocumentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultSuggestedDocumentEntity(options?: base.WebApiRequestOptions): Promise<carriers.SuggestedDocumentEntity>;
    SaveSuggestedDocumentEntity(entity: carriers.SuggestedDocumentEntity, options?: base.WebApiRequestOptions): Promise<carriers.SuggestedDocumentEntity>;
    /**
     * Set default values into a new TemplateVariablesParameters.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultTemplateVariablesParameters(options?: base.WebApiRequestOptions): Promise<carriers.TemplateVariablesParameters>;
    GetDocument(documentId: number, options?: base.WebApiRequestOptions): Promise<carriers.Document>;
    GetDocumentEntity(documentEntityId: number, options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    private _GetDocumentStreamFromEntity;
    /**
     * Get the document as a stream
     * @param request - DocumentEntity
     * @returns The document as a Stream
     */
    GetDocumentStreamFromEntity(request: carriers.Document_GetDocumentStreamFromEntityRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Get the document as a stream
     * @param documentEntity - The document entity object that refers to the binary data (document)
     * @returns The document as a Stream
     */
    GetDocumentStreamFromEntity(documentEntity: carriers.DocumentEntity, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _SetDocumentStream;
    /**
     * Store a document&apos;s contents from its stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - DocumentEntity, Stream, OverwriteExistingData
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    SetDocumentStream(request: carriers.Document_SetDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    /**
     * Store a document&apos;s contents from its stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param documentEntity - The document entity object that the binary data (document) should be stored to. Its file name may be amended by this call, see the return value
     * @param stream - The document as a stream.
     * @param overwriteExistingData - If true, the stream will overwrite existing data stored for this record in the document archive; this works only for documents that already have a physical document in existence. If false, the call will only work for a document that has no physical document in the archive, and such a physical document will be created.
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    SetDocumentStream(documentEntity: carriers.DocumentEntity, stream: ArrayBuffer | string, overwriteExistingData: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    private _CreateDocumentStream;
    /**
     * Creates a new Stream that can be used to store the document in the file archive.
     * @param request - DocumentEntity, OverwriteExistingData
     * @returns A writeable stream. When written and closed, the stream will become the new document content, subject to locking and versioning constraints.
     */
    CreateDocumentStream(request: carriers.Document_CreateDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Creates a new Stream that can be used to store the document in the file archive.
     * @param documentEntity - The document the stream belongs to
     * @param overwriteExistingData - If true, the stream will overwrite existing data stored for this record in the document archive
     * @returns A writeable stream. When written and closed, the stream will become the new document content, subject to locking and versioning constraints.
     */
    CreateDocumentStream(documentEntity: carriers.DocumentEntity, overwriteExistingData: boolean, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _GetTemplateStream;
    /**
     * Retrieve a stream to a mail template based on its name
     * @param request - TemplateName, AllowPersonal, UiCulture
     * @returns Open stream to the mail template
     */
    GetTemplateStream(request: carriers.Document_GetTemplateStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Retrieve a stream to a mail template based on its name
     * @param templateName - Filename of mail template to retrieve
     * @param allowPersonal - If true, try looking up template in personal area before looking in shared document template area
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns Open stream to the mail template
     */
    GetTemplateStream(templateName: string, allowPersonal: boolean, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _GetSanitizedTemplateStream;
    /**
     * Retrieve a stream to a mail template based on its name. Sanitizes the contents if possible.
     * @param request - TemplateName, AllowPersonal, UiCulture
     * @returns Open stream to the mail template
     */
    GetSanitizedTemplateStream(request: carriers.Document_GetSanitizedTemplateStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Retrieve a stream to a mail template based on its name. Sanitizes the contents if possible.
     * @param templateName - Filename of mail template to retrieve
     * @param allowPersonal - If true, try looking up template in personal area before looking in shared document template area
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns Open stream to the mail template
     */
    GetSanitizedTemplateStream(templateName: string, allowPersonal: boolean, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _GetTemplateStreamFromId;
    /**
     * Retrieve a stream to a document template based on its id
     * @param request - TemplateId, UiCulture
     * @returns Open stream to the template
     */
    GetTemplateStreamFromId(request: carriers.Document_GetTemplateStreamFromIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Retrieve a stream to a document template based on its id
     * @param templateId - Id of template to retrieve
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns Open stream to the template
     */
    GetTemplateStreamFromId(templateId: number, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _GetSanitizedTemplateStreamFromId;
    /**
     * Retrieve a stream to a document template based on its id. Sanitizes the contents if possible.
     * @param request - TemplateId, UiCulture
     * @returns Open stream to the template
     */
    GetSanitizedTemplateStreamFromId(request: carriers.Document_GetSanitizedTemplateStreamFromIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Retrieve a stream to a document template based on its id. Sanitizes the contents if possible.
     * @param templateId - Id of template to retrieve
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns Open stream to the template
     */
    GetSanitizedTemplateStreamFromId(templateId: number, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _GetDocumentStream;
    /**
     * Get the document content as a stream
     * @param request - DocumentId
     * @returns The document as a Stream. This stream can be read once and clients should not assume it remains valid after a ReadToEnd or Close.
     */
    GetDocumentStream(request: carriers.Document_GetDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Get the document content as a stream
     * @param documentId - SuperOffice document id
     * @returns The document as a Stream. This stream can be read once and clients should not assume it remains valid after a ReadToEnd or Close.
     */
    GetDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _GetSanitizedDocumentStream;
    /**
     * Get the document content as a stream. Retrieves a sanitized version if possible
     * @param request - DocumentId
     * @returns The document as a Stream. This stream can be read once and clients should not assume it remains valid after a ReadToEnd or Close.
     */
    GetSanitizedDocumentStream(request: carriers.Document_GetSanitizedDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Get the document content as a stream. Retrieves a sanitized version if possible
     * @param documentId - SuperOffice document id
     * @returns The document as a Stream. This stream can be read once and clients should not assume it remains valid after a ReadToEnd or Close.
     */
    GetSanitizedDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _GetPreviewDocumentStream;
    /**
     * Get the preview version of the document content as a stream. Retrieves a sanitized version if possible
     * @param request - DocumentId
     * @returns Preview version of the document
     */
    GetPreviewDocumentStream(request: carriers.Document_GetPreviewDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    /**
     * Get the preview version of the document content as a stream. Retrieves a sanitized version if possible
     * @param documentId - SuperOffice document id
     * @returns Preview version of the document
     */
    GetPreviewDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    private _GetUnsanitizedPreviewDocumentStream;
    /**
     * Get the preview version of the document content as a stream. Retrieves an unsanitized version. This has less CPU impact but the caller must sanitize the content before presenting it to the user.
     * @param request - DocumentId
     * @returns Unsanitized preview version of the document
     */
    GetUnsanitizedPreviewDocumentStream(request: carriers.Document_GetUnsanitizedPreviewDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    /**
     * Get the preview version of the document content as a stream. Retrieves an unsanitized version. This has less CPU impact but the caller must sanitize the content before presenting it to the user.
     * @param documentId - SuperOffice document id
     * @returns Unsanitized preview version of the document
     */
    GetUnsanitizedPreviewDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    private _CreateNewPhysicalMailMergeDocumentFromTemplate;
    /**
     * Create a new physical document based on the documents template. Do not replace template tags, as the document is going to be used as a mail merge source. Use GetDocumentStream to obtain the created documents. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - DocumentId, UiCulture
     * @returns The document object with updated info after creating the document.
     */
    CreateNewPhysicalMailMergeDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalMailMergeDocumentFromTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    /**
     * Create a new physical document based on the documents template. Do not replace template tags, as the document is going to be used as a mail merge source. Use GetDocumentStream to obtain the created documents. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param documentId - Identifier for a document. The template to use is stored in the document entity.
     * @param uiCulture - Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns The document object with updated info after creating the document.
     */
    CreateNewPhysicalMailMergeDocumentFromTemplate(documentId: number, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    private _CreateNewPhysicalDocumentFromTemplateWithCustomTags;
    /**
     * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CustomTags, CustomValues, UiCulture
     * @returns The document object with updated info after creating the document
     */
    CreateNewPhysicalDocumentFromTemplateWithCustomTags(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTagsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    /**
     * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param contactId - Identifier for a contact. Defaults to document's contact if 0
     * @param personId - Identifier for a person. Defaults to document's person if 0
     * @param appointmentId - identifier for an appointment. Defaults to document if 0
     * @param documentId - Identifier for the document
     * @param saleId - Identifier for sale. Defaults to document's sale if 0.
     * @param selectionId - identifier for selection.
     * @param projectId - identifier for project. Defaults to document's project if 0
     * @param customTags - Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param customValues - Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param uiCulture - Language variation of template to use when creating document. (ISO code - "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns The document object with updated info after creating the document
     */
    CreateNewPhysicalDocumentFromTemplateWithCustomTags(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, customTags: string[], customValues: string[], uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    private _CreateNewPhysicalDocumentFromTemplateWithCustomTags2;
    /**
     * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CustomTags, UiCulture
     * @returns The document object with updated info after creating the document
     */
    CreateNewPhysicalDocumentFromTemplateWithCustomTags2(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateWithCustomTags2Request, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    /**
     * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param contactId - Identifier for a contact. Defaults to document's contact if 0
     * @param personId - Identifier for a person. Defaults to document's person if 0
     * @param appointmentId - identifier for an appointment. Defaults to document if 0
     * @param documentId - Identifier for the document
     * @param saleId - Identifier for sale. Defaults to document's sale if 0.
     * @param selectionId - identifier for selection.
     * @param projectId - identifier for project. Defaults to document's project if 0
     * @param customTags - Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag.
     * @param uiCulture - Language variation of template to use when creating document. (ISO code - "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns The document object with updated info after creating the document
     */
    CreateNewPhysicalDocumentFromTemplateWithCustomTags2(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, customTags: carriers.StringDictionary, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    private _SubstituteTemplateVariables;
    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.
     * @param request - Source, GeneratorEncoding, ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CultureName
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    SubstituteTemplateVariables(request: carriers.Document_SubstituteTemplateVariablesRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.
     * @param source - Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.<p/>Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     * @param generatorEncoding - Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     * @param contactId - Identifier for a contact
     * @param personId - Identifier for a person
     * @param appointmentId - Identifier for an appointment
     * @param documentId - Identifier for a document
     * @param saleId - Identifier for a sale
     * @param selectionId - Identifier for a selection
     * @param projectId - Identifier for a project
     * @param cultureName - Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    SubstituteTemplateVariables(source: string, generatorEncoding: enums.GeneratorEncoding, contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _SubstituteTemplateVariablesWithCustomTags;
    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.&lt;p/&gt;This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - Source, GeneratorEncoding, CustomTags, CustomValues, ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CultureName
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    SubstituteTemplateVariablesWithCustomTags(request: carriers.Document_SubstituteTemplateVariablesWithCustomTagsRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.&lt;p/&gt;This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param source - Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.<p/>Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     * @param generatorEncoding - Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     * @param customTags - Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param customValues - Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param contactId - Identifier for a contact
     * @param personId - Identifier for a person
     * @param appointmentId - Identifier for an appointment
     * @param documentId - Identifier for a document
     * @param saleId - Identifier for a sale
     * @param selectionId - Identifier for a selection
     * @param projectId - Identifier for a project
     * @param cultureName - Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    SubstituteTemplateVariablesWithCustomTags(source: string, generatorEncoding: enums.GeneratorEncoding, customTags: string[], customValues: string[], contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _SubstituteTemplateVariablesWithCustomTags2;
    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.&lt;p/&gt;This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - Source, GeneratorEncoding, CustomTags, ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, CultureName
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    SubstituteTemplateVariablesWithCustomTags2(request: carriers.Document_SubstituteTemplateVariablesWithCustomTags2Request, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Parse the source string, and replace any template variable tags with their values, based on the ID&apos;s given in the other parameters.&lt;p/&gt;This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param source - Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.<p/>Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     * @param generatorEncoding - Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     * @param customTags - Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag.
     * @param contactId - Identifier for a contact
     * @param personId - Identifier for a person
     * @param appointmentId - Identifier for an appointment
     * @param documentId - Identifier for a document
     * @param saleId - Identifier for a sale
     * @param selectionId - Identifier for a selection
     * @param projectId - Identifier for a project
     * @param cultureName - Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    SubstituteTemplateVariablesWithCustomTags2(source: string, generatorEncoding: enums.GeneratorEncoding, customTags: carriers.StringDictionary, contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, cultureName: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _CreateTempFile;
    /**
     * Create a new temporary file based on the provided stream.  Specified filename may be overridden, and actual name is returned.
     * @param request - Filename, DataStream
     * @returns Actual used filename.
     */
    CreateTempFile(request: carriers.Document_CreateTempFileRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Create a new temporary file based on the provided stream.  Specified filename may be overridden, and actual name is returned.
     * @param filename - Wanted name of file.
     * @param dataStream - Data to be added to the file.
     * @returns Actual used filename.
     */
    CreateTempFile(filename: string, dataStream: ArrayBuffer | string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _GetTempFile;
    /**
     * Get data stream for temporary file created with CreateTempFile.
     * @param request - Filename
     * @returns The document as a Stream
     */
    GetTempFile(request: carriers.Document_GetTempFileRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Get data stream for temporary file created with CreateTempFile.
     * @param filename - Name of temporary file to retrieve.
     * @returns The document as a Stream
     */
    GetTempFile(filename: string, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _DeleteTempFile;
    /**
     * Delete a temporary file created with CreateTempFile.
     * @param request - Filename
     * @returns
     */
    DeleteTempFile(request: carriers.Document_DeleteTempFileRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Delete a temporary file created with CreateTempFile.
     * @param filename - Name of temporary file to delete.
     * @returns
     */
    DeleteTempFile(filename: string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _SetTemplateStream;
    /**
     * Save a mail signature template to the document archive
     * @param request - Filename, Personal, Stream
     * @returns This method has no return value
     */
    SetTemplateStream(request: carriers.Document_SetTemplateStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Save a mail signature template to the document archive
     * @param filename - Filename of template.
     * @param personal - If true, save the template in the user area, instead of in shared template area.
     * @param stream - The signature template content as a stream.
     * @returns This method has no return value
     */
    SetTemplateStream(filename: string, personal: boolean, stream: ArrayBuffer | string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _CreateNewPhysicalDocumentFromTemplate;
    /**
     * Create a new document content based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - ContactId, PersonId, AppointmentId, DocumentId, SaleId, SelectionId, ProjectId, UiCulture
     * @returns The updated document entity, after creating the document content from the template.
     */
    CreateNewPhysicalDocumentFromTemplate(request: carriers.Document_CreateNewPhysicalDocumentFromTemplateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    /**
     * Create a new document content based on a document template and store it in the document archive.  Tags are substituted according to the provided id&apos;s.  Use GetDocumentStream to obtain the created document. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param contactId - Identifier for a contact. Defaults to document's contact if 0
     * @param personId - Identifier for a person. Defaults to document's person if 0
     * @param appointmentId - identifier for an appointment. Defaults to document if 0
     * @param documentId - Identifier for a document. The document defines the template to use.
     * @param saleId - Identifier for sale. Defaults to document's sale if 0.
     * @param selectionId - identifier for selection.
     * @param projectId - identifier for project. Defaults to document's project if 0
     * @param uiCulture - Language variation of template to use when creating document content. (ISO code "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @returns The updated document entity, after creating the document content from the template.
     */
    CreateNewPhysicalDocumentFromTemplate(contactId: number, personId: number, appointmentId: number, documentId: number, saleId: number, selectionId: number, projectId: number, uiCulture: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    private _SubstituteMergeDocumentTemplateVariables;
    /**
     * Parse the source document, and replace any template variable tags with their values, based on the associate Id.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - DocumentId, AssociateId, CustomTags, CustomValues
     * @returns The document as a Stream
     */
    SubstituteMergeDocumentTemplateVariables(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Parse the source document, and replace any template variable tags with their values, based on the associate Id.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param documentId - The document id that refers to the binary data (document)
     * @param associateId - The associateId used to subsitute tags in the document.
     * @param customTags - Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param customValues - Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @returns The document as a Stream
     */
    SubstituteMergeDocumentTemplateVariables(documentId: number, associateId: number, customTags: string[], customValues: string[], webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _SubstituteMergeDocumentTemplateVariables2;
    /**
     * Parse the source document, and replace any template variable tags with their values, based on the associate Id.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - DocumentId, AssociateId, CustomTags
     * @returns The document as a Stream
     */
    SubstituteMergeDocumentTemplateVariables2(request: carriers.Document_SubstituteMergeDocumentTemplateVariables2Request, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Parse the source document, and replace any template variable tags with their values, based on the associate Id.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param documentId - The document id that refers to the binary data (document)
     * @param associateId - The associateId used to subsitute tags in the document.
     * @param customTags - Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag.
     * @returns The document as a Stream
     */
    SubstituteMergeDocumentTemplateVariables2(documentId: number, associateId: number, customTags: carriers.StringDictionary, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _SubstituteTemplateVariablesEx;
    /**
     * Parse the source string, and replace any template variable tags with their values, based on the identities, custom values and entities specified in the other parameters.
     * @param request - Parameters
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    SubstituteTemplateVariablesEx(request: carriers.Document_SubstituteTemplateVariablesExRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Parse the source string, and replace any template variable tags with their values, based on the identities, custom values and entities specified in the other parameters.
     * @param parameters - Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     * @returns Source string with templates substituted, using the same encoding as for the source (binary data will be returned in Base64).
     */
    SubstituteTemplateVariablesEx(parameters: carriers.TemplateVariablesParameters, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _VerifyGetDocumentStream;
    /**
     * Verify that the requested document stream exists, and that we can access it, without actually getting the stream.
     * @param request - DocumentId
     * @returns
     */
    VerifyGetDocumentStream(request: carriers.Document_VerifyGetDocumentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Verify that the requested document stream exists, and that we can access it, without actually getting the stream.
     * @param documentId - The document id that refers to the binary data (document)
     * @returns
     */
    VerifyGetDocumentStream(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _SubstituteMergeDocumentTemplateVariablesEx;
    /**
     * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - MergeDocumentId, ContactId, PersonId, ProjectId, SelectionId, AppointmentId, DocumentId, SaleId, CustomTags, CustomValues
     * @returns The document as a Stream
     */
    SubstituteMergeDocumentTemplateVariablesEx(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesExRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param mergeDocumentId - The document id that refers to the binary data (document)
     * @param contactId - The contact identifier to use for template substitution
     * @param personId - The person identifier to use for template substitution
     * @param projectId - The project identifier to use for template substitution
     * @param selectionId - The selection identifier to use for template substitution
     * @param appointmentId - The appointment identifier to use for template substitution
     * @param documentId - The document identifier to use for template substitution
     * @param saleId - The sale identifier to use for template substitution
     * @param customTags - Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @param customValues - Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     * @returns The document as a Stream
     */
    SubstituteMergeDocumentTemplateVariablesEx(mergeDocumentId: number, contactId: number, personId: number, projectId: number, selectionId: number, appointmentId: number, documentId: number, saleId: number, customTags: string[], customValues: string[], webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _SubstituteMergeDocumentTemplateVariablesEx2;
    /**
     * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param request - MergeDocumentId, ContactId, PersonId, ProjectId, SelectionId, AppointmentId, DocumentId, SaleId, CustomTags
     * @returns The document as a Stream
     */
    SubstituteMergeDocumentTemplateVariablesEx2(request: carriers.Document_SubstituteMergeDocumentTemplateVariablesEx2Request, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.&lt;p/&gt; The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
     * @param mergeDocumentId - The document id that refers to the binary data (document)
     * @param contactId - The contact identifier to use for template substitution
     * @param personId - The person identifier to use for template substitution
     * @param projectId - The project identifier to use for template substitution
     * @param selectionId - The selection identifier to use for template substitution
     * @param appointmentId - The appointment identifier to use for template substitution
     * @param documentId - The document identifier to use for template substitution
     * @param saleId - The sale identifier to use for template substitution
     * @param customTags - Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag
     * @returns The document as a Stream
     */
    SubstituteMergeDocumentTemplateVariablesEx2(mergeDocumentId: number, contactId: number, personId: number, projectId: number, selectionId: number, appointmentId: number, documentId: number, saleId: number, customTags: carriers.StringDictionary, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    private _GetDocumentUrl;
    /**
     * Get a URL referring to the given document content.&lt;para/&gt;This URL may be passed to the ultimate client (text editor of some kind?), which is then responsible for all further operations.&lt;para/&gt;The returned string is a fully qualified URL.&lt;para/&gt;Not all documents and document plugins support this feature.
     * @param request - DocumentId, VersionId, WriteableUrl
     * @returns Fully resolved URL referring to the document. May be NULL or blank if plugin does not support URLs.
     */
    GetDocumentUrl(request: carriers.Document_GetDocumentUrlRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Get a URL referring to the given document content.&lt;para/&gt;This URL may be passed to the ultimate client (text editor of some kind?), which is then responsible for all further operations.&lt;para/&gt;The returned string is a fully qualified URL.&lt;para/&gt;Not all documents and document plugins support this feature.
     * @param documentId - SuperOffice document primary key
     * @param versionId - Version ID if applicable/desired; a blank value implies "latest" version and is always acceptable.
     * @param writeableUrl - If true, then a URL that supports saving is requested. Som edocument plugins may not support read-only URLs, so there is no guarantee that a False value will actually yield a read-only URL, and vice versa.
     * @returns Fully resolved URL referring to the document. May be NULL or blank if plugin does not support URLs.
     */
    GetDocumentUrl(documentId: number, versionId: string, writeableUrl: boolean, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _DeletePhysicalDocument;
    /**
     * Delete the document contents
     * @param request - DocumentId, AllowedReturnType
     * @returns Delete status - did removal succeed or not
     */
    DeletePhysicalDocument(request: carriers.Document_DeletePhysicalDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    /**
     * Delete the document contents
     * @param documentId - document primary key
     * @param allowedReturnType - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing. Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests
     * @returns Delete status - did removal succeed or not
     */
    DeletePhysicalDocument(documentId: number, allowedReturnType: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    private _RenameDocument;
    /**
     * Rename the physical document, i.e., change the file name or equivalent concept in the document archive.
     * @param request - DocumentId, NewFilename
     * @returns The actual, new "file" name. This will generally be derived from the suggested name, but may be amended.
     */
    RenameDocument(request: carriers.Document_RenameDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Rename the physical document, i.e., change the file name or equivalent concept in the document archive.
     * @param documentId - SuperOffice document ID
     * @param newFilename - Suggested new file name. The document archive may amend this to conform to uniqueness constraints, character range limitations etc.
     * @returns The actual, new "file" name. This will generally be derived from the suggested name, but may be amended.
     */
    RenameDocument(documentId: number, newFilename: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _GetCheckoutState;
    /**
     * Get the current checkout state for a document, relative to the user perforing the call.
     * @param request - DocumentId
     * @returns Current checkout state of the document
     */
    GetCheckoutState(request: carriers.Document_GetCheckoutStateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CheckoutInfo>;
    /**
     * Get the current checkout state for a document, relative to the user perforing the call.
     * @param documentId - SuperOffice document ID
     * @returns Current checkout state of the document
     */
    GetCheckoutState(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CheckoutInfo>;
    private _CheckoutDocument;
    /**
     * Check out a document for editing by the current user.
     * @param request - DocumentId, AllowedReturnTypes
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    CheckoutDocument(request: carriers.Document_CheckoutDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    /**
     * Check out a document for editing by the current user.
     * @param documentId - SuperOffice document ID
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    CheckoutDocument(documentId: number, allowedReturnTypes: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    private _CheckinDocument;
    /**
     * Check in a currently checked-out document
     * @param request - DocumentId, AllowedReturnTypes, VersionDescription, VersionExtraFields
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    CheckinDocument(request: carriers.Document_CheckinDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    /**
     * Check in a currently checked-out document
     * @param documentId - SuperOffice document Id
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     * @param versionDescription - Optional textual description related to this version of the document; may be blank, and is discarded if the document/plugin do not support versioning.
     * @param versionExtraFields - Optional extra metadata related to the new version (as opposed to metadata related to the document as a whole). Discarded if the document/plugin do not support versioning.
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    CheckinDocument(documentId: number, allowedReturnTypes: string[], versionDescription: string, versionExtraFields: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    private _UndoCheckoutDocument;
    /**
     * Undo (abandon) a checkout
     * @param request - DocumentId, AllowedReturnTypes
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    UndoCheckoutDocument(request: carriers.Document_UndoCheckoutDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    /**
     * Undo (abandon) a checkout
     * @param documentId - SuperOffice document ID
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    UndoCheckoutDocument(documentId: number, allowedReturnTypes: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    private _GetVersionList;
    /**
     * Get a list of existing, committed  versions for a given document
     * @param request - DocumentId
     * @returns Array of objects describing the existing, committed versions for this document
     */
    GetVersionList(request: carriers.Document_GetVersionListRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.VersionInfo[]>;
    /**
     * Get a list of existing, committed  versions for a given document
     * @param documentId - SuperOffice document Id
     * @returns Array of objects describing the existing, committed versions for this document
     */
    GetVersionList(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.VersionInfo[]>;
    private _GetPluginList;
    /**
     * Get a list of installed document plugins
     * @returns Dictionary mapping plugin id=plugin name
     */
    GetPluginList(webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    private _GetPluginCapabilities;
    /**
     * Get a list of plugin-dependent capabilities for a given document archive plugin.&lt;br/&gt;A standard set of properties is defined in SuperOffice.CRM.Documents.Constants.Capabilities.
     * @param request - PluginId
     * @returns Dictionary mapping capability names=values
     */
    GetPluginCapabilities(request: carriers.Document_GetPluginCapabilitiesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    /**
     * Get a list of plugin-dependent capabilities for a given document archive plugin.&lt;br/&gt;A standard set of properties is defined in SuperOffice.CRM.Documents.Constants.Capabilities.
     * @param pluginId - Numeric document plugin id, corresponding to the document.archiveProvider id or doctmpl.autoeventid.
     * @returns Dictionary mapping capability names=values
     */
    GetPluginCapabilities(pluginId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    private _GetDocumentProperties;
    /**
     * Get plugin-dependent properties for the document. A number of standard properties that should be supported by all plugins are defined in SuperOffice.CRM.Documents.Constants.Properties.
     * @param request - DocumentId, RequestedProperties
     * @returns Dictionary of name=value pairs, corresponding to the requested properties.
     */
    GetDocumentProperties(request: carriers.Document_GetDocumentPropertiesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    /**
     * Get plugin-dependent properties for the document. A number of standard properties that should be supported by all plugins are defined in SuperOffice.CRM.Documents.Constants.Properties.
     * @param documentId - SuperOffice document ID
     * @param requestedProperties - Array of property names whose values are being requested.
     * @returns Dictionary of name=value pairs, corresponding to the requested properties.
     */
    GetDocumentProperties(documentId: number, requestedProperties: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    private _GetDocumentCommands;
    /**
     * Get a list of custom commands valid for the specific document at this time. This information should not be cached by clients, as it may change between documents and over time.
     * @param request - DocumentId, AllowedReturnTypes
     * @returns Array of command information items. The command list is constrained by the allowedReturnTypes parameter.
     */
    GetDocumentCommands(request: carriers.Document_GetDocumentCommandsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.CommandInfo[]>;
    /**
     * Get a list of custom commands valid for the specific document at this time. This information should not be cached by clients, as it may change between documents and over time.
     * @param documentId - SuperOffice document ID
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.<br/>In this context the parameter is used to filter the returned command list, so that commands that require return actions not supported, will not be included by the document plugin.
     * @returns Array of command information items. The command list is constrained by the allowedReturnTypes parameter.
     */
    GetDocumentCommands(documentId: number, allowedReturnTypes: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.CommandInfo[]>;
    private _ExecuteDocumentCommand;
    /**
     * Execute a custom command on a particular document, optionally a particular version
     * @param request - DocumentId, VersionId, AllowedReturnTypes, Command, AdditionalData
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    ExecuteDocumentCommand(request: carriers.Document_ExecuteDocumentCommandRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    /**
     * Execute a custom command on a particular document, optionally a particular version
     * @param documentId - SuperOffice document ID
     * @param versionId - Version ID if applicable/desired; a blank value implies "latest" version and is always acceptable.
     * @param allowedReturnTypes - List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     * @param command - Command name, generally matching one of those returned from the GetDocumentCommands service. However, it is legal for document plugins to support commands that are not declared through GetDocumentCommands, for instance if a custom GUI needs to access plugin functionality.
     * @param additionalData - Any additional data that the document command needs. This parameter can be used as a tunnel between a custom-programmed GUI and its plugin.<br/>It is suggested that the format is name=value, with one such pair per array item.
     * @returns Return information, including possible requests for further processing ("Return Action"). Return actions are constrained by the allowedReturnTypes parameter.
     */
    ExecuteDocumentCommand(documentId: number, versionId: string, allowedReturnTypes: string[], command: string, additionalData: string[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.ReturnInfo>;
    private _CreateDefaultDocumentEntityFromSuggestion;
    /**
     *
     * @param request - SuggestedDocumentId
     * @returns
     */
    CreateDefaultDocumentEntityFromSuggestion(request: carriers.Document_CreateDefaultDocumentEntityFromSuggestionRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    /**
     *
     * @param suggestedDocumentId -
     * @returns
     */
    CreateDefaultDocumentEntityFromSuggestion(suggestedDocumentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    private _SaveDocumentTemplateStream;
    /**
     * Saves content in stream to document template file
     * @param request - DocumentTemplateId, Content, LanguageCode, PluginId
     * @returns Template info
     */
    SaveDocumentTemplateStream(request: carriers.Document_SaveDocumentTemplateStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TemplateInfo>;
    /**
     * Saves content in stream to document template file
     * @param documentTemplateId - Identifier for document template
     * @param content - Stream containing content to be saved to document template file
     * @param languageCode - Language variation of template to update. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     * @param pluginId - Plugin id. Use -1 to use the plugin specified in the template.
     * @returns Template info
     */
    SaveDocumentTemplateStream(documentTemplateId: number, content: ArrayBuffer | string, languageCode: string, pluginId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TemplateInfo>;
    private _SetDocumentStreamFromId;
    /**
     * Store document content from stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param request - DocumentId, Stream
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    SetDocumentStreamFromId(request: carriers.Document_SetDocumentStreamFromIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    /**
     * Store document content from stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     * @param documentId - The document entity object that the binary data (document) should be stored to. Its file name may be amended by this call, see the return value.
     * @param stream - The document content as a stream.
     * @returns Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
     */
    SetDocumentStreamFromId(documentId: number, stream: ArrayBuffer | string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentEntity>;
    private _SavePrivacyReport;
    /**
     * Generates a Pdf from HTML and makes a document
     * @param request - HtmlReport, Title, PersonId
     * @returns Document id of saved report
     */
    SavePrivacyReport(request: carriers.Document_SavePrivacyReportRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    /**
     * Generates a Pdf from HTML and makes a document
     * @param htmlReport - Html to convert
     * @param title - Title of report
     * @param personId - Person id associated with the report
     * @returns Document id of saved report
     */
    SavePrivacyReport(htmlReport: string, title: string, personId: number, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    private _ValidateDocumentEntity;
    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param request - DocumentEntity
     * @returns Error messages tagged by field.
     */
    ValidateDocumentEntity(request: carriers.Document_ValidateDocumentEntityRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    /**
     * Check that entity is ready for saving, return error messages by field.
     * @param documentEntity - Entity to be checked for errors.
     * @returns Error messages tagged by field.
     */
    ValidateDocumentEntity(documentEntity: carriers.DocumentEntity, webapi_options?: base.WebApiRequestOptions): Promise<carriers.StringDictionary>;
    private _GetDocumentLength;
    /**
     * Get length of the document content in bytes.
     * @param request - DocumentId, VersionId
     * @returns The length of the document content in bytes.
     */
    GetDocumentLength(request: carriers.Document_GetDocumentLengthRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    /**
     * Get length of the document content in bytes.
     * @param documentId - SuperOffice document id
     * @param versionId - Version ID if applicable; a blank value implies "latest" version and is always acceptable.
     * @returns The length of the document content in bytes.
     */
    GetDocumentLength(documentId: number, versionId: string, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    GetDocumentList(documentIds: number[], options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetAppointmentDocuments;
    /**
     * Get all documents that are linked to the appointment. I.e. the documents that are listed in the appointment dialog.
     * @param request - AppointmentId
     * @returns Array of documents
     */
    GetAppointmentDocuments(request: carriers.Document_GetAppointmentDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Get all documents that are linked to the appointment. I.e. the documents that are listed in the appointment dialog.
     * @param appointmentId - The appointment id.
     * @returns Array of documents
     */
    GetAppointmentDocuments(appointmentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetSaleDocuments;
    /**
     * Get all documents that are linked to the sale. I.e. the documents that are listed in the sale dialog.
     * @param request - SaleId
     * @returns Array of documents
     */
    GetSaleDocuments(request: carriers.Document_GetSaleDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Get all documents that are linked to the sale. I.e. the documents that are listed in the sale dialog.
     * @param saleId - The sale id.
     * @returns Array of documents
     */
    GetSaleDocuments(saleId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetPersonDocuments;
    /**
     * Get all documents that are linked to the person. I.e. the documents that are listed in the person dialog.
     * @param request - PersonId
     * @returns Array of documents
     */
    GetPersonDocuments(request: carriers.Document_GetPersonDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Get all documents that are linked to the person. I.e. the documents that are listed in the person dialog.
     * @param personId - The person id.
     * @returns Array of documents
     */
    GetPersonDocuments(personId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetPublishedDocument;
    /**
     * Get the document if it&apos;s published
     * @param request - DocumentId
     * @returns Document
     */
    GetPublishedDocument(request: carriers.Document_GetPublishedDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document>;
    /**
     * Get the document if it&apos;s published
     * @param documentId - The document id
     * @returns Document
     */
    GetPublishedDocument(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document>;
    private _GetPublishedDocuments;
    /**
     * Get the published documents from an array of doucment ids.
     * @param request - DocumentIds
     * @returns Array of Document
     */
    GetPublishedDocuments(request: carriers.Document_GetPublishedDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Get the published documents from an array of doucment ids.
     * @param documentIds - Array of document ids.
     * @returns Array of Document
     */
    GetPublishedDocuments(documentIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetMyPublishedDocuments;
    /**
     *
     * @returns Array of documents
     */
    GetMyPublishedDocuments(webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetPublishedDocumentsByDate;
    /**
     * Method that returns a specified number of published document appointments within a time range. The document appointments is visible to the person specified or the document is in a project the person belongs to.
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    GetPublishedDocumentsByDate(request: carriers.Document_GetPublishedDocumentsByDateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of published document appointments within a time range. The document appointments is visible to the person specified or the document is in a project the person belongs to.
     * @param personId - The personId
     * @param includeProjectDocuments - Include projectDocuments to select documents in projects person is a member of.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    GetPublishedDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetContactDocumentsByTemplateTypes;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the contact specified.
     * @param request - ContactId, StartTime, EndTime, Count, DocumentTemplateIds
     * @returns Array of Appointments.
     */
    GetContactDocumentsByTemplateTypes(request: carriers.Document_GetContactDocumentsByTemplateTypesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the contact specified.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateIds - Ids of the document template types to filter on.
     * @returns Array of Appointments.
     */
    GetContactDocumentsByTemplateTypes(contactId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetContactDocumentsByTemplateType;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the contact specified.
     * @param request - ContactId, StartTime, EndTime, Count, DocumentTemplateId
     * @returns Array of Appointments.
     */
    GetContactDocumentsByTemplateType(request: carriers.Document_GetContactDocumentsByTemplateTypeRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the contact specified.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateId - Id of the document template type to filter on.
     * @returns Array of Appointments.
     */
    GetContactDocumentsByTemplateType(contactId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetContactDocumentsByTemplateHeading;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by the document template heading. The document appointments belong to the contact specified. The heading represents a grouping or filtering of document templates.
     * @param request - ContactId, StartTime, EndTime, Count, TemplateHeadingId
     * @returns Array of Appointments.
     */
    GetContactDocumentsByTemplateHeading(request: carriers.Document_GetContactDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by the document template heading. The document appointments belong to the contact specified. The heading represents a grouping or filtering of document templates.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    GetContactDocumentsByTemplateHeading(contactId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetContactDocuments;
    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the contact specified.
     * @param request - ContactId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    GetContactDocuments(request: carriers.Document_GetContactDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the contact specified.
     * @param contactId - The contact id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    GetContactDocuments(contactId: number, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetPublishedPersonDocumentsByDate;
    /**
     * Method that returns a specified number of published document appointments within a time range. The document appointments belong to the person specified or the document is in a project the person belongs to.
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    GetPublishedPersonDocumentsByDate(request: carriers.Document_GetPublishedPersonDocumentsByDateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of published document appointments within a time range. The document appointments belong to the person specified or the document is in a project the person belongs to.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    GetPublishedPersonDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetPublishedProjectDocuments;
    /**
     * Get published appointment documents by project id.
     * @param request - ProjectId
     * @returns Array of Appointment
     */
    GetPublishedProjectDocuments(request: carriers.Document_GetPublishedProjectDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Get published appointment documents by project id.
     * @param projectId - The project id
     * @returns Array of Appointment
     */
    GetPublishedProjectDocuments(projectId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetProjectMemberDocumentsByTemplateTypes;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project member specified.
     * @param request - PersonId, StartTime, EndTime, Count, DocumentTemplateIds
     * @returns Array of Appointments.
     */
    GetProjectMemberDocumentsByTemplateTypes(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project member specified.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateIds - Ids of the document template types to filter on.
     * @returns Array of Appointments.
     */
    GetProjectMemberDocumentsByTemplateTypes(personId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetProjectMemberDocumentsByTemplateType;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project member specified.
     * @param request - PersonId, StartTime, EndTime, Count, DocumentTemplateId
     * @returns Array of Appointments.
     */
    GetProjectMemberDocumentsByTemplateType(request: carriers.Document_GetProjectMemberDocumentsByTemplateTypeRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project member specified.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateId - Id of the document template type to filter on.
     * @returns Array of Appointments.
     */
    GetProjectMemberDocumentsByTemplateType(personId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetProjectMemberDocumentsByTemplateHeading;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project member specified. The heading represents a grouping or filtering of document templates.
     * @param request - PersonId, StartTime, EndTime, Count, TemplateHeadingId
     * @returns Array of Appointments.
     */
    GetProjectMemberDocumentsByTemplateHeading(request: carriers.Document_GetProjectMemberDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project member specified. The heading represents a grouping or filtering of document templates.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    GetProjectMemberDocumentsByTemplateHeading(personId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetProjectMemberDocuments;
    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project member specified.
     * @param request - PersonId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    GetProjectMemberDocuments(request: carriers.Document_GetProjectMemberDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project member specified.
     * @param personId - The project member's person id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    GetProjectMemberDocuments(personId: number, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetProjectDocumentsByTemplateTypes;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project specified.
     * @param request - ProjectId, StartTime, EndTime, Count, DocumentTemplateIds
     * @returns Array of Appointments.
     */
    GetProjectDocumentsByTemplateTypes(request: carriers.Document_GetProjectDocumentsByTemplateTypesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project specified.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateIds - Ids of the document template types to filter on.
     * @returns Array of Appointments.
     */
    GetProjectDocumentsByTemplateTypes(projectId: number, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetProjectDocumentsByTemplateType;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project specified.
     * @param request - ProjectId, StartTime, EndTime, Count, DocumentTemplateId
     * @returns Array of Appointments.
     */
    GetProjectDocumentsByTemplateType(request: carriers.Document_GetProjectDocumentsByTemplateTypeRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project specified.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateId - Id of the document template type to filter on.
     * @returns Array of Appointments.
     */
    GetProjectDocumentsByTemplateType(projectId: number, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetProjectDocumentsByTemplateHeading;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project specified. The heading represents a grouping or filtering of document templates.
     * @param request - ProjectId, StartTime, EndTime, Count, TemplateHeadingId
     * @returns Array of Appointments.
     */
    GetProjectDocumentsByTemplateHeading(request: carriers.Document_GetProjectDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project specified. The heading represents a grouping or filtering of document templates.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    GetProjectDocumentsByTemplateHeading(projectId: number, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetProjectDocuments;
    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project specified.
     * @param request - ProjectId, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    GetProjectDocuments(request: carriers.Document_GetProjectDocumentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project specified.
     * @param projectId - The project id
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    GetProjectDocuments(projectId: number, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetPersonDocumentsByTemplateTypes;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the person specified.
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count, DocumentTemplateIds
     * @returns Array of Appointments.
     */
    GetPersonDocumentsByTemplateTypes(request: carriers.Document_GetPersonDocumentsByTemplateTypesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the person specified.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateIds - Ids of the document template types to filter on.
     * @returns Array of Appointments.
     */
    GetPersonDocumentsByTemplateTypes(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, documentTemplateIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetPersonDocumentsByTemplateType;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the person specified.
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count, DocumentTemplateId
     * @returns Array of Appointments.
     */
    GetPersonDocumentsByTemplateType(request: carriers.Document_GetPersonDocumentsByTemplateTypeRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the person specified.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param documentTemplateId - Id of the document template type to filter on.
     * @returns Array of Appointments.
     */
    GetPersonDocumentsByTemplateType(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, documentTemplateId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetPersonDocumentsByTemplateHeading;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the person specified. The heading represents a grouping or filtering of document templates.
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count, TemplateHeadingId
     * @returns Array of Appointments.
     */
    GetPersonDocumentsByTemplateHeading(request: carriers.Document_GetPersonDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the person specified. The heading represents a grouping or filtering of document templates.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    GetPersonDocumentsByTemplateHeading(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetPersonDocumentsByDate;
    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the person specified.
     * @param request - PersonId, IncludeProjectDocuments, StartTime, EndTime, Count
     * @returns Array of Appointments.
     */
    GetPersonDocumentsByDate(request: carriers.Document_GetPersonDocumentsByDateRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns a specified number of document appointments within a time range. The document appointments belong to the person specified.
     * @param personId - The person id of the SuperOffice user (associate).
     * @param includeProjectDocuments - If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     * @param startTime - The start of the time interval we want appointments from. This will usually be the current time.
     * @param endTime - The end of the time interval.
     * @param count - The maximum number of appointments that should be returned. -1 means no count restrictions.
     * @returns Array of Appointments.
     */
    GetPersonDocumentsByDate(personId: number, includeProjectDocuments: boolean, startTime: Date, endTime: Date, count: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    private _GetDocumentsByTemplateHeading;
    /**
     * Method that returns document appointments, filtered by the document template heading. The heading represents a grouping or filtering of document templates.
     * @param request - TemplateHeadingId
     * @returns Array of Appointments.
     */
    GetDocumentsByTemplateHeading(request: carriers.Document_GetDocumentsByTemplateHeadingRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    /**
     * Method that returns document appointments, filtered by the document template heading. The heading represents a grouping or filtering of document templates.
     * @param templateHeadingId - The document template heading id. The heading represents a grouping or filtering of document templates.
     * @returns Array of Appointments.
     */
    GetDocumentsByTemplateHeading(templateHeadingId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Document[]>;
    GetSuggestedDocumentEntity(suggestedDocumentEntityId: number, options?: base.WebApiRequestOptions): Promise<carriers.SuggestedDocumentEntity>;
}
//# sourceMappingURL=DocumentAgent.d.ts.map
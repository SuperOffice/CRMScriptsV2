"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticsAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Diagnostics, usage data collection, caches and flushing
 */
class DiagnosticsAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Diagnostics/";
        super(options);
    }
    async _FlushCaches(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FlushCaches", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Flushes all NetServer caches
     * @returns
     */
    async FlushCaches(webapi_options) {
        return this._FlushCaches(webapi_options);
    }
    async _GetCacheNames(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCacheNames", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the name of the caches that can be flushed
     * @returns Name of the caches that can be flusehd
     */
    async GetCacheNames(webapi_options) {
        return this._GetCacheNames(webapi_options);
    }
    async _FlushCachesByName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FlushCachesByName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FlushCachesByName(cacheNames, webapi_options) {
        let _request = null;
        let _options = null;
        const first = cacheNames;
        if (typeof (first) === "object" && first && (typeof (first.CacheNames) != 'undefined')) {
            _request = cacheNames;
            _options = webapi_options;
        }
        else {
            _request = {
                CacheNames: cacheNames,
            };
            _options = webapi_options;
        }
        return this._FlushCachesByName(_request, _options);
    }
    async _GetCacheState(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCacheState", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCacheState(cacheNames, webapi_options) {
        let _request = null;
        let _options = null;
        const first = cacheNames;
        if (typeof (first) === "object" && first && (typeof (first.CacheNames) != 'undefined')) {
            _request = cacheNames;
            _options = webapi_options;
        }
        else {
            _request = {
                CacheNames: cacheNames,
            };
            _options = webapi_options;
        }
        return this._GetCacheState(_request, _options);
    }
    async _GetEntityCountsForCurrentUser(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEntityCountsForCurrentUser", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EntityCountsArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get an array of entities and number of entities created for the current associate
     * @returns Array of EntityCounts[] for the current associate
     */
    async GetEntityCountsForCurrentUser(webapi_options) {
        return this._GetEntityCountsForCurrentUser(webapi_options);
    }
    async _LogViewState(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("LogViewState", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async LogViewState(viewState, webapi_options) {
        let _request = null;
        let _options = null;
        const first = viewState;
        if (typeof (first) === "object" && first && (typeof (first.ViewState) != 'undefined')) {
            _request = viewState;
            _options = webapi_options;
        }
        else {
            _request = {
                ViewState: viewState,
            };
            _options = webapi_options;
        }
        return this._LogViewState(_request, _options);
    }
    async _ChangeLogSettings(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeLogSettings", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeLogSettings(logWarning, logInformation, logSuccessAudit, logFailureAudit, logToEventLog, logToSuperOffice, logToFile, logToTrace, webapi_options) {
        let _request = null;
        let _options = null;
        const first = logWarning;
        if (typeof (first) === "object" && first && (typeof (first.LogWarning) != 'undefined' || typeof (first.LogInformation) != 'undefined' || typeof (first.LogSuccessAudit) != 'undefined' || typeof (first.LogFailureAudit) != 'undefined' || typeof (first.LogToEventLog) != 'undefined' || typeof (first.LogToSuperOffice) != 'undefined' || typeof (first.LogToFile) != 'undefined' || typeof (first.LogToTrace) != 'undefined')) {
            _request = logWarning;
            _options = logInformation;
        }
        else {
            _request = {
                LogWarning: logWarning,
                LogInformation: logInformation,
                LogSuccessAudit: logSuccessAudit,
                LogFailureAudit: logFailureAudit,
                LogToEventLog: logToEventLog,
                LogToSuperOffice: logToSuperOffice,
                LogToFile: logToFile,
                LogToTrace: logToTrace,
            };
            _options = webapi_options;
        }
        return this._ChangeLogSettings(_request, _options);
    }
    async _CollectDataAdditions(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CollectDataAdditions", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Collect and transmit usage statistics: Database Additions. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    async CollectDataAdditions(webapi_options) {
        return this._CollectDataAdditions(webapi_options);
    }
    async _CollectWinUsage(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CollectWinUsage", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Collect and transmit usage statistics: Windows CRM Client Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    async CollectWinUsage(webapi_options) {
        return this._CollectWinUsage(webapi_options);
    }
    async _CollectWebUsage(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CollectWebUsage", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Collect and transmit usage statistics: Web-based clients Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    async CollectWebUsage(webapi_options) {
        return this._CollectWebUsage(webapi_options);
    }
    async _CollectTableSizes(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CollectTableSizes", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Collect and transmit usage statistics: Table Sizes. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    async CollectTableSizes(webapi_options) {
        return this._CollectTableSizes(webapi_options);
    }
    async _ResyncUsers(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResyncUsers", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Resynchronize user information with SuperOffice Community, if opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    async ResyncUsers(webapi_options) {
        return this._ResyncUsers(webapi_options);
    }
    async _PerformTasksAfterUpgrade(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("PerformTasksAfterUpgrade", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * After upgrading to a new fileset, there may be tasks that need to be done. Examples - import new TypicalSearches, if present. Tasks performed here need to be idempotent and independent of the actual upgrade jump (what was the previous version). They should complete in a reasonable time, not more than a few minutes maximum.
     * @returns Message that can be shown to the user, summarizing what has been done, if anything.
     */
    async PerformTasksAfterUpgrade(webapi_options) {
        return this._PerformTasksAfterUpgrade(webapi_options);
    }
    async _AddWebAppUsage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddWebAppUsage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddWebAppUsage(webAppUsages, webapi_options) {
        let _request = null;
        let _options = null;
        const first = webAppUsages;
        if (typeof (first) === "object" && first && (typeof (first.WebAppUsages) != 'undefined')) {
            _request = webAppUsages;
            _options = webapi_options;
        }
        else {
            _request = {
                WebAppUsages: webAppUsages,
            };
            _options = webapi_options;
        }
        return this._AddWebAppUsage(_request, _options);
    }
    async _WebAppUsageExistsInPeriod(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("WebAppUsageExistsInPeriod", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async WebAppUsageExistsInPeriod(associateId, viewState, fromDate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.ViewState) != 'undefined' || typeof (first.FromDate) != 'undefined')) {
            _request = associateId;
            _options = viewState;
        }
        else {
            _request = {
                AssociateId: associateId,
                ViewState: viewState,
                FromDate: fromDate,
            };
            _options = webapi_options;
        }
        return this._WebAppUsageExistsInPeriod(_request, _options);
    }
    async _GetWebAppUsagesForPeriod(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWebAppUsagesForPeriod", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WebAppUsageArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetWebAppUsagesForPeriod(fromDate, toDate, searchTerm, webapi_options) {
        let _request = null;
        let _options = null;
        const first = fromDate;
        if (typeof (first) === "object" && first && (typeof (first.FromDate) != 'undefined' || typeof (first.ToDate) != 'undefined' || typeof (first.SearchTerm) != 'undefined')) {
            _request = fromDate;
            _options = toDate;
        }
        else {
            _request = {
                FromDate: fromDate,
                ToDate: toDate,
                SearchTerm: searchTerm,
            };
            _options = webapi_options;
        }
        return this._GetWebAppUsagesForPeriod(_request, _options);
    }
} // class v1DiagnosticsAgentController 
exports.DiagnosticsAgent = DiagnosticsAgent;
//# sourceMappingURL=DiagnosticsAgent.js.map
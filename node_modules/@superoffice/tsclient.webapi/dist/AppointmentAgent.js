"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppointmentAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
const Base64_1 = require("./Base64");
/**
 * Collection of all services that works with Appointment data.
 */
class AppointmentAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Appointment/";
        super(options);
    }
    /**
     * Set default values into a new AppointmentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultAppointmentEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultAppointmentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing AppointmentEntity or creates a new AppointmentEntity if the id parameter is empty
     * @param entity - The AppointmentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated AppointmentEntity
     */
    async SaveAppointmentEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveAppointmentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the AppointmentEntity
     * @param AppointmentEntityId - The id of the AppointmentEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteAppointmentEntity(AppointmentEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteAppointmentEntity?AppointmentEntityId=" + AppointmentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new SuggestedAppointmentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSuggestedAppointmentEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSuggestedAppointmentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedAppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SuggestedAppointmentEntity or creates a new SuggestedAppointmentEntity if the id parameter is empty
     * @param entity - The SuggestedAppointmentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SuggestedAppointmentEntity
     */
    async SaveSuggestedAppointmentEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSuggestedAppointmentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedAppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TaskListItem.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTaskListItem(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTaskListItem", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskListItem_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TaskListItem or creates a new TaskListItem if the id parameter is empty
     * @param entity - The TaskListItem to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TaskListItem
     */
    async SaveTaskListItem(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTaskListItem", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskListItem_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Appointment object.
     * @param appointmentId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Appointment
     */
    async GetAppointment(appointmentId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAppointment?appointmentId=" + appointmentId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Appointment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _ToggleAppointmentStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleAppointmentStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleAppointmentStatus(appointmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined')) {
            _request = appointmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
            };
            _options = webapi_options;
        }
        return this._ToggleAppointmentStatus(_request, _options);
    }
    async _ToggleActivity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleActivity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleActivity(activityIdentifier, webapi_options) {
        let _request = null;
        let _options = null;
        const first = activityIdentifier;
        if (typeof (first) === "object" && first && (typeof (first.ActivityIdentifier) != 'undefined')) {
            _request = activityIdentifier;
            _options = webapi_options;
        }
        else {
            _request = {
                ActivityIdentifier: activityIdentifier,
            };
            _options = webapi_options;
        }
        return this._ToggleActivity(_request, _options);
    }
    async _ToggleActivities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleActivities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleActivities(activityIdentifier, webapi_options) {
        let _request = null;
        let _options = null;
        const first = activityIdentifier;
        if (typeof (first) === "object" && first && (typeof (first.ActivityIdentifier) != 'undefined')) {
            _request = activityIdentifier;
            _options = webapi_options;
        }
        else {
            _request = {
                ActivityIdentifier: activityIdentifier,
            };
            _options = webapi_options;
        }
        return this._ToggleActivities(_request, _options);
    }
    async _SetActivityStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetActivityStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetActivityStatus(activityIdentifier, activityStatus, webapi_options) {
        let _request = null;
        let _options = null;
        const first = activityIdentifier;
        if (typeof (first) === "object" && first && (typeof (first.ActivityIdentifier) != 'undefined' || typeof (first.ActivityStatus) != 'undefined')) {
            _request = activityIdentifier;
            _options = activityStatus;
        }
        else {
            _request = {
                ActivityIdentifier: activityIdentifier,
                ActivityStatus: activityStatus,
            };
            _options = webapi_options;
        }
        return this._SetActivityStatus(_request, _options);
    }
    async _ToggleAndSetActivities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleAndSetActivities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleAndSetActivities(activityIdentifiers, webapi_options) {
        let _request = null;
        let _options = null;
        const first = activityIdentifiers;
        if (typeof (first) === "object" && first && (typeof (first.ActivityIdentifiers) != 'undefined')) {
            _request = activityIdentifiers;
            _options = webapi_options;
        }
        else {
            _request = {
                ActivityIdentifiers: activityIdentifiers,
            };
            _options = webapi_options;
        }
        return this._ToggleAndSetActivities(_request, _options);
    }
    /*
     * Gets a AppointmentEntity object.
     * @param appointmentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single AppointmentEntity
     */
    async GetAppointmentEntity(appointmentEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAppointmentEntity?appointmentEntityId=" + appointmentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _CreateDefaultAppointmentEntityByType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultAppointmentEntityByType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultAppointmentEntityByType(type, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined')) {
            _request = type;
            _options = webapi_options;
        }
        else {
            _request = {
                Type: type,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultAppointmentEntityByType(_request, _options);
    }
    async _Accept(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Accept", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Accept(appointmentId, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentId;
            _options = updateMode;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._Accept(_request, _options);
    }
    async _CreateAndAccept(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndAccept", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateAndAccept(emailItemId, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailItemId;
        if (typeof (first) === "object" && first && (typeof (first.EmailItemId) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = emailItemId;
            _options = updateMode;
        }
        else {
            _request = {
                EmailItemId: emailItemId,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._CreateAndAccept(_request, _options);
    }
    async _AcceptWithEmailConfirmation(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AcceptWithEmailConfirmation", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AcceptWithEmailConfirmation(appointmentId, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentId;
            _options = updateMode;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._AcceptWithEmailConfirmation(_request, _options);
    }
    async _CreateAndAcceptWithEmailConfirmation(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAndAcceptWithEmailConfirmation", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateAndAcceptWithEmailConfirmation(emailItemId, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailItemId;
        if (typeof (first) === "object" && first && (typeof (first.EmailItemId) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = emailItemId;
            _options = updateMode;
        }
        else {
            _request = {
                EmailItemId: emailItemId,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._CreateAndAcceptWithEmailConfirmation(_request, _options);
    }
    async _Reject(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Reject", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Reject(appointmentId, rejectReason, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.RejectReason) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentId;
            _options = rejectReason;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                RejectReason: rejectReason,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._Reject(_request, _options);
    }
    async _RejectWithEmailConfirmation(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RejectWithEmailConfirmation", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RejectWithEmailConfirmation(appointmentId, rejectReason, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.RejectReason) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentId;
            _options = rejectReason;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                RejectReason: rejectReason,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._RejectWithEmailConfirmation(_request, _options);
    }
    async _DeclineInvitationFromEmailItem(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeclineInvitationFromEmailItem", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeclineInvitationFromEmailItem(emailItemId, rejectReason, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailItemId;
        if (typeof (first) === "object" && first && (typeof (first.EmailItemId) != 'undefined' || typeof (first.RejectReason) != 'undefined')) {
            _request = emailItemId;
            _options = rejectReason;
        }
        else {
            _request = {
                EmailItemId: emailItemId,
                RejectReason: rejectReason,
            };
            _options = webapi_options;
        }
        return this._DeclineInvitationFromEmailItem(_request, _options);
    }
    async _GetOrganizerName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOrganizerName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetOrganizerName(motherAppointmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = motherAppointmentId;
        if (typeof (first) === "object" && first && (typeof (first.MotherAppointmentId) != 'undefined')) {
            _request = motherAppointmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                MotherAppointmentId: motherAppointmentId,
            };
            _options = webapi_options;
        }
        return this._GetOrganizerName(_request, _options);
    }
    async _Save(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Save", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Save(appointmentEntity, updateMode, sendEmailToParticipants, smtpEMailConnectionInfo, imapEMailConnectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentEntity;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentEntity) != 'undefined' || typeof (first.UpdateMode) != 'undefined' || typeof (first.SendEmailToParticipants) != 'undefined' || typeof (first.SmtpEMailConnectionInfo) != 'undefined' || typeof (first.ImapEMailConnectionInfo) != 'undefined')) {
            _request = appointmentEntity;
            _options = updateMode;
        }
        else {
            _request = {
                AppointmentEntity: appointmentEntity,
                UpdateMode: updateMode,
                SendEmailToParticipants: sendEmailToParticipants,
                SmtpEMailConnectionInfo: smtpEMailConnectionInfo,
                ImapEMailConnectionInfo: imapEMailConnectionInfo,
            };
            _options = webapi_options;
        }
        return this._Save(_request, _options);
    }
    async _Delete(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Delete", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Delete(appointmentId, updateMode, sendEmailToParticipants, smtpEMailConnectionInfo, imapEMailConnectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.UpdateMode) != 'undefined' || typeof (first.SendEmailToParticipants) != 'undefined' || typeof (first.SmtpEMailConnectionInfo) != 'undefined' || typeof (first.ImapEMailConnectionInfo) != 'undefined')) {
            _request = appointmentId;
            _options = updateMode;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                UpdateMode: updateMode,
                SendEmailToParticipants: sendEmailToParticipants,
                SmtpEMailConnectionInfo: smtpEMailConnectionInfo,
                ImapEMailConnectionInfo: imapEMailConnectionInfo,
            };
            _options = webapi_options;
        }
        return this._Delete(_request, _options);
    }
    async _CalculateDays(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CalculateDays", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RecurrenceInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CalculateDays(appointmentEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentEntity;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentEntity) != 'undefined')) {
            _request = appointmentEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentEntity: appointmentEntity,
            };
            _options = webapi_options;
        }
        return this._CalculateDays(_request, _options);
    }
    async _ValidateDays(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateDays", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RecurrenceDateArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateDays(appointmentEntity, dates, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentEntity;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentEntity) != 'undefined' || typeof (first.Dates) != 'undefined')) {
            _request = appointmentEntity;
            _options = dates;
        }
        else {
            _request = {
                AppointmentEntity: appointmentEntity,
                Dates: dates,
            };
            _options = webapi_options;
        }
        return this._ValidateDays(_request, _options);
    }
    async _CreateDefaultRecurrence(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultRecurrence", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RecurrenceInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Creates a RecurrenceInfo object populated with the default values for the specific type.
     * @returns RecurrenceInfo object with default values.
     */
    async CreateDefaultRecurrence(webapi_options) {
        return this._CreateDefaultRecurrence(webapi_options);
    }
    async _AssignTo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AssignTo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AssignTo(appointmentId, participant, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.Participant) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentId;
            _options = participant;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                Participant: participant,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._AssignTo(_request, _options);
    }
    async _SetSeen(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetSeen", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetSeen(appointmentId, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentId;
            _options = updateMode;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._SetSeen(_request, _options);
    }
    async _SetSeenMany(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetSeenMany", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetSeenMany(appointmentIds, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentIds;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentIds) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentIds;
            _options = updateMode;
        }
        else {
            _request = {
                AppointmentIds: appointmentIds,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._SetSeenMany(_request, _options);
    }
    async _Move(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Move", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Move(appointmentId, newStartTime, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.NewStartTime) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentId;
            _options = newStartTime;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                NewStartTime: newStartTime,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._Move(_request, _options);
    }
    async _AcceptRejected(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AcceptRejected", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AcceptRejected(appointmentId, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentId;
            _options = updateMode;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._AcceptRejected(_request, _options);
    }
    async _CreateDefaultRecurrenceByDate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultRecurrenceByDate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RecurrenceInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultRecurrenceByDate(startDate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = startDate;
        if (typeof (first) === "object" && first && (typeof (first.StartDate) != 'undefined')) {
            _request = startDate;
            _options = webapi_options;
        }
        else {
            _request = {
                StartDate: startDate,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultRecurrenceByDate(_request, _options);
    }
    async _CleanUpBookingDeleted(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CleanUpBookingDeleted", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CleanUpBookingDeleted(appointmentIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentIds;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentIds) != 'undefined')) {
            _request = appointmentIds;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentIds: appointmentIds,
            };
            _options = webapi_options;
        }
        return this._CleanUpBookingDeleted(_request, _options);
    }
    async _CleanUpBookingDeletedWithUpdateMode(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CleanUpBookingDeletedWithUpdateMode", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CleanUpBookingDeletedWithUpdateMode(appointmentIds, updateMode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentIds;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentIds) != 'undefined' || typeof (first.UpdateMode) != 'undefined')) {
            _request = appointmentIds;
            _options = updateMode;
        }
        else {
            _request = {
                AppointmentIds: appointmentIds,
                UpdateMode: updateMode,
            };
            _options = webapi_options;
        }
        return this._CleanUpBookingDeletedWithUpdateMode(_request, _options);
    }
    async _CleanUpRecurringBookingDeleted(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CleanUpRecurringBookingDeleted", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Deletes all appointments with status BookingDeleted and for in logged user.
     * @returns
     */
    async CleanUpRecurringBookingDeleted(webapi_options) {
        return this._CleanUpRecurringBookingDeleted(webapi_options);
    }
    async _CreateDefaultAppointmentEntityByTypeAndAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultAppointmentEntityByTypeAndAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultAppointmentEntityByTypeAndAssociate(type, associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined' || typeof (first.AssociateId) != 'undefined')) {
            _request = type;
            _options = associateId;
        }
        else {
            _request = {
                Type: type,
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultAppointmentEntityByTypeAndAssociate(_request, _options);
    }
    async _GetCanInsertForAssociates(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCanInsertForAssociates", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCanInsertForAssociates(associateIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateIds;
        if (typeof (first) === "object" && first && (typeof (first.AssociateIds) != 'undefined')) {
            _request = associateIds;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateIds: associateIds,
            };
            _options = webapi_options;
        }
        return this._GetCanInsertForAssociates(_request, _options);
    }
    async _GetAppointmentHaveParticipantsWithEmail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentHaveParticipantsWithEmail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAppointmentHaveParticipantsWithEmail(appointmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined')) {
            _request = appointmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
            };
            _options = webapi_options;
        }
        return this._GetAppointmentHaveParticipantsWithEmail(_request, _options);
    }
    async _CreateDefaultAppointmentEntityFromSaleSuggestion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultAppointmentEntityFromSaleSuggestion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultAppointmentEntityFromSaleSuggestion(suggestedAppointmentId, saleId, createNow, ownerId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = suggestedAppointmentId;
        if (typeof (first) === "object" && first && (typeof (first.SuggestedAppointmentId) != 'undefined' || typeof (first.SaleId) != 'undefined' || typeof (first.CreateNow) != 'undefined' || typeof (first.OwnerId) != 'undefined')) {
            _request = suggestedAppointmentId;
            _options = saleId;
        }
        else {
            _request = {
                SuggestedAppointmentId: suggestedAppointmentId,
                SaleId: saleId,
                CreateNow: createNow,
                OwnerId: ownerId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultAppointmentEntityFromSaleSuggestion(_request, _options);
    }
    async _GetNextSuggestedAppointmentBySale(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextSuggestedAppointmentBySale", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedAppointment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetNextSuggestedAppointmentBySale(saleId, currentAppointmentId, skipCompleteCheck, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined' || typeof (first.CurrentAppointmentId) != 'undefined' || typeof (first.SkipCompleteCheck) != 'undefined')) {
            _request = saleId;
            _options = currentAppointmentId;
        }
        else {
            _request = {
                SaleId: saleId,
                CurrentAppointmentId: currentAppointmentId,
                SkipCompleteCheck: skipCompleteCheck,
            };
            _options = webapi_options;
        }
        return this._GetNextSuggestedAppointmentBySale(_request, _options);
    }
    async _CreateDefaultReOpenAppointment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultReOpenAppointment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultReOpenAppointment(saleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined')) {
            _request = saleId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleId: saleId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultReOpenAppointment(_request, _options);
    }
    async _CreateDefaultAppointmentEntityFromProjectSuggestion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultAppointmentEntityFromProjectSuggestion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultAppointmentEntityFromProjectSuggestion(suggestedAppointmentId, projectId, createNow, ownerId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = suggestedAppointmentId;
        if (typeof (first) === "object" && first && (typeof (first.SuggestedAppointmentId) != 'undefined' || typeof (first.ProjectId) != 'undefined' || typeof (first.CreateNow) != 'undefined' || typeof (first.OwnerId) != 'undefined')) {
            _request = suggestedAppointmentId;
            _options = projectId;
        }
        else {
            _request = {
                SuggestedAppointmentId: suggestedAppointmentId,
                ProjectId: projectId,
                CreateNow: createNow,
                OwnerId: ownerId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultAppointmentEntityFromProjectSuggestion(_request, _options);
    }
    async _CreateAppointmentForUID(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateAppointmentForUID", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateAppointmentForUID(appointmentEntity, uID, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentEntity;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentEntity) != 'undefined' || typeof (first.UID) != 'undefined')) {
            _request = appointmentEntity;
            _options = uID;
        }
        else {
            _request = {
                AppointmentEntity: appointmentEntity,
                UID: uID,
            };
            _options = webapi_options;
        }
        return this._CreateAppointmentForUID(_request, _options);
    }
    async _GetAppointmentFromUID(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentFromUID", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAppointmentFromUID(uID, webapi_options) {
        let _request = null;
        let _options = null;
        const first = uID;
        if (typeof (first) === "object" && first && (typeof (first.UID) != 'undefined')) {
            _request = uID;
            _options = webapi_options;
        }
        else {
            _request = {
                UID: uID,
            };
            _options = webapi_options;
        }
        return this._GetAppointmentFromUID(_request, _options);
    }
    async _CanAssignToProjectMember(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanAssignToProjectMember", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CanAssignToProjectMember(projectId, suggestedAppointmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.SuggestedAppointmentId) != 'undefined')) {
            _request = projectId;
            _options = suggestedAppointmentId;
        }
        else {
            _request = {
                ProjectId: projectId,
                SuggestedAppointmentId: suggestedAppointmentId,
            };
            _options = webapi_options;
        }
        return this._CanAssignToProjectMember(_request, _options);
    }
    async _GetUIDFromAppointmentId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUIDFromAppointmentId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUIDFromAppointmentId(appointmentId, useMotherId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.UseMotherId) != 'undefined')) {
            _request = appointmentId;
            _options = useMotherId;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                UseMotherId: useMotherId,
            };
            _options = webapi_options;
        }
        return this._GetUIDFromAppointmentId(_request, _options);
    }
    async _UpdateAppointmentFromIcsResponse(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateAppointmentFromIcsResponse", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateAppointmentFromIcsResponse(emailAddress, icsData, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailAddress;
        if (typeof (first) === "object" && first && (typeof (first.EmailAddress) != 'undefined' || typeof (first.IcsData) != 'undefined')) {
            _request = emailAddress;
            _options = icsData;
        }
        else {
            _request = {
                EmailAddress: emailAddress,
                IcsData: icsData,
            };
            _options = webapi_options;
        }
        _request.IcsData = (0, Base64_1.ToBase64)(_request.IcsData);
        return this._UpdateAppointmentFromIcsResponse(_request, _options);
    }
    async _ValidateAppointmentEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateAppointmentEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateAppointmentEntity(appointmentEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentEntity;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentEntity) != 'undefined')) {
            _request = appointmentEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentEntity: appointmentEntity,
            };
            _options = webapi_options;
        }
        return this._ValidateAppointmentEntity(_request, _options);
    }
    async _WillSendEmail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("WillSendEmail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async WillSendEmail(appointment, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointment;
        if (typeof (first) === "object" && first && (typeof (first.Appointment) != 'undefined')) {
            _request = appointment;
            _options = webapi_options;
        }
        else {
            _request = {
                Appointment: appointment,
            };
            _options = webapi_options;
        }
        return this._WillSendEmail(_request, _options);
    }
    async _AcceptWithSmtpEmailConfirmation(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AcceptWithSmtpEmailConfirmation", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AcceptWithSmtpEmailConfirmation(appointmentId, updateMode, smtpEMailConnectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.UpdateMode) != 'undefined' || typeof (first.SmtpEMailConnectionInfo) != 'undefined')) {
            _request = appointmentId;
            _options = updateMode;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                UpdateMode: updateMode,
                SmtpEMailConnectionInfo: smtpEMailConnectionInfo,
            };
            _options = webapi_options;
        }
        return this._AcceptWithSmtpEmailConfirmation(_request, _options);
    }
    async _RejectWithSmtpEmailConfirmation(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RejectWithSmtpEmailConfirmation", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RejectWithSmtpEmailConfirmation(appointmentId, rejectReason, updateMode, smtpEMailConnectionInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined' || typeof (first.RejectReason) != 'undefined' || typeof (first.UpdateMode) != 'undefined' || typeof (first.SmtpEMailConnectionInfo) != 'undefined')) {
            _request = appointmentId;
            _options = rejectReason;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
                RejectReason: rejectReason,
                UpdateMode: updateMode,
                SmtpEMailConnectionInfo: smtpEMailConnectionInfo,
            };
            _options = webapi_options;
        }
        return this._RejectWithSmtpEmailConfirmation(_request, _options);
    }
    /*
     * Gets an array of Appointment objects.
     * @param appointmentIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Appointment
     */
    async GetAppointmentList(appointmentIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAppointmentList", appointmentIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetMyAppointments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyAppointments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMyAppointments(startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = startTime;
        if (typeof (first) === "object" && first && (typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = startTime;
            _options = endTime;
        }
        else {
            _request = {
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetMyAppointments(_request, _options);
    }
    async _GetPersonAppointments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonAppointments(personId, includeProjectAppointments, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectAppointments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = personId;
            _options = includeProjectAppointments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectAppointments: includeProjectAppointments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetPersonAppointments(_request, _options);
    }
    async _GetMyDiary(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyDiary", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMyDiary(startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = startTime;
        if (typeof (first) === "object" && first && (typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = startTime;
            _options = endTime;
        }
        else {
            _request = {
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetMyDiary(_request, _options);
    }
    async _GetMyTasks(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyTasks", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMyTasks(count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = count;
        if (typeof (first) === "object" && first && (typeof (first.Count) != 'undefined')) {
            _request = count;
            _options = webapi_options;
        }
        else {
            _request = {
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetMyTasks(_request, _options);
    }
    async _GetPersonDiary(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDiary", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonDiary(personId, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetPersonDiary(_request, _options);
    }
    async _GetPersonTasks(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonTasks", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonTasks(personId, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = personId;
            _options = count;
        }
        else {
            _request = {
                PersonId: personId,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetPersonTasks(_request, _options);
    }
    async _GetPersonAppointmentsByType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointmentsByType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonAppointmentsByType(personId, includeProjectAppointments, startTime, endTime, count, appointmentType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectAppointments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.AppointmentType) != 'undefined')) {
            _request = personId;
            _options = includeProjectAppointments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectAppointments: includeProjectAppointments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                AppointmentType: appointmentType,
            };
            _options = webapi_options;
        }
        return this._GetPersonAppointmentsByType(_request, _options);
    }
    async _GetProjectAppointments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectAppointments(projectId, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = projectId;
            _options = startTime;
        }
        else {
            _request = {
                ProjectId: projectId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetProjectAppointments(_request, _options);
    }
    async _GetProjectAppointmentsByType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointmentsByType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectAppointmentsByType(projectId, startTime, endTime, count, appointmentType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.AppointmentType) != 'undefined')) {
            _request = projectId;
            _options = startTime;
        }
        else {
            _request = {
                ProjectId: projectId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                AppointmentType: appointmentType,
            };
            _options = webapi_options;
        }
        return this._GetProjectAppointmentsByType(_request, _options);
    }
    async _GetContactAppointments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactAppointments(contactId, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = contactId;
            _options = startTime;
        }
        else {
            _request = {
                ContactId: contactId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetContactAppointments(_request, _options);
    }
    async _GetContactAppointmentsByType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointmentsByType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactAppointmentsByType(contactId, startTime, endTime, count, appointmentType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.AppointmentType) != 'undefined')) {
            _request = contactId;
            _options = startTime;
        }
        else {
            _request = {
                ContactId: contactId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                AppointmentType: appointmentType,
            };
            _options = webapi_options;
        }
        return this._GetContactAppointmentsByType(_request, _options);
    }
    async _GetProjectMemberAppointments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMemberAppointments(personId, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointments(_request, _options);
    }
    async _GetProjectMemberAppointmentsByType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointmentsByType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMemberAppointmentsByType(personId, startTime, endTime, count, appointmentType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.AppointmentType) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                AppointmentType: appointmentType,
            };
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointmentsByType(_request, _options);
    }
    async _GetPersonAppointmentsByTask(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointmentsByTask", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonAppointmentsByTask(personId, includeProjectAppointments, startTime, endTime, count, taskId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectAppointments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskId) != 'undefined')) {
            _request = personId;
            _options = includeProjectAppointments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectAppointments: includeProjectAppointments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskId: taskId,
            };
            _options = webapi_options;
        }
        return this._GetPersonAppointmentsByTask(_request, _options);
    }
    async _GetPersonAppointmentsByTasks(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointmentsByTasks", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonAppointmentsByTasks(personId, includeProjectAppointments, startTime, endTime, count, taskIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectAppointments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskIds) != 'undefined')) {
            _request = personId;
            _options = includeProjectAppointments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectAppointments: includeProjectAppointments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskIds: taskIds,
            };
            _options = webapi_options;
        }
        return this._GetPersonAppointmentsByTasks(_request, _options);
    }
    async _GetPersonAppointmentsByTaskHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonAppointmentsByTaskHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonAppointmentsByTaskHeading(personId, includeProjectAppointments, startTime, endTime, count, taskHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectAppointments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskHeadingId) != 'undefined')) {
            _request = personId;
            _options = includeProjectAppointments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectAppointments: includeProjectAppointments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskHeadingId: taskHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetPersonAppointmentsByTaskHeading(_request, _options);
    }
    async _GetProjectAppointmentsByTask(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointmentsByTask", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectAppointmentsByTask(projectId, startTime, endTime, count, taskId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskId) != 'undefined')) {
            _request = projectId;
            _options = startTime;
        }
        else {
            _request = {
                ProjectId: projectId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskId: taskId,
            };
            _options = webapi_options;
        }
        return this._GetProjectAppointmentsByTask(_request, _options);
    }
    async _GetProjectAppointmentsByTasks(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointmentsByTasks", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectAppointmentsByTasks(projectId, startTime, endTime, count, taskIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskIds) != 'undefined')) {
            _request = projectId;
            _options = startTime;
        }
        else {
            _request = {
                ProjectId: projectId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskIds: taskIds,
            };
            _options = webapi_options;
        }
        return this._GetProjectAppointmentsByTasks(_request, _options);
    }
    async _GetProjectAppointmentsByTaskHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectAppointmentsByTaskHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectAppointmentsByTaskHeading(projectId, startTime, endTime, count, taskHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskHeadingId) != 'undefined')) {
            _request = projectId;
            _options = startTime;
        }
        else {
            _request = {
                ProjectId: projectId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskHeadingId: taskHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetProjectAppointmentsByTaskHeading(_request, _options);
    }
    async _GetProjectMemberAppointmentsByTask(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointmentsByTask", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMemberAppointmentsByTask(personId, startTime, endTime, count, taskId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskId) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskId: taskId,
            };
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointmentsByTask(_request, _options);
    }
    async _GetProjectMemberAppointmentsByTasks(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointmentsByTasks", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMemberAppointmentsByTasks(personId, startTime, endTime, count, taskIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskIds) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskIds: taskIds,
            };
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointmentsByTasks(_request, _options);
    }
    async _GetProjectMemberAppointmentsByTaskHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberAppointmentsByTaskHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMemberAppointmentsByTaskHeading(personId, startTime, endTime, count, taskHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskHeadingId) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskHeadingId: taskHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetProjectMemberAppointmentsByTaskHeading(_request, _options);
    }
    async _GetContactAppointmentsByTask(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointmentsByTask", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactAppointmentsByTask(contactId, startTime, endTime, count, taskId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskId) != 'undefined')) {
            _request = contactId;
            _options = startTime;
        }
        else {
            _request = {
                ContactId: contactId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskId: taskId,
            };
            _options = webapi_options;
        }
        return this._GetContactAppointmentsByTask(_request, _options);
    }
    async _GetContactAppointmentsByTasks(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointmentsByTasks", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactAppointmentsByTasks(contactId, startTime, endTime, count, taskIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskIds) != 'undefined')) {
            _request = contactId;
            _options = startTime;
        }
        else {
            _request = {
                ContactId: contactId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskIds: taskIds,
            };
            _options = webapi_options;
        }
        return this._GetContactAppointmentsByTasks(_request, _options);
    }
    async _GetContactAppointmentsByTaskHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactAppointmentsByTaskHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactAppointmentsByTaskHeading(contactId, startTime, endTime, count, taskHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TaskHeadingId) != 'undefined')) {
            _request = contactId;
            _options = startTime;
        }
        else {
            _request = {
                ContactId: contactId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TaskHeadingId: taskHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetContactAppointmentsByTaskHeading(_request, _options);
    }
    async _GetPublishedAppointment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedAppointment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Appointment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedAppointment(appointmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined')) {
            _request = appointmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
            };
            _options = webapi_options;
        }
        return this._GetPublishedAppointment(_request, _options);
    }
    async _GetPublishedAppointments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedAppointments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedAppointments(appointmentIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentIds;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentIds) != 'undefined')) {
            _request = appointmentIds;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentIds: appointmentIds,
            };
            _options = webapi_options;
        }
        return this._GetPublishedAppointments(_request, _options);
    }
    async _GetMyPublishedAppointments(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyPublishedAppointments", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get published appointments from the logged in user.
     * @returns Appointments
     */
    async GetMyPublishedAppointments(webapi_options) {
        return this._GetMyPublishedAppointments(webapi_options);
    }
    async _GetPublishedProjectAppointments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProjectAppointments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedProjectAppointments(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetPublishedProjectAppointments(_request, _options);
    }
    async _GetAppointmentsByTaskHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentsByTaskHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAppointmentsByTaskHeading(taskHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = taskHeadingId;
        if (typeof (first) === "object" && first && (typeof (first.TaskHeadingId) != 'undefined')) {
            _request = taskHeadingId;
            _options = webapi_options;
        }
        else {
            _request = {
                TaskHeadingId: taskHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetAppointmentsByTaskHeading(_request, _options);
    }
    async _GetAssociateDiary(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAssociateDiary", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAssociateDiary(associateId, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = associateId;
            _options = startTime;
        }
        else {
            _request = {
                AssociateId: associateId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetAssociateDiary(_request, _options);
    }
    async _GetDiaryByGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDiaryByGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDiaryByGroup(groupId, groupType, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = groupId;
        if (typeof (first) === "object" && first && (typeof (first.GroupId) != 'undefined' || typeof (first.GroupType) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = groupId;
            _options = groupType;
        }
        else {
            _request = {
                GroupId: groupId,
                GroupType: groupType,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetDiaryByGroup(_request, _options);
    }
    async _UpdateAppointment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateAppointment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Appointment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateAppointment(id, startTime, endTime, status, type, associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Status) != 'undefined' || typeof (first.Type) != 'undefined' || typeof (first.AssociateId) != 'undefined')) {
            _request = id;
            _options = startTime;
        }
        else {
            _request = {
                Id: id,
                StartTime: startTime,
                EndTime: endTime,
                Status: status,
                Type: type,
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._UpdateAppointment(_request, _options);
    }
    async _GetAssociatesDiary(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAssociatesDiary", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAssociatesDiary(associateIds, startTime, endTime, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateIds;
        if (typeof (first) === "object" && first && (typeof (first.AssociateIds) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined')) {
            _request = associateIds;
            _options = startTime;
        }
        else {
            _request = {
                AssociateIds: associateIds,
                StartTime: startTime,
                EndTime: endTime,
            };
            _options = webapi_options;
        }
        return this._GetAssociatesDiary(_request, _options);
    }
    async _GetAppointmentRecords(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentRecords", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAppointmentRecords(motherId, recurrenceRuleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = motherId;
        if (typeof (first) === "object" && first && (typeof (first.MotherId) != 'undefined' || typeof (first.RecurrenceRuleId) != 'undefined')) {
            _request = motherId;
            _options = recurrenceRuleId;
        }
        else {
            _request = {
                MotherId: motherId,
                RecurrenceRuleId: recurrenceRuleId,
            };
            _options = webapi_options;
        }
        return this._GetAppointmentRecords(_request, _options);
    }
    async _GetMySyncAppointments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMySyncAppointments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AppointmentSyncDataArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMySyncAppointments(startTime, endTime, webapi_options) {
        let _request = null;
        let _options = null;
        const first = startTime;
        if (typeof (first) === "object" && first && (typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined')) {
            _request = startTime;
            _options = endTime;
        }
        else {
            _request = {
                StartTime: startTime,
                EndTime: endTime,
            };
            _options = webapi_options;
        }
        return this._GetMySyncAppointments(_request, _options);
    }
    async _GetDayInformationListByDatesAndAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDayInformationListByDatesAndAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DayInformationListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDayInformationListByDatesAndAssociate(startDate, endDate, associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = startDate;
        if (typeof (first) === "object" && first && (typeof (first.StartDate) != 'undefined' || typeof (first.EndDate) != 'undefined' || typeof (first.AssociateId) != 'undefined')) {
            _request = startDate;
            _options = endDate;
        }
        else {
            _request = {
                StartDate: startDate,
                EndDate: endDate,
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._GetDayInformationListByDatesAndAssociate(_request, _options);
    }
    async _GetActivityInformationListByDatesAndAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetActivityInformationListByDatesAndAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ActivityInformationListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetActivityInformationListByDatesAndAssociate(startDate, endDate, associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = startDate;
        if (typeof (first) === "object" && first && (typeof (first.StartDate) != 'undefined' || typeof (first.EndDate) != 'undefined' || typeof (first.AssociateId) != 'undefined')) {
            _request = startDate;
            _options = endDate;
        }
        else {
            _request = {
                StartDate: startDate,
                EndDate: endDate,
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._GetActivityInformationListByDatesAndAssociate(_request, _options);
    }
    async _GetRedLetterInformationListByDatesAndAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRedLetterInformationListByDatesAndAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RedLetterInformationListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetRedLetterInformationListByDatesAndAssociate(startDate, endDate, associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = startDate;
        if (typeof (first) === "object" && first && (typeof (first.StartDate) != 'undefined' || typeof (first.EndDate) != 'undefined' || typeof (first.AssociateId) != 'undefined')) {
            _request = startDate;
            _options = endDate;
        }
        else {
            _request = {
                StartDate: startDate,
                EndDate: endDate,
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._GetRedLetterInformationListByDatesAndAssociate(_request, _options);
    }
    async _GetAlarms(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAlarms", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MultiAlarmData_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAlarms(includeInvitations, includeAllAppointments, defaultAlarmLeadTimeInMinutes, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeInvitations;
        if (typeof (first) === "object" && first && (typeof (first.IncludeInvitations) != 'undefined' || typeof (first.IncludeAllAppointments) != 'undefined' || typeof (first.DefaultAlarmLeadTimeInMinutes) != 'undefined')) {
            _request = includeInvitations;
            _options = includeAllAppointments;
        }
        else {
            _request = {
                IncludeInvitations: includeInvitations,
                IncludeAllAppointments: includeAllAppointments,
                DefaultAlarmLeadTimeInMinutes: defaultAlarmLeadTimeInMinutes,
            };
            _options = webapi_options;
        }
        return this._GetAlarms(_request, _options);
    }
    async _GenerateLead(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateLead", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SalesActivity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GenerateLead(associateIdForNewContact, leadDescription, relation, relationId, leadContact, leadPersonFirstname, leadPersonLastname, leadPersonEmail, leadPhoneNumber, creatorsContact, creatorsFirstname, creatorsLastname, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateIdForNewContact;
        if (typeof (first) === "object" && first && (typeof (first.AssociateIdForNewContact) != 'undefined' || typeof (first.LeadDescription) != 'undefined' || typeof (first.Relation) != 'undefined' || typeof (first.RelationId) != 'undefined' || typeof (first.LeadContact) != 'undefined' || typeof (first.LeadPersonFirstname) != 'undefined' || typeof (first.LeadPersonLastname) != 'undefined' || typeof (first.LeadPersonEmail) != 'undefined' || typeof (first.LeadPhoneNumber) != 'undefined' || typeof (first.CreatorsContact) != 'undefined' || typeof (first.CreatorsFirstname) != 'undefined' || typeof (first.CreatorsLastname) != 'undefined')) {
            _request = associateIdForNewContact;
            _options = leadDescription;
        }
        else {
            _request = {
                AssociateIdForNewContact: associateIdForNewContact,
                LeadDescription: leadDescription,
                Relation: relation,
                RelationId: relationId,
                LeadContact: leadContact,
                LeadPersonFirstname: leadPersonFirstname,
                LeadPersonLastname: leadPersonLastname,
                LeadPersonEmail: leadPersonEmail,
                LeadPhoneNumber: leadPhoneNumber,
                CreatorsContact: creatorsContact,
                CreatorsFirstname: creatorsFirstname,
                CreatorsLastname: creatorsLastname,
            };
            _options = webapi_options;
        }
        return this._GenerateLead(_request, _options);
    }
    async _RequestForInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RequestForInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SalesActivity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RequestForInfo(associateIdForNewContact, channel, regarding, contactName, personFirstname, personLastname, emailAddress, phoneNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateIdForNewContact;
        if (typeof (first) === "object" && first && (typeof (first.AssociateIdForNewContact) != 'undefined' || typeof (first.Channel) != 'undefined' || typeof (first.Regarding) != 'undefined' || typeof (first.ContactName) != 'undefined' || typeof (first.PersonFirstname) != 'undefined' || typeof (first.PersonLastname) != 'undefined' || typeof (first.EmailAddress) != 'undefined' || typeof (first.PhoneNumber) != 'undefined')) {
            _request = associateIdForNewContact;
            _options = channel;
        }
        else {
            _request = {
                AssociateIdForNewContact: associateIdForNewContact,
                Channel: channel,
                Regarding: regarding,
                ContactName: contactName,
                PersonFirstname: personFirstname,
                PersonLastname: personLastname,
                EmailAddress: emailAddress,
                PhoneNumber: phoneNumber,
            };
            _options = webapi_options;
        }
        return this._RequestForInfo(_request, _options);
    }
    /*
     * Gets a SuggestedAppointment object.
     * @param suggestedAppointmentId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SuggestedAppointment
     */
    async GetSuggestedAppointment(suggestedAppointmentId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSuggestedAppointment?suggestedAppointmentId=" + suggestedAppointmentId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedAppointment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a SuggestedAppointmentEntity object.
     * @param suggestedAppointmentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SuggestedAppointmentEntity
     */
    async GetSuggestedAppointmentEntity(suggestedAppointmentEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSuggestedAppointmentEntity?suggestedAppointmentEntityId=" + suggestedAppointmentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedAppointmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a TaskListItem object.
     * @param taskListItemId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TaskListItem
     */
    async GetTaskListItem(taskListItemId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTaskListItem?taskListItemId=" + taskListItemId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskListItem_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetTaskListItems(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTaskListItems", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTaskListItems(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetTaskListItems(_request, _options);
    }
} // class v1AppointmentAgentController 
exports.AppointmentAgent = AppointmentAgent;
//# sourceMappingURL=AppointmentAgent.js.map
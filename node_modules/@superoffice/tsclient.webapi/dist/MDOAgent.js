"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDOAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * MDO Lists, reading, searching, and item lookup.
 */
class MDOAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/MDO/";
        super(options);
    }
    async _GetList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetList(name, forceFlatList, additionalInfo, onlyHistory, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.ForceFlatList) != 'undefined' || typeof (first.AdditionalInfo) != 'undefined' || typeof (first.OnlyHistory) != 'undefined')) {
            _request = name;
            _options = forceFlatList;
        }
        else {
            _request = {
                Name: name,
                ForceFlatList: forceFlatList,
                AdditionalInfo: additionalInfo,
                OnlyHistory: onlyHistory,
            };
            _options = webapi_options;
        }
        return this._GetList(_request, _options);
    }
    async _GetListWithHistory(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListWithHistory", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListWithHistory(name, forceFlatList, additionalInfo, historyItems, onlyHistory, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.ForceFlatList) != 'undefined' || typeof (first.AdditionalInfo) != 'undefined' || typeof (first.HistoryItems) != 'undefined' || typeof (first.OnlyHistory) != 'undefined')) {
            _request = name;
            _options = forceFlatList;
        }
        else {
            _request = {
                Name: name,
                ForceFlatList: forceFlatList,
                AdditionalInfo: additionalInfo,
                HistoryItems: historyItems,
                OnlyHistory: onlyHistory,
            };
            _options = webapi_options;
        }
        return this._GetListWithHistory(_request, _options);
    }
    async _GetListWithRestriction(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListWithRestriction", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListWithRestriction(name, additionalInfo, searchValue, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.AdditionalInfo) != 'undefined' || typeof (first.SearchValue) != 'undefined')) {
            _request = name;
            _options = additionalInfo;
        }
        else {
            _request = {
                Name: name,
                AdditionalInfo: additionalInfo,
                SearchValue: searchValue,
            };
            _options = webapi_options;
        }
        return this._GetListWithRestriction(_request, _options);
    }
    async _GetSimpleList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSimpleList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSimpleList(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._GetSimpleList(_request, _options);
    }
    async _GetListItem(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListItem", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MDOListItem_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListItem(listName, id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = listName;
        if (typeof (first) === "object" && first && (typeof (first.ListName) != 'undefined' || typeof (first.Id) != 'undefined')) {
            _request = listName;
            _options = id;
        }
        else {
            _request = {
                ListName: listName,
                Id: id,
            };
            _options = webapi_options;
        }
        return this._GetListItem(_request, _options);
    }
    async _GetListNames(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListNames", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns a list of all MDO List names. These names can also be used with the Archive agent as ProviderNames.
     * @returns Array of list names.
     */
    async GetListNames(webapi_options) {
        return this._GetListNames(webapi_options);
    }
    async _GetListIdByListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListIdByListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListIdByListName(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._GetListIdByListName(_request, _options);
    }
    async _GetSelectableSimpleList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectableSimpleList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSelectableSimpleList(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._GetSelectableSimpleList(_request, _options);
    }
    async _GetSelectableListWithRestriction(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectableListWithRestriction", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSelectableListWithRestriction(name, additionalInfo, searchValue, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.AdditionalInfo) != 'undefined' || typeof (first.SearchValue) != 'undefined')) {
            _request = name;
            _options = additionalInfo;
        }
        else {
            _request = {
                Name: name,
                AdditionalInfo: additionalInfo,
                SearchValue: searchValue,
            };
            _options = webapi_options;
        }
        return this._GetSelectableListWithRestriction(_request, _options);
    }
    async _GetSelectableListWithHistory(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectableListWithHistory", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSelectableListWithHistory(name, forceFlatList, additionalInfo, historyItems, onlyHistory, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.ForceFlatList) != 'undefined' || typeof (first.AdditionalInfo) != 'undefined' || typeof (first.HistoryItems) != 'undefined' || typeof (first.OnlyHistory) != 'undefined')) {
            _request = name;
            _options = forceFlatList;
        }
        else {
            _request = {
                Name: name,
                ForceFlatList: forceFlatList,
                AdditionalInfo: additionalInfo,
                HistoryItems: historyItems,
                OnlyHistory: onlyHistory,
            };
            _options = webapi_options;
        }
        return this._GetSelectableListWithHistory(_request, _options);
    }
    async _GetSelectableList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSelectableList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSelectableList(name, forceFlatList, additionalInfo, onlyHistory, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.ForceFlatList) != 'undefined' || typeof (first.AdditionalInfo) != 'undefined' || typeof (first.OnlyHistory) != 'undefined')) {
            _request = name;
            _options = forceFlatList;
        }
        else {
            _request = {
                Name: name,
                ForceFlatList: forceFlatList,
                AdditionalInfo: additionalInfo,
                OnlyHistory: onlyHistory,
            };
            _options = webapi_options;
        }
        return this._GetSelectableList(_request, _options);
    }
    async _SetSelected(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetSelected", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetSelected(name, additionalInfo, selectableMDOList, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.AdditionalInfo) != 'undefined' || typeof (first.SelectableMDOList) != 'undefined')) {
            _request = name;
            _options = additionalInfo;
        }
        else {
            _request = {
                Name: name,
                AdditionalInfo: additionalInfo,
                SelectableMDOList: selectableMDOList,
            };
            _options = webapi_options;
        }
        return this._SetSelected(_request, _options);
    }
} // class v1MDOAgentController 
exports.MDOAgent = MDOAgent;
//# sourceMappingURL=MDOAgent.js.map
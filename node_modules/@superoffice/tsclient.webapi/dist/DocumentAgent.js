"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
const Base64_1 = require("./Base64");
/**
 * Collection of all services that works with Document data. This is services for the document information, not the physical document themselves. These are handled by the BLOB service methods.
 */
class DocumentAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Document/";
        super(options);
    }
    /**
     * Set default values into a new DocumentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultDocumentEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDocumentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DocumentEntity or creates a new DocumentEntity if the id parameter is empty
     * @param entity - The DocumentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DocumentEntity
     */
    async SaveDocumentEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDocumentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the DocumentEntity
     * @param DocumentEntityId - The id of the DocumentEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteDocumentEntity(DocumentEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteDocumentEntity?DocumentEntityId=" + DocumentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new DocumentPreview.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultDocumentPreview(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDocumentPreview", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentPreview_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new SuggestedDocumentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSuggestedDocumentEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSuggestedDocumentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedDocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SuggestedDocumentEntity or creates a new SuggestedDocumentEntity if the id parameter is empty
     * @param entity - The SuggestedDocumentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SuggestedDocumentEntity
     */
    async SaveSuggestedDocumentEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSuggestedDocumentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedDocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TemplateVariablesParameters.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTemplateVariablesParameters(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTemplateVariablesParameters", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TemplateVariablesParameters_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Document object.
     * @param documentId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Document
     */
    async GetDocument(documentId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocument?documentId=" + documentId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Document_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a DocumentEntity object.
     * @param documentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DocumentEntity
     */
    async GetDocumentEntity(documentEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentEntity?documentEntityId=" + documentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetDocumentStreamFromEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentStreamFromEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentStreamFromEntity(documentEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentEntity;
        if (typeof (first) === "object" && first && (typeof (first.DocumentEntity) != 'undefined')) {
            _request = documentEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentEntity: documentEntity,
            };
            _options = webapi_options;
        }
        return this._GetDocumentStreamFromEntity(_request, _options);
    }
    async _SetDocumentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDocumentStream(documentEntity, stream, overwriteExistingData, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentEntity;
        if (typeof (first) === "object" && first && (typeof (first.DocumentEntity) != 'undefined' || typeof (first.Stream) != 'undefined' || typeof (first.OverwriteExistingData) != 'undefined')) {
            _request = documentEntity;
            _options = stream;
        }
        else {
            _request = {
                DocumentEntity: documentEntity,
                Stream: stream,
                OverwriteExistingData: overwriteExistingData,
            };
            _options = webapi_options;
        }
        _request.Stream = (0, Base64_1.ToBase64)(_request.Stream);
        return this._SetDocumentStream(_request, _options);
    }
    async _CreateDocumentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDocumentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDocumentStream(documentEntity, overwriteExistingData, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentEntity;
        if (typeof (first) === "object" && first && (typeof (first.DocumentEntity) != 'undefined' || typeof (first.OverwriteExistingData) != 'undefined')) {
            _request = documentEntity;
            _options = overwriteExistingData;
        }
        else {
            _request = {
                DocumentEntity: documentEntity,
                OverwriteExistingData: overwriteExistingData,
            };
            _options = webapi_options;
        }
        return this._CreateDocumentStream(_request, _options);
    }
    async _GetTemplateStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTemplateStream", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTemplateStream(templateName, allowPersonal, uiCulture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = templateName;
        if (typeof (first) === "object" && first && (typeof (first.TemplateName) != 'undefined' || typeof (first.AllowPersonal) != 'undefined' || typeof (first.UiCulture) != 'undefined')) {
            _request = templateName;
            _options = allowPersonal;
        }
        else {
            _request = {
                TemplateName: templateName,
                AllowPersonal: allowPersonal,
                UiCulture: uiCulture,
            };
            _options = webapi_options;
        }
        return this._GetTemplateStream(_request, _options);
    }
    async _GetSanitizedTemplateStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSanitizedTemplateStream", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSanitizedTemplateStream(templateName, allowPersonal, uiCulture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = templateName;
        if (typeof (first) === "object" && first && (typeof (first.TemplateName) != 'undefined' || typeof (first.AllowPersonal) != 'undefined' || typeof (first.UiCulture) != 'undefined')) {
            _request = templateName;
            _options = allowPersonal;
        }
        else {
            _request = {
                TemplateName: templateName,
                AllowPersonal: allowPersonal,
                UiCulture: uiCulture,
            };
            _options = webapi_options;
        }
        return this._GetSanitizedTemplateStream(_request, _options);
    }
    async _GetTemplateStreamFromId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTemplateStreamFromId", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTemplateStreamFromId(templateId, uiCulture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = templateId;
        if (typeof (first) === "object" && first && (typeof (first.TemplateId) != 'undefined' || typeof (first.UiCulture) != 'undefined')) {
            _request = templateId;
            _options = uiCulture;
        }
        else {
            _request = {
                TemplateId: templateId,
                UiCulture: uiCulture,
            };
            _options = webapi_options;
        }
        return this._GetTemplateStreamFromId(_request, _options);
    }
    async _GetSanitizedTemplateStreamFromId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSanitizedTemplateStreamFromId", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSanitizedTemplateStreamFromId(templateId, uiCulture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = templateId;
        if (typeof (first) === "object" && first && (typeof (first.TemplateId) != 'undefined' || typeof (first.UiCulture) != 'undefined')) {
            _request = templateId;
            _options = uiCulture;
        }
        else {
            _request = {
                TemplateId: templateId,
                UiCulture: uiCulture,
            };
            _options = webapi_options;
        }
        return this._GetSanitizedTemplateStreamFromId(_request, _options);
    }
    async _GetDocumentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentStream(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetDocumentStream(_request, _options);
    }
    async _GetSanitizedDocumentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSanitizedDocumentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSanitizedDocumentStream(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetSanitizedDocumentStream(_request, _options);
    }
    async _GetPreviewDocumentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewDocumentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentPreview_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreviewDocumentStream(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetPreviewDocumentStream(_request, _options);
    }
    async _GetUnsanitizedPreviewDocumentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUnsanitizedPreviewDocumentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentPreview_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUnsanitizedPreviewDocumentStream(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetUnsanitizedPreviewDocumentStream(_request, _options);
    }
    async _CreateNewPhysicalMailMergeDocumentFromTemplate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewPhysicalMailMergeDocumentFromTemplate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateNewPhysicalMailMergeDocumentFromTemplate(documentId, uiCulture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.UiCulture) != 'undefined')) {
            _request = documentId;
            _options = uiCulture;
        }
        else {
            _request = {
                DocumentId: documentId,
                UiCulture: uiCulture,
            };
            _options = webapi_options;
        }
        return this._CreateNewPhysicalMailMergeDocumentFromTemplate(_request, _options);
    }
    async _CreateNewPhysicalDocumentFromTemplateWithCustomTags(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewPhysicalDocumentFromTemplateWithCustomTags", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateNewPhysicalDocumentFromTemplateWithCustomTags(contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, customTags, customValues, uiCulture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.AppointmentId) != 'undefined' || typeof (first.DocumentId) != 'undefined' || typeof (first.SaleId) != 'undefined' || typeof (first.SelectionId) != 'undefined' || typeof (first.ProjectId) != 'undefined' || typeof (first.CustomTags) != 'undefined' || typeof (first.CustomValues) != 'undefined' || typeof (first.UiCulture) != 'undefined')) {
            _request = contactId;
            _options = personId;
        }
        else {
            _request = {
                ContactId: contactId,
                PersonId: personId,
                AppointmentId: appointmentId,
                DocumentId: documentId,
                SaleId: saleId,
                SelectionId: selectionId,
                ProjectId: projectId,
                CustomTags: customTags,
                CustomValues: customValues,
                UiCulture: uiCulture,
            };
            _options = webapi_options;
        }
        return this._CreateNewPhysicalDocumentFromTemplateWithCustomTags(_request, _options);
    }
    async _CreateNewPhysicalDocumentFromTemplateWithCustomTags2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewPhysicalDocumentFromTemplateWithCustomTags2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateNewPhysicalDocumentFromTemplateWithCustomTags2(contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, customTags, uiCulture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.AppointmentId) != 'undefined' || typeof (first.DocumentId) != 'undefined' || typeof (first.SaleId) != 'undefined' || typeof (first.SelectionId) != 'undefined' || typeof (first.ProjectId) != 'undefined' || typeof (first.CustomTags) != 'undefined' || typeof (first.UiCulture) != 'undefined')) {
            _request = contactId;
            _options = personId;
        }
        else {
            _request = {
                ContactId: contactId,
                PersonId: personId,
                AppointmentId: appointmentId,
                DocumentId: documentId,
                SaleId: saleId,
                SelectionId: selectionId,
                ProjectId: projectId,
                CustomTags: customTags,
                UiCulture: uiCulture,
            };
            _options = webapi_options;
        }
        return this._CreateNewPhysicalDocumentFromTemplateWithCustomTags2(_request, _options);
    }
    async _SubstituteTemplateVariables(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteTemplateVariables", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SubstituteTemplateVariables(source, generatorEncoding, contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, cultureName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = source;
        if (typeof (first) === "object" && first && (typeof (first.Source) != 'undefined' || typeof (first.GeneratorEncoding) != 'undefined' || typeof (first.ContactId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.AppointmentId) != 'undefined' || typeof (first.DocumentId) != 'undefined' || typeof (first.SaleId) != 'undefined' || typeof (first.SelectionId) != 'undefined' || typeof (first.ProjectId) != 'undefined' || typeof (first.CultureName) != 'undefined')) {
            _request = source;
            _options = generatorEncoding;
        }
        else {
            _request = {
                Source: source,
                GeneratorEncoding: generatorEncoding,
                ContactId: contactId,
                PersonId: personId,
                AppointmentId: appointmentId,
                DocumentId: documentId,
                SaleId: saleId,
                SelectionId: selectionId,
                ProjectId: projectId,
                CultureName: cultureName,
            };
            _options = webapi_options;
        }
        return this._SubstituteTemplateVariables(_request, _options);
    }
    async _SubstituteTemplateVariablesWithCustomTags(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteTemplateVariablesWithCustomTags", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SubstituteTemplateVariablesWithCustomTags(source, generatorEncoding, customTags, customValues, contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, cultureName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = source;
        if (typeof (first) === "object" && first && (typeof (first.Source) != 'undefined' || typeof (first.GeneratorEncoding) != 'undefined' || typeof (first.CustomTags) != 'undefined' || typeof (first.CustomValues) != 'undefined' || typeof (first.ContactId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.AppointmentId) != 'undefined' || typeof (first.DocumentId) != 'undefined' || typeof (first.SaleId) != 'undefined' || typeof (first.SelectionId) != 'undefined' || typeof (first.ProjectId) != 'undefined' || typeof (first.CultureName) != 'undefined')) {
            _request = source;
            _options = generatorEncoding;
        }
        else {
            _request = {
                Source: source,
                GeneratorEncoding: generatorEncoding,
                CustomTags: customTags,
                CustomValues: customValues,
                ContactId: contactId,
                PersonId: personId,
                AppointmentId: appointmentId,
                DocumentId: documentId,
                SaleId: saleId,
                SelectionId: selectionId,
                ProjectId: projectId,
                CultureName: cultureName,
            };
            _options = webapi_options;
        }
        return this._SubstituteTemplateVariablesWithCustomTags(_request, _options);
    }
    async _SubstituteTemplateVariablesWithCustomTags2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteTemplateVariablesWithCustomTags2", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SubstituteTemplateVariablesWithCustomTags2(source, generatorEncoding, customTags, contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, cultureName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = source;
        if (typeof (first) === "object" && first && (typeof (first.Source) != 'undefined' || typeof (first.GeneratorEncoding) != 'undefined' || typeof (first.CustomTags) != 'undefined' || typeof (first.ContactId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.AppointmentId) != 'undefined' || typeof (first.DocumentId) != 'undefined' || typeof (first.SaleId) != 'undefined' || typeof (first.SelectionId) != 'undefined' || typeof (first.ProjectId) != 'undefined' || typeof (first.CultureName) != 'undefined')) {
            _request = source;
            _options = generatorEncoding;
        }
        else {
            _request = {
                Source: source,
                GeneratorEncoding: generatorEncoding,
                CustomTags: customTags,
                ContactId: contactId,
                PersonId: personId,
                AppointmentId: appointmentId,
                DocumentId: documentId,
                SaleId: saleId,
                SelectionId: selectionId,
                ProjectId: projectId,
                CultureName: cultureName,
            };
            _options = webapi_options;
        }
        return this._SubstituteTemplateVariablesWithCustomTags2(_request, _options);
    }
    async _CreateTempFile(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTempFile", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateTempFile(filename, dataStream, webapi_options) {
        let _request = null;
        let _options = null;
        const first = filename;
        if (typeof (first) === "object" && first && (typeof (first.Filename) != 'undefined' || typeof (first.DataStream) != 'undefined')) {
            _request = filename;
            _options = dataStream;
        }
        else {
            _request = {
                Filename: filename,
                DataStream: dataStream,
            };
            _options = webapi_options;
        }
        _request.DataStream = (0, Base64_1.ToBase64)(_request.DataStream);
        return this._CreateTempFile(_request, _options);
    }
    async _GetTempFile(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTempFile", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTempFile(filename, webapi_options) {
        let _request = null;
        let _options = null;
        const first = filename;
        if (typeof (first) === "object" && first && (typeof (first.Filename) != 'undefined')) {
            _request = filename;
            _options = webapi_options;
        }
        else {
            _request = {
                Filename: filename,
            };
            _options = webapi_options;
        }
        return this._GetTempFile(_request, _options);
    }
    async _DeleteTempFile(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteTempFile", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteTempFile(filename, webapi_options) {
        let _request = null;
        let _options = null;
        const first = filename;
        if (typeof (first) === "object" && first && (typeof (first.Filename) != 'undefined')) {
            _request = filename;
            _options = webapi_options;
        }
        else {
            _request = {
                Filename: filename,
            };
            _options = webapi_options;
        }
        return this._DeleteTempFile(_request, _options);
    }
    async _SetTemplateStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTemplateStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetTemplateStream(filename, personal, stream, webapi_options) {
        let _request = null;
        let _options = null;
        const first = filename;
        if (typeof (first) === "object" && first && (typeof (first.Filename) != 'undefined' || typeof (first.Personal) != 'undefined' || typeof (first.Stream) != 'undefined')) {
            _request = filename;
            _options = personal;
        }
        else {
            _request = {
                Filename: filename,
                Personal: personal,
                Stream: stream,
            };
            _options = webapi_options;
        }
        _request.Stream = (0, Base64_1.ToBase64)(_request.Stream);
        return this._SetTemplateStream(_request, _options);
    }
    async _CreateNewPhysicalDocumentFromTemplate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewPhysicalDocumentFromTemplate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateNewPhysicalDocumentFromTemplate(contactId, personId, appointmentId, documentId, saleId, selectionId, projectId, uiCulture, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.AppointmentId) != 'undefined' || typeof (first.DocumentId) != 'undefined' || typeof (first.SaleId) != 'undefined' || typeof (first.SelectionId) != 'undefined' || typeof (first.ProjectId) != 'undefined' || typeof (first.UiCulture) != 'undefined')) {
            _request = contactId;
            _options = personId;
        }
        else {
            _request = {
                ContactId: contactId,
                PersonId: personId,
                AppointmentId: appointmentId,
                DocumentId: documentId,
                SaleId: saleId,
                SelectionId: selectionId,
                ProjectId: projectId,
                UiCulture: uiCulture,
            };
            _options = webapi_options;
        }
        return this._CreateNewPhysicalDocumentFromTemplate(_request, _options);
    }
    async _SubstituteMergeDocumentTemplateVariables(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteMergeDocumentTemplateVariables", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SubstituteMergeDocumentTemplateVariables(documentId, associateId, customTags, customValues, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.AssociateId) != 'undefined' || typeof (first.CustomTags) != 'undefined' || typeof (first.CustomValues) != 'undefined')) {
            _request = documentId;
            _options = associateId;
        }
        else {
            _request = {
                DocumentId: documentId,
                AssociateId: associateId,
                CustomTags: customTags,
                CustomValues: customValues,
            };
            _options = webapi_options;
        }
        return this._SubstituteMergeDocumentTemplateVariables(_request, _options);
    }
    async _SubstituteMergeDocumentTemplateVariables2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteMergeDocumentTemplateVariables2", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SubstituteMergeDocumentTemplateVariables2(documentId, associateId, customTags, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.AssociateId) != 'undefined' || typeof (first.CustomTags) != 'undefined')) {
            _request = documentId;
            _options = associateId;
        }
        else {
            _request = {
                DocumentId: documentId,
                AssociateId: associateId,
                CustomTags: customTags,
            };
            _options = webapi_options;
        }
        return this._SubstituteMergeDocumentTemplateVariables2(_request, _options);
    }
    async _SubstituteTemplateVariablesEx(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteTemplateVariablesEx", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SubstituteTemplateVariablesEx(parameters, webapi_options) {
        let _request = null;
        let _options = null;
        const first = parameters;
        if (typeof (first) === "object" && first && (typeof (first.Parameters) != 'undefined')) {
            _request = parameters;
            _options = webapi_options;
        }
        else {
            _request = {
                Parameters: parameters,
            };
            _options = webapi_options;
        }
        return this._SubstituteTemplateVariablesEx(_request, _options);
    }
    async _VerifyGetDocumentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("VerifyGetDocumentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async VerifyGetDocumentStream(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._VerifyGetDocumentStream(_request, _options);
    }
    async _SubstituteMergeDocumentTemplateVariablesEx(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteMergeDocumentTemplateVariablesEx", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SubstituteMergeDocumentTemplateVariablesEx(mergeDocumentId, contactId, personId, projectId, selectionId, appointmentId, documentId, saleId, customTags, customValues, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mergeDocumentId;
        if (typeof (first) === "object" && first && (typeof (first.MergeDocumentId) != 'undefined' || typeof (first.ContactId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.ProjectId) != 'undefined' || typeof (first.SelectionId) != 'undefined' || typeof (first.AppointmentId) != 'undefined' || typeof (first.DocumentId) != 'undefined' || typeof (first.SaleId) != 'undefined' || typeof (first.CustomTags) != 'undefined' || typeof (first.CustomValues) != 'undefined')) {
            _request = mergeDocumentId;
            _options = contactId;
        }
        else {
            _request = {
                MergeDocumentId: mergeDocumentId,
                ContactId: contactId,
                PersonId: personId,
                ProjectId: projectId,
                SelectionId: selectionId,
                AppointmentId: appointmentId,
                DocumentId: documentId,
                SaleId: saleId,
                CustomTags: customTags,
                CustomValues: customValues,
            };
            _options = webapi_options;
        }
        return this._SubstituteMergeDocumentTemplateVariablesEx(_request, _options);
    }
    async _SubstituteMergeDocumentTemplateVariablesEx2(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SubstituteMergeDocumentTemplateVariablesEx2", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SubstituteMergeDocumentTemplateVariablesEx2(mergeDocumentId, contactId, personId, projectId, selectionId, appointmentId, documentId, saleId, customTags, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mergeDocumentId;
        if (typeof (first) === "object" && first && (typeof (first.MergeDocumentId) != 'undefined' || typeof (first.ContactId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.ProjectId) != 'undefined' || typeof (first.SelectionId) != 'undefined' || typeof (first.AppointmentId) != 'undefined' || typeof (first.DocumentId) != 'undefined' || typeof (first.SaleId) != 'undefined' || typeof (first.CustomTags) != 'undefined')) {
            _request = mergeDocumentId;
            _options = contactId;
        }
        else {
            _request = {
                MergeDocumentId: mergeDocumentId,
                ContactId: contactId,
                PersonId: personId,
                ProjectId: projectId,
                SelectionId: selectionId,
                AppointmentId: appointmentId,
                DocumentId: documentId,
                SaleId: saleId,
                CustomTags: customTags,
            };
            _options = webapi_options;
        }
        return this._SubstituteMergeDocumentTemplateVariablesEx2(_request, _options);
    }
    async _GetDocumentUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentUrl(documentId, versionId, writeableUrl, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.VersionId) != 'undefined' || typeof (first.WriteableUrl) != 'undefined')) {
            _request = documentId;
            _options = versionId;
        }
        else {
            _request = {
                DocumentId: documentId,
                VersionId: versionId,
                WriteableUrl: writeableUrl,
            };
            _options = webapi_options;
        }
        return this._GetDocumentUrl(_request, _options);
    }
    async _DeletePhysicalDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeletePhysicalDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReturnInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeletePhysicalDocument(documentId, allowedReturnType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.AllowedReturnType) != 'undefined')) {
            _request = documentId;
            _options = allowedReturnType;
        }
        else {
            _request = {
                DocumentId: documentId,
                AllowedReturnType: allowedReturnType,
            };
            _options = webapi_options;
        }
        return this._DeletePhysicalDocument(_request, _options);
    }
    async _RenameDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RenameDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RenameDocument(documentId, newFilename, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.NewFilename) != 'undefined')) {
            _request = documentId;
            _options = newFilename;
        }
        else {
            _request = {
                DocumentId: documentId,
                NewFilename: newFilename,
            };
            _options = webapi_options;
        }
        return this._RenameDocument(_request, _options);
    }
    async _GetCheckoutState(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCheckoutState", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CheckoutInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCheckoutState(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetCheckoutState(_request, _options);
    }
    async _CheckoutDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckoutDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReturnInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CheckoutDocument(documentId, allowedReturnTypes, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.AllowedReturnTypes) != 'undefined')) {
            _request = documentId;
            _options = allowedReturnTypes;
        }
        else {
            _request = {
                DocumentId: documentId,
                AllowedReturnTypes: allowedReturnTypes,
            };
            _options = webapi_options;
        }
        return this._CheckoutDocument(_request, _options);
    }
    async _CheckinDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckinDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReturnInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CheckinDocument(documentId, allowedReturnTypes, versionDescription, versionExtraFields, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.AllowedReturnTypes) != 'undefined' || typeof (first.VersionDescription) != 'undefined' || typeof (first.VersionExtraFields) != 'undefined')) {
            _request = documentId;
            _options = allowedReturnTypes;
        }
        else {
            _request = {
                DocumentId: documentId,
                AllowedReturnTypes: allowedReturnTypes,
                VersionDescription: versionDescription,
                VersionExtraFields: versionExtraFields,
            };
            _options = webapi_options;
        }
        return this._CheckinDocument(_request, _options);
    }
    async _UndoCheckoutDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UndoCheckoutDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReturnInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UndoCheckoutDocument(documentId, allowedReturnTypes, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.AllowedReturnTypes) != 'undefined')) {
            _request = documentId;
            _options = allowedReturnTypes;
        }
        else {
            _request = {
                DocumentId: documentId,
                AllowedReturnTypes: allowedReturnTypes,
            };
            _options = webapi_options;
        }
        return this._UndoCheckoutDocument(_request, _options);
    }
    async _GetVersionList(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetVersionList", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_VersionInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetVersionList(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetVersionList(_request, _options);
    }
    async _GetPluginList(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPluginList", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get a list of installed document plugins
     * @returns Dictionary mapping plugin id=plugin name
     */
    async GetPluginList(webapi_options) {
        return this._GetPluginList(webapi_options);
    }
    async _GetPluginCapabilities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPluginCapabilities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPluginCapabilities(pluginId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = pluginId;
        if (typeof (first) === "object" && first && (typeof (first.PluginId) != 'undefined')) {
            _request = pluginId;
            _options = webapi_options;
        }
        else {
            _request = {
                PluginId: pluginId,
            };
            _options = webapi_options;
        }
        return this._GetPluginCapabilities(_request, _options);
    }
    async _GetDocumentProperties(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentProperties", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentProperties(documentId, requestedProperties, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.RequestedProperties) != 'undefined')) {
            _request = documentId;
            _options = requestedProperties;
        }
        else {
            _request = {
                DocumentId: documentId,
                RequestedProperties: requestedProperties,
            };
            _options = webapi_options;
        }
        return this._GetDocumentProperties(_request, _options);
    }
    async _GetDocumentCommands(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentCommands", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CommandInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentCommands(documentId, allowedReturnTypes, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.AllowedReturnTypes) != 'undefined')) {
            _request = documentId;
            _options = allowedReturnTypes;
        }
        else {
            _request = {
                DocumentId: documentId,
                AllowedReturnTypes: allowedReturnTypes,
            };
            _options = webapi_options;
        }
        return this._GetDocumentCommands(_request, _options);
    }
    async _ExecuteDocumentCommand(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ExecuteDocumentCommand", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReturnInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ExecuteDocumentCommand(documentId, versionId, allowedReturnTypes, command, additionalData, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.VersionId) != 'undefined' || typeof (first.AllowedReturnTypes) != 'undefined' || typeof (first.Command) != 'undefined' || typeof (first.AdditionalData) != 'undefined')) {
            _request = documentId;
            _options = versionId;
        }
        else {
            _request = {
                DocumentId: documentId,
                VersionId: versionId,
                AllowedReturnTypes: allowedReturnTypes,
                Command: command,
                AdditionalData: additionalData,
            };
            _options = webapi_options;
        }
        return this._ExecuteDocumentCommand(_request, _options);
    }
    async _CreateDefaultDocumentEntityFromSuggestion(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultDocumentEntityFromSuggestion", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultDocumentEntityFromSuggestion(suggestedDocumentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = suggestedDocumentId;
        if (typeof (first) === "object" && first && (typeof (first.SuggestedDocumentId) != 'undefined')) {
            _request = suggestedDocumentId;
            _options = webapi_options;
        }
        else {
            _request = {
                SuggestedDocumentId: suggestedDocumentId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultDocumentEntityFromSuggestion(_request, _options);
    }
    async _SaveDocumentTemplateStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDocumentTemplateStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TemplateInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveDocumentTemplateStream(documentTemplateId, content, languageCode, pluginId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined' || typeof (first.Content) != 'undefined' || typeof (first.LanguageCode) != 'undefined' || typeof (first.PluginId) != 'undefined')) {
            _request = documentTemplateId;
            _options = content;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
                Content: content,
                LanguageCode: languageCode,
                PluginId: pluginId,
            };
            _options = webapi_options;
        }
        _request.Content = (0, Base64_1.ToBase64)(_request.Content);
        return this._SaveDocumentTemplateStream(_request, _options);
    }
    async _SetDocumentStreamFromId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentStreamFromId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDocumentStreamFromId(documentId, stream, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.Stream) != 'undefined')) {
            _request = documentId;
            _options = stream;
        }
        else {
            _request = {
                DocumentId: documentId,
                Stream: stream,
            };
            _options = webapi_options;
        }
        _request.Stream = (0, Base64_1.ToBase64)(_request.Stream);
        return this._SetDocumentStreamFromId(_request, _options);
    }
    async _SavePrivacyReport(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SavePrivacyReport", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SavePrivacyReport(htmlReport, title, personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = htmlReport;
        if (typeof (first) === "object" && first && (typeof (first.HtmlReport) != 'undefined' || typeof (first.Title) != 'undefined' || typeof (first.PersonId) != 'undefined')) {
            _request = htmlReport;
            _options = title;
        }
        else {
            _request = {
                HtmlReport: htmlReport,
                Title: title,
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._SavePrivacyReport(_request, _options);
    }
    async _ValidateDocumentEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateDocumentEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateDocumentEntity(documentEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentEntity;
        if (typeof (first) === "object" && first && (typeof (first.DocumentEntity) != 'undefined')) {
            _request = documentEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentEntity: documentEntity,
            };
            _options = webapi_options;
        }
        return this._ValidateDocumentEntity(_request, _options);
    }
    async _GetDocumentLength(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentLength", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentLength(documentId, versionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined' || typeof (first.VersionId) != 'undefined')) {
            _request = documentId;
            _options = versionId;
        }
        else {
            _request = {
                DocumentId: documentId,
                VersionId: versionId,
            };
            _options = webapi_options;
        }
        return this._GetDocumentLength(_request, _options);
    }
    /*
     * Gets an array of Document objects.
     * @param documentIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Document
     */
    async GetDocumentList(documentIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentList", documentIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetAppointmentDocuments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppointmentDocuments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAppointmentDocuments(appointmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined')) {
            _request = appointmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
            };
            _options = webapi_options;
        }
        return this._GetAppointmentDocuments(_request, _options);
    }
    async _GetSaleDocuments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSaleDocuments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSaleDocuments(saleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined')) {
            _request = saleId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleId: saleId,
            };
            _options = webapi_options;
        }
        return this._GetSaleDocuments(_request, _options);
    }
    async _GetPersonDocuments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocuments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonDocuments(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetPersonDocuments(_request, _options);
    }
    async _GetPublishedDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Document_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedDocument(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._GetPublishedDocument(_request, _options);
    }
    async _GetPublishedDocuments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedDocuments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedDocuments(documentIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentIds;
        if (typeof (first) === "object" && first && (typeof (first.DocumentIds) != 'undefined')) {
            _request = documentIds;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentIds: documentIds,
            };
            _options = webapi_options;
        }
        return this._GetPublishedDocuments(_request, _options);
    }
    async _GetMyPublishedDocuments(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyPublishedDocuments", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     *
     * @returns Array of documents
     */
    async GetMyPublishedDocuments(webapi_options) {
        return this._GetMyPublishedDocuments(webapi_options);
    }
    async _GetPublishedDocumentsByDate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedDocumentsByDate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedDocumentsByDate(personId, includeProjectDocuments, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectDocuments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = personId;
            _options = includeProjectDocuments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectDocuments: includeProjectDocuments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetPublishedDocumentsByDate(_request, _options);
    }
    async _GetContactDocumentsByTemplateTypes(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactDocumentsByTemplateTypes", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactDocumentsByTemplateTypes(contactId, startTime, endTime, count, documentTemplateIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.DocumentTemplateIds) != 'undefined')) {
            _request = contactId;
            _options = startTime;
        }
        else {
            _request = {
                ContactId: contactId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                DocumentTemplateIds: documentTemplateIds,
            };
            _options = webapi_options;
        }
        return this._GetContactDocumentsByTemplateTypes(_request, _options);
    }
    async _GetContactDocumentsByTemplateType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactDocumentsByTemplateType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactDocumentsByTemplateType(contactId, startTime, endTime, count, documentTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.DocumentTemplateId) != 'undefined')) {
            _request = contactId;
            _options = startTime;
        }
        else {
            _request = {
                ContactId: contactId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                DocumentTemplateId: documentTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetContactDocumentsByTemplateType(_request, _options);
    }
    async _GetContactDocumentsByTemplateHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactDocumentsByTemplateHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactDocumentsByTemplateHeading(contactId, startTime, endTime, count, templateHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TemplateHeadingId) != 'undefined')) {
            _request = contactId;
            _options = startTime;
        }
        else {
            _request = {
                ContactId: contactId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TemplateHeadingId: templateHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetContactDocumentsByTemplateHeading(_request, _options);
    }
    async _GetContactDocuments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetContactDocuments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetContactDocuments(contactId, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = contactId;
            _options = startTime;
        }
        else {
            _request = {
                ContactId: contactId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetContactDocuments(_request, _options);
    }
    async _GetPublishedPersonDocumentsByDate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedPersonDocumentsByDate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedPersonDocumentsByDate(personId, includeProjectDocuments, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectDocuments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = personId;
            _options = includeProjectDocuments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectDocuments: includeProjectDocuments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetPublishedPersonDocumentsByDate(_request, _options);
    }
    async _GetPublishedProjectDocuments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProjectDocuments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedProjectDocuments(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetPublishedProjectDocuments(_request, _options);
    }
    async _GetProjectMemberDocumentsByTemplateTypes(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberDocumentsByTemplateTypes", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMemberDocumentsByTemplateTypes(personId, startTime, endTime, count, documentTemplateIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.DocumentTemplateIds) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                DocumentTemplateIds: documentTemplateIds,
            };
            _options = webapi_options;
        }
        return this._GetProjectMemberDocumentsByTemplateTypes(_request, _options);
    }
    async _GetProjectMemberDocumentsByTemplateType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberDocumentsByTemplateType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMemberDocumentsByTemplateType(personId, startTime, endTime, count, documentTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.DocumentTemplateId) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                DocumentTemplateId: documentTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetProjectMemberDocumentsByTemplateType(_request, _options);
    }
    async _GetProjectMemberDocumentsByTemplateHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberDocumentsByTemplateHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMemberDocumentsByTemplateHeading(personId, startTime, endTime, count, templateHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TemplateHeadingId) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TemplateHeadingId: templateHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetProjectMemberDocumentsByTemplateHeading(_request, _options);
    }
    async _GetProjectMemberDocuments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMemberDocuments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMemberDocuments(personId, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = personId;
            _options = startTime;
        }
        else {
            _request = {
                PersonId: personId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetProjectMemberDocuments(_request, _options);
    }
    async _GetProjectDocumentsByTemplateTypes(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectDocumentsByTemplateTypes", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectDocumentsByTemplateTypes(projectId, startTime, endTime, count, documentTemplateIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.DocumentTemplateIds) != 'undefined')) {
            _request = projectId;
            _options = startTime;
        }
        else {
            _request = {
                ProjectId: projectId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                DocumentTemplateIds: documentTemplateIds,
            };
            _options = webapi_options;
        }
        return this._GetProjectDocumentsByTemplateTypes(_request, _options);
    }
    async _GetProjectDocumentsByTemplateType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectDocumentsByTemplateType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectDocumentsByTemplateType(projectId, startTime, endTime, count, documentTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.DocumentTemplateId) != 'undefined')) {
            _request = projectId;
            _options = startTime;
        }
        else {
            _request = {
                ProjectId: projectId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                DocumentTemplateId: documentTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetProjectDocumentsByTemplateType(_request, _options);
    }
    async _GetProjectDocumentsByTemplateHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectDocumentsByTemplateHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectDocumentsByTemplateHeading(projectId, startTime, endTime, count, templateHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TemplateHeadingId) != 'undefined')) {
            _request = projectId;
            _options = startTime;
        }
        else {
            _request = {
                ProjectId: projectId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TemplateHeadingId: templateHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetProjectDocumentsByTemplateHeading(_request, _options);
    }
    async _GetProjectDocuments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectDocuments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectDocuments(projectId, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = projectId;
            _options = startTime;
        }
        else {
            _request = {
                ProjectId: projectId,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetProjectDocuments(_request, _options);
    }
    async _GetPersonDocumentsByTemplateTypes(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocumentsByTemplateTypes", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonDocumentsByTemplateTypes(personId, includeProjectDocuments, startTime, endTime, count, documentTemplateIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectDocuments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.DocumentTemplateIds) != 'undefined')) {
            _request = personId;
            _options = includeProjectDocuments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectDocuments: includeProjectDocuments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                DocumentTemplateIds: documentTemplateIds,
            };
            _options = webapi_options;
        }
        return this._GetPersonDocumentsByTemplateTypes(_request, _options);
    }
    async _GetPersonDocumentsByTemplateType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocumentsByTemplateType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonDocumentsByTemplateType(personId, includeProjectDocuments, startTime, endTime, count, documentTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectDocuments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.DocumentTemplateId) != 'undefined')) {
            _request = personId;
            _options = includeProjectDocuments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectDocuments: includeProjectDocuments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                DocumentTemplateId: documentTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetPersonDocumentsByTemplateType(_request, _options);
    }
    async _GetPersonDocumentsByTemplateHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocumentsByTemplateHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonDocumentsByTemplateHeading(personId, includeProjectDocuments, startTime, endTime, count, templateHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectDocuments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined' || typeof (first.TemplateHeadingId) != 'undefined')) {
            _request = personId;
            _options = includeProjectDocuments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectDocuments: includeProjectDocuments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
                TemplateHeadingId: templateHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetPersonDocumentsByTemplateHeading(_request, _options);
    }
    async _GetPersonDocumentsByDate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonDocumentsByDate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonDocumentsByDate(personId, includeProjectDocuments, startTime, endTime, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.IncludeProjectDocuments) != 'undefined' || typeof (first.StartTime) != 'undefined' || typeof (first.EndTime) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = personId;
            _options = includeProjectDocuments;
        }
        else {
            _request = {
                PersonId: personId,
                IncludeProjectDocuments: includeProjectDocuments,
                StartTime: startTime,
                EndTime: endTime,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetPersonDocumentsByDate(_request, _options);
    }
    async _GetDocumentsByTemplateHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentsByTemplateHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentsByTemplateHeading(templateHeadingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = templateHeadingId;
        if (typeof (first) === "object" && first && (typeof (first.TemplateHeadingId) != 'undefined')) {
            _request = templateHeadingId;
            _options = webapi_options;
        }
        else {
            _request = {
                TemplateHeadingId: templateHeadingId,
            };
            _options = webapi_options;
        }
        return this._GetDocumentsByTemplateHeading(_request, _options);
    }
    /*
     * Gets a SuggestedDocumentEntity object.
     * @param suggestedDocumentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SuggestedDocumentEntity
     */
    async GetSuggestedDocumentEntity(suggestedDocumentEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSuggestedDocumentEntity?suggestedDocumentEntityId=" + suggestedDocumentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SuggestedDocumentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
} // class v1DocumentAgentController 
exports.DocumentAgent = DocumentAgent;
//# sourceMappingURL=DocumentAgent.js.map
"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErpSyncAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Services for the ERP Integration Services feature
 */
class ErpSyncAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/ErpSync/";
        super(options);
    }
    /**
     * Set default values into a new ErpSyncConnectorEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultErpSyncConnectorEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultErpSyncConnectorEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncConnectorEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ErpSyncConnectorEntity or creates a new ErpSyncConnectorEntity if the id parameter is empty
     * @param entity - The ErpSyncConnectorEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ErpSyncConnectorEntity
     */
    async SaveErpSyncConnectorEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveErpSyncConnectorEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncConnectorEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ErpSyncConnectorEntity
     * @param ErpSyncConnectorEntityId - The id of the ErpSyncConnectorEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteErpSyncConnectorEntity(ErpSyncConnectorEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteErpSyncConnectorEntity?ErpSyncConnectorEntityId=" + ErpSyncConnectorEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetConnection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpConnection_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConnection(erpConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined')) {
            _request = erpConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
            };
            _options = webapi_options;
        }
        return this._GetConnection(_request, _options);
    }
    async _SaveConnection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConnection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpConnection_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveConnection(connection, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connection;
        if (typeof (first) === "object" && first && (typeof (first.Connection) != 'undefined')) {
            _request = connection;
            _options = webapi_options;
        }
        else {
            _request = {
                Connection: connection,
            };
            _options = webapi_options;
        }
        return this._SaveConnection(_request, _options);
    }
    async _DeleteConnection(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteConnection", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteConnection(erpConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined')) {
            _request = erpConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
            };
            _options = webapi_options;
        }
        return this._DeleteConnection(_request, _options);
    }
    async _GetConfigurationFields(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConfigurationFields", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FieldMetadataArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConfigurationFields(erpConnectorId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectorId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectorId) != 'undefined')) {
            _request = erpConnectorId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpConnectorId: erpConnectorId,
            };
            _options = webapi_options;
        }
        return this._GetConfigurationFields(_request, _options);
    }
    async _GetErpConnectionConfigFields(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetErpConnectionConfigFields", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetErpConnectionConfigFields(erpConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined')) {
            _request = erpConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
            };
            _options = webapi_options;
        }
        return this._GetErpConnectionConfigFields(_request, _options);
    }
    async _ToggleErpConnectionActive(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleErpConnectionActive", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleErpConnectionActive(erpConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined')) {
            _request = erpConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
            };
            _options = webapi_options;
        }
        return this._ToggleErpConnectionActive(_request, _options);
    }
    async _TestConnectionById(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestConnectionById", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async TestConnectionById(erpConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined')) {
            _request = erpConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
            };
            _options = webapi_options;
        }
        return this._TestConnectionById(_request, _options);
    }
    async _TestConnectionByConfig(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestConnectionByConfig", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async TestConnectionByConfig(erpConnectionId, configFields, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.ConfigFields) != 'undefined')) {
            _request = erpConnectionId;
            _options = configFields;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                ConfigFields: configFields,
            };
            _options = webapi_options;
        }
        return this._TestConnectionByConfig(_request, _options);
    }
    async _SaveErpConnectionSyncPriorities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveErpConnectionSyncPriorities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveErpConnectionSyncPriorities(erpConnectionIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionIds;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionIds) != 'undefined')) {
            _request = erpConnectionIds;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpConnectionIds: erpConnectionIds,
            };
            _options = webapi_options;
        }
        return this._SaveErpConnectionSyncPriorities(_request, _options);
    }
    async _MoveErpFieldItem(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveErpFieldItem", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MoveErpFieldItem(erpFieldId, direction, erpConnectionId, erpActorType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpFieldId;
        if (typeof (first) === "object" && first && (typeof (first.ErpFieldId) != 'undefined' || typeof (first.Direction) != 'undefined' || typeof (first.ErpConnectionId) != 'undefined' || typeof (first.ErpActorType) != 'undefined')) {
            _request = erpFieldId;
            _options = direction;
        }
        else {
            _request = {
                ErpFieldId: erpFieldId,
                Direction: direction,
                ErpConnectionId: erpConnectionId,
                ErpActorType: erpActorType,
            };
            _options = webapi_options;
        }
        return this._MoveErpFieldItem(_request, _options);
    }
    async _SupportsAdvancedSearch(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SupportsAdvancedSearch", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SupportsAdvancedSearch(erpConnectionId, erpActorType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.ErpActorType) != 'undefined')) {
            _request = erpConnectionId;
            _options = erpActorType;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                ErpActorType: erpActorType,
            };
            _options = webapi_options;
        }
        return this._SupportsAdvancedSearch(_request, _options);
    }
    async _GetAllConnectors(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllConnectors", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all ERP Sync connectors. Uses the `ErpConnector` archive.
     * @returns The connector id, name, url
     */
    async GetAllConnectors(webapi_options) {
        return this._GetAllConnectors(webapi_options);
    }
    async _GetAllConnections(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllConnections", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpConnectionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllConnections(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllConnections(_request, _options);
    }
    async _GetConnectionsAndDisplayFields(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionsAndDisplayFields", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpConnectionDataArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConnectionsAndDisplayFields(crmActorType, entityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = crmActorType;
        if (typeof (first) === "object" && first && (typeof (first.CrmActorType) != 'undefined' || typeof (first.EntityId) != 'undefined')) {
            _request = crmActorType;
            _options = entityId;
        }
        else {
            _request = {
                CrmActorType: crmActorType,
                EntityId: entityId,
            };
            _options = webapi_options;
        }
        return this._GetConnectionsAndDisplayFields(_request, _options);
    }
    async _GetErpFieldValues(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetErpFieldValues", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetErpFieldValues(erpConnectionId, crmActorType, entityId, fieldKeys, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.CrmActorType) != 'undefined' || typeof (first.EntityId) != 'undefined' || typeof (first.FieldKeys) != 'undefined')) {
            _request = erpConnectionId;
            _options = crmActorType;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                CrmActorType: crmActorType,
                EntityId: entityId,
                FieldKeys: fieldKeys,
            };
            _options = webapi_options;
        }
        return this._GetErpFieldValues(_request, _options);
    }
    async _GetFieldsForNewErpActor(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFieldsForNewErpActor", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_FieldMetadataArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFieldsForNewErpActor(erpConnectionId, erpActorType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.ErpActorType) != 'undefined')) {
            _request = erpConnectionId;
            _options = erpActorType;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                ErpActorType: erpActorType,
            };
            _options = webapi_options;
        }
        return this._GetFieldsForNewErpActor(_request, _options);
    }
    async _GetConnectionListMappings(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConnectionListMappings", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpConnectionListMappingContainer_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConnectionListMappings(erpConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined')) {
            _request = erpConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
            };
            _options = webapi_options;
        }
        return this._GetConnectionListMappings(_request, _options);
    }
    async _SaveConnectionListMappings(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConnectionListMappings", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpConnectionListMappingContainer_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveConnectionListMappings(listMapping, webapi_options) {
        let _request = null;
        let _options = null;
        const first = listMapping;
        if (typeof (first) === "object" && first && (typeof (first.ListMapping) != 'undefined')) {
            _request = listMapping;
            _options = webapi_options;
        }
        else {
            _request = {
                ListMapping: listMapping,
            };
            _options = webapi_options;
        }
        return this._SaveConnectionListMappings(_request, _options);
    }
    async _ConnectActor(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ConnectActor", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ConnectActor(erpConnectionId, crmRecordId, crmActorType, erpKey, erpActorType, fieldValues, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.CrmRecordId) != 'undefined' || typeof (first.CrmActorType) != 'undefined' || typeof (first.ErpKey) != 'undefined' || typeof (first.ErpActorType) != 'undefined' || typeof (first.FieldValues) != 'undefined')) {
            _request = erpConnectionId;
            _options = crmRecordId;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                CrmRecordId: crmRecordId,
                CrmActorType: crmActorType,
                ErpKey: erpKey,
                ErpActorType: erpActorType,
                FieldValues: fieldValues,
            };
            _options = webapi_options;
        }
        return this._ConnectActor(_request, _options);
    }
    async _TryConnectActor(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TryConnectActor", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async TryConnectActor(erpConnectionId, crmRecordId, crmActorType, erpKey, erpActorType, fieldValues, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.CrmRecordId) != 'undefined' || typeof (first.CrmActorType) != 'undefined' || typeof (first.ErpKey) != 'undefined' || typeof (first.ErpActorType) != 'undefined' || typeof (first.FieldValues) != 'undefined')) {
            _request = erpConnectionId;
            _options = crmRecordId;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                CrmRecordId: crmRecordId,
                CrmActorType: crmActorType,
                ErpKey: erpKey,
                ErpActorType: erpActorType,
                FieldValues: fieldValues,
            };
            _options = webapi_options;
        }
        return this._TryConnectActor(_request, _options);
    }
    async _GetFieldValuesFromCrm(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFieldValuesFromCrm", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncFieldValueArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFieldValuesFromCrm(recordId, actorTypeCrm, webapi_options) {
        let _request = null;
        let _options = null;
        const first = recordId;
        if (typeof (first) === "object" && first && (typeof (first.RecordId) != 'undefined' || typeof (first.ActorTypeCrm) != 'undefined')) {
            _request = recordId;
            _options = actorTypeCrm;
        }
        else {
            _request = {
                RecordId: recordId,
                ActorTypeCrm: actorTypeCrm,
            };
            _options = webapi_options;
        }
        return this._GetFieldValuesFromCrm(_request, _options);
    }
    async _GetFieldValuesFromErp(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFieldValuesFromErp", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncFieldValueArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFieldValuesFromErp(erpConnectionId, actorTypeErp, erpKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.ActorTypeErp) != 'undefined' || typeof (first.ErpKey) != 'undefined')) {
            _request = erpConnectionId;
            _options = actorTypeErp;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                ActorTypeErp: actorTypeErp,
                ErpKey: erpKey,
            };
            _options = webapi_options;
        }
        return this._GetFieldValuesFromErp(_request, _options);
    }
    async _GetActorTypeMapping(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetActorTypeMapping", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncActorTypeMapping_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetActorTypeMapping(erpConnectionId, actorType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.ActorType) != 'undefined')) {
            _request = erpConnectionId;
            _options = actorType;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                ActorType: actorType,
            };
            _options = webapi_options;
        }
        return this._GetActorTypeMapping(_request, _options);
    }
    async _CreateActorLink(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateActorLink", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateActorLink(erpConnectionId, crmRecordId, crmActorType, erpKey, erpActorType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.CrmRecordId) != 'undefined' || typeof (first.CrmActorType) != 'undefined' || typeof (first.ErpKey) != 'undefined' || typeof (first.ErpActorType) != 'undefined')) {
            _request = erpConnectionId;
            _options = crmRecordId;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                CrmRecordId: crmRecordId,
                CrmActorType: crmActorType,
                ErpKey: erpKey,
                ErpActorType: erpActorType,
            };
            _options = webapi_options;
        }
        return this._CreateActorLink(_request, _options);
    }
    async _BreakActorLink(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("BreakActorLink", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async BreakActorLink(erpConnectionId, crmRecordId, crmActorType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.CrmRecordId) != 'undefined' || typeof (first.CrmActorType) != 'undefined')) {
            _request = erpConnectionId;
            _options = crmRecordId;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                CrmRecordId: crmRecordId,
                CrmActorType: crmActorType,
            };
            _options = webapi_options;
        }
        return this._BreakActorLink(_request, _options);
    }
    async _CreateErpActorFromCrm(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateErpActorFromCrm", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateErpActorFromCrm(connectionId, crmEntityId, erpActorType, crmActorType, erpFieldKeyValues, webapi_options) {
        let _request = null;
        let _options = null;
        const first = connectionId;
        if (typeof (first) === "object" && first && (typeof (first.ConnectionId) != 'undefined' || typeof (first.CrmEntityId) != 'undefined' || typeof (first.ErpActorType) != 'undefined' || typeof (first.CrmActorType) != 'undefined' || typeof (first.ErpFieldKeyValues) != 'undefined')) {
            _request = connectionId;
            _options = crmEntityId;
        }
        else {
            _request = {
                ConnectionId: connectionId,
                CrmEntityId: crmEntityId,
                ErpActorType: erpActorType,
                CrmActorType: crmActorType,
                ErpFieldKeyValues: erpFieldKeyValues,
            };
            _options = webapi_options;
        }
        return this._CreateErpActorFromCrm(_request, _options);
    }
    async _SaveActorTypeMapping(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveActorTypeMapping", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncActorTypeMapping_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveActorTypeMapping(mapping, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mapping;
        if (typeof (first) === "object" && first && (typeof (first.Mapping) != 'undefined')) {
            _request = mapping;
            _options = webapi_options;
        }
        else {
            _request = {
                Mapping: mapping,
            };
            _options = webapi_options;
        }
        return this._SaveActorTypeMapping(_request, _options);
    }
    async _ValidateArchiveColumnConfig(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateArchiveColumnConfig", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateArchiveColumnConfig(listOwner, erpConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = listOwner;
        if (typeof (first) === "object" && first && (typeof (first.ListOwner) != 'undefined' || typeof (first.ErpConnectionId) != 'undefined')) {
            _request = listOwner;
            _options = erpConnectionId;
        }
        else {
            _request = {
                ListOwner: listOwner,
                ErpConnectionId: erpConnectionId,
            };
            _options = webapi_options;
        }
        return this._ValidateArchiveColumnConfig(_request, _options);
    }
    async _UpdateConnectionFields(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateConnectionFields", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateConnectionFields(erpConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined')) {
            _request = erpConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
            };
            _options = webapi_options;
        }
        return this._UpdateConnectionFields(_request, _options);
    }
    async _GetCrmActorType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCrmActorType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCrmActorType(erpConnectionId, erpActorType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.ErpActorType) != 'undefined')) {
            _request = erpConnectionId;
            _options = erpActorType;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                ErpActorType: erpActorType,
            };
            _options = webapi_options;
        }
        return this._GetCrmActorType(_request, _options);
    }
    async _GetErpSyncConnectionSummary(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetErpSyncConnectionSummary", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncConnectionSummary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetErpSyncConnectionSummary(erpSyncConnectionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpSyncConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpSyncConnectionId) != 'undefined')) {
            _request = erpSyncConnectionId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpSyncConnectionId: erpSyncConnectionId,
            };
            _options = webapi_options;
        }
        return this._GetErpSyncConnectionSummary(_request, _options);
    }
    /*
     * Gets a ErpSyncConnectorEntity object.
     * @param erpSyncConnectorEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ErpSyncConnectorEntity
     */
    async GetErpSyncConnectorEntity(erpSyncConnectorEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetErpSyncConnectorEntity?erpSyncConnectorEntityId=" + erpSyncConnectorEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncConnectorEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _CanDeleteErpSyncConnectorEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanDeleteErpSyncConnectorEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CanDeleteErpSyncConnectorEntity(erpSyncConnectorId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpSyncConnectorId;
        if (typeof (first) === "object" && first && (typeof (first.ErpSyncConnectorId) != 'undefined')) {
            _request = erpSyncConnectorId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpSyncConnectorId: erpSyncConnectorId,
            };
            _options = webapi_options;
        }
        return this._CanDeleteErpSyncConnectorEntity(_request, _options);
    }
    async _TestConnectorUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TestConnectorUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async TestConnectorUrl(url, webapi_options) {
        let _request = null;
        let _options = null;
        const first = url;
        if (typeof (first) === "object" && first && (typeof (first.Url) != 'undefined')) {
            _request = url;
            _options = webapi_options;
        }
        else {
            _request = {
                Url: url,
            };
            _options = webapi_options;
        }
        return this._TestConnectorUrl(_request, _options);
    }
    async _SaveDefaultValueInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDefaultValueInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncDefaultValue_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveDefaultValueInfo(erpSyncDefaultValue, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpSyncDefaultValue;
        if (typeof (first) === "object" && first && (typeof (first.ErpSyncDefaultValue) != 'undefined')) {
            _request = erpSyncDefaultValue;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpSyncDefaultValue: erpSyncDefaultValue,
            };
            _options = webapi_options;
        }
        return this._SaveDefaultValueInfo(_request, _options);
    }
    async _GetDefaultValueInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultValueInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncDefaultValue_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDefaultValueInfo(erpFieldId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpFieldId;
        if (typeof (first) === "object" && first && (typeof (first.ErpFieldId) != 'undefined')) {
            _request = erpFieldId;
            _options = webapi_options;
        }
        else {
            _request = {
                ErpFieldId: erpFieldId,
            };
            _options = webapi_options;
        }
        return this._GetDefaultValueInfo(_request, _options);
    }
    async _SyncAll(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SyncAll", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Sync all active connections
     * @returns The response
     */
    async SyncAll(webapi_options) {
        return this._SyncAll(webapi_options);
    }
    async _ForceSyncAll(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceSyncAll", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Sync all active connections even when automatic sync is off
     * @returns The response
     */
    async ForceSyncAll(webapi_options) {
        return this._ForceSyncAll(webapi_options);
    }
    async _ForceResync(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResync", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ForceResync(erpConnectionId, internalKeyIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.InternalKeyIds) != 'undefined')) {
            _request = erpConnectionId;
            _options = internalKeyIds;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                InternalKeyIds: internalKeyIds,
            };
            _options = webapi_options;
        }
        return this._ForceResync(_request, _options);
    }
    async _ForceResyncNoBlankValues(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResyncNoBlankValues", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ForceResyncNoBlankValues(erpConnectionId, internalKeyIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.InternalKeyIds) != 'undefined')) {
            _request = erpConnectionId;
            _options = internalKeyIds;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                InternalKeyIds: internalKeyIds,
            };
            _options = webapi_options;
        }
        return this._ForceResyncNoBlankValues(_request, _options);
    }
    async _ForceResyncBatchTask(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResyncBatchTask", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ForceResyncBatchTask(erpConnectionId, internalKeyIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.InternalKeyIds) != 'undefined')) {
            _request = erpConnectionId;
            _options = internalKeyIds;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                InternalKeyIds: internalKeyIds,
            };
            _options = webapi_options;
        }
        return this._ForceResyncBatchTask(_request, _options);
    }
    async _ForceResyncExternal(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResyncExternal", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ForceResyncExternal(erpConnectionId, erpActorType, externalKeys, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.ErpActorType) != 'undefined' || typeof (first.ExternalKeys) != 'undefined')) {
            _request = erpConnectionId;
            _options = erpActorType;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                ErpActorType: erpActorType,
                ExternalKeys: externalKeys,
            };
            _options = webapi_options;
        }
        return this._ForceResyncExternal(_request, _options);
    }
    async _ForceResyncExternalNoBlankValues(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ForceResyncExternalNoBlankValues", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PluginResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ForceResyncExternalNoBlankValues(erpConnectionId, erpActorType, externalKeys, webapi_options) {
        let _request = null;
        let _options = null;
        const first = erpConnectionId;
        if (typeof (first) === "object" && first && (typeof (first.ErpConnectionId) != 'undefined' || typeof (first.ErpActorType) != 'undefined' || typeof (first.ExternalKeys) != 'undefined')) {
            _request = erpConnectionId;
            _options = erpActorType;
        }
        else {
            _request = {
                ErpConnectionId: erpConnectionId,
                ErpActorType: erpActorType,
                ExternalKeys: externalKeys,
            };
            _options = webapi_options;
        }
        return this._ForceResyncExternalNoBlankValues(_request, _options);
    }
    async _GetEngineStatus(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEngineStatus", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncEngineStatus_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the current status of the Sync engine
     * @returns The current status of the engine
     */
    async GetEngineStatus(webapi_options) {
        return this._GetEngineStatus(webapi_options);
    }
    async _ChangeEngineStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeEngineStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ErpSyncEngineStatus_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeEngineStatus(run, webapi_options) {
        let _request = null;
        let _options = null;
        const first = run;
        if (typeof (first) === "object" && first && (typeof (first.Run) != 'undefined')) {
            _request = run;
            _options = webapi_options;
        }
        else {
            _request = {
                Run: run,
            };
            _options = webapi_options;
        }
        return this._ChangeEngineStatus(_request, _options);
    }
    async _ChangeEngineInterval(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeEngineInterval", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeEngineInterval(interval, webapi_options) {
        let _request = null;
        let _options = null;
        const first = interval;
        if (typeof (first) === "object" && first && (typeof (first.Interval) != 'undefined')) {
            _request = interval;
            _options = webapi_options;
        }
        else {
            _request = {
                Interval: interval,
            };
            _options = webapi_options;
        }
        return this._ChangeEngineInterval(_request, _options);
    }
} // class v1ErpSyncAgentController 
exports.ErpSyncAgent = ErpSyncAgent;
//# sourceMappingURL=ErpSyncAgent.js.map
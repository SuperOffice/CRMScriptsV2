"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
const Base64_1 = require("./Base64");
/**
 * Collection of all services that works with Project data.
 */
class ProjectAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Project/";
        super(options);
    }
    /**
     * Set default values into a new ProjectEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultProjectEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProjectEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ProjectEntity or creates a new ProjectEntity if the id parameter is empty
     * @param entity - The ProjectEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ProjectEntity
     */
    async SaveProjectEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProjectEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ProjectEntity
     * @param ProjectEntityId - The id of the ProjectEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteProjectEntity(ProjectEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteProjectEntity?ProjectEntityId=" + ProjectEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ProjectEventEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultProjectEventEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProjectEventEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEventEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ProjectEventEntity or creates a new ProjectEventEntity if the id parameter is empty
     * @param entity - The ProjectEventEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ProjectEventEntity
     */
    async SaveProjectEventEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProjectEventEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEventEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ProjectEventEntity
     * @param ProjectEventEntityId - The id of the ProjectEventEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteProjectEventEntity(ProjectEventEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteProjectEventEntity?ProjectEventEntityId=" + ProjectEventEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ProjectMember.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultProjectMember(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProjectMember", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectMember_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ProjectMember or creates a new ProjectMember if the id parameter is empty
     * @param entity - The ProjectMember to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ProjectMember
     */
    async SaveProjectMember(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProjectMember", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectMember_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ProjectMember
     * @param ProjectMemberId - The id of the ProjectMember to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteProjectMember(ProjectMemberId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteProjectMember?ProjectMemberId=" + ProjectMemberId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Project object.
     * @param projectId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Project
     */
    async GetProject(projectId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProject?projectId=" + projectId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Project_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ProjectEntity object.
     * @param projectEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectEntity
     */
    async GetProjectEntity(projectEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectEntity?projectEntityId=" + projectEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _AddProjectMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddProjectMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddProjectMembers(projectEntityId, projectMembers, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectEntityId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectEntityId) != 'undefined' || typeof (first.ProjectMembers) != 'undefined')) {
            _request = projectEntityId;
            _options = projectMembers;
        }
        else {
            _request = {
                ProjectEntityId: projectEntityId,
                ProjectMembers: projectMembers,
            };
            _options = webapi_options;
        }
        return this._AddProjectMembers(_request, _options);
    }
    async _DeleteProjectMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteProjectMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteProjectMembers(projectEntityId, memberIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectEntityId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectEntityId) != 'undefined' || typeof (first.MemberIds) != 'undefined')) {
            _request = projectEntityId;
            _options = memberIds;
        }
        else {
            _request = {
                ProjectEntityId: projectEntityId,
                MemberIds: memberIds,
            };
            _options = webapi_options;
        }
        return this._DeleteProjectMembers(_request, _options);
    }
    async _GetProjectImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectImage", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectImage(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetProjectImage(_request, _options);
    }
    async _SetProjectImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetProjectImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetProjectImage(projectId, image, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.Image) != 'undefined')) {
            _request = projectId;
            _options = image;
        }
        else {
            _request = {
                ProjectId: projectId,
                Image: image,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SetProjectImage(_request, _options);
    }
    async _DeleteProjectMemberByIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteProjectMemberByIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteProjectMemberByIds(projectMemberIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectMemberIds;
        if (typeof (first) === "object" && first && (typeof (first.ProjectMemberIds) != 'undefined')) {
            _request = projectMemberIds;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectMemberIds: projectMemberIds,
            };
            _options = webapi_options;
        }
        return this._DeleteProjectMemberByIds(_request, _options);
    }
    async _GetDuplicates(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicates", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DuplicateEntryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDuplicates(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._GetDuplicates(_request, _options);
    }
    async _CreateNewEntry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateNewEntry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateNewEntry(duplicate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = duplicate;
        if (typeof (first) === "object" && first && (typeof (first.Duplicate) != 'undefined')) {
            _request = duplicate;
            _options = webapi_options;
        }
        else {
            _request = {
                Duplicate: duplicate,
            };
            _options = webapi_options;
        }
        return this._CreateNewEntry(_request, _options);
    }
    async _SetDuplicateRulesStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDuplicateRulesStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDuplicateRulesStatus(rules, webapi_options) {
        let _request = null;
        let _options = null;
        const first = rules;
        if (typeof (first) === "object" && first && (typeof (first.Rules) != 'undefined')) {
            _request = rules;
            _options = webapi_options;
        }
        else {
            _request = {
                Rules: rules,
            };
            _options = webapi_options;
        }
        return this._SetDuplicateRulesStatus(_request, _options);
    }
    async _GetDuplicateRules(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDuplicateRules", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DuplicateRuleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Retrieve all available duplicate rules for project
     * @returns All available duplicate rules
     */
    async GetDuplicateRules(webapi_options) {
        return this._GetDuplicateRules(webapi_options);
    }
    async _Merge(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Merge", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Merge(sourceProjectId, destinationProjectId, replaceEmptyFieldsOnDestination, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourceProjectId;
        if (typeof (first) === "object" && first && (typeof (first.SourceProjectId) != 'undefined' || typeof (first.DestinationProjectId) != 'undefined' || typeof (first.ReplaceEmptyFieldsOnDestination) != 'undefined')) {
            _request = sourceProjectId;
            _options = destinationProjectId;
        }
        else {
            _request = {
                SourceProjectId: sourceProjectId,
                DestinationProjectId: destinationProjectId,
                ReplaceEmptyFieldsOnDestination: replaceEmptyFieldsOnDestination,
            };
            _options = webapi_options;
        }
        return this._Merge(_request, _options);
    }
    async _IsNumberValid(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNumberValid", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsNumberValid(contactId, number, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.Number) != 'undefined')) {
            _request = contactId;
            _options = number;
        }
        else {
            _request = {
                ContactId: contactId,
                Number: number,
            };
            _options = webapi_options;
        }
        return this._IsNumberValid(_request, _options);
    }
    async _HasGuide(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasGuide", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async HasGuide(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._HasGuide(_request, _options);
    }
    async _GetNextMilestone(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextMilestone", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Appointment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetNextMilestone(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetNextMilestone(_request, _options);
    }
    async _OfferAutoNextStatusOnApppointmentCompleted(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("OfferAutoNextStatusOnApppointmentCompleted", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async OfferAutoNextStatusOnApppointmentCompleted(appointmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined')) {
            _request = appointmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
            };
            _options = webapi_options;
        }
        return this._OfferAutoNextStatusOnApppointmentCompleted(_request, _options);
    }
    async _GetNextProjectStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextProjectStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetNextProjectStatus(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetNextProjectStatus(_request, _options);
    }
    async _HasGuideActivities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasGuideActivities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async HasGuideActivities(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._HasGuideActivities(_request, _options);
    }
    async _ValidateProjectEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateProjectEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateProjectEntity(projectEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectEntity;
        if (typeof (first) === "object" && first && (typeof (first.ProjectEntity) != 'undefined')) {
            _request = projectEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectEntity: projectEntity,
            };
            _options = webapi_options;
        }
        return this._ValidateProjectEntity(_request, _options);
    }
    /*
     * Gets a ProjectEvent object.
     * @param projectEventId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectEvent
     */
    async GetProjectEvent(projectEventId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectEvent?projectEventId=" + projectEventId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEvent_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetProjectEventOnPerson(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectEventOnPerson", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEvent_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectEventOnPerson(projectId, personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined' || typeof (first.PersonId) != 'undefined')) {
            _request = projectId;
            _options = personId;
        }
        else {
            _request = {
                ProjectId: projectId,
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetProjectEventOnPerson(_request, _options);
    }
    /*
     * Gets a ProjectEventEntity object.
     * @param projectEventEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectEventEntity
     */
    async GetProjectEventEntity(projectEventEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectEventEntity?projectEventEntityId=" + projectEventEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEventEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetProjectEventEntityFromProjectId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectEventEntityFromProjectId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEventEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectEventEntityFromProjectId(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetProjectEventEntityFromProjectId(_request, _options);
    }
    async _DeleteProjectEventEntityFromProjectId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteProjectEventEntityFromProjectId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteProjectEventEntityFromProjectId(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._DeleteProjectEventEntityFromProjectId(_request, _options);
    }
    /*
     * Gets an array of ProjectEvent objects.
     * @param projectEventIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ProjectEvent
     */
    async GetProjectEventList(projectEventIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectEventList", projectEventIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEventArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetMyProjectEvents(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyProjectEvents", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEventArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets all project events that belongs to the currently logged on user. The list of events are filtered by the Audience Visibility restrictions set when the project event is created.
     * @returns Array of project events
     */
    async GetMyProjectEvents(webapi_options) {
        return this._GetMyProjectEvents(webapi_options);
    }
    async _GetProjectEventsOnPerson(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectEventsOnPerson", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectEventArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectEventsOnPerson(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetProjectEventsOnPerson(_request, _options);
    }
    /*
     * Gets an array of Project objects.
     * @param projectIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Project
     */
    async GetProjectList(projectIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectList", projectIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetMyProjects(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyProjects", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMyProjects(includeMemberProjects, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeMemberProjects;
        if (typeof (first) === "object" && first && (typeof (first.IncludeMemberProjects) != 'undefined')) {
            _request = includeMemberProjects;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeMemberProjects: includeMemberProjects,
            };
            _options = webapi_options;
        }
        return this._GetMyProjects(_request, _options);
    }
    async _GetMyMemberProjects(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyMemberProjects", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returning the projects where an user is project member.
     * @returns The list of projects.
     */
    async GetMyMemberProjects(webapi_options) {
        return this._GetMyMemberProjects(webapi_options);
    }
    async _GetProjectsFromPerson(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectsFromPerson", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectsFromPerson(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetProjectsFromPerson(_request, _options);
    }
    async _GetProjectsFromContact(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectsFromContact", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectsFromContact(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._GetProjectsFromContact(_request, _options);
    }
    async _GetPublishedProject(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProject", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Project_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedProject(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetPublishedProject(_request, _options);
    }
    async _GetPublishedProjects(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProjects", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedProjects(projectIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectIds;
        if (typeof (first) === "object" && first && (typeof (first.ProjectIds) != 'undefined')) {
            _request = projectIds;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectIds: projectIds,
            };
            _options = webapi_options;
        }
        return this._GetPublishedProjects(_request, _options);
    }
    async _GetMyPublishedProjects(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyPublishedProjects", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get published projects from the logged in user.
     * @returns Projects
     */
    async GetMyPublishedProjects(webapi_options) {
        return this._GetMyPublishedProjects(webapi_options);
    }
    async _GetPublishedProjectsOnPersonId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPublishedProjectsOnPersonId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPublishedProjectsOnPersonId(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetPublishedProjectsOnPersonId(_request, _options);
    }
    /*
     * Gets a ProjectMember object.
     * @param projectMemberId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectMember
     */
    async GetProjectMember(projectMemberId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectMember?projectMemberId=" + projectMemberId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectMember_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetProjectMembers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMembers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectMemberArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMembers(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetProjectMembers(_request, _options);
    }
    async _UpdateProjectMember(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateProjectMember", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectMember_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateProjectMember(projectMember, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectMember;
        if (typeof (first) === "object" && first && (typeof (first.ProjectMember) != 'undefined')) {
            _request = projectMember;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectMember: projectMember,
            };
            _options = webapi_options;
        }
        return this._UpdateProjectMember(_request, _options);
    }
    async _GetProjectMembersById(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectMembersById", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectMemberArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProjectMembersById(projectMemberIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectMemberIds;
        if (typeof (first) === "object" && first && (typeof (first.ProjectMemberIds) != 'undefined')) {
            _request = projectMemberIds;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectMemberIds: projectMemberIds,
            };
            _options = webapi_options;
        }
        return this._GetProjectMembersById(_request, _options);
    }
    async _SaveProjectMembersFunctionAndComment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveProjectMembersFunctionAndComment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveProjectMembersFunctionAndComment(projectMemberIds, roleId, comment, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectMemberIds;
        if (typeof (first) === "object" && first && (typeof (first.ProjectMemberIds) != 'undefined' || typeof (first.RoleId) != 'undefined' || typeof (first.Comment) != 'undefined')) {
            _request = projectMemberIds;
            _options = roleId;
        }
        else {
            _request = {
                ProjectMemberIds: projectMemberIds,
                RoleId: roleId,
                Comment: comment,
            };
            _options = webapi_options;
        }
        return this._SaveProjectMembersFunctionAndComment(_request, _options);
    }
} // class v1ProjectAgentController 
exports.ProjectAgent = ProjectAgent;
//# sourceMappingURL=ProjectAgent.js.map
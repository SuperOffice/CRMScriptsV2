"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
const Base64_1 = require("./Base64");
/**
 * Collection of all services that works with Lists. These are typical lists of data shown in dropdown list, checkbox lists, etc.
 */
class ListAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/List/";
        super(options);
    }
    /**
     * Set default values into a new AmountClassEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultAmountClassEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultAmountClassEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AmountClassEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing AmountClassEntity or creates a new AmountClassEntity if the id parameter is empty
     * @param entity - The AmountClassEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated AmountClassEntity
     */
    async SaveAmountClassEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveAmountClassEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AmountClassEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TaskMenu.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTaskMenu(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTaskMenu", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskMenu_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TaskMenu or creates a new TaskMenu if the id parameter is empty
     * @param entity - The TaskMenu to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TaskMenu
     */
    async SaveTaskMenu(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTaskMenu", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskMenu_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the TaskMenu
     * @param TaskMenuId - The id of the TaskMenu to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteTaskMenu(TaskMenuId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTaskMenu?TaskMenuId=" + TaskMenuId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new CurrencyEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultCurrencyEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultCurrencyEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CurrencyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing CurrencyEntity or creates a new CurrencyEntity if the id parameter is empty
     * @param entity - The CurrencyEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated CurrencyEntity
     */
    async SaveCurrencyEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveCurrencyEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CurrencyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new DocumentTemplateEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultDocumentTemplateEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultDocumentTemplateEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing DocumentTemplateEntity or creates a new DocumentTemplateEntity if the id parameter is empty
     * @param entity - The DocumentTemplateEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated DocumentTemplateEntity
     */
    async SaveDocumentTemplateEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveDocumentTemplateEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ExtAppEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultExtAppEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultExtAppEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ExtAppEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ExtAppEntity or creates a new ExtAppEntity if the id parameter is empty
     * @param entity - The ExtAppEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ExtAppEntity
     */
    async SaveExtAppEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveExtAppEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ExtAppEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new HeadingEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultHeadingEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultHeadingEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing HeadingEntity or creates a new HeadingEntity if the id parameter is empty
     * @param entity - The HeadingEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated HeadingEntity
     */
    async SaveHeadingEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveHeadingEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new HierarchyEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultHierarchyEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultHierarchyEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HierarchyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing HierarchyEntity or creates a new HierarchyEntity if the id parameter is empty
     * @param entity - The HierarchyEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated HierarchyEntity
     */
    async SaveHierarchyEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveHierarchyEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HierarchyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the HierarchyEntity
     * @param HierarchyEntityId - The id of the HierarchyEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteHierarchyEntity(HierarchyEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteHierarchyEntity?HierarchyEntityId=" + HierarchyEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ListEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultListEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultListEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ListEntity or creates a new ListEntity if the id parameter is empty
     * @param entity - The ListEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ListEntity
     */
    async SaveListEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveListEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ListEntity
     * @param ListEntityId - The id of the ListEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteListEntity(ListEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteListEntity?ListEntityId=" + ListEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ListItemEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultListItemEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultListItemEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ProjectTypeEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultProjectTypeEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultProjectTypeEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectTypeEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ProjectTypeEntity or creates a new ProjectTypeEntity if the id parameter is empty
     * @param entity - The ProjectTypeEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ProjectTypeEntity
     */
    async SaveProjectTypeEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveProjectTypeEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectTypeEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new RelationDefinitionEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultRelationDefinitionEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultRelationDefinitionEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RelationDefinitionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing RelationDefinitionEntity or creates a new RelationDefinitionEntity if the id parameter is empty
     * @param entity - The RelationDefinitionEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated RelationDefinitionEntity
     */
    async SaveRelationDefinitionEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveRelationDefinitionEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RelationDefinitionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ResourceEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultResourceEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultResourceEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ResourceEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ResourceEntity or creates a new ResourceEntity if the id parameter is empty
     * @param entity - The ResourceEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ResourceEntity
     */
    async SaveResourceEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveResourceEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ResourceEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ResourceEntity
     * @param ResourceEntityId - The id of the ResourceEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteResourceEntity(ResourceEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteResourceEntity?ResourceEntityId=" + ResourceEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new SaleStageEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSaleStageEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleStageEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SaleStageEntity or creates a new SaleStageEntity if the id parameter is empty
     * @param entity - The SaleStageEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SaleStageEntity
     */
    async SaveSaleStageEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSaleStageEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new SaleTypeEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSaleTypeEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleTypeEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleTypeEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SaleTypeEntity or creates a new SaleTypeEntity if the id parameter is empty
     * @param entity - The SaleTypeEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SaleTypeEntity
     */
    async SaveSaleTypeEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSaleTypeEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleTypeEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TicketCategoryEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTicketCategoryEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketCategoryEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketCategoryEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketCategoryEntity or creates a new TicketCategoryEntity if the id parameter is empty
     * @param entity - The TicketCategoryEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketCategoryEntity
     */
    async SaveTicketCategoryEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketCategoryEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketCategoryEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the TicketCategoryEntity
     * @param TicketCategoryEntityId - The id of the TicketCategoryEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteTicketCategoryEntity(TicketCategoryEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTicketCategoryEntity?TicketCategoryEntityId=" + TicketCategoryEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TicketPriorityEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTicketPriorityEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketPriorityEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriorityEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketPriorityEntity or creates a new TicketPriorityEntity if the id parameter is empty
     * @param entity - The TicketPriorityEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketPriorityEntity
     */
    async SaveTicketPriorityEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketPriorityEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriorityEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the TicketPriorityEntity
     * @param TicketPriorityEntityId - The id of the TicketPriorityEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteTicketPriorityEntity(TicketPriorityEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTicketPriorityEntity?TicketPriorityEntityId=" + TicketPriorityEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TicketStatusEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTicketStatusEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketStatusEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketStatusEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketStatusEntity or creates a new TicketStatusEntity if the id parameter is empty
     * @param entity - The TicketStatusEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketStatusEntity
     */
    async SaveTicketStatusEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketStatusEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketStatusEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the TicketStatusEntity
     * @param TicketStatusEntityId - The id of the TicketStatusEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteTicketStatusEntity(TicketStatusEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteTicketStatusEntity?TicketStatusEntityId=" + TicketStatusEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new WebPanelEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultWebPanelEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultWebPanelEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WebPanelEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing WebPanelEntity or creates a new WebPanelEntity if the id parameter is empty
     * @param entity - The WebPanelEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated WebPanelEntity
     */
    async SaveWebPanelEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveWebPanelEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WebPanelEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a AmountClassEntity object.
     * @param amountClassEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single AmountClassEntity
     */
    async GetAmountClassEntity(amountClassEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAmountClassEntity?amountClassEntityId=" + amountClassEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AmountClassEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Business object.
     * @param businessId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Business
     */
    async GetBusiness(businessId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetBusiness?businessId=" + businessId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Business_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Business objects.
     * @param businessIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Business
     */
    async GetBusinessList(businessIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetBusinessList", businessIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BusinessArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetBusinesses(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBusinesses", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_BusinessArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all available businesses that a contact could have.
     * @returns An array of all available businesses
     */
    async GetBusinesses(webapi_options) {
        return this._GetBusinesses(webapi_options);
    }
    /*
     * Gets a Category object.
     * @param categoryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Category
     */
    async GetCategory(categoryId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCategory?categoryId=" + categoryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Category_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Category objects.
     * @param categoryIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Category
     */
    async GetCategoryList(categoryIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCategoryList", categoryIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CategoryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetCategories(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCategories", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CategoryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all categories a contact could belong to
     * @returns An array of all available categories
     */
    async GetCategories(webapi_options) {
        return this._GetCategories(webapi_options);
    }
    /*
     * Gets a Competitor object.
     * @param competitorId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Competitor
     */
    async GetCompetitor(competitorId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCompetitor?competitorId=" + competitorId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Competitor_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Competitor objects.
     * @param competitorIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Competitor
     */
    async GetCompetitorList(competitorIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCompetitorList", competitorIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CompetitorArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetCompetitors(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCompetitors", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CompetitorArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all competitors
     * @returns
     */
    async GetCompetitors(webapi_options) {
        return this._GetCompetitors(webapi_options);
    }
    /*
     * Gets a TaskMenu object.
     * @param taskMenuId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TaskMenu
     */
    async GetTaskMenu(taskMenuId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTaskMenu?taskMenuId=" + taskMenuId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskMenu_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetAppTaskMenus(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppTaskMenus", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskMenuArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get all task menus owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken
     * @returns List of all task menus owned by the current App
     */
    async GetAppTaskMenus(webapi_options) {
        return this._GetAppTaskMenus(webapi_options);
    }
    async _DeleteAppTaskMenus(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAppTaskMenus", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Permanentely delete all task menus owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken; otherwise nothing happens
     * @returns This method has no return value
     */
    async DeleteAppTaskMenus(webapi_options) {
        return this._DeleteAppTaskMenus(webapi_options);
    }
    async _GetTaskMenuByProgId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTaskMenuByProgId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskMenu_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTaskMenuByProgId(progId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = progId;
        if (typeof (first) === "object" && first && (typeof (first.ProgId) != 'undefined')) {
            _request = progId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProgId: progId,
            };
            _options = webapi_options;
        }
        return this._GetTaskMenuByProgId(_request, _options);
    }
    /*
     * Gets a ConsentPurpose object.
     * @param consentPurposeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ConsentPurpose
     */
    async GetConsentPurpose(consentPurposeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentPurpose?consentPurposeId=" + consentPurposeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPurpose_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SaveConsentPurpose(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConsentPurpose", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPurpose_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveConsentPurpose(consentPurpose, webapi_options) {
        let _request = null;
        let _options = null;
        const first = consentPurpose;
        if (typeof (first) === "object" && first && (typeof (first.ConsentPurpose) != 'undefined')) {
            _request = consentPurpose;
            _options = webapi_options;
        }
        else {
            _request = {
                ConsentPurpose: consentPurpose,
            };
            _options = webapi_options;
        }
        return this._SaveConsentPurpose(_request, _options);
    }
    async _SetEmarketingStrictMode(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetEmarketingStrictMode", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetEmarketingStrictMode(enable, webapi_options) {
        let _request = null;
        let _options = null;
        const first = enable;
        if (typeof (first) === "object" && first && (typeof (first.Enable) != 'undefined')) {
            _request = enable;
            _options = webapi_options;
        }
        else {
            _request = {
                Enable: enable,
            };
            _options = webapi_options;
        }
        return this._SetEmarketingStrictMode(_request, _options);
    }
    async _GetEmarketingStrictMode(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetEmarketingStrictMode", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the value of the Emarketing strict mode setting
     * @returns Returns true if Emarkerint strict mode is set, false otherwise
     */
    async GetEmarketingStrictMode(webapi_options) {
        return this._GetEmarketingStrictMode(webapi_options);
    }
    /*
     * Gets an array of ConsentPurpose objects.
     * @param consentPurposeIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ConsentPurpose
     */
    async GetConsentPurposeList(consentPurposeIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentPurposeList", consentPurposeIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPurposeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetConsentPurposes(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConsentPurposes", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPurposeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all defined purposes.
     * @returns An array of all defined purposes
     */
    async GetConsentPurposes(webapi_options) {
        return this._GetConsentPurposes(webapi_options);
    }
    /*
     * Gets a ConsentSource object.
     * @param consentSourceId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ConsentSource
     */
    async GetConsentSource(consentSourceId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentSource?consentSourceId=" + consentSourceId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentSource_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SaveConsentSource(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveConsentSource", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentSource_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveConsentSource(consentSource, webapi_options) {
        let _request = null;
        let _options = null;
        const first = consentSource;
        if (typeof (first) === "object" && first && (typeof (first.ConsentSource) != 'undefined')) {
            _request = consentSource;
            _options = webapi_options;
        }
        else {
            _request = {
                ConsentSource: consentSource,
            };
            _options = webapi_options;
        }
        return this._SaveConsentSource(_request, _options);
    }
    /*
     * Gets an array of ConsentSource objects.
     * @param consentSourceIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ConsentSource
     */
    async GetConsentSourceList(consentSourceIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentSourceList", consentSourceIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentSourceArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetConsentSources(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConsentSources", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentSourceArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all defined Sources.
     * @returns An array of all defined Sources
     */
    async GetConsentSources(webapi_options) {
        return this._GetConsentSources(webapi_options);
    }
    /*
     * Gets a Country object.
     * @param countryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Country
     */
    async GetCountry(countryId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCountry?countryId=" + countryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Country_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SaveCountry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveCountry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Country_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveCountry(country, webapi_options) {
        let _request = null;
        let _options = null;
        const first = country;
        if (typeof (first) === "object" && first && (typeof (first.Country) != 'undefined')) {
            _request = country;
            _options = webapi_options;
        }
        else {
            _request = {
                Country: country,
            };
            _options = webapi_options;
        }
        return this._SaveCountry(_request, _options);
    }
    async _CreateDefaultCountry(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultCountry", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Country_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets a new country
     * @returns A new country with default values
     */
    async CreateDefaultCountry(webapi_options) {
        return this._CreateDefaultCountry(webapi_options);
    }
    /*
     * Gets an array of Country objects.
     * @param countryIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Country
     */
    async GetCountryList(countryIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCountryList", countryIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CountryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetCountries(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCountries", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CountryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all available countries a contact or person could belong to.
     * @returns An array of all available countries
     */
    async GetCountries(webapi_options) {
        return this._GetCountries(webapi_options);
    }
    async _GetAllCountries(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllCountries", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CountryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllCountries(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllCountries(_request, _options);
    }
    /*
     * Gets a Credited object.
     * @param creditedId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Credited
     */
    async GetCredited(creditedId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCredited?creditedId=" + creditedId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Credited_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Credited objects.
     * @param creditedIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Credited
     */
    async GetCreditedList(creditedIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCreditedList", creditedIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CreditedArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetCrediteds(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCrediteds", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CreditedArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all credited
     * @returns
     */
    async GetCrediteds(webapi_options) {
        return this._GetCrediteds(webapi_options);
    }
    /*
     * Gets a Currency object.
     * @param currencyId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Currency
     */
    async GetCurrency(currencyId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCurrency?currencyId=" + currencyId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Currency_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetOurCurrency(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOurCurrency", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Currency_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets the Our currency object if currency is enabled
     * @returns Our currency
     */
    async GetOurCurrency(webapi_options) {
        return this._GetOurCurrency(webapi_options);
    }
    async _ChangeCurrency(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeCurrency", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeCurrency(amount, fromCurrency, toCurrency, webapi_options) {
        let _request = null;
        let _options = null;
        const first = amount;
        if (typeof (first) === "object" && first && (typeof (first.Amount) != 'undefined' || typeof (first.FromCurrency) != 'undefined' || typeof (first.ToCurrency) != 'undefined')) {
            _request = amount;
            _options = fromCurrency;
        }
        else {
            _request = {
                Amount: amount,
                FromCurrency: fromCurrency,
                ToCurrency: toCurrency,
            };
            _options = webapi_options;
        }
        return this._ChangeCurrency(_request, _options);
    }
    async _GetOwnerCompanysCurrency(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOwnerCompanysCurrency", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Currency_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the currency of the user&apos;s owner company
     * @returns Currency of the user's owner company
     */
    async GetOwnerCompanysCurrency(webapi_options) {
        return this._GetOwnerCompanysCurrency(webapi_options);
    }
    /*
     * Gets a CurrencyEntity object.
     * @param currencyEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single CurrencyEntity
     */
    async GetCurrencyEntity(currencyEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCurrencyEntity?currencyEntityId=" + currencyEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CurrencyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetBaseCurrency(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBaseCurrency", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CurrencyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the base currency, used for calculating exchange rates
     * @returns The base currency that other currencies are expressed in terms of
     */
    async GetBaseCurrency(webapi_options) {
        return this._GetBaseCurrency(webapi_options);
    }
    /*
     * Gets an array of Currency objects.
     * @param currencyIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Currency
     */
    async GetCurrencyList(currencyIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCurrencyList", currencyIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CurrencyArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetCurrencies(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCurrencies", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CurrencyArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all currencies
     * @returns Array of currencies
     */
    async GetCurrencies(webapi_options) {
        return this._GetCurrencies(webapi_options);
    }
    async _GetAllCurrencies(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllCurrencies", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CurrencyEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllCurrencies(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllCurrencies(_request, _options);
    }
    /*
     * Gets a CustomerLanguage object.
     * @param customerLanguageId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single CustomerLanguage
     */
    async GetCustomerLanguage(customerLanguageId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCustomerLanguage?customerLanguageId=" + customerLanguageId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerLanguage_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of CustomerLanguage objects.
     * @param customerLanguageIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of CustomerLanguage
     */
    async GetCustomerLanguageList(customerLanguageIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetCustomerLanguageList", customerLanguageIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerLanguageArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetCustomerLanguages(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCustomerLanguages", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomerLanguageArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     *
     * @returns
     */
    async GetCustomerLanguages(webapi_options) {
        return this._GetCustomerLanguages(webapi_options);
    }
    /*
     * Gets a DeliveryTerm object.
     * @param deliveryTermId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DeliveryTerm
     */
    async GetDeliveryTerm(deliveryTermId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDeliveryTerm?deliveryTermId=" + deliveryTermId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DeliveryTerm_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetDeliveryTerms(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDeliveryTerms", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DeliveryTermArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all DeliveryTerms in SuperOffice db.
     * @returns An array of all available DeliveryTerms
     */
    async GetDeliveryTerms(webapi_options) {
        return this._GetDeliveryTerms(webapi_options);
    }
    /*
     * Gets a DeliveryType object.
     * @param deliveryTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DeliveryType
     */
    async GetDeliveryType(deliveryTypeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDeliveryType?deliveryTypeId=" + deliveryTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DeliveryType_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetDeliveryTypes(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDeliveryTypes", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DeliveryTypeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all DeliveryTypes in SuperOffice db.
     * @returns An array of all available DeliveryType
     */
    async GetDeliveryTypes(webapi_options) {
        return this._GetDeliveryTypes(webapi_options);
    }
    /*
     * Gets a Department object.
     * @param departmentId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Department
     */
    async GetDepartment(departmentId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDepartment?departmentId=" + departmentId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Department_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Department objects.
     * @param departmentIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Department
     */
    async GetDepartmentList(departmentIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDepartmentList", departmentIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DepartmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetDepartments(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDepartments", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DepartmentArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Getting all departments/user groups for the internal phone list with the user&apos;s colleagues.
     * @returns Returns all departments.
     */
    async GetDepartments(webapi_options) {
        return this._GetDepartments(webapi_options);
    }
    /*
     * Gets a DocumentTemplate object.
     * @param documentTemplateId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DocumentTemplate
     */
    async GetDocumentTemplate(documentTemplateId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentTemplate?documentTemplateId=" + documentTemplateId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplate_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a DocumentTemplateEntity object.
     * @param documentTemplateEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single DocumentTemplateEntity
     */
    async GetDocumentTemplateEntity(documentTemplateEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentTemplateEntity?documentTemplateEntityId=" + documentTemplateEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SetDocumentTemplateStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentTemplateStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDocumentTemplateStream(documentTemplateEntity, stream, languageCode, pluginId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateEntity;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateEntity) != 'undefined' || typeof (first.Stream) != 'undefined' || typeof (first.LanguageCode) != 'undefined' || typeof (first.PluginId) != 'undefined')) {
            _request = documentTemplateEntity;
            _options = stream;
        }
        else {
            _request = {
                DocumentTemplateEntity: documentTemplateEntity,
                Stream: stream,
                LanguageCode: languageCode,
                PluginId: pluginId,
            };
            _options = webapi_options;
        }
        _request.Stream = (0, Base64_1.ToBase64)(_request.Stream);
        return this._SetDocumentTemplateStream(_request, _options);
    }
    async _GetDocumentTemplateUsedInSalesStage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateUsedInSalesStage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentTemplateUsedInSalesStage(documentTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined')) {
            _request = documentTemplateId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetDocumentTemplateUsedInSalesStage(_request, _options);
    }
    async _GetDocumentTemplateUsedInProjectStage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateUsedInProjectStage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentTemplateUsedInProjectStage(documentTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined')) {
            _request = documentTemplateId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetDocumentTemplateUsedInProjectStage(_request, _options);
    }
    async _GetDocumentTemplateUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentTemplateUrl(documentTemplateId, writableUrl, languageCode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined' || typeof (first.WritableUrl) != 'undefined' || typeof (first.LanguageCode) != 'undefined')) {
            _request = documentTemplateId;
            _options = writableUrl;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
                WritableUrl: writableUrl,
                LanguageCode: languageCode,
            };
            _options = webapi_options;
        }
        return this._GetDocumentTemplateUrl(_request, _options);
    }
    async _GetDocumentTemplateProperties(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateProperties", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentTemplateProperties(documentTemplateId, requestedProperties, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined' || typeof (first.RequestedProperties) != 'undefined')) {
            _request = documentTemplateId;
            _options = requestedProperties;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
                RequestedProperties: requestedProperties,
            };
            _options = webapi_options;
        }
        return this._GetDocumentTemplateProperties(_request, _options);
    }
    async _GetDocumentTemplateLanguages(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateLanguages", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentTemplateLanguages(documentTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined')) {
            _request = documentTemplateId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetDocumentTemplateLanguages(_request, _options);
    }
    async _CreateDefaultDocumentTemplateLanguage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultDocumentTemplateLanguage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultDocumentTemplateLanguage(documentTemplateId, languageCode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined' || typeof (first.LanguageCode) != 'undefined')) {
            _request = documentTemplateId;
            _options = languageCode;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
                LanguageCode: languageCode,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultDocumentTemplateLanguage(_request, _options);
    }
    async _DeleteDocumentTemplateLanguage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteDocumentTemplateLanguage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteDocumentTemplateLanguage(documentTemplateId, languageCode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined' || typeof (first.LanguageCode) != 'undefined')) {
            _request = documentTemplateId;
            _options = languageCode;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
                LanguageCode: languageCode,
            };
            _options = webapi_options;
        }
        return this._DeleteDocumentTemplateLanguage(_request, _options);
    }
    async _GetDocumentTemplateExtension(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateExtension", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentTemplateExtension(documentTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined')) {
            _request = documentTemplateId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetDocumentTemplateExtension(_request, _options);
    }
    async _SetDocumentTemplateFromDocumentTemplate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentTemplateFromDocumentTemplate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDocumentTemplateFromDocumentTemplate(sourceDocumentTemplateId, documentTemplateEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourceDocumentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.SourceDocumentTemplateId) != 'undefined' || typeof (first.DocumentTemplateEntity) != 'undefined')) {
            _request = sourceDocumentTemplateId;
            _options = documentTemplateEntity;
        }
        else {
            _request = {
                SourceDocumentTemplateId: sourceDocumentTemplateId,
                DocumentTemplateEntity: documentTemplateEntity,
            };
            _options = webapi_options;
        }
        return this._SetDocumentTemplateFromDocumentTemplate(_request, _options);
    }
    async _GetDocumentTemplateStreamFromId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateStreamFromId", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentTemplateStreamFromId(documentTemplateId, languageCode, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined' || typeof (first.LanguageCode) != 'undefined')) {
            _request = documentTemplateId;
            _options = languageCode;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
                LanguageCode: languageCode,
            };
            _options = webapi_options;
        }
        return this._GetDocumentTemplateStreamFromId(_request, _options);
    }
    async _SaveDocumentTemplateStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveDocumentTemplateStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TemplateInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveDocumentTemplateStream(documentTemplateId, content, languageCode, pluginId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined' || typeof (first.Content) != 'undefined' || typeof (first.LanguageCode) != 'undefined' || typeof (first.PluginId) != 'undefined')) {
            _request = documentTemplateId;
            _options = content;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
                Content: content,
                LanguageCode: languageCode,
                PluginId: pluginId,
            };
            _options = webapi_options;
        }
        _request.Content = (0, Base64_1.ToBase64)(_request.Content);
        return this._SaveDocumentTemplateStream(_request, _options);
    }
    async _GetPluginList(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPluginList", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get a list of installed document plugins
     * @returns Dictionary mapping plugin id=plugin name
     */
    async GetPluginList(webapi_options) {
        return this._GetPluginList(webapi_options);
    }
    async _GetPluginCapabilities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPluginCapabilities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPluginCapabilities(pluginId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = pluginId;
        if (typeof (first) === "object" && first && (typeof (first.PluginId) != 'undefined')) {
            _request = pluginId;
            _options = webapi_options;
        }
        else {
            _request = {
                PluginId: pluginId,
            };
            _options = webapi_options;
        }
        return this._GetPluginCapabilities(_request, _options);
    }
    async _GetDocumentTypesForPlugin(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTypesForPlugin", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_IntStringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentTypesForPlugin(pluginId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = pluginId;
        if (typeof (first) === "object" && first && (typeof (first.PluginId) != 'undefined')) {
            _request = pluginId;
            _options = webapi_options;
        }
        else {
            _request = {
                PluginId: pluginId,
            };
            _options = webapi_options;
        }
        return this._GetDocumentTypesForPlugin(_request, _options);
    }
    /*
     * Gets an array of DocumentTemplate objects.
     * @param documentTemplateIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of DocumentTemplate
     */
    async GetDocumentTemplateList(documentTemplateIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetDocumentTemplateList", documentTemplateIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetDocumentTemplates(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplates", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all available document templates
     * @returns Array of DocumentTemplates
     */
    async GetDocumentTemplates(webapi_options) {
        return this._GetDocumentTemplates(webapi_options);
    }
    async _GetAllDocumentTemplates(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllDocumentTemplates", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentTemplateEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllDocumentTemplates(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllDocumentTemplates(_request, _options);
    }
    async _SetDocumentPluginForAllDocumentTemplates(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDocumentPluginForAllDocumentTemplates", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDocumentPluginForAllDocumentTemplates(documentPluginId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentPluginId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentPluginId) != 'undefined')) {
            _request = documentPluginId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentPluginId: documentPluginId,
            };
            _options = webapi_options;
        }
        return this._SetDocumentPluginForAllDocumentTemplates(_request, _options);
    }
    /*
     * Gets a ExtAppEntity object.
     * @param extAppEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ExtAppEntity
     */
    async GetExtAppEntity(extAppEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetExtAppEntity?extAppEntityId=" + extAppEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ExtAppEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a HeadingEntity object.
     * @param headingEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single HeadingEntity
     */
    async GetHeadingEntity(headingEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetHeadingEntity?headingEntityId=" + headingEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _CreateDefaultHeadingFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultHeadingFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultHeadingFromListDefinition(udListDefinitionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined')) {
            _request = udListDefinitionId;
            _options = webapi_options;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultHeadingFromListDefinition(_request, _options);
    }
    /*
     * Gets a HierarchyEntity object.
     * @param hierarchyEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single HierarchyEntity
     */
    async GetHierarchyEntity(hierarchyEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetHierarchyEntity?hierarchyEntityId=" + hierarchyEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HierarchyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetAllDomains(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllDomains", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get list of all domains
     * @returns Domain types (scripts, extra tables, etc)
     */
    async GetAllDomains(webapi_options) {
        return this._GetAllDomains(webapi_options);
    }
    async _GetAllInDomain(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllInDomain", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HierarchyEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllInDomain(domain, children, webapi_options) {
        let _request = null;
        let _options = null;
        const first = domain;
        if (typeof (first) === "object" && first && (typeof (first.Domain) != 'undefined' || typeof (first.Children) != 'undefined')) {
            _request = domain;
            _options = children;
        }
        else {
            _request = {
                Domain: domain,
                Children: children,
            };
            _options = webapi_options;
        }
        return this._GetAllInDomain(_request, _options);
    }
    async _GetHierarchyFromPath(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHierarchyFromPath", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HierarchyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetHierarchyFromPath(domain, path, children, webapi_options) {
        let _request = null;
        let _options = null;
        const first = domain;
        if (typeof (first) === "object" && first && (typeof (first.Domain) != 'undefined' || typeof (first.Path) != 'undefined' || typeof (first.Children) != 'undefined')) {
            _request = domain;
            _options = path;
        }
        else {
            _request = {
                Domain: domain,
                Path: path,
                Children: children,
            };
            _options = webapi_options;
        }
        return this._GetHierarchyFromPath(_request, _options);
    }
    async _AddHierarchyToPath(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddHierarchyToPath", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HierarchyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddHierarchyToPath(domain, path, name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = domain;
        if (typeof (first) === "object" && first && (typeof (first.Domain) != 'undefined' || typeof (first.Path) != 'undefined' || typeof (first.Name) != 'undefined')) {
            _request = domain;
            _options = path;
        }
        else {
            _request = {
                Domain: domain,
                Path: path,
                Name: name,
            };
            _options = webapi_options;
        }
        return this._AddHierarchyToPath(_request, _options);
    }
    async _UpdateHierarchyFromPath(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateHierarchyFromPath", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HierarchyEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateHierarchyFromPath(domain, path, entity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = domain;
        if (typeof (first) === "object" && first && (typeof (first.Domain) != 'undefined' || typeof (first.Path) != 'undefined' || typeof (first.Entity) != 'undefined')) {
            _request = domain;
            _options = path;
        }
        else {
            _request = {
                Domain: domain,
                Path: path,
                Entity: entity,
            };
            _options = webapi_options;
        }
        return this._UpdateHierarchyFromPath(_request, _options);
    }
    async _DeleteHierarchyFromPath(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteHierarchyFromPath", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteHierarchyFromPath(domain, path, webapi_options) {
        let _request = null;
        let _options = null;
        const first = domain;
        if (typeof (first) === "object" && first && (typeof (first.Domain) != 'undefined' || typeof (first.Path) != 'undefined')) {
            _request = domain;
            _options = path;
        }
        else {
            _request = {
                Domain: domain,
                Path: path,
            };
            _options = webapi_options;
        }
        return this._DeleteHierarchyFromPath(_request, _options);
    }
    /*
     * Gets a LanguageInfo object.
     * @param languageInfoId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single LanguageInfo
     */
    async GetLanguageInfo(languageInfoId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLanguageInfo?languageInfoId=" + languageInfoId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LanguageInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of LanguageInfo objects.
     * @param languageInfoIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of LanguageInfo
     */
    async GetLanguageInfoList(languageInfoIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLanguageInfoList", languageInfoIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LanguageInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetInstalledLanguages(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetInstalledLanguages", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LanguageInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns the list of all languages installed in this database.
     * @returns Array of installed languages
     */
    async GetInstalledLanguages(webapi_options) {
        return this._GetInstalledLanguages(webapi_options);
    }
    /*
     * Gets a LegalBase object.
     * @param legalBaseId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single LegalBase
     */
    async GetLegalBase(legalBaseId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLegalBase?legalBaseId=" + legalBaseId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LegalBase_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SaveLegalBase(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveLegalBase", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LegalBase_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveLegalBase(legalBase, webapi_options) {
        let _request = null;
        let _options = null;
        const first = legalBase;
        if (typeof (first) === "object" && first && (typeof (first.LegalBase) != 'undefined')) {
            _request = legalBase;
            _options = webapi_options;
        }
        else {
            _request = {
                LegalBase: legalBase,
            };
            _options = webapi_options;
        }
        return this._SaveLegalBase(_request, _options);
    }
    /*
     * Gets an array of LegalBase objects.
     * @param legalBaseIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of LegalBase
     */
    async GetLegalBaseList(legalBaseIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLegalBaseList", legalBaseIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LegalBaseArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetLegalBases(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLegalBases", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LegalBaseArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all defined bases.
     * @returns An array of all defined bases
     */
    async GetLegalBases(webapi_options) {
        return this._GetLegalBases(webapi_options);
    }
    /*
     * Gets a Link object.
     * @param linkId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Link
     */
    async GetLink(linkId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLink?linkId=" + linkId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Link_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Link objects.
     * @param linkIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Link
     */
    async GetLinkList(linkIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLinkList", linkIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LinkArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ListEntity object.
     * @param listEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ListEntity
     */
    async GetListEntity(listEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetListEntity?listEntityId=" + listEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetListDefinitions(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListDefinitions", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListDefinitions(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetListDefinitions(_request, _options);
    }
    async _GetListEntityByName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListEntityByName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListEntityByName(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._GetListEntityByName(_request, _options);
    }
    async _SaveListEntityByName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveListEntityByName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveListEntityByName(name, listEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.ListEntity) != 'undefined')) {
            _request = name;
            _options = listEntity;
        }
        else {
            _request = {
                Name: name,
                ListEntity: listEntity,
            };
            _options = webapi_options;
        }
        return this._SaveListEntityByName(_request, _options);
    }
    async _DeleteListEntityByName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteListEntityByName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteListEntityByName(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._DeleteListEntityByName(_request, _options);
    }
    async _SaveListItemEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveListItemEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveListItemEntity(listItemEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = listItemEntity;
        if (typeof (first) === "object" && first && (typeof (first.ListItemEntity) != 'undefined')) {
            _request = listItemEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                ListItemEntity: listItemEntity,
            };
            _options = webapi_options;
        }
        return this._SaveListItemEntity(_request, _options);
    }
    async _SortListItems(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SortListItems", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SortListItems(udListDefinitionId, cultureName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.CultureName) != 'undefined')) {
            _request = udListDefinitionId;
            _options = cultureName;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                CultureName: cultureName,
            };
            _options = webapi_options;
        }
        return this._SortListItems(_request, _options);
    }
    async _MoveListItem(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveListItem", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MoveListItem(udListDefinitionId, listItemId, direction, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.ListItemId) != 'undefined' || typeof (first.Direction) != 'undefined')) {
            _request = udListDefinitionId;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                ListItemId: listItemId,
                Direction: direction,
            };
            _options = webapi_options;
        }
        return this._MoveListItem(_request, _options);
    }
    async _GetVisibleForUserGroups(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetVisibleForUserGroups", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetVisibleForUserGroups(udListDefinitionId, listItemId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.ListItemId) != 'undefined')) {
            _request = udListDefinitionId;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                ListItemId: listItemId,
            };
            _options = webapi_options;
        }
        return this._GetVisibleForUserGroups(_request, _options);
    }
    async _GetVisibleForUserGroupsFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetVisibleForUserGroupsFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetVisibleForUserGroupsFromListName(udListDefinitionName, listItemId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.ListItemId) != 'undefined')) {
            _request = udListDefinitionName;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                ListItemId: listItemId,
            };
            _options = webapi_options;
        }
        return this._GetVisibleForUserGroupsFromListName(_request, _options);
    }
    async _SetVisibleForUserGroups(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetVisibleForUserGroups", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetVisibleForUserGroups(udListDefinitionId, listItemId, userGroups, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.ListItemId) != 'undefined' || typeof (first.UserGroups) != 'undefined')) {
            _request = udListDefinitionId;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                ListItemId: listItemId,
                UserGroups: userGroups,
            };
            _options = webapi_options;
        }
        return this._SetVisibleForUserGroups(_request, _options);
    }
    async _SetVisibleForUserGroupsFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetVisibleForUserGroupsFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetVisibleForUserGroupsFromListName(udListDefinitionName, listItemId, userGroups, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.ListItemId) != 'undefined' || typeof (first.UserGroups) != 'undefined')) {
            _request = udListDefinitionName;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                ListItemId: listItemId,
                UserGroups: userGroups,
            };
            _options = webapi_options;
        }
        return this._SetVisibleForUserGroupsFromListName(_request, _options);
    }
    async _SetVisibleForUserGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetVisibleForUserGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetVisibleForUserGroup(udListDefinitionId, listItemId, userGroupId, enable, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.ListItemId) != 'undefined' || typeof (first.UserGroupId) != 'undefined' || typeof (first.Enable) != 'undefined')) {
            _request = udListDefinitionId;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                ListItemId: listItemId,
                UserGroupId: userGroupId,
                Enable: enable,
            };
            _options = webapi_options;
        }
        return this._SetVisibleForUserGroup(_request, _options);
    }
    async _GetListItemsForUserGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListItemsForUserGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListItemsForUserGroup(udListDefinitionId, groupId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.GroupId) != 'undefined')) {
            _request = udListDefinitionId;
            _options = groupId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                GroupId: groupId,
            };
            _options = webapi_options;
        }
        return this._GetListItemsForUserGroup(_request, _options);
    }
    async _GetListItemsForUserGroupFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListItemsForUserGroupFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListItemsForUserGroupFromListName(udListDefinitionName, groupId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.GroupId) != 'undefined')) {
            _request = udListDefinitionName;
            _options = groupId;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                GroupId: groupId,
            };
            _options = webapi_options;
        }
        return this._GetListItemsForUserGroupFromListName(_request, _options);
    }
    async _SetListItemsForUserGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetListItemsForUserGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetListItemsForUserGroup(udListDefinitionId, usergroupId, listItemIds, enable, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.UsergroupId) != 'undefined' || typeof (first.ListItemIds) != 'undefined' || typeof (first.Enable) != 'undefined')) {
            _request = udListDefinitionId;
            _options = usergroupId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                UsergroupId: usergroupId,
                ListItemIds: listItemIds,
                Enable: enable,
            };
            _options = webapi_options;
        }
        return this._SetListItemsForUserGroup(_request, _options);
    }
    async _SetListItemsForUserGroupFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetListItemsForUserGroupFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetListItemsForUserGroupFromListName(udListDefinitionName, usergroupId, listItemsID, enable, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.UsergroupId) != 'undefined' || typeof (first.ListItemsID) != 'undefined' || typeof (first.Enable) != 'undefined')) {
            _request = udListDefinitionName;
            _options = usergroupId;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                UsergroupId: usergroupId,
                ListItemsID: listItemsID,
                Enable: enable,
            };
            _options = webapi_options;
        }
        return this._SetListItemsForUserGroupFromListName(_request, _options);
    }
    async _GetHeadings(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHeadings", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetHeadings(udListDefinitionId, listItemId, showDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.ListItemId) != 'undefined' || typeof (first.ShowDeleted) != 'undefined')) {
            _request = udListDefinitionId;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                ListItemId: listItemId,
                ShowDeleted: showDeleted,
            };
            _options = webapi_options;
        }
        return this._GetHeadings(_request, _options);
    }
    async _GetHeadingsForListItemFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHeadingsForListItemFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetHeadingsForListItemFromListName(udListDefinitionName, listItemId, showDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.ListItemId) != 'undefined' || typeof (first.ShowDeleted) != 'undefined')) {
            _request = udListDefinitionName;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                ListItemId: listItemId,
                ShowDeleted: showDeleted,
            };
            _options = webapi_options;
        }
        return this._GetHeadingsForListItemFromListName(_request, _options);
    }
    async _SaveHeadingsForListItemFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingsForListItemFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveHeadingsForListItemFromListDefinition(udListDefinitionId, listItemId, headings, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.ListItemId) != 'undefined' || typeof (first.Headings) != 'undefined')) {
            _request = udListDefinitionId;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                ListItemId: listItemId,
                Headings: headings,
            };
            _options = webapi_options;
        }
        return this._SaveHeadingsForListItemFromListDefinition(_request, _options);
    }
    async _SaveHeadingsForListItemFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingsForListItemFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveHeadingsForListItemFromListName(udListDefinitionName, listItemId, headings, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.ListItemId) != 'undefined' || typeof (first.Headings) != 'undefined')) {
            _request = udListDefinitionName;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                ListItemId: listItemId,
                Headings: headings,
            };
            _options = webapi_options;
        }
        return this._SaveHeadingsForListItemFromListName(_request, _options);
    }
    async _GetListItemsForHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListItemsForHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListItemsForHeading(udListDefinitionId, headingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.HeadingId) != 'undefined')) {
            _request = udListDefinitionId;
            _options = headingId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                HeadingId: headingId,
            };
            _options = webapi_options;
        }
        return this._GetListItemsForHeading(_request, _options);
    }
    async _GetListItemsForHeadingFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetListItemsForHeadingFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetListItemsForHeadingFromListName(udListDefinitionName, headingId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.HeadingId) != 'undefined')) {
            _request = udListDefinitionName;
            _options = headingId;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                HeadingId: headingId,
            };
            _options = webapi_options;
        }
        return this._GetListItemsForHeadingFromListName(_request, _options);
    }
    async _SetListItemsForHeading(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetListItemsForHeading", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetListItemsForHeading(udListDefinitionId, headingId, listItemIds, enable, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.HeadingId) != 'undefined' || typeof (first.ListItemIds) != 'undefined' || typeof (first.Enable) != 'undefined')) {
            _request = udListDefinitionId;
            _options = headingId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                HeadingId: headingId,
                ListItemIds: listItemIds,
                Enable: enable,
            };
            _options = webapi_options;
        }
        return this._SetListItemsForHeading(_request, _options);
    }
    async _SetListItemsForHeadingFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetListItemsForHeadingFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetListItemsForHeadingFromListName(udListDefinitionName, headingId, listItemIds, enable, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.HeadingId) != 'undefined' || typeof (first.ListItemIds) != 'undefined' || typeof (first.Enable) != 'undefined')) {
            _request = udListDefinitionName;
            _options = headingId;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                HeadingId: headingId,
                ListItemIds: listItemIds,
                Enable: enable,
            };
            _options = webapi_options;
        }
        return this._SetListItemsForHeadingFromListName(_request, _options);
    }
    async _SetHeadingsForListItem(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetHeadingsForListItem", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetHeadingsForListItem(udListDefinitionId, listItemId, headingIds, enable, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.ListItemId) != 'undefined' || typeof (first.HeadingIds) != 'undefined' || typeof (first.Enable) != 'undefined')) {
            _request = udListDefinitionId;
            _options = listItemId;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                ListItemId: listItemId,
                HeadingIds: headingIds,
                Enable: enable,
            };
            _options = webapi_options;
        }
        return this._SetHeadingsForListItem(_request, _options);
    }
    async _SetRankOnHeadings(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnHeadings", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetRankOnHeadings(udListDefinitionId, headingIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.HeadingIds) != 'undefined')) {
            _request = udListDefinitionId;
            _options = headingIds;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                HeadingIds: headingIds,
            };
            _options = webapi_options;
        }
        return this._SetRankOnHeadings(_request, _options);
    }
    async _SetRankOnSaleActivity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnSaleActivity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetRankOnSaleActivity(saleTypeStageLinkId, itemsIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleTypeStageLinkId;
        if (typeof (first) === "object" && first && (typeof (first.SaleTypeStageLinkId) != 'undefined' || typeof (first.ItemsIds) != 'undefined')) {
            _request = saleTypeStageLinkId;
            _options = itemsIds;
        }
        else {
            _request = {
                SaleTypeStageLinkId: saleTypeStageLinkId,
                ItemsIds: itemsIds,
            };
            _options = webapi_options;
        }
        return this._SetRankOnSaleActivity(_request, _options);
    }
    async _SetRankOnSaleDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnSaleDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetRankOnSaleDocument(saleTypeStageLinkId, itemsIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleTypeStageLinkId;
        if (typeof (first) === "object" && first && (typeof (first.SaleTypeStageLinkId) != 'undefined' || typeof (first.ItemsIds) != 'undefined')) {
            _request = saleTypeStageLinkId;
            _options = itemsIds;
        }
        else {
            _request = {
                SaleTypeStageLinkId: saleTypeStageLinkId,
                ItemsIds: itemsIds,
            };
            _options = webapi_options;
        }
        return this._SetRankOnSaleDocument(_request, _options);
    }
    async _SetRankOnProjectActivity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnProjectActivity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetRankOnProjectActivity(projectTypeStatusLinkId, itemsIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectTypeStatusLinkId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectTypeStatusLinkId) != 'undefined' || typeof (first.ItemsIds) != 'undefined')) {
            _request = projectTypeStatusLinkId;
            _options = itemsIds;
        }
        else {
            _request = {
                ProjectTypeStatusLinkId: projectTypeStatusLinkId,
                ItemsIds: itemsIds,
            };
            _options = webapi_options;
        }
        return this._SetRankOnProjectActivity(_request, _options);
    }
    async _SetRankOnProjectDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetRankOnProjectDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetRankOnProjectDocument(projectTypeStatusLinkId, itemsIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectTypeStatusLinkId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectTypeStatusLinkId) != 'undefined' || typeof (first.ItemsIds) != 'undefined')) {
            _request = projectTypeStatusLinkId;
            _options = itemsIds;
        }
        else {
            _request = {
                ProjectTypeStatusLinkId: projectTypeStatusLinkId,
                ItemsIds: itemsIds,
            };
            _options = webapi_options;
        }
        return this._SetRankOnProjectDocument(_request, _options);
    }
    async _GetAllFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllFromListDefinition(udListDefinitionId, includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.IncludeDeleted) != 'undefined')) {
            _request = udListDefinitionId;
            _options = includeDeleted;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllFromListDefinition(_request, _options);
    }
    async _GetAllFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllFromListName(udListDefinitionName, includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.IncludeDeleted) != 'undefined')) {
            _request = udListDefinitionName;
            _options = includeDeleted;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllFromListName(_request, _options);
    }
    async _SaveAllFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveAllFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveAllFromListDefinition(udListDefinitionId, items, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.Items) != 'undefined')) {
            _request = udListDefinitionId;
            _options = items;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                Items: items,
            };
            _options = webapi_options;
        }
        return this._SaveAllFromListDefinition(_request, _options);
    }
    async _SaveAllFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveAllFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveAllFromListName(udListDefinitionName, items, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.Items) != 'undefined')) {
            _request = udListDefinitionName;
            _options = items;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                Items: items,
            };
            _options = webapi_options;
        }
        return this._SaveAllFromListName(_request, _options);
    }
    async _AddFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddFromListDefinition(udListDefinitionId, item, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.Item) != 'undefined')) {
            _request = udListDefinitionId;
            _options = item;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
                Item: item,
            };
            _options = webapi_options;
        }
        return this._AddFromListDefinition(_request, _options);
    }
    async _AddFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddFromListName(udListDefinitionName, item, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.Item) != 'undefined')) {
            _request = udListDefinitionName;
            _options = item;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
                Item: item,
            };
            _options = webapi_options;
        }
        return this._AddFromListName(_request, _options);
    }
    async _DeleteAllFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAllFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteAllFromListDefinition(udListDefinitionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionId;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionId) != 'undefined')) {
            _request = udListDefinitionId;
            _options = webapi_options;
        }
        else {
            _request = {
                UdListDefinitionId: udListDefinitionId,
            };
            _options = webapi_options;
        }
        return this._DeleteAllFromListDefinition(_request, _options);
    }
    async _DeleteAllFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAllFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteAllFromListName(udListDefinitionName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = udListDefinitionName;
        if (typeof (first) === "object" && first && (typeof (first.UdListDefinitionName) != 'undefined')) {
            _request = udListDefinitionName;
            _options = webapi_options;
        }
        else {
            _request = {
                UdListDefinitionName: udListDefinitionName,
            };
            _options = webapi_options;
        }
        return this._DeleteAllFromListName(_request, _options);
    }
    async _GetFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFromListDefinition(id, udListDefinitionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.UdListDefinitionId) != 'undefined')) {
            _request = id;
            _options = udListDefinitionId;
        }
        else {
            _request = {
                Id: id,
                UdListDefinitionId: udListDefinitionId,
            };
            _options = webapi_options;
        }
        return this._GetFromListDefinition(_request, _options);
    }
    async _GetFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFromListName(id, udListDefinitionName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.UdListDefinitionName) != 'undefined')) {
            _request = id;
            _options = udListDefinitionName;
        }
        else {
            _request = {
                Id: id,
                UdListDefinitionName: udListDefinitionName,
            };
            _options = webapi_options;
        }
        return this._GetFromListName(_request, _options);
    }
    async _SaveFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveFromListDefinition(id, udListDefinitionId, item, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.UdListDefinitionId) != 'undefined' || typeof (first.Item) != 'undefined')) {
            _request = id;
            _options = udListDefinitionId;
        }
        else {
            _request = {
                Id: id,
                UdListDefinitionId: udListDefinitionId,
                Item: item,
            };
            _options = webapi_options;
        }
        return this._SaveFromListDefinition(_request, _options);
    }
    async _SaveFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ListItemEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveFromListName(id, udListDefinitionName, item, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.UdListDefinitionName) != 'undefined' || typeof (first.Item) != 'undefined')) {
            _request = id;
            _options = udListDefinitionName;
        }
        else {
            _request = {
                Id: id,
                UdListDefinitionName: udListDefinitionName,
                Item: item,
            };
            _options = webapi_options;
        }
        return this._SaveFromListName(_request, _options);
    }
    async _DeleteFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteFromListDefinition(id, udListDefinitionId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.UdListDefinitionId) != 'undefined')) {
            _request = id;
            _options = udListDefinitionId;
        }
        else {
            _request = {
                Id: id,
                UdListDefinitionId: udListDefinitionId,
            };
            _options = webapi_options;
        }
        return this._DeleteFromListDefinition(_request, _options);
    }
    async _DeleteFromListName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteFromListName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteFromListName(id, udListDefinitionName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.UdListDefinitionName) != 'undefined')) {
            _request = id;
            _options = udListDefinitionName;
        }
        else {
            _request = {
                Id: id,
                UdListDefinitionName: udListDefinitionName,
            };
            _options = webapi_options;
        }
        return this._DeleteFromListName(_request, _options);
    }
    async _GetHeadingsFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHeadingsFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetHeadingsFromName(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._GetHeadingsFromName(_request, _options);
    }
    async _GetHeadingsFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetHeadingsFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetHeadingsFromListDefinition(id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined')) {
            _request = id;
            _options = webapi_options;
        }
        else {
            _request = {
                Id: id,
            };
            _options = webapi_options;
        }
        return this._GetHeadingsFromListDefinition(_request, _options);
    }
    async _SaveHeadingsFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingsFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveHeadingsFromName(name, entities, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.Entities) != 'undefined')) {
            _request = name;
            _options = entities;
        }
        else {
            _request = {
                Name: name,
                Entities: entities,
            };
            _options = webapi_options;
        }
        return this._SaveHeadingsFromName(_request, _options);
    }
    async _SaveHeadingsFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingsFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveHeadingsFromListDefinition(id, entities, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.Entities) != 'undefined')) {
            _request = id;
            _options = entities;
        }
        else {
            _request = {
                Id: id,
                Entities: entities,
            };
            _options = webapi_options;
        }
        return this._SaveHeadingsFromListDefinition(_request, _options);
    }
    async _SaveHeadingFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveHeadingFromName(name, entity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined' || typeof (first.Entity) != 'undefined')) {
            _request = name;
            _options = entity;
        }
        else {
            _request = {
                Name: name,
                Entity: entity,
            };
            _options = webapi_options;
        }
        return this._SaveHeadingFromName(_request, _options);
    }
    async _SaveHeadingFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveHeadingFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_HeadingEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveHeadingFromListDefinition(id, entity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.Entity) != 'undefined')) {
            _request = id;
            _options = entity;
        }
        else {
            _request = {
                Id: id,
                Entity: entity,
            };
            _options = webapi_options;
        }
        return this._SaveHeadingFromListDefinition(_request, _options);
    }
    async _DeleteAllHeadingsFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAllHeadingsFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteAllHeadingsFromName(name, webapi_options) {
        let _request = null;
        let _options = null;
        const first = name;
        if (typeof (first) === "object" && first && (typeof (first.Name) != 'undefined')) {
            _request = name;
            _options = webapi_options;
        }
        else {
            _request = {
                Name: name,
            };
            _options = webapi_options;
        }
        return this._DeleteAllHeadingsFromName(_request, _options);
    }
    async _DeleteAllHeadingsFromListDefinition(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAllHeadingsFromListDefinition", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteAllHeadingsFromListDefinition(id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined')) {
            _request = id;
            _options = webapi_options;
        }
        else {
            _request = {
                Id: id,
            };
            _options = webapi_options;
        }
        return this._DeleteAllHeadingsFromListDefinition(_request, _options);
    }
    /*
     * Gets a LocalizedText object.
     * @param localizedTextId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single LocalizedText
     */
    async GetLocalizedText(localizedTextId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLocalizedText?localizedTextId=" + localizedTextId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LocalizedText_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetLocalizedTextByType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLocalizedTextByType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LocalizedText_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetLocalizedTextByType(textType, resourceId, languageId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = textType;
        if (typeof (first) === "object" && first && (typeof (first.TextType) != 'undefined' || typeof (first.ResourceId) != 'undefined' || typeof (first.LanguageId) != 'undefined')) {
            _request = textType;
            _options = resourceId;
        }
        else {
            _request = {
                TextType: textType,
                ResourceId: resourceId,
                LanguageId: languageId,
            };
            _options = webapi_options;
        }
        return this._GetLocalizedTextByType(_request, _options);
    }
    /*
     * Gets an array of LocalizedText objects.
     * @param localizedTextIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of LocalizedText
     */
    async GetLocalizedTextList(localizedTextIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetLocalizedTextList", localizedTextIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LocalizedTextArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetLocalizedTexts(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLocalizedTexts", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LocalizedTextArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets all localized texts in the CRM database.
     * @returns Array of LocalizedText objects
     */
    async GetLocalizedTexts(webapi_options) {
        return this._GetLocalizedTexts(webapi_options);
    }
    async _GetLocalizedTextsByLanguageId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLocalizedTextsByLanguageId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LocalizedTextArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetLocalizedTextsByLanguageId(languageId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = languageId;
        if (typeof (first) === "object" && first && (typeof (first.LanguageId) != 'undefined')) {
            _request = languageId;
            _options = webapi_options;
        }
        else {
            _request = {
                LanguageId: languageId,
            };
            _options = webapi_options;
        }
        return this._GetLocalizedTextsByLanguageId(_request, _options);
    }
    async _GetLocalizedTextsByType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetLocalizedTextsByType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_LocalizedTextArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetLocalizedTextsByType(textTypes, webapi_options) {
        let _request = null;
        let _options = null;
        const first = textTypes;
        if (typeof (first) === "object" && first && (typeof (first.TextTypes) != 'undefined')) {
            _request = textTypes;
            _options = webapi_options;
        }
        else {
            _request = {
                TextTypes: textTypes,
            };
            _options = webapi_options;
        }
        return this._GetLocalizedTextsByType(_request, _options);
    }
    /*
     * Gets a MrMrs object.
     * @param mrMrsId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single MrMrs
     */
    async GetMrMrs(mrMrsId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetMrMrs?mrMrsId=" + mrMrsId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MrMrs_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of MrMrs objects.
     * @param mrMrsIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of MrMrs
     */
    async GetMrMrsList(mrMrsIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetMrMrsList", mrMrsIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MrMrsArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetMrMrses(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMrMrses", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MrMrsArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all Items from the MrMrs table sorted by their value.
     * @returns All items from the MrMrs table sorted by their value
     */
    async GetMrMrses(webapi_options) {
        return this._GetMrMrses(webapi_options);
    }
    /*
     * Gets a PaymentTerm object.
     * @param paymentTermId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PaymentTerm
     */
    async GetPaymentTerm(paymentTermId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPaymentTerm?paymentTermId=" + paymentTermId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PaymentTerm_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetPaymentTerms(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPaymentTerms", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PaymentTermArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all PaymentTerms in SuperOffice db.
     * @returns An array of all available PaymentTerms
     */
    async GetPaymentTerms(webapi_options) {
        return this._GetPaymentTerms(webapi_options);
    }
    /*
     * Gets a PaymentType object.
     * @param paymentTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PaymentType
     */
    async GetPaymentType(paymentTypeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPaymentType?paymentTypeId=" + paymentTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PaymentType_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetPaymentTypes(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPaymentTypes", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PaymentTypeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all PaymentTypes in SuperOffice db.
     * @returns An array of all available PaymentTypes
     */
    async GetPaymentTypes(webapi_options) {
        return this._GetPaymentTypes(webapi_options);
    }
    /*
     * Gets a Position object.
     * @param positionId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Position
     */
    async GetPosition(positionId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPosition?positionId=" + positionId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Position_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Position objects.
     * @param positionIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Position
     */
    async GetPositionList(positionIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPositionList", positionIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PositionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetPositions(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPositions", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PositionArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all the positions a person could have.
     * @returns An array of all available positions
     */
    async GetPositions(webapi_options) {
        return this._GetPositions(webapi_options);
    }
    /*
     * Gets a Priority object.
     * @param priorityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Priority
     */
    async GetPriority(priorityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPriority?priorityId=" + priorityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Priority_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Priority objects.
     * @param priorityIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Priority
     */
    async GetPriorityList(priorityIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPriorityList", priorityIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriorityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetPriorities(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPriorities", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PriorityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all priorities an appointment could have.
     * @returns An array of all available priorities
     */
    async GetPriorities(webapi_options) {
        return this._GetPriorities(webapi_options);
    }
    /*
     * Gets a ProductCategory object.
     * @param productCategoryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProductCategory
     */
    async GetProductCategory(productCategoryId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProductCategory?productCategoryId=" + productCategoryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductCategory_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetProductCategories(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductCategories", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductCategoryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all ProductCategories in SuperOffice list.
     * @returns An array of all available ProductCategory
     */
    async GetProductCategories(webapi_options) {
        return this._GetProductCategories(webapi_options);
    }
    /*
     * Gets a ProductFamily object.
     * @param productFamilyId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProductFamily
     */
    async GetProductFamily(productFamilyId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProductFamily?productFamilyId=" + productFamilyId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductFamily_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetProductFamilies(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductFamilies", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductFamilyArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all ProductFamily in SuperOffice list.
     * @returns An array of all available ProductFamilies
     */
    async GetProductFamilies(webapi_options) {
        return this._GetProductFamilies(webapi_options);
    }
    /*
     * Gets a ProductType object.
     * @param productTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProductType
     */
    async GetProductType(productTypeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProductType?productTypeId=" + productTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductType_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetProductTypes(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProductTypes", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProductTypeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all ProductTypes in SuperOffice list.
     * @returns An array of all available ProductTypes
     */
    async GetProductTypes(webapi_options) {
        return this._GetProductTypes(webapi_options);
    }
    /*
     * Gets a ProjectStatus object.
     * @param projectStatusId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectStatus
     */
    async GetProjectStatus(projectStatusId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectStatus?projectStatusId=" + projectStatusId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectStatus_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _DeleteProjectStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteProjectStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteProjectStatus(projectStatusId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectStatusId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectStatusId) != 'undefined')) {
            _request = projectStatusId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectStatusId: projectStatusId,
            };
            _options = webapi_options;
        }
        return this._DeleteProjectStatus(_request, _options);
    }
    /*
     * Gets an array of ProjectStatus objects.
     * @param projectStatusIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ProjectStatus
     */
    async GetProjectStatusList(projectStatusIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectStatusList", projectStatusIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectStatusArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetProjectStatuses(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectStatuses", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectStatusArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets all items from the Project Status (ProjStatus) table.
     * @returns List of all Project statuses.
     */
    async GetProjectStatuses(webapi_options) {
        return this._GetProjectStatuses(webapi_options);
    }
    /*
     * Gets a ProjectType object.
     * @param projectTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectType
     */
    async GetProjectType(projectTypeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectType?projectTypeId=" + projectTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectType_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ProjectTypeEntity object.
     * @param projectTypeEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ProjectTypeEntity
     */
    async GetProjectTypeEntity(projectTypeEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectTypeEntity?projectTypeEntityId=" + projectTypeEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectTypeEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of ProjectType objects.
     * @param projectTypeIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ProjectType
     */
    async GetProjectTypeList(projectTypeIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetProjectTypeList", projectTypeIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectTypeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetProjectTypes(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProjectTypes", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ProjectTypeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets all items from the Project Type (ProjType) table.
     * @returns List of all project types.
     */
    async GetProjectTypes(webapi_options) {
        return this._GetProjectTypes(webapi_options);
    }
    async _SaveQuickReplies(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveQuickReplies", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveQuickReplies(quickReplies, webapi_options) {
        let _request = null;
        let _options = null;
        const first = quickReplies;
        if (typeof (first) === "object" && first && (typeof (first.QuickReplies) != 'undefined')) {
            _request = quickReplies;
            _options = webapi_options;
        }
        else {
            _request = {
                QuickReplies: quickReplies,
            };
            _options = webapi_options;
        }
        return this._SaveQuickReplies(_request, _options);
    }
    async _GetQuickReplies(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuickReplies", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuickReplyArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Method to return all quick replies for a given associate
     * @returns Array of quick replies
     */
    async GetQuickReplies(webapi_options) {
        return this._GetQuickReplies(webapi_options);
    }
    /*
     * Gets a Rating object.
     * @param ratingId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Rating
     */
    async GetRating(ratingId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRating?ratingId=" + ratingId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Rating_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Rating objects.
     * @param ratingIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Rating
     */
    async GetRatingList(ratingIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRatingList", ratingIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RatingArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetRatings(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRatings", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RatingArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all ratings
     * @returns Array of ratings
     */
    async GetRatings(webapi_options) {
        return this._GetRatings(webapi_options);
    }
    async _GetAllSaleStages(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllSaleStages", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStageEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllSaleStages(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllSaleStages(_request, _options);
    }
    /*
     * Gets a Reason object.
     * @param reasonId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Reason
     */
    async GetReason(reasonId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReason?reasonId=" + reasonId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Reason_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Reason objects.
     * @param reasonIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Reason
     */
    async GetReasonList(reasonIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonList", reasonIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetReasons(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetReasons", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all reasons
     * @returns Array of reasons
     */
    async GetReasons(webapi_options) {
        return this._GetReasons(webapi_options);
    }
    /*
     * Gets a QuoteApproveReason object.
     * @param quoteApproveReasonId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single QuoteApproveReason
     */
    async GetQuoteApproveReason(quoteApproveReasonId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteApproveReason?quoteApproveReasonId=" + quoteApproveReasonId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteApproveReason_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of QuoteApproveReason objects.
     * @param quoteApproveReasonIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of QuoteApproveReason
     */
    async GetQuoteApproveReasonList(quoteApproveReasonIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteApproveReasonList", quoteApproveReasonIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteApproveReasonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetQuoteApproveReasons(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteApproveReasons", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteApproveReasonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all available QuoteApproveReasons.
     * @returns An array of all non-deleted QuoteApproveReason
     */
    async GetQuoteApproveReasons(webapi_options) {
        return this._GetQuoteApproveReasons(webapi_options);
    }
    /*
     * Gets a QuoteDenyReason object.
     * @param quoteDenyReasonId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single QuoteDenyReason
     */
    async GetQuoteDenyReason(quoteDenyReasonId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteDenyReason?quoteDenyReasonId=" + quoteDenyReasonId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteDenyReason_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of QuoteDenyReason objects.
     * @param quoteDenyReasonIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of QuoteDenyReason
     */
    async GetQuoteDenyReasonList(quoteDenyReasonIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetQuoteDenyReasonList", quoteDenyReasonIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteDenyReasonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetQuoteDenyReasons(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetQuoteDenyReasons", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_QuoteDenyReasonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all available QuoteDenyReasons.
     * @returns An array of all non-deleted QuoteDenyReason
     */
    async GetQuoteDenyReasons(webapi_options) {
        return this._GetQuoteDenyReasons(webapi_options);
    }
    /*
     * Gets a ReasonSold object.
     * @param reasonSoldId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ReasonSold
     */
    async GetReasonSold(reasonSoldId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonSold?reasonSoldId=" + reasonSoldId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonSold_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of ReasonSold objects.
     * @param reasonSoldIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ReasonSold
     */
    async GetReasonSoldList(reasonSoldIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonSoldList", reasonSoldIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonSoldArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ReasonStalled object.
     * @param reasonStalledId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ReasonStalled
     */
    async GetReasonStalled(reasonStalledId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonStalled?reasonStalledId=" + reasonStalledId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonStalled_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of ReasonStalled objects.
     * @param reasonStalledIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of ReasonStalled
     */
    async GetReasonStalledList(reasonStalledIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetReasonStalledList", reasonStalledIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReasonStalledArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a RelationDefinitionEntity object.
     * @param relationDefinitionEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single RelationDefinitionEntity
     */
    async GetRelationDefinitionEntity(relationDefinitionEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRelationDefinitionEntity?relationDefinitionEntityId=" + relationDefinitionEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RelationDefinitionEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ResourceEntity object.
     * @param resourceEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ResourceEntity
     */
    async GetResourceEntity(resourceEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetResourceEntity?resourceEntityId=" + resourceEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ResourceEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a SaleStageEntity object.
     * @param saleStageEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleStageEntity
     */
    async GetSaleStageEntity(saleStageEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleStageEntity?saleStageEntityId=" + saleStageEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a SaleType object.
     * @param saleTypeId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleType
     */
    async GetSaleType(saleTypeId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleType?saleTypeId=" + saleTypeId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleType_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a SaleTypeEntity object.
     * @param saleTypeEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleTypeEntity
     */
    async GetSaleTypeEntity(saleTypeEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleTypeEntity?saleTypeEntityId=" + saleTypeEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleTypeEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of SaleType objects.
     * @param saleTypeIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of SaleType
     */
    async GetSaleTypeList(saleTypeIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleTypeList", saleTypeIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleTypeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetAllSaleType(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllSaleType", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleTypeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all sale types as simple list items
     * @returns Array of simple sale type list items
     */
    async GetAllSaleType(webapi_options) {
        return this._GetAllSaleType(webapi_options);
    }
    async _GetAllSaleTypeEntities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllSaleTypeEntities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleTypeEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllSaleTypeEntities(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllSaleTypeEntities(_request, _options);
    }
    /*
     * Gets a SelectionCategory object.
     * @param selectionCategoryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SelectionCategory
     */
    async GetSelectionCategory(selectionCategoryId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSelectionCategory?selectionCategoryId=" + selectionCategoryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionCategory_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of SelectionCategory objects.
     * @param selectionCategoryIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of SelectionCategory
     */
    async GetSelectionCategoryList(selectionCategoryIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSelectionCategoryList", selectionCategoryIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectionCategoryArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Source object.
     * @param sourceId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Source
     */
    async GetSource(sourceId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSource?sourceId=" + sourceId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Source_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of Source objects.
     * @param sourceIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Source
     */
    async GetSourceList(sourceIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSourceList", sourceIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SourceArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetSources(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSources", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SourceArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all sources
     * @returns Array of sources
     */
    async GetSources(webapi_options) {
        return this._GetSources(webapi_options);
    }
    /*
     * Gets a Task object.
     * @param taskId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Task
     */
    async GetTask(taskId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTask?taskId=" + taskId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Task_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetDocumentTemplateTask(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplateTask", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Task_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDocumentTemplateTask(documentTemplateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentTemplateId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentTemplateId) != 'undefined')) {
            _request = documentTemplateId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentTemplateId: documentTemplateId,
            };
            _options = webapi_options;
        }
        return this._GetDocumentTemplateTask(_request, _options);
    }
    /*
     * Gets an array of Task objects.
     * @param taskIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Task
     */
    async GetTaskList(taskIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTaskList", taskIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetTasks(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTasks", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns all appointment tasks
     * @returns An array of all available tasks
     */
    async GetTasks(webapi_options) {
        return this._GetTasks(webapi_options);
    }
    async _GetDocumentTemplatesTasks(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDocumentTemplatesTasks", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * The appointment&apos;s task is a Document template item when the appointment is a document.
     * @returns Document Template list as a array of Tasks
     */
    async GetDocumentTemplatesTasks(webapi_options) {
        return this._GetDocumentTemplatesTasks(webapi_options);
    }
    async _GetAllTasks(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllTasks", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TaskListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllTasks(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllTasks(_request, _options);
    }
    /*
     * Gets a TicketCategory object.
     * @param ticketCategoryId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketCategory
     */
    async GetTicketCategory(ticketCategoryId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketCategory?ticketCategoryId=" + ticketCategoryId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketCategory_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a TicketCategoryEntity object.
     * @param ticketCategoryEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketCategoryEntity
     */
    async GetTicketCategoryEntity(ticketCategoryEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketCategoryEntity?ticketCategoryEntityId=" + ticketCategoryEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketCategoryEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _MoveAllTickets(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MoveAllTickets", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MoveAllTickets(fromTicketCategoryId, toTicketCategoryId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = fromTicketCategoryId;
        if (typeof (first) === "object" && first && (typeof (first.FromTicketCategoryId) != 'undefined' || typeof (first.ToTicketCategoryId) != 'undefined')) {
            _request = fromTicketCategoryId;
            _options = toTicketCategoryId;
        }
        else {
            _request = {
                FromTicketCategoryId: fromTicketCategoryId,
                ToTicketCategoryId: toTicketCategoryId,
            };
            _options = webapi_options;
        }
        return this._MoveAllTickets(_request, _options);
    }
    async _RebuildFullnames(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RebuildFullnames", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Update the fullname field of all categories. Use this e.g. when changing parentId or renaming a category with children.
     * @returns This method has no return value
     */
    async RebuildFullnames(webapi_options) {
        return this._RebuildFullnames(webapi_options);
    }
    /*
     * Gets an array of TicketCategoryEntity objects.
     * @param ticketCategoryEntityIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of TicketCategoryEntity
     */
    async GetTicketCategoryList(ticketCategoryEntityIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketCategoryList", ticketCategoryEntityIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketCategoryEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetTicketCategories(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketCategories", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketCategoryEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     *
     * @returns
     */
    async GetTicketCategories(webapi_options) {
        return this._GetTicketCategories(webapi_options);
    }
    async _GetTicketCategoriesForUserGroups(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketCategoriesForUserGroups", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTicketCategoriesForUserGroups(userGroupIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userGroupIds;
        if (typeof (first) === "object" && first && (typeof (first.UserGroupIds) != 'undefined')) {
            _request = userGroupIds;
            _options = webapi_options;
        }
        else {
            _request = {
                UserGroupIds: userGroupIds,
            };
            _options = webapi_options;
        }
        return this._GetTicketCategoriesForUserGroups(_request, _options);
    }
    async _SetTicketCategoriesForUserGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketCategoriesForUserGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetTicketCategoriesForUserGroup(userGroupId, categoryIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userGroupId;
        if (typeof (first) === "object" && first && (typeof (first.UserGroupId) != 'undefined' || typeof (first.CategoryIds) != 'undefined')) {
            _request = userGroupId;
            _options = categoryIds;
        }
        else {
            _request = {
                UserGroupId: userGroupId,
                CategoryIds: categoryIds,
            };
            _options = webapi_options;
        }
        return this._SetTicketCategoriesForUserGroup(_request, _options);
    }
    async _UpdateCategoryMemberships(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateCategoryMemberships", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateCategoryMemberships(ticketCategoryId, membershipsToAdd, membershipsToUpdate, membershipsToDelete, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketCategoryId;
        if (typeof (first) === "object" && first && (typeof (first.TicketCategoryId) != 'undefined' || typeof (first.MembershipsToAdd) != 'undefined' || typeof (first.MembershipsToUpdate) != 'undefined' || typeof (first.MembershipsToDelete) != 'undefined')) {
            _request = ticketCategoryId;
            _options = membershipsToAdd;
        }
        else {
            _request = {
                TicketCategoryId: ticketCategoryId,
                MembershipsToAdd: membershipsToAdd,
                MembershipsToUpdate: membershipsToUpdate,
                MembershipsToDelete: membershipsToDelete,
            };
            _options = webapi_options;
        }
        return this._UpdateCategoryMemberships(_request, _options);
    }
    /*
     * Gets a TicketPriority object.
     * @param ticketPriorityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketPriority
     */
    async GetTicketPriority(ticketPriorityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketPriority?ticketPriorityId=" + ticketPriorityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriority_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a TicketPriorityEntity object.
     * @param ticketPriorityEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketPriorityEntity
     */
    async GetTicketPriorityEntity(ticketPriorityEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketPriorityEntity?ticketPriorityEntityId=" + ticketPriorityEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriorityEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SetTicketPrioritySortOrder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketPrioritySortOrder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetTicketPrioritySortOrder(ticketPriorityId, sortOrder, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketPriorityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketPriorityId) != 'undefined' || typeof (first.SortOrder) != 'undefined')) {
            _request = ticketPriorityId;
            _options = sortOrder;
        }
        else {
            _request = {
                TicketPriorityId: ticketPriorityId,
                SortOrder: sortOrder,
            };
            _options = webapi_options;
        }
        return this._SetTicketPrioritySortOrder(_request, _options);
    }
    /*
     * Gets an array of TicketPriority objects.
     * @param ticketPriorityIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of TicketPriority
     */
    async GetTicketPriorityList(ticketPriorityIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketPriorityList", ticketPriorityIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriorityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetTicketPriorities(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketPriorities", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriorityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     *
     * @returns
     */
    async GetTicketPriorities(webapi_options) {
        return this._GetTicketPriorities(webapi_options);
    }
    async _GetAllTicketPriorities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllTicketPriorities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketPriorityEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllTicketPriorities(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllTicketPriorities(_request, _options);
    }
    /*
     * Gets a TicketStatusEntity object.
     * @param ticketStatusEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketStatusEntity
     */
    async GetTicketStatusEntity(ticketStatusEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketStatusEntity?ticketStatusEntityId=" + ticketStatusEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketStatusEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GlobalChangeTicketStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GlobalChangeTicketStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GlobalChangeTicketStatus(fromTicketStatusId, toTicketStatusId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = fromTicketStatusId;
        if (typeof (first) === "object" && first && (typeof (first.FromTicketStatusId) != 'undefined' || typeof (first.ToTicketStatusId) != 'undefined')) {
            _request = fromTicketStatusId;
            _options = toTicketStatusId;
        }
        else {
            _request = {
                FromTicketStatusId: fromTicketStatusId,
                ToTicketStatusId: toTicketStatusId,
            };
            _options = webapi_options;
        }
        return this._GlobalChangeTicketStatus(_request, _options);
    }
    async _SetTicketStatusSortOrder(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketStatusSortOrder", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetTicketStatusSortOrder(ticketStatusId, sortOrder, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketStatusId;
        if (typeof (first) === "object" && first && (typeof (first.TicketStatusId) != 'undefined' || typeof (first.SortOrder) != 'undefined')) {
            _request = ticketStatusId;
            _options = sortOrder;
        }
        else {
            _request = {
                TicketStatusId: ticketStatusId,
                SortOrder: sortOrder,
            };
            _options = webapi_options;
        }
        return this._SetTicketStatusSortOrder(_request, _options);
    }
    /*
     * Gets an array of TicketStatusEntity objects.
     * @param ticketStatusEntityIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of TicketStatusEntity
     */
    async GetTicketStatusList(ticketStatusEntityIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketStatusList", ticketStatusEntityIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketStatusEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetTicketStatuses(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketStatuses", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketStatusEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     *
     * @returns
     */
    async GetTicketStatuses(webapi_options) {
        return this._GetTicketStatuses(webapi_options);
    }
    /*
     * Gets a WebPanelEntity object.
     * @param webPanelEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single WebPanelEntity
     */
    async GetWebPanelEntity(webPanelEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetWebPanelEntity?webPanelEntityId=" + webPanelEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WebPanelEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GenerateNavigationUrl(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateNavigationUrl", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GenerateNavigationUrl(visibleIn, windowName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = visibleIn;
        if (typeof (first) === "object" && first && (typeof (first.VisibleIn) != 'undefined' || typeof (first.WindowName) != 'undefined')) {
            _request = visibleIn;
            _options = windowName;
        }
        else {
            _request = {
                VisibleIn: visibleIn,
                WindowName: windowName,
            };
            _options = webapi_options;
        }
        return this._GenerateNavigationUrl(_request, _options);
    }
    async _GetWebPanelList(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWebPanelList", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WebPanelEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Return a list of all web panels.
     * @returns List of all web panels
     */
    async GetWebPanelList(webapi_options) {
        return this._GetWebPanelList(webapi_options);
    }
    async _DeleteWebPanel(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteWebPanel", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteWebPanel(id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined')) {
            _request = id;
            _options = webapi_options;
        }
        else {
            _request = {
                Id: id,
            };
            _options = webapi_options;
        }
        return this._DeleteWebPanel(_request, _options);
    }
    async _GetAppWebPanels(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAppWebPanels", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WebPanelEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get all web panels owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken
     * @returns List of all web panels owned by the current App
     */
    async GetAppWebPanels(webapi_options) {
        return this._GetAppWebPanels(webapi_options);
    }
    async _DeleteAppWebPanels(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteAppWebPanels", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Permanentely delete all web panels owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken; otherwise nothing happens
     * @returns This method has no return value
     */
    async DeleteAppWebPanels(webapi_options) {
        return this._DeleteAppWebPanels(webapi_options);
    }
    async _GetWebPanelByProgId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetWebPanelByProgId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_WebPanelEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetWebPanelByProgId(progId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = progId;
        if (typeof (first) === "object" && first && (typeof (first.ProgId) != 'undefined')) {
            _request = progId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProgId: progId,
            };
            _options = webapi_options;
        }
        return this._GetWebPanelByProgId(_request, _options);
    }
} // class v1ListAgentController 
exports.ListAgent = ListAgent;
//# sourceMappingURL=ListAgent.js.map
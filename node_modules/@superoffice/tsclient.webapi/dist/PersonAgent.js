"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersonAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
const Base64_1 = require("./Base64");
/**
 * Person data services.
 */
class PersonAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Person/";
        super(options);
    }
    /**
     * Set default values into a new ConsentPerson.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultConsentPerson(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultConsentPerson", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPerson_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ConsentPerson or creates a new ConsentPerson if the id parameter is empty
     * @param entity - The ConsentPerson to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ConsentPerson
     */
    async SaveConsentPerson(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveConsentPerson", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPerson_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ConsentPerson
     * @param ConsentPersonId - The id of the ConsentPerson to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteConsentPerson(ConsentPersonId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteConsentPerson?ConsentPersonId=" + ConsentPersonId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new PersonEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultPersonEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPersonEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing PersonEntity or creates a new PersonEntity if the id parameter is empty
     * @param entity - The PersonEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated PersonEntity
     */
    async SavePersonEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SavePersonEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the PersonEntity
     * @param PersonEntityId - The id of the PersonEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeletePersonEntity(PersonEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeletePersonEntity?PersonEntityId=" + PersonEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new PersonImage.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultPersonImage(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultPersonImage", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonImage_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a ConsentPerson object.
     * @param consentPersonId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ConsentPerson
     */
    async GetConsentPerson(consentPersonId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetConsentPerson?consentPersonId=" + consentPersonId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentPerson_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Person object.
     * @param personId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Person
     */
    async GetPerson(personId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPerson?personId=" + personId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Person_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a PersonEntity object.
     * @param personEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single PersonEntity
     */
    async GetPersonEntity(personEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPersonEntity?personEntityId=" + personEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _Undelete(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Undelete", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Undelete(id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined')) {
            _request = id;
            _options = webapi_options;
        }
        else {
            _request = {
                Id: id,
            };
            _options = webapi_options;
        }
        return this._Undelete(_request, _options);
    }
    async _GetMyPerson(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyPerson", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets the person info belonging to the currently logged on user.
     * @returns The PersonEntity
     */
    async GetMyPerson(webapi_options) {
        return this._GetMyPerson(webapi_options);
    }
    async _GetSalesRep(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSalesRep", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSalesRep(contactName, personFirstname, personLastname, emailAddress, phoneNumber, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactName;
        if (typeof (first) === "object" && first && (typeof (first.ContactName) != 'undefined' || typeof (first.PersonFirstname) != 'undefined' || typeof (first.PersonLastname) != 'undefined' || typeof (first.EmailAddress) != 'undefined' || typeof (first.PhoneNumber) != 'undefined')) {
            _request = contactName;
            _options = personFirstname;
        }
        else {
            _request = {
                ContactName: contactName,
                PersonFirstname: personFirstname,
                PersonLastname: personLastname,
                EmailAddress: emailAddress,
                PhoneNumber: phoneNumber,
            };
            _options = webapi_options;
        }
        return this._GetSalesRep(_request, _options);
    }
    async _GetPhones(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPhones", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_EntityElementArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPhones(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetPhones(_request, _options);
    }
    async _ChangeCountry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeCountry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeCountry(personEntity, toCountryId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personEntity;
        if (typeof (first) === "object" && first && (typeof (first.PersonEntity) != 'undefined' || typeof (first.ToCountryId) != 'undefined')) {
            _request = personEntity;
            _options = toCountryId;
        }
        else {
            _request = {
                PersonEntity: personEntity,
                ToCountryId: toCountryId,
            };
            _options = webapi_options;
        }
        return this._ChangeCountry(_request, _options);
    }
    async _GetAddress(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAddress", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Address_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAddress(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetAddress(_request, _options);
    }
    async _GetAddressByCountry(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAddressByCountry", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Address_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAddressByCountry(personId, countryId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.CountryId) != 'undefined')) {
            _request = personId;
            _options = countryId;
        }
        else {
            _request = {
                PersonId: personId,
                CountryId: countryId,
            };
            _options = webapi_options;
        }
        return this._GetAddressByCountry(_request, _options);
    }
    async _GetPersonImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonImage", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonImage(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetPersonImage(_request, _options);
    }
    async _SetPersonImage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPersonImage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetPersonImage(personId, image, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.Image) != 'undefined')) {
            _request = personId;
            _options = image;
        }
        else {
            _request = {
                PersonId: personId,
                Image: image,
            };
            _options = webapi_options;
        }
        _request.Image = (0, Base64_1.ToBase64)(_request.Image);
        return this._SetPersonImage(_request, _options);
    }
    async _CreateDefaultByContactId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultByContactId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultByContactId(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultByContactId(_request, _options);
    }
    async _Move(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Move", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Move(personId, destinationContactId, moveAfterDate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.DestinationContactId) != 'undefined' || typeof (first.MoveAfterDate) != 'undefined')) {
            _request = personId;
            _options = destinationContactId;
        }
        else {
            _request = {
                PersonId: personId,
                DestinationContactId: destinationContactId,
                MoveAfterDate: moveAfterDate,
            };
            _options = webapi_options;
        }
        return this._Move(_request, _options);
    }
    async _Merge(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Merge", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Merge(sourcePersonId, destinationPersonId, moveAfterDate, deleteSource, replaceEmptyFieldsOnDestination, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourcePersonId;
        if (typeof (first) === "object" && first && (typeof (first.SourcePersonId) != 'undefined' || typeof (first.DestinationPersonId) != 'undefined' || typeof (first.MoveAfterDate) != 'undefined' || typeof (first.DeleteSource) != 'undefined' || typeof (first.ReplaceEmptyFieldsOnDestination) != 'undefined')) {
            _request = sourcePersonId;
            _options = destinationPersonId;
        }
        else {
            _request = {
                SourcePersonId: sourcePersonId,
                DestinationPersonId: destinationPersonId,
                MoveAfterDate: moveAfterDate,
                DeleteSource: deleteSource,
                ReplaceEmptyFieldsOnDestination: replaceEmptyFieldsOnDestination,
            };
            _options = webapi_options;
        }
        return this._Merge(_request, _options);
    }
    async _CreateDefaultFromCredential(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultFromCredential", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultFromCredential(contactId, credentialType, credentialValue, credentialDisplayValue, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.CredentialType) != 'undefined' || typeof (first.CredentialValue) != 'undefined' || typeof (first.CredentialDisplayValue) != 'undefined')) {
            _request = contactId;
            _options = credentialType;
        }
        else {
            _request = {
                ContactId: contactId,
                CredentialType: credentialType,
                CredentialValue: credentialValue,
                CredentialDisplayValue: credentialDisplayValue,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultFromCredential(_request, _options);
    }
    async _IsNumberValid(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNumberValid", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsNumberValid(contactId, number, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.Number) != 'undefined')) {
            _request = contactId;
            _options = number;
        }
        else {
            _request = {
                ContactId: contactId,
                Number: number,
            };
            _options = webapi_options;
        }
        return this._IsNumberValid(_request, _options);
    }
    async _SetConsent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetConsent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetConsent(personId, purpose, source, legalBase, comment, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.Purpose) != 'undefined' || typeof (first.Source) != 'undefined' || typeof (first.LegalBase) != 'undefined' || typeof (first.Comment) != 'undefined')) {
            _request = personId;
            _options = purpose;
        }
        else {
            _request = {
                PersonId: personId,
                Purpose: purpose,
                Source: source,
                LegalBase: legalBase,
                Comment: comment,
            };
            _options = webapi_options;
        }
        return this._SetConsent(_request, _options);
    }
    async _RemoveConsent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveConsent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveConsent(personId, purpose, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.Purpose) != 'undefined')) {
            _request = personId;
            _options = purpose;
        }
        else {
            _request = {
                PersonId: personId,
                Purpose: purpose,
            };
            _options = webapi_options;
        }
        return this._RemoveConsent(_request, _options);
    }
    async _HasConsent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasConsent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async HasConsent(personId, purpose, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.Purpose) != 'undefined')) {
            _request = personId;
            _options = purpose;
        }
        else {
            _request = {
                PersonId: personId,
                Purpose: purpose,
            };
            _options = webapi_options;
        }
        return this._HasConsent(_request, _options);
    }
    async _GetConsentInfos(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetConsentInfos", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ConsentInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetConsentInfos(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetConsentInfos(_request, _options);
    }
    async _SendConsentConfirmationEmail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendConsentConfirmationEmail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SendConsentConfirmationEmail(personId, emailAddress, emailTemplateId, cultureLcidId, subject, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.EmailAddress) != 'undefined' || typeof (first.EmailTemplateId) != 'undefined' || typeof (first.CultureLcidId) != 'undefined' || typeof (first.Subject) != 'undefined')) {
            _request = personId;
            _options = emailAddress;
        }
        else {
            _request = {
                PersonId: personId,
                EmailAddress: emailAddress,
                EmailTemplateId: emailTemplateId,
                CultureLcidId: cultureLcidId,
                Subject: subject,
            };
            _options = webapi_options;
        }
        return this._SendConsentConfirmationEmail(_request, _options);
    }
    async _ResolvePersonFromInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResolvePersonFromInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ResolvedPerson_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ResolvePersonFromInfo(contactId, personName, phoneNumbers, emails, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.PersonName) != 'undefined' || typeof (first.PhoneNumbers) != 'undefined' || typeof (first.Emails) != 'undefined')) {
            _request = contactId;
            _options = personName;
        }
        else {
            _request = {
                ContactId: contactId,
                PersonName: personName,
                PhoneNumbers: phoneNumbers,
                Emails: emails,
            };
            _options = webapi_options;
        }
        return this._ResolvePersonFromInfo(_request, _options);
    }
    async _AddEmailAddressToPerson(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddEmailAddressToPerson", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddEmailAddressToPerson(personId, emailAddress, setAsPrimaryEmail, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.EmailAddress) != 'undefined' || typeof (first.SetAsPrimaryEmail) != 'undefined')) {
            _request = personId;
            _options = emailAddress;
        }
        else {
            _request = {
                PersonId: personId,
                EmailAddress: emailAddress,
                SetAsPrimaryEmail: setAsPrimaryEmail,
            };
            _options = webapi_options;
        }
        return this._AddEmailAddressToPerson(_request, _options);
    }
    async _CreateTemporaryKey(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateTemporaryKey", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateTemporaryKey(domain, targetId, personId, expires, webapi_options) {
        let _request = null;
        let _options = null;
        const first = domain;
        if (typeof (first) === "object" && first && (typeof (first.Domain) != 'undefined' || typeof (first.TargetId) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.Expires) != 'undefined')) {
            _request = domain;
            _options = targetId;
        }
        else {
            _request = {
                Domain: domain,
                TargetId: targetId,
                PersonId: personId,
                Expires: expires,
            };
            _options = webapi_options;
        }
        return this._CreateTemporaryKey(_request, _options);
    }
    async _CheckTemporaryKey(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckTemporaryKey", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TemporaryKeyInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CheckTemporaryKey(temporaryKey, webapi_options) {
        let _request = null;
        let _options = null;
        const first = temporaryKey;
        if (typeof (first) === "object" && first && (typeof (first.TemporaryKey) != 'undefined')) {
            _request = temporaryKey;
            _options = webapi_options;
        }
        else {
            _request = {
                TemporaryKey: temporaryKey,
            };
            _options = webapi_options;
        }
        return this._CheckTemporaryKey(_request, _options);
    }
    async _DeleteTemporaryKeysOfDomain(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteTemporaryKeysOfDomain", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteTemporaryKeysOfDomain(domain, personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = domain;
        if (typeof (first) === "object" && first && (typeof (first.Domain) != 'undefined' || typeof (first.PersonId) != 'undefined')) {
            _request = domain;
            _options = personId;
        }
        else {
            _request = {
                Domain: domain,
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._DeleteTemporaryKeysOfDomain(_request, _options);
    }
    async _DeleteExpired(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteExpired", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Trigger deletion of persons that has been (soft) deleted and have timed out the expiry period (the SoftDeleteRetention preference).
     * @returns
     */
    async DeleteExpired(webapi_options) {
        return this._DeleteExpired(webapi_options);
    }
    async _GetPersonSummary(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonSummary", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonSummary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonSummary(personId, limit, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.Limit) != 'undefined')) {
            _request = personId;
            _options = limit;
        }
        else {
            _request = {
                PersonId: personId,
                Limit: limit,
            };
            _options = webapi_options;
        }
        return this._GetPersonSummary(_request, _options);
    }
    async _AddBounce(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddBounce", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddBounce(emailAddress, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailAddress;
        if (typeof (first) === "object" && first && (typeof (first.EmailAddress) != 'undefined')) {
            _request = emailAddress;
            _options = webapi_options;
        }
        else {
            _request = {
                EmailAddress: emailAddress,
            };
            _options = webapi_options;
        }
        return this._AddBounce(_request, _options);
    }
    async _ValidatePersonEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidatePersonEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidatePersonEntity(personEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personEntity;
        if (typeof (first) === "object" && first && (typeof (first.PersonEntity) != 'undefined')) {
            _request = personEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonEntity: personEntity,
            };
            _options = webapi_options;
        }
        return this._ValidatePersonEntity(_request, _options);
    }
    async _AddBounceWithCount(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddBounceWithCount", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddBounceWithCount(emailAddress, counts, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailAddress;
        if (typeof (first) === "object" && first && (typeof (first.EmailAddress) != 'undefined' || typeof (first.Counts) != 'undefined')) {
            _request = emailAddress;
            _options = counts;
        }
        else {
            _request = {
                EmailAddress: emailAddress,
                Counts: counts,
            };
            _options = webapi_options;
        }
        return this._AddBounceWithCount(_request, _options);
    }
    async _GetBestSoLanguageForTemplate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBestSoLanguageForTemplate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetBestSoLanguageForTemplate(personId, templateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.TemplateId) != 'undefined')) {
            _request = personId;
            _options = templateId;
        }
        else {
            _request = {
                PersonId: personId,
                TemplateId: templateId,
            };
            _options = webapi_options;
        }
        return this._GetBestSoLanguageForTemplate(_request, _options);
    }
    async _AddBounceWithDetails(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddBounceWithDetails", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddBounceWithDetails(emailAddress, counts, code, reason, webapi_options) {
        let _request = null;
        let _options = null;
        const first = emailAddress;
        if (typeof (first) === "object" && first && (typeof (first.EmailAddress) != 'undefined' || typeof (first.Counts) != 'undefined' || typeof (first.Code) != 'undefined' || typeof (first.Reason) != 'undefined')) {
            _request = emailAddress;
            _options = counts;
        }
        else {
            _request = {
                EmailAddress: emailAddress,
                Counts: counts,
                Code: code,
                Reason: reason,
            };
            _options = webapi_options;
        }
        return this._AddBounceWithDetails(_request, _options);
    }
    async _GetPersonImages(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonImages", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonImageArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonImages(personIds, scaledWidth, scaledHeight, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personIds;
        if (typeof (first) === "object" && first && (typeof (first.PersonIds) != 'undefined' || typeof (first.ScaledWidth) != 'undefined' || typeof (first.ScaledHeight) != 'undefined')) {
            _request = personIds;
            _options = scaledWidth;
        }
        else {
            _request = {
                PersonIds: personIds,
                ScaledWidth: scaledWidth,
                ScaledHeight: scaledHeight,
            };
            _options = webapi_options;
        }
        return this._GetPersonImages(_request, _options);
    }
    async _CreateOrUpdateUserCandidate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateOrUpdateUserCandidate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserCandidate_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateOrUpdateUserCandidate(personId, username, accessAllRequests, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.Username) != 'undefined' || typeof (first.AccessAllRequests) != 'undefined')) {
            _request = personId;
            _options = username;
        }
        else {
            _request = {
                PersonId: personId,
                Username: username,
                AccessAllRequests: accessAllRequests,
            };
            _options = webapi_options;
        }
        return this._CreateOrUpdateUserCandidate(_request, _options);
    }
    async _GetUserCandidateByPerson(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserCandidateByPerson", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserCandidate_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUserCandidateByPerson(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetUserCandidateByPerson(_request, _options);
    }
    async _GetCustomerCentrePasswordReplyTemplate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCustomerCentrePasswordReplyTemplate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ReplyTemplateParsed_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCustomerCentrePasswordReplyTemplate(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetCustomerCentrePasswordReplyTemplate(_request, _options);
    }
    async _SendEmail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendEmail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SendEmail(from, to, subject, plainBody, htmlBody, attachmentIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = from;
        if (typeof (first) === "object" && first && (typeof (first.From) != 'undefined' || typeof (first.To) != 'undefined' || typeof (first.Subject) != 'undefined' || typeof (first.PlainBody) != 'undefined' || typeof (first.HtmlBody) != 'undefined' || typeof (first.AttachmentIds) != 'undefined')) {
            _request = from;
            _options = to;
        }
        else {
            _request = {
                From: from,
                To: to,
                Subject: subject,
                PlainBody: plainBody,
                HtmlBody: htmlBody,
                AttachmentIds: attachmentIds,
            };
            _options = webapi_options;
        }
        return this._SendEmail(_request, _options);
    }
    /*
     * Gets an array of Person objects.
     * @param personIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Person
     */
    async GetPersonList(personIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetPersonList", personIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetPersonsFromContact(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonsFromContact", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonsFromContact(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._GetPersonsFromContact(_request, _options);
    }
    async _GetPersonsFromProject(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPersonsFromProject", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPersonsFromProject(projectId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = projectId;
        if (typeof (first) === "object" && first && (typeof (first.ProjectId) != 'undefined')) {
            _request = projectId;
            _options = webapi_options;
        }
        else {
            _request = {
                ProjectId: projectId,
            };
            _options = webapi_options;
        }
        return this._GetPersonsFromProject(_request, _options);
    }
    async _GetColleagues(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetColleagues", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Gets the persons working in the same company as the logged on user.
     * @returns Colleagues.
     */
    async GetColleagues(webapi_options) {
        return this._GetColleagues(webapi_options);
    }
    async _GetColleaguesByDepartment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetColleaguesByDepartment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetColleaguesByDepartment(departmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = departmentId;
        if (typeof (first) === "object" && first && (typeof (first.DepartmentId) != 'undefined')) {
            _request = departmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DepartmentId: departmentId,
            };
            _options = webapi_options;
        }
        return this._GetColleaguesByDepartment(_request, _options);
    }
    async _GetColleaguesBySource(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetColleaguesBySource", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PersonArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetColleaguesBySource(sourceType, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourceType;
        if (typeof (first) === "object" && first && (typeof (first.SourceType) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = sourceType;
            _options = count;
        }
        else {
            _request = {
                SourceType: sourceType,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetColleaguesBySource(_request, _options);
    }
    async _GetMyOwner(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyOwner", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Person_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the owner of the logged in person.
     * @returns Person
     */
    async GetMyOwner(webapi_options) {
        return this._GetMyOwner(webapi_options);
    }
    async _GetOwnerOnPersonId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOwnerOnPersonId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Person_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetOwnerOnPersonId(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetOwnerOnPersonId(_request, _options);
    }
    async _ChangePersonRank(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangePersonRank", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangePersonRank(personId, moveUp, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.MoveUp) != 'undefined')) {
            _request = personId;
            _options = moveUp;
        }
        else {
            _request = {
                PersonId: personId,
                MoveUp: moveUp,
            };
            _options = webapi_options;
        }
        return this._ChangePersonRank(_request, _options);
    }
    async _SetPersonRank(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPersonRank", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetPersonRank(personId, desiredRank, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.DesiredRank) != 'undefined')) {
            _request = personId;
            _options = desiredRank;
        }
        else {
            _request = {
                PersonId: personId,
                DesiredRank: desiredRank,
            };
            _options = webapi_options;
        }
        return this._SetPersonRank(_request, _options);
    }
    async _NormalizeRanks(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NormalizeRanks", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async NormalizeRanks(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._NormalizeRanks(_request, _options);
    }
} // class v1PersonAgentController 
exports.PersonAgent = PersonAgent;
//# sourceMappingURL=PersonAgent.js.map
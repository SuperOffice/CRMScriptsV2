import * as enums from "./Enums";
import * as moment from "moment";
/**
 * Street and/or Postal address, in both formatted and structured forms. You only need to modify one of the two for the change to be registered.
 */
export interface Address extends Carrier {
    /**
     * Latitude (that's north/south), decimal degrees, relative to WGS 84 ellipsoid. SuperOffice ASA is at 59.91892. This value needs no further grid reference or other qualifying information.
     */
    Wgs84Latitude?: number;
    /**
     * Longitude (that's East/west), decimal degrees, relative to WGS 84 ellipsoid. SuperOffice ASA is at 10.73159. This value needs no further grid reference or other qualifying information.
     */
    Wgs84Longitude?: number;
    /**
     * LocalizedFieldArray is a list of LocalizedFieldList objects. Used to store localized information such as formatted address data.
     */
    LocalizedAddress?: LocalizedField[][];
    /**
     * Street address (company street, person address, delivery address). LocalizedAddress changes override this property, so you do not have to change both Localized and this.
     */
    Street?: StructuredAddress;
    /**
     * Postal address (company postal, billing address). LocalizedAddress changes override this property, so you do not have to change both Localized and this.
     */
    Postal?: StructuredAddress;
    /**
     * Read-only formatted address multi-line string. Combines street and postal into one string. e.g.: <c>"Postboks 123,\nBrugata 123,\n1234 OSLO\n"</c> or <c>"Postbox 123,\nBridgelane 123,\nWest Tooting,\nEast Shire ES2 W31\n"</c>.
     */
    Formatted?: string;
}
/**
 * Base class for carrier objects Implementing common carrier properties
 */
export interface Carrier {
    /**
     * The carrier's table right
     */
    TableRight?: TableRight;
    /**
     * Rights on the carriers fields
     */
    FieldProperties?: FieldPropertyDictionary;
}
/**
 * Serializable dictionary.
 */
export interface ColumnDataDictionary {
    [index: string]: ArchiveColumnData;
}
/**
 * Generic carrier object for entity commands.
 */
export interface CommandResult extends Carrier {
    /**
     * The command was successfully executed.
     */
    Success?: boolean;
    /**
     * Message which should be displayed in GUI.
     */
    Message?: string;
    /**
     * The result used in this action.
     */
    Result?: enums.CommandActionResult;
}
/**
 * Class representing an ContactPersonId carrier used for storing either a person id or a contact id. If PersonId contains an id, ContactId will be 0, and the other way around.
 */
export interface ContactPersonId extends Carrier {
    /**
     * A person id.
     */
    PersonId?: number;
    /**
     * A contact id.
     */
    ContactId?: number;
}
/**
 * Generic carrier object for entity commands.
 */
export interface CustomCommand extends Carrier {
    /**
     * Unique name of the command
     */
    Name?: string;
    /**
     * The name to show in GUI
     */
    DisplayName?: string;
    /**
     * Description of the command.
     */
    Description?: string;
    /**
     * Tooltip to be used in the GUI
     */
    ToolTip?: string;
    /**
     * The actions to call when invoked
     */
    Actions?: enums.CommandAction;
    /**
     * The data to be used when the command is invoked
     */
    ActionData?: string;
}
/**
 * A duplicate entry
 */
export interface DuplicateEntry extends Carrier {
    /**
     * Identifying name for rule
     */
    RuleName?: string;
    /**
     * Identity of an entry in the SuperOffice database. Should be 0 for matches from external systems.
     */
    SoPrimaryKey?: number;
    /**
     * Name of duplicate entry
     */
    EntryName?: string;
    /**
     * String identifier for entry. Typically used to identify an entry in an external system.
     */
    EntryIdentifier?: string;
    /**
     * Short name of rule to display to user
     */
    RuleDisplayName?: string;
}
/**
 * Describes one duplicate rule to be used to find similar entries
 */
export interface DuplicateRule extends Carrier {
    /**
     * Identifying name for rule
     */
    Name?: string;
    /**
     * Short name of rule to display to user
     */
    DisplayName?: string;
    /**
     * Description of the rule
     */
    DisplayTooltip?: string;
    /**
     * Indicating if a rule is current active, and should included in the duplicate detection
     */
    IsActive?: boolean;
}
/**
 * Generic carrier object for entity elements such as Phone, EntityElement, Url. These elements do not have id and rank. These values are changed on each save, and should not be depended on. When used in a list or array the rank is the ascending list order.
 */
export interface EntityElement extends Carrier {
    /**
     * The Element FullName.  This is a value that is intended to be shown to the user.
     */
    Value?: string;
    /**
     * The Element FullName.  This is a value that can be parsed and used by systems.
     */
    StrippedValue?: string;
    /**
     * The Element Description
     */
    Description?: string;
}
/**
 * Class holding properties about a field in the carrier.
 */
export interface FieldProperty {
    /**
     * The field right
     */
    FieldRight?: FieldRight;
    /**
     * Type of field
     */
    FieldType?: string;
    /**
     * Length of the field
     */
    FieldLength?: number;
}
/**
 * Serializable dictionary.
 */
export interface FieldPropertyDictionary {
    [index: string]: FieldProperty;
}
/**
 * Wraps a field right together with an explanatory reason.
 */
export interface FieldRight {
    /**
     * Returns the bitflag of permissions.
     */
    Mask?: enums.EFieldRight;
    /**
     * Contains a string that explains why the right is not available. The reason is blank if HasAll is true.
     */
    Reason?: string;
}
/**
 * Represents a single module license granted to a user.
 */
export interface GrantedModuleLicense extends Carrier {
    /**
     * Primary key of the ModuleOwner row.
     */
    OwnerId?: number;
    /**
     * Unique name identifying the module owner. Must match primer data installed by module. e.g. SUPEROFFICE or ADWIZA
     */
    OwnerName?: string;
    /**
     * Description of the owner module as shown in the user interface.
     */
    OwnerDescription?: string;
    /**
     * Primary key for ModuleLicense row
     */
    ModuleId?: number;
    /**
     * Unique name identifying the module. e.g. WINCAL or SUPERSERVER
     */
    Name?: string;
    /**
     * Name of the module as shown in the user interface.
     */
    Description?: string;
    /**
     * Version of the module license (for future use).
     */
    Version?: string;
    /**
     * Type of license: site(1), satellite(2), user(3)
     */
    LicenseType?: enums.LicenseType;
    /**
     * Any additional data the license module needs.
     */
    ExtraFlags?: number;
    /**
     * Order in which licenses are sorted in the license calculations.
     */
    SortOrder?: number;
    /**
     * Number of licenses granted.
     */
    LicenseNumber?: number;
    /**
     * Is the license hidden from the user? Hidden licenses are usually feature-specific, part of a larger bundle.
     */
    IsHidden?: boolean;
    /**
     * Is the license limited to the number of licenses?
     */
    IsUnrestricted?: boolean;
    /**
     * Expiry date for the license.
     */
    ExpiryDate?: Date;
}
/**
 * Serializable dictionary.
 */
export interface IntStringDictionary {
    [index: number]: string;
}
/**
 * LocalizedField is used to store localized information such as formatted address data, a formatted phone number, etc.
 */
export interface LocalizedField extends Carrier {
    /**
     * Name of the value field
     */
    Name?: string;
    /**
     * The field's value
     */
    Value?: string;
    /**
     * The tooltip
     */
    Tooltip?: string;
    /**
     * The label of the field
     */
    Label?: string;
    /**
     * Database length of the value
     */
    ValueLength?: number;
    /**
     *
     */
    AddressType?: string;
}
/**
 * Metric, in the form of string->int
 */
export interface MetricPair {
    /**
     * The name of the metric
     */
    Name?: string;
    /**
     * The value of the metric
     */
    Value?: number;
}
/**
 * Operation result
 */
export interface OperationResult {
    /**
     * Indicates if the operation was successful.
     */
    Success?: boolean;
    /**
     * Success/Error message. This can be a symbol ([SR_xxxx])
     */
    Message?: string;
}
/**
 *
 */
export interface ProjectTypeStatusLink extends Carrier {
    /**
     * Primary key
     */
    ProjectTypeStatusLinkId?: number;
    /**
     * Primary key
     */
    ProjTypeId?: number;
    /**
     * The list item
     */
    ProjTypeName?: string;
    /**
     * Tooltip or other description
     */
    ProjTypeTooltip?: string;
    /**
     * Primary key
     */
    ProjStatusId?: number;
    /**
     * The list item
     */
    ProjStatusName?: string;
    /**
     * Tooltip or other description
     */
    ProjStatusTooltip?: string;
}
/**
 * Representation of how the current user got authenticated
 */
export interface ProvidedCredential {
    /**
     * The type of credential. This will reflect the value in Credential.Type
     */
    Type?: string;
    /**
     * The search name used for looking up
     */
    SearchName?: string;
    /**
     * The display name used in display fields
     */
    DisplayName?: string;
    /**
     * The credential row that allowed us access
     */
    CredentialId?: number;
}
/**
 * Class representing ticket message recipient.
 */
export interface Recipient {
    /**
     * Recipient type: To, Cc.
     */
    Type?: enums.RecipientType;
    /**
     * Email address
     */
    Value?: string;
    /**
     * User friendly display
     */
    DisplayValue?: string;
}
/**
 * Class representing a RecipientStatistics carrier used for counting attributes on selection members.
 */
export interface RecipientStatistics extends Carrier {
    /**
     * Total number of members.
     */
    Total?: number;
    /**
     * Number of members with a valid postal address.
     */
    ValidPostalAddresses?: number;
    /**
     * Number of members with a valid email address.
     */
    ValidEmailAddresses?: number;
    /**
     * Number of members with a valid fax number.
     */
    ValidFaxNumbers?: number;
    /**
     * Number of members with an invalid address.
     */
    NoAddresses?: number;
    /**
     * Number of members with no fax or email address.
     */
    NoFaxOrEmails?: number;
}
/**
 * Class representing a recurrence date.
 */
export interface RecurrenceDate {
    /**
     * The date of the recurring appointment.
     */
    Date?: Date;
    /**
     * True if this date creates a conflict.
     */
    IsConflict?: boolean;
    /**
     * Any description, such as red letter day info, or marked dates
     */
    Description?: string;
    /**
     * Style hint for the description (i.e. red for red-letter-days)
     */
    DescriptionStyleHint?: string;
    /**
     * Tooltip describing any conflicts.
     */
    Tooltip?: string;
}
/**
 * Class representing a pattern for daily recurrence
 */
export interface RecurrenceDayPattern {
    /**
     * The number of days between each recurrence. Only used when the cyclic pattern occurs.
     */
    Cycle?: number;
    /**
     * The type of daily recurrence pattern
     */
    Pattern?: enums.RecurrenceDailyPattern;
}
/**
 * Class representing a recurrence date.
 */
export interface RecurrenceInfo {
    /**
     * Primary key
     */
    RecurrenceId?: number;
    /**
     * Start date for repetition pattern
     */
    StartDate?: Date;
    /**
     * End date for repetition pattern
     */
    EndDate?: Date;
    /**
     * Type defining how the end of the recurrence sequence should be calculated
     */
    RecurrenceEndType?: enums.RecurrenceEndType;
    /**
     * Recurrence pattern (daily, weekly etc)
     */
    Pattern?: enums.RecurrencePattern;
    /**
     * Pattern describing a daily recurrence. Only set when the recurrence pattern i daily.
     */
    DayPattern?: RecurrenceDayPattern;
    /**
     * Pattern describing a daily recurrence. Only set when the recurrence pattern i weekly.
     */
    WeekPattern?: RecurrenceWeekPattern;
    /**
     * Pattern describing a daily recurrence. Only set when the recurrence pattern i monthly.
     */
    MonthPattern?: RecurrenceMonthPattern;
    /**
     * Pattern describing a daily recurrence. Only set when the recurrence pattern i yearly.
     */
    YearPattern?: RecurrenceYearPattern;
    /**
     * List of all dates where this recurrence occurs
     */
    Dates?: RecurrenceDate[];
    /**
     *
     */
    RecurrenceCounter?: number;
    /**
     * Get a or set IsRecurrence, indicating if this is a repeating appointment or not.
     */
    IsRecurrence?: boolean;
}
/**
 * Class representing a pattern for monthly recurrence.
 */
export interface RecurrenceMonthPattern {
    /**
     * The number of months between each repetition
     */
    Cycle?: number;
    /**
     * The day of the month when the recurrence occurs. Only used when the weekday of month pattern occurs.
     */
    Day?: number;
    /**
     * he weekday of the recurring pattern. Only used when the weekday of month pattern occurs.
     */
    Weekday?: enums.Weekday;
    /**
     * The week of the month. Only used when the weekday of month pattern occurs.
     */
    WeekOfMonth?: enums.WeekOfMonth;
    /**
     * The type of monthly recurrence pattern
     */
    Pattern?: enums.RecurrenceMonthlyPattern;
}
/**
 * Class representing a pattern for weekly recurrence
 */
export interface RecurrenceWeekPattern {
    /**
     * The number of weeks between each repetition
     */
    Cycle?: number;
    /**
     * The weekdays the recurrence should occur for
     */
    Weekdays?: enums.Weekday;
}
/**
 * Class representing a pattern for yearly recurrence
 */
export interface RecurrenceYearPattern {
    /**
     * The month of the year where the recurrence occurs. 1 is January and 12 is December.
     */
    Cycle?: number;
    /**
     * The day of the month when the recurrence occurs. Only used when the weekday of month pattern occurs.
     */
    Day?: number;
    /**
     * he weekday of the recurring pattern. Only used when the weekday of month pattern occurs.
     */
    Weekday?: enums.Weekday;
    /**
     * The week of the month. Only used when the weekday of month pattern occurs.
     */
    WeekOfMonth?: enums.WeekOfMonth;
    /**
     * The type of yearly recurrence pattern
     */
    Pattern?: enums.RecurrenceYearlyPattern;
}
/**
 *
 */
export interface SaleTypeStageLink extends Carrier {
    /**
     * Primary key
     */
    SaleTypeStageLinkId?: number;
    /**
     * Primary key
     */
    SaleTypeId?: number;
    /**
     * The list item
     */
    SaleTypeName?: string;
    /**
     * Tooltip or other description
     */
    SaleTypeTooltip?: string;
    /**
     * Primary key
     */
    ProbId?: number;
    /**
     * The list item
     */
    ProbName?: string;
    /**
     * Tooltip or other description
     */
    ProbTooltip?: string;
    /**
     * The numeric probability of the sale
     */
    Probability?: number;
}
/**
 * A class representing values to change when changing company and contact details from the Edit Company Details task for selections.
 */
export interface SelectionMemberEditValues extends Carrier {
    /**
     * Contains new value for the company category.
     */
    CompanyCategory?: number;
    /**
     * Contains new value for company business.
     */
    CompanyBusiness?: number;
    /**
     * Contains new value for company, our contact.
     */
    CompanyOurContact?: number;
    /**
     * Contains new value for company name.
     */
    CompanyName?: string;
    /**
     * Contains new value for the company department.
     */
    CompanyDepartment?: string;
    /**
     * Contains new value for the company number.
     */
    CompanyNumber?: string;
    /**
     * Contains new value for the company code.
     */
    CompanyCode?: string;
    /**
     * Contains new value for the contact position.
     */
    ContactPosition?: number;
    /**
     * If true, the category of the company will be changed.
     */
    ChangeCompanyCategory?: boolean;
    /**
     * If true, the business of the company will change.
     */
    ChangeCompanyBusiness?: boolean;
    /**
     * If true, the our contact of the company will change.
     */
    ChangeCompanyOurContact?: boolean;
    /**
     * If true, the name of the company will change.
     */
    ChangeCompanyName?: boolean;
    /**
     * If true, the department of the company will change.
     */
    ChangeCompanyDepartment?: boolean;
    /**
     * If true, the number of the company will change.
     */
    ChangeCompanyNumber?: boolean;
    /**
     * If true, the code of the company will change.
     */
    ChangeCompanyCode?: boolean;
    /**
     * If true, the position of the contact will change.
     */
    ChangeContactPosition?: boolean;
    /**
     * Contains new value for the company country.
     */
    CompanyCountry?: number;
    /**
     * If true, the country of the company will change.
     */
    ChangeCompanyCountry?: boolean;
    /**
     * Contains new value for the contact VAT number.
     */
    ContactJobTitle?: string;
    /**
     * If true, the VAT number  of the contact will change.
     */
    ChangeContactJobTitle?: boolean;
    /**
     * Contains new value for the company VAT number.
     */
    CompanyOrgNr?: string;
    /**
     * If true, the VAT number  of the company will change.
     */
    ChangeCompanyOrgNr?: boolean;
}
/**
 * Representation of a serialized exception that can be communicatyed over web services
 */
export interface SoExceptionInfo {
    /**
     * The message that describes the error.
     */
    Message?: string;
    /**
     * A string that describes the contents of the call stack, with the most recent method call appearing first.
     */
    StackTrace?: string;
    /**
     * Friendly name.
     */
    FriendlyText?: string;
    /**
     * Type of Exception.
     */
    ExceptionType?: string;
    /**
     * The name of the application or the object that causes the error.
     */
    Source?: string;
    /**
     * Inner Exception.
     */
    InnerException?: SoExceptionInfo;
    /**
     * Additional parameters relevant to describe the exception.
     */
    Parameters?: SoExceptionInfoParameters;
}
/**
 * Serializable dictionary.
 */
export interface SoExceptionInfoParameters {
    [index: string]: string;
}
/**
 * Serializable dictionary.
 */
export interface SoExtraInfo {
    [index: string]: string;
}
/**
 * Representation of a serialized exception that can be communicatyed over web services
 */
export interface SoPrincipalCarrier {
    /**
     * Type of user
     */
    UserType?: enums.UserType;
    /**
     * Associate name (e.g. logon name) for the user
     */
    Associate?: string;
    /**
     * AssociateId for the user.
     */
    AssociateId?: number;
    /**
     * Is this associate a person, and not a resource?
     */
    IsPerson?: boolean;
    /**
     * Associate's person id
     */
    PersonId?: number;
    /**
     * Country id for the user.
     */
    CountryId?: number;
    /**
     * Country id for the user's home country.  This is the default country id when creating new items.
     */
    HomeCountryId?: number;
    /**
     * Company of the associate's person
     */
    ContactId?: number;
    /**
     * Associate's group_idx
     */
    GroupId?: number;
    /**
     * BusinessIdx for the company that the user belongs to.
     */
    BusinessId?: number;
    /**
     * CategoryIdx of the company that the user belongs to.
     */
    CategoryId?: number;
    /**
     * Owner (AssocaiteId) of the company that the user belongs to.
     */
    ContactOwner?: number;
    /**
     * Id of the users role
     */
    RoleId?: number;
    /**
     * Name of the users role
     */
    RoleName?: string;
    /**
     * Descrtiption (e.g. tooltip) for the users role
     */
    RoleDescription?: string;
    /**
     * Type of user.
     */
    RoleType?: enums.RoleType;
    /**
     * License granted to the site and user.
     */
    Licenses?: GrantedModuleLicense[];
    /**
     * The Person full name if the associate is a person. Use IsPerson to check
     */
    FullName?: string;
    /**
     * The Person e-mail address if the associate is a person. Use IsPerson to check
     */
    EMailAddress?: string;
    /**
     * Functional rights for the user.  This array is sorted.
     */
    FunctionRights?: string[];
    /**
     * Primary key in eJournal's old user table.
     */
    EjUserId?: number;
    /**
     * eJournal user access level
     */
    EjAccessLevel?: number;
    /**
     * eJournal user status
     */
    EjUserStatus?: enums.EjUserStatus;
    /**
     * The credentials used for authenticating this user
     */
    ProvidedCredentials?: ProvidedCredential[];
    /**
     * Secondary user groups
     */
    SecondaryGroups?: number[];
    /**
     * Name of the database context
     */
    DatabaseContextIdentifier?: string;
}
/**
 * Representation of a serialized exception that can be communicatyed over web services
 */
export interface SoSystemInfoCarrier extends Carrier {
    /**
     * License issued by SuperOffice
     */
    License?: LicenseInfo;
    /**
     * Warning information to be displayed to the user in plain English
     */
    WarningEnglish?: string;
    /**
     * Warning information to be displayed to the user in resource format.
     */
    WarningResource?: string;
    /**
     * Name of the branch the NetServer is built from.
     */
    BranchName?: string;
    /**
     * Build label for NetServer.
     */
    BuildLabel?: string;
    /**
     * AssemblyVersion of NetServer
     */
    AssemblyVersion?: string;
    /**
     * The next date a new check of the license is to be performed, incremented daily if the check did not result in a new license.
     */
    AccumulatedNextCheckDate?: Date;
    /**
     * FileVersion of NetServer.
     */
    FileVersion?: string;
    /**
     * Description of the NetServer version.
     */
    Description?: string;
    /**
     * Days until this version of NetServer expires
     */
    DaysUntilNetServerExpiry?: number;
    /**
     * Type of build.
     */
    BuildType?: enums.NetServerBuildType;
    /**
     * Database version number
     */
    DatabaseVersion?: number;
    /**
     * Is the database strings formatted as Unicode (i.e. NVARCHAR)
     */
    IsUnicode?: boolean;
    /**
     * License Info: Company name associated with license.
     */
    CompanyName?: string;
    /**
     * License Info: Company name associated with license.
     */
    CompanyId?: number;
    /**
     * Major name of database provider
     */
    DatabaseType?: string;
    /**
     * Minor name of database provider
     */
    DatabaseMinor?: string;
    /**
     * Name of database
     */
    DatabaseName?: string;
    /**
     * Is the current database on travel.
     */
    IsOnTravel?: boolean;
    /**
     * Is the current database a Satellite
     */
    IsSatellite?: boolean;
}
/**
 * Serializable dictionary.
 */
export interface StringDictionary {
    [index: string]: string;
}
/**
 * Serializable dictionary.
 */
export interface StringObjectDictionary {
    [index: string]: Object;
}
/**
 * Address with structured fields (Address1, City, Zip) - does not vary its layout by country, unliked the formatted address.
 */
export interface StructuredAddress {
    /**
     * Bit mask, combines address type (EAddressType) and owner type (EOwnerType)
     */
    AtypeIdx?: enums.AddressType;
    /**
     * Address line 1
     */
    Address1?: string;
    /**
     * Address line 2
     */
    Address2?: string;
    /**
     * Address line 3
     */
    Address3?: string;
    /**
     * City corresponding to zip code
     */
    City?: string;
    /**
     * County (not country)
     */
    County?: string;
    /**
     * State
     */
    State?: string;
    /**
     * Zip code, alphanumeric
     */
    Zipcode?: string;
    /**
     * Read-only formatted address multi-line string. e.g.: <c>"Brugata 123,\n1234 OSLO\n"</c> or <c>"Bridgelane 123,\nWest Tooting,\nThe Shire ES2 W31\n"</c>.
     */
    Formatted?: string;
}
/**
 * Wraps a table right together with an explanatory reason.
 */
export interface TableRight {
    /**
     *  Returns the bitflag of permissions.
     */
    Mask?: enums.ETableRight;
    /**
     * Contains a string that explains why the right is not available. The reason is blank if HasAll is true.
     */
    Reason?: string;
}
/**
 * Class representing form submission related to ticket.
 */
export interface TicketFormSubmission {
    /**
     * Primary key
     */
    FormSubmissionId?: number;
    /**
     * The email address of the person who submitted
     */
    EmailAddress?: string;
    /**
     * What is the status of this submission
     */
    Status?: enums.FormSubmissionStatus;
}
/**
 * Contains information about a header connected to a ticket message
 */
export interface TicketMessageHeader extends Carrier {
    /**
     * Id
     */
    Id?: number;
    /**
     * The name of the header. This can for example be To, Cc or other custom headers that is set up in Service
     */
    Name?: string;
    /**
     * The value of the header. Can for example be an email address, or a custom header extracted from emails
     */
    Value?: string;
    /**
     * If this has a value, it indicates that a standard header text from the language database should be used - and witch one to use
     */
    StdItem?: enums.MessageHeaderStdItem;
    /**
     * If this is 1, concatenate the standard item text with header name field, if 2 use header value field instead. If this col is 0, use the empty field - preferably the value column.
     */
    StdItemCol?: enums.MessageHeaderStdItemCol;
}
/**
 * The UserCandidate carrier is used to represent a Customer Centre User.
 */
export interface UserCandidate extends Carrier {
    /**
     * Primary key
     */
    UserCandidateId?: number;
    /**
     * Foreign key. Id of a person representing Customer Center User.
     */
    PersonId?: number;
    /**
     * Username of a Customer Centre User.
     */
    SecretKey?: string;
    /**
     * Password of a Customer Centre User.
     */
    SecretValue?: string;
}
/**
 * ApproveRejectResponse contains a PluginResponse and an appointmentId if the operation created one.
 */
export interface ApproveRejectResponse extends Carrier {
    /**
     * The response from the operation.
     */
    PluginResponse?: PluginResponse;
    /**
     * Id of the created follow up.
     */
    CreatedAppointmentId?: number;
}
/**
 * Generic carrier, used in return values to indicate what data NetServer has changed 'behind the scenes' so clients can know what to update
 */
export interface ChangedData extends Carrier {
    /**
     * Ids of added records.
     */
    AddedRecords?: ChangedDataItem[];
    /**
     * Ids of updated records.
     */
    UpdatedRecords?: ChangedDataItem[];
    /**
     * Ids of deleted records.
     */
    DeletedRecords?: ChangedDataItem[];
}
/**
 * Tablename/recordid pair used to refer to records
 */
export interface ChangedDataItem extends Carrier {
    /**
     * Name of table, standardized to lowercase
     */
    Tablename?: string;
    /**
     * Id of record, should never be 0
     */
    RecordId?: number;
}
/**
 * This is used to populate the Admin configuration dialog for a connection. The call to the ERP Connector’s GetConfigurationFields method returns a list of fields and field types. The Admin client builds a dialog with these fields
 */
export interface FieldMetadata extends Carrier {
    /**
     * Internal key/name of the field. Used as the key in the ConnectionConfigField values when TestConnection is called.
     */
    FieldKey?: string;
    /**
     * A way to set the order of the fields. Lowest value will be displayed first/over the fields with other values.
     */
    Rank?: number;
    /**
     * Localized field name – shown in the GUI
     */
    DisplayName?: string;
    /**
     * Tooltip for the field name.
     */
    DisplayDescription?: string;
    /**
     * String, int, decimal, etc.
     */
    FieldType?: enums.FieldMetadataType;
    /**
     * MDO List provider name for list fields
     */
    ListName?: string;
    /**
     * A default value for the field.
     */
    DefaultValue?: string;
    /**
     * Maximum length for strings, if set. 0 means no restriction. (Though sooner or later something will no doubt overflow if you pile on the gigabytes.)
     */
    MaxLength?: number;
    /**
     * Access restrictions on the field
     */
    Access?: enums.FieldAccess;
    /**
     * True if this field is displayed in search result
     */
    ShowInSearch?: boolean;
}
/**
 * Used by ADMIN. Asks for metadata needed to populate admin dialog that takes in the information needed to create a connection to an ERP system. The values entered in the dialog are stored in SuperOffice db and used when InitializeConnector is called by the client.
 * Returns FieldMetadataDictionary
 */
export interface Quote_GetConfigurationFieldsRequest {
    /**
     * Id of an existing connection, if any. Initializes connection with current config values if non-zero.
     */
    ConnectionId: number;
    /**
     * Name of the connector. Ignored if connectionId is non-zero.
     */
    ConnectorName: string;
}
/**
 * Used by the Admin clients. Testing if the connection data is sufficient to get a connection with the ERP system. The Connector should try to do some operations to check if the connection has sufficient rights to run. The connection has not been created yet. TestConnection is called without InitializeConnector being called first.
 * Returns PluginResponse
 */
export interface Quote_TestConnectionRequest {
    /**
     * Name of the connector.
     */
    ConnectorName: string;
    /**
     * Basically the name/value collection of the configuration data requested to create a connection
     */
    ConnectionData: StringDictionary;
}
/**
 * Serializable dictionary.
 */
export interface FieldMetadataDictionary {
    [index: string]: FieldMetadata;
}
/**
 * PluginResponse exists to be able to respond with more than just a true/false, but also an explanation. Such an explanation can be displayed on for instance a disabled “Place Order” button.
 */
export interface PluginResponse extends Carrier {
    /**
     * Answer to the question / An indication if the operation went well. Equivalent to Status != Error
     */
    IsOk?: boolean;
    /**
     * A localized explanation to the answer. Text here is displayed to the user.
     */
    UserExplanation?: string;
    /**
     * Always in English
     */
    TechExplanation?: string;
    /**
     * An error code, if available.
     */
    ErrorCode?: string;
    /**
     * Tablename/recordid of data changed by this method, that the client may need to reload
     */
    Changes?: ChangedData;
    /**
     * QuoteStatus = Ok / OkWithInfo / Warn / Error. Error implies IsOk = false.
     */
    Status?: enums.QuoteStatus;
}
/**
 * PluginUrlResponse exists to be able to respond with more than just a true/false, but also an explanation. Such an explanation can be displayed on for instance a disabled “Place Order” button. In addition, an URL can be returned, which the GUI should navigate to/display if it is non-blank. The URL can be an SoProtocol or http(s)
 */
export interface PluginUrlResponse extends Carrier {
    /**
     * Answer to the question / An indication if the operation went well.  Equivalent to Status != Error
     */
    IsOk?: boolean;
    /**
     * A localized explanation to the answer.
     */
    UserExplanation?: string;
    /**
     * Always in English
     */
    TechExplanation?: string;
    /**
     * An error code, if available.
     */
    ErrorCode?: string;
    /**
     * Tablename/recordid of data changed by this method, that the client may need to reload
     */
    Changes?: ChangedData;
    /**
     * Url that the GUI should navigato to/open, if non-blank. The GUI cannot enforce any rules subsequent to opening the requested url.
     */
    Url?: string;
    /**
     * QuoteStatus = Ok / OkWithInfo / Warn / Error. Error implies IsOk = false.
     */
    Status?: enums.QuoteStatus;
}
/**
 * A pricelist is basically a collection of products. It can be valid in a time period, and outright deactivated. All prices in the product list is in a specific currency. We have decieded not to separate prices and products, which means that we get a simpler data model, but some redundancy.
 */
export interface PriceList extends Carrier {
    /**
     * Primary key
     */
    PriceListId?: number;
    /**
     * The key that uniquely identifies this pricelist in the ERP system
     */
    ERPPriceListKey?: string;
    /**
     * (Reserved for future use) The connection to the ERP system used for this pricelist
     */
    QuoteConnectionId?: number;
    /**
     * Name of this pricelist to use in the user interface.
     */
    Name?: string;
    /**
     * Description of this pricelist , will be used as tool-tip in the user interface.
     */
    Description?: string;
    /**
     * The iso currency code, like 'USD' or 'NOK'.
     */
    Currency?: string;
    /**
     * The name to use in the user interface, like perhaps 'US dollar' or '$'
     */
    CurrencyName?: string;
    /**
     * The date (inclusive) the pricelist start to be valid. This can be DateTime.MinValue to signal that it doesn't have a specific start date.
     */
    ValidFrom?: Date;
    /**
     * The date (inclusive) the pricelist ends to be valid. This can be DateTime.MaxValue to signal that it doesn't have a specific end date.
     */
    ValidTo?: Date;
    /**
     * Is the list active (as opposed to being worked on, suddenly canceled, etc.
     */
    IsActive?: boolean;
}
/**
 * Create a copy of a PriceList in the SuperOffice database
 * Returns PriceList
 */
export interface Quote_CopySuperOfficePriceListRequest {
    /**
     * Id of the PriceList to be copied
     */
    OriginalPriceListId: number;
    /**
     * Name of the copied PriceList
     */
    NewName: string;
    /**
     * Start date for the new pricelist.
     */
    ValidFrom: Date;
    /**
     * End date for the new pricelist.
     */
    ValidTo: Date;
    /**
     * Currency id of the copied PriceList. If 0 or the same as the original the copied products will keep their prices and the currency will be the same as the original.
     */
    NewCurrencyId: number;
    /**
     * If true, product prices will be recalculated to the new currency. If false, product prices will be set to zero.
     */
    ConvertCurrency: boolean;
}
/**
 * Information about a Product from the ERP system. This may be fetched from SuperOffice Product table through the SO Connector
 */
export interface Product extends Carrier {
    /**
     * Primary key
     */
    ProductId?: number;
    /**
     * Reference/foreign key to the product in the given pricelist in the product supplier system, if it exists there.
     */
    ERPProductKey?: string;
    /**
     * Foreign key to the price list that this product is a part of, or the primary key of the pricelist if this is a built-in pricelist.
     */
    ERPPriceListKey?: string;
    /**
     * The name to use in the user interface.
     */
    Name?: string;
    /**
     * The description to use, with potentially several lines. Will be used as tool-tip to use in the list user interface too.
     */
    Description?: string;
    /**
     * The product code / article number in the product supplier system.
     */
    Code?: string;
    /**
     * What is the unit (meter, ton, bushel, microsecond, gradus, τρυβλίον, 五合枡, دونم or whatever); read-only for lines that originate in defined products
     */
    PriceUnit?: string;
    /**
     * What is the unit (meter, ton, bushel, microsecond, gradus, τρυβλίον, 五合枡, دونم or whatever); Connector handles conversion relative to PriceUnit if they are different
     */
    QuantityUnit?: string;
    /**
     * Is this a subscription product, sold in repeating intervals/amounts?
     */
    IsSubscription?: boolean;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn’t support lists, a text with the actual subscription unit.
     */
    SubscriptionUnit?: string;
    /**
     * The default number of SubscriptionUnits to suggest when creating quote lines from this product
     */
    DefaultSubscriptionQuantity?: number;
    /**
     * Line item number, NOR: «Postnummer». Specific numbers from some hierarchy, for instance “1.4.3.2P”. Typically used to sort the items in the quote by some standard way.
     */
    ItemNumber?: string;
    /**
     * URL to product information web page.
     */
    Url?: string;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn’t support lists, a text with the actual product category.
     */
    ProductCategoryKey?: string;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn't support lists, a text with the actual product family.
     */
    ProductFamilyKey?: string;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn’t support lists, a text with the actual product type.
     */
    ProductTypeKey?: string;
    /**
     * Tax/VAT if available from ERP system. THIS IS A PERCENTAGE. In the Superoffice product register, this field is available in the product admin GUI.
     */
    VAT?: number;
    /**
     * A field for putting VATInfo you need to show in the final quoteDocument, like the VAT type that is used. Not used in any business logic in SuperOffice; available to document templates.
     */
    VATInfo?: string;
    /**
     * The cost price. Might not be given, use Decimal.MinValue to signal this.
     */
    UnitCost?: number;
    /**
     * The minimum price this salesman can offer to his customer. This might be cost price if there is no policy. Might not be given, use Decimal.MinValue to signal this.
     */
    UnitMinimumPrice?: number;
    /**
     * (Basic Price, normal price, standard price.) This is the basic price from which the discount is computed from. The ListPrice will stay the same even when a larger amount is ordered.
     */
    UnitListPrice?: number;
    /**
     * True for products that should currently be offered, false when the product is discontinued and should not ordinarily be offered. When false the product no longer appears in search results.
     */
    InAssortment?: boolean;
    /**
     * In SuperOffice, an id from the contact table, when saved as an ERP cache, the name of the supplier
     */
    Supplier?: string;
    /**
     * Suppliers part code/number or other key-like field
     */
    SupplierCode?: string;
    /**
     * Field1=right&Field2=right, etc. of any fields that have non-standard field access rights. Rights can be one of: N (=None or Hidden), R (=Read-only), W (=Writeable), M (=Mandatory). The fields will mostly be from the Quoteline table, but some added fields that are conceptually part of the quoteline, like Image will also be possibly to set rights on. Will be used by SuperOffice to control the user interface when showing the record.
     */
    Rights?: string;
    /**
     * The names of one or more calculation rules that are in effect for this line, comma-separated case-insensitive. Will NOT be used by SuperOffice.
     */
    Rule?: string;
    /**
     * Extra information, supplied by QuoteConnector, used by a future dynamic GUI extension
     */
    ExtraInfo?: ProductExtraDataField[];
    /**
     * Read-only extra information in plain text, supplied by QuoteConnector, used by a future dynamic GUI extension
     */
    RawExtraInfo?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField1?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField2?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField3?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField4?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField5?: string;
    /**
     * Negative numbers will be interpreted as how many is ordered. Might not be available.
     */
    InStock?: number;
}
/**
 * Gets an image connected to a product, from the ProductProvider
 * Returns string
 */
export interface Quote_GetProductImageRequest {
    /**
     * The connection this product comes from.
     */
    QuoteConnectionId: number;
    /**
     * Primary key of the Product in the ProductProvider
     */
    ERPProductKey: string;
    /**
     * The rank of the image.
     */
    Rank: number;
}
/**
 * Gets a product, from the ProductProvider
 * Returns Product[]
 */
export interface Quote_FindProductRequest {
    /**
     * Quote alternative to search in.
     */
    QuoteAlternativeId: number;
    /**
     * search string
     */
    UserInput: string;
    /**
     * If the pricelist is null or empty, the function will search in all active pricelists.
     */
    PriceListKey: string;
}
/**
 * Get a product with the given key
 * Returns Product
 */
export interface Quote_GetProductRequest {
    /**
     * The connection this product comes from.
     */
    QuoteConnectionId: number;
    /**
     * Primary key of the Product in the ProductProvider
     */
    ERPProductKey: string;
}
/**
 * Get a product with the given database id
 * Returns Product
 */
export interface Quote_GetProductFromDbIdRequest {
    /**
     * The database id of the product
     */
    ProductId: number;
}
/**
 * Removes a product from the database
 */
export interface Quote_RemoveProductRequest {
    /**
     * The database id of the product to remove
     */
    ProductId: number;
}
/**
 * Toggles if the prdouct is in assortment or not
 */
export interface Quote_ToggleProductInAssortmentRequest {
    /**
     * The database id of the product to toggle is assortment value of
     */
    ProductId: number;
}
/**
 * A way to show some simple extra data on a product, typically to hep the user to identify the correct product. Basically a bucket of additional info that the ERP system would like to store and show in the user interface. Information placed here is shown in the GUI if the “provide-extra-data” capability is true.
 */
export interface ProductExtraDataField extends Carrier {
    /**
     * Label for the field
     */
    Name?: string;
    /**
     * Value for the field. If type is string, it can contain formatspecifiers (use this for displaying numbers correctly as the user's computer is set up).
     */
    Value?: string;
    /**
     * String, url, image. How the value should be interpreted.
     */
    Type?: enums.ExtraDataFieldType;
}
/**
 * Quote carrier with the active quote version and favorite alternative.
 */
export interface Quote extends Carrier {
    /**
     * Primary key
     */
    QuoteId?: number;
    /**
     * The foreign key to the corresponding sale
     */
    SaleId?: number;
    /**
     * The connection in the CRM system to where this quote came from. Identifies the ERP connection used for this quote. Each quote is bound to one and only one connection.
     */
    QuoteConnectionId?: number;
    /**
     * Foreign key of quote (if available). The key in the ERP system that identifies this sale's Quote (as opposed to the later Order information)
     */
    ERPQuoteKey?: string;
    /**
     * The key in the ERP system that identifies this sale's Order, as transferred and possibly later edited in the ERP system.  Only filled out if there exists a corresponding order representation of the quote in the ERP system.
     */
    ERPOrderKey?: string;
    /**
     * The primary key of the Quote Version that is currently active. (The active version will always be the latest version.)
     */
    ActiveQuoteVersionId?: number;
    /**
     * The primary key of the Quote Alternative which was finally accepted by the customer. Set when the user is marking a quote as accepted.
     */
    AcceptedQuoteAlternativeId?: number;
    /**
     * If true, then the Earning, Earning_Percent and Amount fields are populated from the QuoteVersion.QuoteAlternative (current revision, most-likely alternative).
     */
    UseValuesFromQuote?: number;
    /**
     * The ID of the main Quote Document
     */
    DocumentId?: number;
    /**
     * Customer's Purchase order number
     */
    PoNumber?: string;
    /**
     * A comment that is intended for the Invoice, Order, Packing list and similar stages - AFTER the quote has become an order and goes to ERP for processing
     */
    OrderComment?: string;
    /**
     * When emails are sent (offer or confirmation), a language can be chosen in the GUI; this field saves the most recent choice and can be used to default the next such choice. Default-default is user's current language
     */
    PreferredEmailCulture?: string;
    /**
     * The active quote version for the quote
     */
    ActiveQuoteVersion?: QuoteVersion;
    /**
     * The favorite quote alternative for the quote and active quote version.
     */
    FavoriteQuoteAlternative?: QuoteAlternative;
}
/**
 * Saves a Quote
 * Returns Quote
 */
export interface Quote_SaveQuoteRequest {
    /**
     * The Quote to save
     */
    Quote: Quote;
}
/**
 * Get a Quote
 * Returns Quote
 */
export interface Quote_GetQuoteRequest {
    /**
     * QuoteId of the Quote to get.
     */
    QuoteId: number;
}
/**
 * Get a Quote for a sale
 * Returns Quote
 */
export interface Quote_GetQuoteFromSaleIdRequest {
    /**
     * SaleId of the Quote to get.
     */
    SaleId: number;
}
/**
 * Information about a connection to the ERP system.
 */
export interface QuoteAlternative extends Carrier {
    /**
     * Primary key
     */
    QuoteAlternativeId?: number;
    /**
     * Key that identifies this alternative in the ERP system, if it exists there.
     */
    ERPQuoteAlternativeKey?: string;
    /**
     * The version that owns this alternative (the chain is Sale 1->1 Quote 1->+ QuoteVersion 1->+ QuoteAlternative.
     */
    QuoteVersionId?: number;
    /**
     * Name of Alternative. Shown in tab in user interface, intentionally kept short
     */
    Name?: string;
    /**
     * The tool-tip to use in the user interface (on the tab, for instance).
     */
    Description?: string;
    /**
     * If there was a problem with for instance calculation, this field is set to warning or error.
     */
    Status?: enums.QuoteStatus;
    /**
     * If there was a problem, this field contains a localized explanation of the problem and possible steps to fix it that the user can be shown.
     */
    Reason?: string;
    /**
     * The discount the system calculates based on customer /amount / whatever. Can be overridden by the sales rep in the field ‘DiscountPercent’ or ‘DiscountAmount’. Both the two ‘ERPDiscountPercent’ and ‘ERPDiscountAmount’ shall be filled out. If UserValueOverride is 'None', then the ERPDiscountAmount shall be copied into DiscountAmount and ERPDiscountPercent into DiscountPercent. The Percentage is given in integer form, i.e. ‘12%’ is represented as ‘12’.
     */
    ERPDiscountPercent?: number;
    /**
     * The discount the system calculates based on customer /amount / whatever. Can be overridden by the user in the field ‘DiscountPercent’ or ‘DiscountAmount’. Both the two ‘ERPDiscountPercent’ and ‘ERPDiscountAmount’ shall be filled out. If UserValueOverride is 'None', then the ERPDiscountAmount shall be copied into DiscountAmount and ERPDiscountPercent into DiscountPercent.
     */
    ERPDiscountAmount?: number;
    /**
     * The discount the sales rep specifies, in percent. Both the two ‘DiscountPercent’ and ‘DiscountAmount’ shall be filled out, but the UserValueOverride field must be set to the field the user actually changed. If this field is filled out by the user, it overrides the discount suggested by the connector. If the user has not filled any values, the system will copy the ERP discount percent value into this field. The Percentage is given in integer form, i.e. ‘12%’ is represented as ‘12’.
     */
    DiscountPercent?: number;
    /**
     * The discount the sales rep specifies, in whatever currency the sale is in. Both the two ‘DiscountPercent’ and ‘DiscountAmount’ shall be filled out, but the UserValueOverride field must be set to the field the user actually changed. If this field is filled out by the user, it overrides the discount suggested by the connector. If the user has not filled any values, the system will copy the ERP discount amount value into this field.
     */
    DiscountAmount?: number;
    /**
     * Has the pre-calculated (from ERP) price information been overridden, and how. If the user has filled out the discountpercentage field, then the UserValueOverride field is set to OverridePercent. (The DiscountAmount, EarningPercent, EarningAmount and TotalPrice fields are calculated based on the discountPercent.)
     */
    UserValueOverride?: enums.ValueOverride;
    /**
     * Extra info about VAT that the connector might insert. This field has no business logic in the CRM code, but is available as a merge field in the quote documents.
     */
    VATInfo?: string;
    /**
     * Tax/VAT - THIS IS AN AMOUNT, available as a merge field in the quote document. The SuperOffice quote connector will calculate this field based on the vat PERCENTAGES on the individual lines; other connectors may implement other algorithms at will.
     */
    VAT?: number;
    /**
     * The earning on this alternative, in percent of total. The Percentage is given in integer form, i.e. ‘12%’ is represented as ‘12’.
     */
    EarningPercent?: number;
    /**
     * Earning on this alternative, as an absolute amount
     */
    EarningAmount?: number;
    /**
     * Value to help the user interface, is computed by summing the totalprice of the quotelines, and NOT by summing their subtotals
     */
    SubTotal?: number;
    /**
     * Sum of the QuoteLines.TotalPrice - AlternativeDiscount or QuoteLines.TotalCost + Earning based on what, if anything, the user has entered last. Shall be calculated by the connector.
     */
    TotalPrice?: number;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField1?: string;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField2?: string;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField3?: string;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField4?: string;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField5?: string;
}
/**
 * When the user changes one or more values in a quoteline or a quoteAlternative, the connector gets to change the QuoteLines and the alternative, for instance calculate VAT. RecalculateQuoteAlternative shall be called when the user changes any of the following fields: Quantity, DiscountAmount, DiscountPercent, listprice (if allowed). RecalculateQuoteAlternative will calculate the TotalPrice and the VAT (if possible) for the lines and the alternative.
 * Returns QuoteAlternativeRecalculated
 */
export interface Quote_RecalculateQuoteAlternativeRequest {
    /**
     * The alternative to be recalculated
     */
    QuoteAlternative: number;
}
/**
 * Get all quote alternatives for a quote version
 * Returns QuoteAlternative[]
 */
export interface Quote_GetQuoteAlternativesRequest {
    /**
     * QuoteVersionId of the revison to get alternatives for.
     */
    QuoteVersionId: number;
}
/**
 * Move quote line rank up/down
 */
export interface Quote_MoveQuoteLineRequest {
    /**
     * Id of quote line to move up/down
     */
    QuoteLineId: number;
    /**
     * True is up, false is down
     */
    Direction: boolean;
}
/**
 * Create a new quote alternative on a version.
 * Returns QuoteAlternative
 */
export interface Quote_CreateQuoteAlternativeRequest {
    /**
     * QuoteVersionId of the version to create the alternative on.
     */
    QuoteVersionId: number;
    /**
     * The name to set on the new alternative.
     */
    QuoteAlternativeName: string;
    /**
     * The description to set on the new alternative.
     */
    QuoteAlternativeDescription: string;
}
/**
 * Copy a quote alternative from the same sale and adds it to a version.
 * Returns QuoteAlternative
 */
export interface Quote_CopyQuoteAlternativeRequest {
    /**
     * QuoteVersionId of the version to copy the alternative to.
     */
    QuoteVersionId: number;
    /**
     * QuoteAlternativeId of the alternative to make a copy of.
     */
    QuoteAlternativeId: number;
    /**
     * The name to set on the new alternative.
     */
    QuoteAlternativeName: string;
}
/**
 * Delete a quote alternative
 */
export interface Quote_DeleteQuoteAlternativeRequest {
    /**
     * Id of the quote alternative to delete.
     */
    QuoteAlternativeId: number;
}
/**
 * The QuoteAlternativeRecalculated is returned after a call to RecalculateQuoteAlternative. It contains flags indicating changes to quote alternative and quote lines.
 */
export interface QuoteAlternativeRecalculated extends Carrier {
    /**
     * If true any of the quotelines for the alternative has been changed.
     */
    QuoteLinesHasChanged?: boolean;
    /**
     * The recalculated QuoteAlternative
     */
    ChangedQuoteAlternative?: QuoteAlternative;
    /**
     * Tablename/recordid of data changed by this method
     */
    Changes?: ChangedData;
}
/**
 * Information about a connection to the ERP system.
 */
export interface QuoteConnection extends Carrier {
    /**
     * Primary key
     */
    QuoteConnectionId?: number;
    /**
     * Name of the ERP system (programmatic).
     */
    ERPName?: string;
    /**
     * Connection name shown to user; multi-language support. The name of the connector to display in a list so that the users can choose between them. Typically the name of the client, with maybe the ERP system in parenthesis.
     */
    DisplayName?: string;
    /**
     * Tooltip/description shown to user; multi-language support. Any other info available that would make an uncertain user chose the right connector. Typically, used for tooltip.
     */
    DisplayDescription?: string;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Programmatic name of the Connector plugin that implements this kind of connection
     */
    ConnectorName?: string;
    /**
     * The ERP Connection that this Quote connection is an extension of
     */
    ErpConnectionId?: number;
    /**
     * Optional extra data, in XML format, for configuring the connector. Connector-specific!
     */
    ExtraData?: string;
    /**
     * Whether or not the specified connection is available. Typically, without network access the availability is false.
     */
    IsAvailable?: boolean;
    /**
     * Status and Error message when the system called the connector Initialize method. Null if the connector has not been initialized yet.
     */
    InitializeResponse?: PluginResponse;
    /**
     * The PriceLists that this connection offers.
     */
    PriceLists?: PriceList[];
    /**
     * Is this connection accessible to everyone?  If not, then the QuoteConnectionAccess table tells us who can access it.
     */
    AllAccess?: boolean;
    /**
     * If set, then this is a row that has been 'deleted'; we do not physically delete rows to avoid disaster.
     */
    Deleted?: boolean;
    /**
     * Array of ids containing usergroups that will have access to this connection.
     */
    UserGroupAccessIds?: number[];
    /**
     * Array of ids containing associates that will have access to this connection.
     */
    AssociateAccessIds?: number[];
}
/**
 * Whether or not the system has any connections available for this user.
 * Returns PluginResponse
 */
export interface Quote_HasConnectionsRequest {
}
/**
 * Get all installed connections. Some installed connections may not be available to the user.
 * Returns QuoteConnection[]
 */
export interface Quote_GetAllInstalledQuoteConnectionsRequest {
}
/**
 * Get all available connections. Some installed connections may not be available to the user. Use GetAllAvailableQuoteConnectionsWithPriceLists if you need the pricelists on the connections as well.
 * Returns QuoteConnection[]
 */
export interface Quote_GetAllAvailableQuoteConnectionsRequest {
}
/**
 * Get all available connections. Some installed connections may not be available to the user. Includes pricelists for the connection. This is a heavy call
 * Returns QuoteConnection[]
 */
export interface Quote_GetAllAvailableQuoteConnectionsWithPriceListsRequest {
}
/**
 * Create a new connection.
 * Returns QuoteConnection
 */
export interface Quote_CreateConnectionFromConnectorNameRequest {
    /**
     * The name of the connector to create this connection for.
     */
    ConnectorName: string;
}
/**
 * Returns the specified connection.
 * Returns QuoteConnection
 */
export interface Quote_GetConnectionRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
}
/**
 * Saves a connection to the database.
 * Returns QuoteConnection
 */
export interface Quote_SaveConnectionRequest {
    /**
     * The connection to save.
     */
    Connection: QuoteConnection;
}
/**
 * Marks a connection as deleted.
 */
export interface Quote_DeleteConnectionRequest {
    /**
     * Primary key of the connection to delete
     */
    QuoteConnectionId: number;
}
/**
 * Restores a connection marked as deleted.
 */
export interface Quote_RestoreConnectionRequest {
    /**
     * Primary key of the connection to restore
     */
    QuoteConnectionId: number;
}
/**
 * Returns all connections available for the specified user.
 * Returns QuoteConnection[]
 */
export interface Quote_GetConnectionsForAssociateRequest {
    /**
     * Primary key of the user
     */
    AssociateId: number;
}
/**
 * Gets the available active PriceLists in a specific currency. Will return empty array if there is no PriceList with the stated currency available.
 * Returns PriceList[]
 */
export interface Quote_GetActivePriceListsRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
    /**
     * Iso currency like: USD or NOK. See http://www.currency-iso.org/dl_iso_table_a1.xls for details. Case insensitive. Will return empty array if there is no PriceList with the stated currency available.
     */
    Currency: string;
}
/**
 * Gets the available active PriceLists in a specific currency. Will return empty array if there is no PriceList with the stated currency available.
 * Returns PriceList[]
 */
export interface Quote_GetActivePriceListsByCurrencyIdRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
    /**
     * SuperOffice currency id.
     */
    CurrencyId: number;
}
/**
 * Gets the all PriceLists in all currencies, including those inactive. Will return empty array if there is no PriceList available.
 * Returns PriceList[]
 */
export interface Quote_GetAllPriceListsRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
    /**
     * Iso currency like: USD or NOK. See http://www.currency-iso.org/dl_iso_table_a1.xls for details. Case insensitive. Will return empty array if there is no PriceList with the stated currency available.
     */
    Currency: string;
}
/**
 * Gets the all PriceLists in all currencies, including those inactive. Will return empty array if there is no PriceList available.
 * Returns PriceList[]
 */
export interface Quote_GetAllPriceListsByCurrencyIdRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
    /**
     * SuperOffice currency id.
     */
    CurrencyId: number;
}
/**
 * Gets a list of all possible connector capabilities
 * Returns string[]
 */
export interface Quote_GetConnectorCapabilityNamesRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
}
/**
 * Gets a list of connector capabilities
 * Returns string[]
 */
export interface Quote_GetConnectorCapabilitiesRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
}
/**
 * Can the connector provide the capability
 * Returns boolean
 */
export interface Quote_CanConnectorProvideCapabilityRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
    /**
     * Capability name
     */
    CapabilityName: string;
}
/**
 * Returns an array of PluginResponseInfos for all failed connection initializations.
 * Returns PluginResponse[]
 */
export interface Quote_GetConnectionStartupErrorsRequest {
}
/**
 * Returns the PluginResponseInfo for the connection initialization. Does not initialize the connection, just returns what happened when initialize was called.
 * Returns PluginResponse
 */
export interface Quote_GetConnectionStartupResponseRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
}
/**
 * Returns the config fields for the connection.
 * Returns StringDictionary
 */
export interface Quote_GetConnectionConfigFieldsRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
}
/**
 * Saves the connection config fields
 * Returns StringDictionary
 */
export interface Quote_SaveConnectionConfigFieldsRequest {
    /**
     * Primary key of the connection
     */
    QuoteConnectionId: number;
    /**
     * ConnectionConfigFields to save.
     */
    ConnectionConfigFields: StringDictionary;
}
/**
 * The context a quote is created in.
 */
export interface QuoteContext extends Carrier {
    /**
     * The associate (salesman) that is logged into the CRM system.
     */
    CRMAssociate?: Associate;
    /**
     * The sale the quote is registered in the CRM system.
     */
    CRMSale?: Sale;
    /**
     * The relevant or current revision of the quote in the CRM system, if applicable.
     */
    CRMQuoteVersion?: QuoteVersion;
    /**
     * The relevant or current alternative of the quote in the CRM system, if applicable.
     */
    CRMQuoteAlternative?: QuoteAlternative;
    /**
     * The relevant or current quote line of the quote in the CRM system, if applicable.
     */
    CRMQuoteLine?: QuoteLine;
    /**
     * The iso language code of the language the user is using in the crm system. Use this language when replying, if possible.
     */
    UserLanguageCode?: string;
}
/**
 * Quote methods
 */
export interface QuoteEntity extends Carrier {
    /**
     * Primary key
     */
    QuoteId?: number;
    /**
     * The foreign key to the corresponding sale
     */
    SaleId?: number;
    /**
     * The connection in the CRM system to where this quote came from. Identifies the ERP connection used for this quote. Each quote is bound to one and only one connection.
     */
    QuoteConnectionId?: number;
    /**
     * Foreign key of quote (if available). The key in the ERP system that identifies this sale's Quote (as opposed to the later Order information)
     */
    ERPQuoteKey?: string;
    /**
     * The key in the ERP system that identifies this sale's Order, as transferred and possibly later edited in the ERP system.  Only filled out if there exists a corresponding order representation of the quote in the ERP system.
     */
    ERPOrderKey?: string;
    /**
     * The primary key of the Quote Version that is currently active. (The active version will always be the latest version.)
     */
    ActiveQuoteVersionId?: number;
    /**
     * The primary key of the Quote Alternative which was finally accepted by the customer. Set when the user is marking a quote as accepted.
     */
    AcceptedQuoteAlternativeId?: number;
    /**
     * If true, then the Earning, Earning_Percent and Amount fields are populated from the QuoteVersion.QuoteAlternative (current revision, most-likely alternative).
     */
    UseValuesFromQuote?: number;
    /**
     * The ID of the main Quote Document
     */
    DocumentId?: number;
    /**
     * Customer's Purchase order number
     */
    PoNumber?: string;
    /**
     * A comment that is intended for the Invoice, Order, Packing list and similar stages - AFTER the quote has become an order and goes to ERP for processing
     */
    OrderComment?: string;
    /**
     * When emails are sent (offer or confirmation), a language can be chosen in the GUI; this field saves the most recent choice and can be used to default the next such choice. Default-default is user's current language
     */
    PreferredEmailCulture?: string;
    /**
     * Array og QuoteVersions connected to the quote.
     */
    QuoteVersions?: QuoteVersion[];
}
/**
 * Creates a new quote on a sale.
 * Returns QuoteEntity
 */
export interface Quote_CreateAndSaveQuoteRequest {
    /**
     * SaleId of the connected sale
     */
    SaleId: number;
    /**
     * ConnectionId
     */
    ConnectionId: number;
    /**
     * Name to be given to the default alternative
     */
    FirstAlternativeName: string;
}
/**
 * Get a Quote
 * Returns QuoteEntity
 */
export interface Quote_GetQuoteEntityRequest {
    /**
     * QuoteId of the Quote to get.
     */
    QuoteId: number;
}
/**
 * Get a Quote for a sale
 * Returns QuoteEntity
 */
export interface Quote_GetQuoteEntityFromSaleIdRequest {
    /**
     * SaleId of the Quote to get.
     */
    SaleId: number;
}
/**
 * Saves a QuoteEntity. Versions and alternatives will not be saved by this call.
 * Returns QuoteEntity
 */
export interface Quote_SaveQuoteEntityRequest {
    /**
     * The Quote entity to save
     */
    QuoteEntity: QuoteEntity;
}
/**
 * Creates a copy the active version with connected alternatives and quotelines from another sale.
 * Returns QuoteEntity
 */
export interface Quote_CreateAndSaveQuoteFromSaleRequest {
    /**
     * Id of the sale to copy the active quote from.
     */
    CopyFromSaleId: number;
    /**
     * Id of the sale to copy the active quote to.
     */
    CopyToSaleId: number;
}
/**
 * Place an order in the ERP system.
 * Returns PluginUrlResponse
 */
export interface Quote_PlaceOrderRequest {
    /**
     * Id of the alternative to place the order on.
     */
    QuoteAlternativeId: number;
    /**
     * Should the state of the owning Sale be set to sold
     */
    MarkSaleAsSold: boolean;
    /**
     * Purchase order number, saved to Quote record
     */
    PoNumber: string;
    /**
     * Order comment, saved to Quote record
     */
    OrderComment: string;
    /**
     * Desired culture for email body and other culture-sensitive templates/content
     */
    Culture: string;
}
/**
 * If there is a problem with a quoteline, the error description shall be placed in the status and reason fields of the quoteline, if there is a problem with the alternative, the error description shall be placed in the status and reason fields of the alternative. A summary of all the problems (if any) should be placed in the response object. Requires that the Create-Order capability is true.
 * Returns PluginUrlResponse
 */
export interface Quote_GetOrderStateRequest {
    /**
     * the QuoteVersionId of the ordered version.
     */
    QuoteVersionId: number;
}
/**
 * Delete a Quote
 */
export interface Quote_DeleteQuoteRequest {
    /**
     * QuoteId of the Quote to delete.
     */
    QuoteId: number;
}
/**
 * Information about a connection to the ERP system.
 */
export interface QuoteLine extends Carrier {
    /**
     * Primary key
     */
    QuoteLineId?: number;
    /**
     * The foreign key to the quoteline in ERP system (if it has such a representation).
     */
    ERPQuoteLineKey?: string;
    /**
     * The alternative this line is part of, the conceptual Parent in CRM database.
     */
    QuoteAlternativeId?: number;
    /**
     * Foreign key of product+pricelist this line is based on. Can be blank since the QuoteLine doesn’t have to be connected to a product.
     */
    ERPProductKey?: string;
    /**
     * If there was a problem with for instance calculation, this field is set to warning or error. Typically shown as an icon. QuoteStatus is an enum with statuses: OK, OKWithInfo, Warning, Error.
     */
    Status?: enums.QuoteStatus;
    /**
     * If QuoteStatus is not OK, then this field contains a localized explanation that the user can be shown.
     */
    Reason?: string;
    /**
     * How many units; this is a decimal field since you might want to offer fractional units (2.5kg, or 0.5PC).
     */
    Quantity?: number;
    /**
     * How many units have been delivered - updated by ERP system.
     */
    DeliveredQuantity?: number;
    /**
     * QuoteLines can be re-ordered, so we must track the ordering.
     */
    Rank?: number;
    /**
     * The name of the product. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    Name?: string;
    /**
     * A longer description for the product. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    Description?: string;
    /**
     * A value the salesmen use to quickly find the correct product. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    Code?: string;
    /**
     * What is the unit (meter, ton, bushel, microsecond, gradus, τρυβλίον, 五合枡, دونم or whatever); Connector handles conversion relative to PriceUnit if they are different.
     */
    QuantityUnit?: string;
    /**
     * What is the unit (meter, ton, bushel, microsecond, gradus, τρυβλίον, 五合枡, دونم or whatever); read-only for lines that originate in defined products.
     */
    PriceUnit?: string;
    /**
     * Norwegian: «Postnummer». Specific numbers from some hierarchy, for instance '1.4.3.2'. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    ItemNumber?: string;
    /**
     * A url to the product info. Can be empty. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    Url?: string;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn't support lists, a text. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    ProductCategoryKey?: string;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn't support lists, a text. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    ProductFamilyKey?: string;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn't support lists, a text. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    ProductTypeKey?: string;
    /**
     * The name of the supplier. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    Supplier?: string;
    /**
     * The suppliers' code or part number for this product. Is stored here if the user changes the value from the product in the pricelist, or just enters a QuoteLine without a product link.
     */
    SupplierCode?: string;
    /**
     * A small image of the product, typically used to show in a list. Base64 encoded png.
     */
    Thumbnail?: string;
    /**
     * Tax/VAT information, Extra info about VAT that the connector might insert, and the users might want to specify on the quote. The core CRM product has no business logic for this field, it is wholly up to connectors to use it.
     */
    VATInfo?: string;
    /**
     * Tax/VAT - THIS IS A PERCENTAGE. The connector is responsible for populating this field; the percentage will be used to calculate VAT amounts available as merge fields in the document templates (but amounts are never stored in the database).
     */
    VAT?: number;
    /**
     * The cost price per unit for this product. May be filled in by connector if it has the Provide-Cost capability.
     */
    UnitCost?: number;
    /**
     * The minimum price this line can be sold for (to limit discounting). Will come from the connector. List price per unit must exceed the minimum price per unit.
     */
    UnitMinimumPrice?: number;
    /**
     * The standard list price; as given by ERP Connector, OR overridden by user
     */
    UnitListPrice?: number;
    /**
     * Extra information, supplied by QuoteConnector, used by a future dynamic GUI extension
     */
    ExtraInfo?: ProductExtraDataField[];
    /**
     * Read-only extra information in plain text, supplied by QuoteConnector, used by a future dynamic GUI extension
     */
    RawExtraInfo?: string;
    /**
     * Is this a subscription product, sold in repeating intervals/amounts?
     */
    IsSubscription?: boolean;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn’t support lists, a text with the actual subscription unit.
     */
    SubscriptionUnit?: string;
    /**
     * The default number of SubscriptionUnits to suggest when creating quote lines from this product
     */
    SubscriptionQuantity?: number;
    /**
     * Start date for subscription, as offered
     */
    SubscriptionStart?: Date;
    /**
     * The discount the system calculates based on customer / quantity / whatever. Can be overrided by the salesman in the field 'DiscountPercent' or 'DiscountAmount'. Both fields ERPDiscountPercent and ERPDiscountAmount will be filled out. If UserValueOverride is set to ‘None’ then the value is copied to DiscountPercent. The Percentage is given in integer form, i.e. ‘12%’ is represented as ‘12’.
     */
    ERPDiscountPercent?: number;
    /**
     * The discount the system calculates based on customer / quantity / whatever. Can be overrided by the salesman in the field 'DiscountPercent' or 'DiscountAmount'. If UserValueOverride is set to ‘None’ then the value is copied to DiscountAmount. Both fields ERPDiscountPercent and ERPDiscountAmount will be filled out.
     */
    ERPDiscountAmount?: number;
    /**
     * The discount for the line, in percent. Both ‘DiscountPercent’ and ‘DiscountAmount’ shall be filled out, but the UserValueOverride field must be set to the field the user actually changed last. If this field is filled out by the user, it overrides any discount suggested by the connector. If the user has not filled this in, the system will copy the ERP discount amount to this field. The Percentage is given in integer form, i.e. ‘12%’ is represented as ‘12’.
     */
    DiscountPercent?: number;
    /**
     * The discount for the line, in whatever currency the sale is in. Both ‘DiscountPercent’ and ‘DiscountAmount’ shall be filled out, but the UserValueOverride field must be set to the field the user actually changed last. If this field is filled out by the user, it overrides any discount suggested by the connector. If the user has not filled this in, the system will copy the ERP discount amount to this field.
     */
    DiscountAmount?: number;
    /**
     * Has the pre-calculated (from ERP) price information been overridden, and how. If the user has filled out the discountpercentage field, then the UserValueOverride field is set to OverridePercent. (The DiscountAmount, EarningPercent, EarningAmount and TotalPrice fields are calculated based on the DiscountPercent.)
     */
    UserValueOverride?: enums.ValueOverride;
    /**
     * The earning, in percent. Both ‘EarningAmount and ‘EarningPercent shall be filled out, but the UserValueOverride field must be set to the field the user actually changed last. The Percentage is given in integer form, i.e. ‘12%’ is represented as ‘12’.
     */
    EarningPercent?: number;
    /**
     * The earning, in whatever currency the sale is in. Both ‘EarningAmount and ‘EarningPercent shall be filled out, but the UserValueOverride field must be set to the field the user actually changed last.
     */
    EarningAmount?: number;
    /**
     * Value to help the user interface, is equal to 'Quantity * ListPrice'
     */
    SubTotal?: number;
    /**
     * TotalPrice  = SubTotal - DiscountAmount or TotalPrice = (UnitCost * Quantity) + EarningAmount, according to what the user changed last.
     */
    TotalPrice?: number;
    /**
     * Field1=right&Field2=right, etc. of any fields that have non-standard field access rights. Rights can be one of: N (=None or Hidden), R (=Read-only), W (=Writeable), M (=Mandatory). The fields will mostly be from the Quoteline table, but some added fields that are conceptually part of the quoteline, like Image will also be possibly to set rights on. Will be used by SuperOffice to control the user interface when showing the record.
     */
    Rights?: string;
    /**
     * The names of one or more calculation rules that are in effect for this line, comma-separated case-insensitive
     */
    Rule?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField1?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField2?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField3?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField4?: string;
    /**
     * This a simple field for adding information that the Connector can provide, and that the qoute document need to display.
     */
    ExtraField5?: string;
}
/**
 * Create a quoteline based on a product key.
 * Returns QuoteLine
 */
export interface Quote_CreateQuoteLineRequest {
    /**
     * Primary key of the alternative
     */
    QuoteAlternativeId: number;
    /**
     * Primary key of the product in the ProductProvider
     */
    ERPProductKey: string;
}
/**
 * Create a quoteline based on a product.
 * Returns QuoteLine
 */
export interface Quote_CreateQuoteLineFromProductRequest {
    /**
     * Primary key of the alternative
     */
    QuoteAlternativeId: number;
    /**
     * Product carrier
     */
    Product: Product;
}
/**
 * Saves the QuoteLine in the SuperOffice database
 * Returns QuoteLine
 */
export interface Quote_SaveQuoteLineRequest {
    /**
     * The QuoteLine to save.
     */
    QuoteLine: QuoteLine;
}
/**
 * Saves the QuoteLines in the SuperOffice database
 * Returns QuoteLine[]
 */
export interface Quote_SaveQuoteLinesRequest {
    /**
     * The QuoteLines to save.
     */
    QuoteLines: QuoteLine[];
}
/**
 * Get QuoteLine from database
 * Returns QuoteLine
 */
export interface Quote_GetQuoteLineRequest {
    /**
     * Primary key of the quoteline to get.
     */
    QuoteLineId: number;
}
/**
 * Get all QuoteLines from an alternative
 * Returns QuoteLine[]
 */
export interface Quote_GetQuoteLinesRequest {
    /**
     * Id of the alternative to return the quotelines for
     */
    QuoteAlternativeId: number;
}
/**
 * Deletes the QuoteLine in the SuperOffice database
 */
export interface Quote_DeleteQuoteLineRequest {
    /**
     * Primary key of the quoteline to delete
     */
    QuoteLineId: number;
}
/**
 * Delete the QuoteLines in the SuperOffice database
 */
export interface Quote_DeleteQuoteLinesRequest {
    /**
     * Primary keys of the quotelines to delete
     */
    QuoteLineIds: number[];
}
/**
 * When the user changes one or more values in a quoteline, the connector gets to change the QuoteLine, for instance calculate VAT. Shall be called when the user changes any of the following fields: Quantity, DiscountAmount, DiscountPercent, ListPrice (if allowed). Will calculate the TotalPrice and the VAT (if possible) for the line.
 * Returns QuoteLine
 */
export interface Quote_RecalculateQuoteLineRequest {
    /**
     * The QuoteLine to recalculate
     */
    QuoteLine: QuoteLine;
    /**
     * The id of the changed fields in the form 'TableName.FieldName'
     */
    ChangedFields: string[];
}
/**
 * Gets an image connected to a quoteline, either from the ERPProvider or from the SuperOffice database
 * Returns Blob
 */
export interface Quote_GetQuoteLineImageRequest {
    /**
     * Primary key of the quoteline
     */
    QuoteLineId: number;
    /**
     * The rank of the image.
     */
    Rank: number;
}
/**
 * Saves the image connected to a quoteline in the SuperOffice database
 */
export interface Quote_SaveQuoteLineImageRequest {
    /**
     * Primary key of the quoteline
     */
    QuoteLineId: number;
    /**
     * The image.
     */
    Image: ArrayBuffer | string;
    /**
     * The rank of the image.
     */
    Rank: number;
}
/**
 * Converts an xml string into an object representation.
 * Returns ProductExtraDataField[]
 */
export interface Quote_GetExtraInfoRequest {
    /**
     * The extra data as xml.
     */
    QuoteLineExtraData: string;
}
/**
 * QuoteLineConfiguration contains information about which configuration fields that is visible in the GUI. Read only and mandatory fields are also specified.
 */
export interface QuoteLineConfiguration extends Carrier {
    /**
     * Primary key
     */
    QuoteLineConfigurationId?: number;
    /**
     * The name of the field being configured, from data dictionary
     */
    FieldName?: string;
    /**
     * Label resource string.
     */
    Label?: string;
    /**
     * Tooltip resource string.
     */
    Tooltip?: string;
    /**
     * Is this a read only field?
     */
    Editable?: boolean;
    /**
     * Should this field be displayed in the GUI?
     */
    InUse?: boolean;
    /**
     * Is this a mandatory field?
     */
    Mandatory?: boolean;
    /**
     * Rank of the field
     */
    Rank?: number;
    /**
     * If true, then this field cannot be set readwrite or mandatory: It's bound to be readonly
     */
    RestrictEdit?: boolean;
}
/**
 * Returns the configuration field with the given id
 * Returns QuoteLineConfiguration
 */
export interface Quote_GetQuoteLineConfigurationRequest {
    /**
     * Id of the QuoteLineConfiguration to get.
     */
    QuoteLineConfigurationId: number;
}
/**
 * Returns the configuration field with the given field name
 * Returns QuoteLineConfiguration
 */
export interface Quote_GetQuoteLineConfigurationFromFieldNameRequest {
    /**
     * Field name of the QuoteLineConfiguration to get.
     */
    FieldName: string;
}
/**
 * Returns all the configuration fields
 * Returns QuoteLineConfiguration[]
 */
export interface Quote_GetAllQuoteLineConfigurationsRequest {
}
/**
 * Returns the configuration fields that should be visible in the GUI.
 * Returns QuoteLineConfiguration[]
 */
export interface Quote_GetInUseQuoteLineConfigurationsRequest {
}
/**
 * Save a QuoteLineConfiguration object. It is not possible to add a new configuration.
 * Returns QuoteLineConfiguration
 */
export interface Quote_SaveQuoteLineConfigurationRequest {
    /**
     * The QuoteLineConfiguration to save.
     */
    QuoteLineConfiguration: QuoteLineConfiguration;
}
/**
 * Save a collection of QuoteLineConfigurations. It is not possible to add a new configurations.
 * Returns QuoteLineConfiguration[]
 */
export interface Quote_SaveQuoteLineConfigurationsRequest {
    /**
     * The QuoteLineConfigurations to save.
     */
    QuoteLineConfigurations: QuoteLineConfiguration[];
}
/**
 * One line in a list
 */
export interface QuoteListItem extends Carrier {
    /**
     * Primary key for the item.
     */
    ERPQuoteListItemKey?: string;
    /**
     * List item text to display.
     */
    DisplayValue?: string;
    /**
     * Typically used in a tooltip.
     */
    DisplayDescription?: string;
}
/**
 * Gets a named list from the connector Return array of QuoteListItems. Return NULL if the given list is not supported.
 * Returns QuoteListItem[]
 */
export interface Quote_GetQuoteListRequest {
    /**
     * The name of the requested list, for instance: ProductCategory, ProductFamily, ProductType, PaymentTerms, PaymentType, DeliveryTerms, DeliveryType.
     */
    QuoteListType: string;
}
/**
 * Prepare the documents required to publish a quote - Email, main document as pdf, quoted products as pdf, attachments
 */
export interface QuotePublishDocuments extends Carrier {
    /**
     * Quote document, as PDF; may be zero if there is no document specified for the version
     */
    QuoteDocumentId?: number;
    /**
     * Quoted products (quote lines or confirmation lines) document, as PDF
     */
    QuotedProductsId?: number;
    /**
     * Array of id's of any attachments (standard + custom for this version)
     */
    QuoteAttachmentIds?: number[];
    /**
     * The string that is the content of the mail body; this is the result of merging the mail body template with the current template variable values
     */
    MailBody?: string;
    /**
     * The string that is the mail subject; done by merging the text resource SR_QUOTE_PUBLISH_MAILHEADING with the current template variable values
     */
    MailSubject?: string;
    /**
     * The email address of the recipient, taken from the sale's person
     */
    ToEmail?: string;
    /**
     * The full name of the recipient, taken from the sale's person
     */
    ToFullName?: string;
    /**
     * If something went wrong, show this message and do not continue
     */
    ErrorMessage?: string;
}
/**
 * Information about a version of the .
 */
export interface QuoteVersion extends Carrier {
    /**
     * Primary key
     */
    QuoteVersionId?: number;
    /**
     * Key in the ERP system that uniquely identifies this Version within the ERP system (if available, the field may be empty).
     */
    ERPQuoteVersionKey?: string;
    /**
     * Foreign key to CRM quote (the conceptual parent). Owning Quote of this Quote Version.
     */
    QuoteId?: number;
    /**
     * Description of Version. Potentially longer text description, typically used in a tooltip. Max 2K.
     */
    Description?: string;
    /**
     * A quote number that the user (or ERP connector) can fill out.
     */
    Number?: string;
    /**
     * Current state of this quote version.
     */
    State?: enums.QuoteVersionState;
    /**
     * State that this quote version had, right before it was changed to Archived; in this way we can show what happened before the archiving.
     */
    ArchivedState?: enums.QuoteVersionState;
    /**
     * If there was a problem with for instance calculation, this field is set to warning or error.
     */
    Status?: enums.QuoteStatus;
    /**
     * If there was a problem, this field contains a localized explanation of the problem and possible steps to fix it that the user can be shown.
     */
    Reason?: string;
    /**
     * The alternative that is considered most likely to be accepted. Used to calculate probable income.
     */
    LikelyQuoteAlternativeId?: number;
    /**
     * The date the version was sent to the customer.
     */
    SentDate?: Date;
    /**
     * Link to a follow-up activity, created when this quote version was sent to the customer.
     */
    FollowupId?: number;
    /**
     * Last date the quote Version is valid, expiration is at midnight end of this day.
     */
    ExpirationDate?: Date;
    /**
     * Country of delivery address, typically copied from the contact record
     */
    DeliveryCountryId?: number;
    /**
     * The delivery address is not the same as the contact's Street address
     */
    HasOwnDeliveryAddress?: boolean;
    /**
     * Country of invoice address, typically copied from contact record
     */
    InvoiceCountryId?: number;
    /**
     * The quote has an address for Invoicing. This will typically be copied from the company's addresses.
     */
    HasOwnInvoiceAddress?: boolean;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn’t support lists, a text. For instance: ‘Standard 30 days’.
     */
    ERPPaymentTermsKey?: string;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn’t support lists, a text. For instance: 'Invoice'.
     */
    ERPPaymentTypeKey?: string;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn’t support lists, a text. For instance: ‘FOB’ (‘Free on board’).
     */
    ERPDeliveryTermsKey?: string;
    /**
     * Either a List id to an id from a connector provided list, or, if the connection doesn’t support lists, a text. For instance: ‘Air’.
     */
    ERPDeliveryTypeKey?: string;
    /**
     * Rank/Version number, starts at 1
     */
    Rank?: number;
    /**
     * Id of associate who approved (or rejected approval) for this version
     */
    ApprovedBy?: number;
    /**
     * Text with comments on why approval was granted (or rejected)
     */
    ApprovedText?: string;
    /**
     * Id of associate who actually entered the approval; might be different from ApprovedBy (f.x. due to telephone consultation/approval)
     */
    ApprovedRegisteredBy?: number;
    /**
     * When was approval granted or rejected
     */
    ApprovedRegisteredDate?: Date;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField1?: string;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField2?: string;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField3?: string;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField4?: string;
    /**
     * Optional information added by Quote Connector; usable in the quote document merge process
     */
    ExtraField5?: string;
    /**
     * When this version was last subjected to a total recalculation. This field must be set by the connector, since the connector may choose to ignore a RecalculateVersion call based on policies and possibly the current value of this field. SuperOffice will set this field to 1.1.1760 whenever any change occurs to the quote, to indicate that a recalculation is needed.
     */
    LastRecalculated?: Date;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Last updated by whom
     */
    UpdatedAssociateId?: number;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Registered by whom
     */
    RegisteredAssociateId?: number;
    /**
     * User to whom the request proposal should be delivered
     */
    RequestAssociateId?: number;
    /**
     * Comment for why quote should be approved
     */
    RequestComment?: string;
    /**
     * The QuoteAlternatives for the QuoteVersion
     */
    QuoteAlternatives?: QuoteAlternative[];
}
/**
 * When the user changes one or more values in a quoteline or a quoteAlternative, the connector gets to change the QuoteLines and the alternative, for instance calculate VAT. ValidateQuoteVersion shall be called when the user presses the validate button, presses the send button or closes the quote dialog. RecalculateQuoteAlternative should typically validate all alternatives, set values in extrafields, and set the state in the version.
 * Returns QuoteVersionValidated
 */
export interface Quote_ValidateQuoteVersionRequest {
    /**
     * The version to be validated
     */
    QuoteVersionId: number;
    /**
     * The action, if any, related to the validate call, like PlaceOrder or SendQuote
     */
    Action: enums.QuoteVersionButtonAction;
}
/**
 * Created a new QuoteVersion based on another QuoteVersion on the same Quote.
 * Returns QuoteVersion
 */
export interface Quote_CreateAndSaveQuoteVersionRequest {
    /**
     * QuoteVersionId of the version to copy the contents from.
     */
    QuoteVersionId: number;
}
/**
 * Get a QuoteVersion
 * Returns QuoteVersion
 */
export interface Quote_GetQuoteVersionRequest {
    /**
     * QuoteVersionId to get information from
     */
    QuoteVersionId: number;
}
/**
 * Get all quote versions for a sale
 * Returns QuoteVersion[]
 */
export interface Quote_GetQuoteVersionsRequest {
    /**
     * QuoteId of the quote to get versions from
     */
    QuoteId: number;
}
/**
 * Send the quote to the user's customer. More parameters to be added later...
 * Returns PluginUrlResponse
 */
export interface Quote_SendQuoteVersionRequest {
    /**
     * QuoteVersionId of the quoteversion to send
     */
    QuoteVersionId: number;
    /**
     * Date the quote expires
     */
    ExpiryDate: Date;
    /**
     * Date for the followup task, to remind the sales rep about the quote
     */
    FollowupDate: Date;
    /**
     * The body text for the follwup appointment, resolved to the correct culture (no resources please)
     */
    FollowupText: string;
    /**
     * Desired culture for email body and other culture-sensitive templates/content
     */
    Culture: string;
}
/**
 * Saves a quote version
 * Returns QuoteVersion
 */
export interface Quote_SaveQuoteVersionRequest {
    /**
     * The quote version to save
     */
    QuoteVersion: QuoteVersion;
}
/**
 * Approves a quote version
 * Returns ApproveRejectResponse
 */
export interface Quote_ApproveQuoteVersionRequest {
    /**
     * QuoteVersionId to approve.
     */
    QuoteVersionId: number;
    /**
     * 'Approved by' prefix to ApprovalText used when creating appointment task to log approval. Must be passed since service does not know which language to use for 'Approved By' string.
     */
    ApprovedByText: string;
    /**
     * AssociateId of the associate who approved the quote version.
     */
    ApprovedByAssociateId: number;
    /**
     * Approval text.
     */
    ApprovalText: string;
}
/**
 * Rejects a quote version
 * Returns ApproveRejectResponse
 */
export interface Quote_RejectQuoteVersionRequest {
    /**
     * QuoteVersionId to approve.
     */
    QuoteVersionId: number;
    /**
     * 'Rejected by' prefix to RejectionText used when creating appointment task to log rejection. Must be passed since service does not know which language to use for 'Rejected By' string.
     */
    RejectedByText: string;
    /**
     * AssociateId of the associate who rejected the quote version.
     */
    RejectedByAssociateId: number;
    /**
     * Rejection text.
     */
    RejectionText: string;
}
/**
 * Generate all the documents required to send the Quote as an email to the prospect - or an Order Confirmation; it just depends on the template id's for the lines doc and mail body. Quote version status is not changed by this method.
 * Returns QuotePublishDocuments
 */
export interface Quote_GenerateQuoteDocumentsRequest {
    /**
     * VersionId of the quote to be sent; the status of the version will not be changed by calling this method
     */
    QuoteVersionId: number;
    /**
     * Id of the template for the email body, must be nonzero and refer to either a Quote mail body or Order Confirmation mail body, with html content
     */
    EmailBodyTemplateId: number;
    /**
     * Should the main quote document be attached to the email; generally false for Order Confirmations
     */
    AttachMainDocument: boolean;
    /**
     * Id of the template for the quote- or order confirmation-lines; zero if no document should be produced
     */
    QuotedProductsTemplateId: number;
    /**
     * If true, then the currently specified (in the database) attachments will be included
     */
    IncludeAttachments: boolean;
    /**
     * Subject line for email, in the correct language, sent in here to have any template variables substituted
     */
    RawMailSubject: string;
}
/**
 * Get a base64-encoded data stream that is just the order confirmation document, for the given quote version; no permanent document is created or stored anywhere; the result is a PDF
 * Returns string
 */
export interface Quote_GetOrderConfirmationRequest {
    /**
     * VersionId of the quote to be sent; the status of the version will not be changed by calling this method
     */
    QuoteVersionId: number;
    /**
     * Id of the template for the order confirmation lines document
     */
    ConfirmationTemplateId: number;
}
/**
 * Get all button states for the Quote version dialog. Packages ImageState, Button states and status info into one call. Collects most important warnings/errors from across all quotelines/alternatives in this quote version.
 * Returns QuoteVersionWorkflowState
 */
export interface Quote_GetQuoteVersionWorkflowStateRequest {
    /**
     * Id of the quote version to get the button states for.
     */
    QuoteVersionId: number;
    /**
     * Id of the active quote alternative id.
     */
    QuoteAlternativeId: number;
}
/**
 * Update price on the all the quotelines for each alternative in the current quote version
 * Returns QuoteVersionValidated
 */
export interface Quote_UpdateQuoteVersionPricesRequest {
    /**
     * The version to be update prices for
     */
    QuoteVersionId: number;
}
/**
 * Save the quote version number if it is valid
 * Returns boolean
 */
export interface Quote_SaveQuoteVersionNumberRequest {
    /**
     * VersionId of the quote version
     */
    QuoteVersionId: number;
    /**
     * The number to save
     */
    Number: string;
}
/**
 * Get state icon and name for the Quote version dialog header.
 * Returns QuoteVersionButtonState
 */
export interface Quote_GetQuoteVersionWorkflowImageStateRequest {
    /**
     * Id of the quote version to get the version state for.
     */
    QuoteVersionId: number;
}
/**
 * Get all button states for the Quote version dialog.
 * Returns QuoteVersionWorkflowState
 */
export interface Quote_GetQuoteVersionWorkflowButtonStatesRequest {
    /**
     * Id of the quote version to get the button states for.
     */
    QuoteVersionId: number;
    /**
     * Id of the active quote alternative id.
     */
    QuoteAlternativeId: number;
}
/**
 * Get status info for the Quote version dialog header. Collects most important warnings/errors from across all quotelines/alternatives in this quote version.
 * Returns QuoteVersionStatusInformation
 */
export interface Quote_GetQuoteVersionWorkflowStatusInfoRequest {
    /**
     * Id of the quote version to get the status info for.
     */
    QuoteVersionId: number;
}
/**
 * Notifies specified associate that this quote needs approval.
 * Returns PluginResponse
 */
export interface Quote_RequestApprovalRequest {
    /**
     * The quoteversion to be approved.
     */
    QuoteVersionId: number;
    /**
     * The associate that should be notified.
     */
    AssociateId: number;
    /**
     * Details or reason for request
     */
    Comment: string;
}
/**
 * Cancel a pending quote approval request.
 * Returns PluginResponse
 */
export interface Quote_CancelApprovalRequestRequest {
    /**
     * The quoteversion for which approval was previously sent.
     */
    QuoteVersionId: number;
}
/**
 * Attachment documents for a given version of a Quote
 */
export interface QuoteVersionAttachment extends Carrier {
    /**
     * Link to document
     */
    DocumentId?: number;
    /**
     * Will this attachment be included in the next 'Send Quote' operation
     */
    Included?: boolean;
}
/**
 * Look at the Quote version, related sale and sale type, and ensure that the correct QuoteVersionAttachment records exist. This method may create or delete records
 * Returns QuoteVersionAttachment[]
 */
export interface Quote_CreateOrUpdateQuoteVersionAttachmentsRequest {
    /**
     * The ID of the quote version
     */
    QuoteVersionId: number;
}
/**
 * Toggle the 'included' state of a quote version attachment; will throw exceptions if called on locked versions
 * Returns boolean
 */
export interface Quote_IncludeQuoteVersionAttachmentRequest {
    /**
     * The ID of the Quote version
     */
    QuoteVersionId: number;
    /**
     * The ID of the document
     */
    DocumentId: number;
    /**
     * Desired state
     */
    Include: boolean;
}
/**
 * Toggle the 'default included' state of a sale type quote attachment
 * Returns boolean
 */
export interface Quote_ToggleSaleTypeQuoteAttachmentDefaultIncludedRequest {
    /**
     * The ID of the sale type quote attachment row
     */
    SaleTypeQuoteAttachmentId: number;
}
/**
 * Adds a new quote attachment document to a sale type
 * Returns number
 */
export interface Quote_AddSaleTypeQuoteAttachmentRequest {
    /**
     * The ID of the sale type
     */
    SaleTypeId: number;
    /**
     * The ID of the document
     */
    DocumentId: number;
}
/**
 * Deletes the sale type quote attachment with the given id
 */
export interface Quote_DeleteSaleTypeQuoteAttachmentRequest {
    /**
     * The ID of the sale type quote attachment row to delete
     */
    SaleTypeQuoteAttachmentId: number;
}
/**
 * Toggle the 'included' state of a quote version attachment
 * Returns boolean
 */
export interface Quote_ToggleQuoteVersionAttachmentIncludedRequest {
    /**
     * The ID of the quote version attachment row
     */
    QuoteVersionAttachmentId: number;
}
/**
 * Information about possible button actions for the quote version dialog.
 */
export interface QuoteVersionButtonState extends Carrier {
    /**
     * Action for the button
     */
    Action?: enums.QuoteVersionButtonAction;
    /**
     * Image to be shown
     */
    ImageHint?: string;
    /**
     * Text to be displayed on the button
     */
    DisplayText?: string;
    /**
     * The tooltip for the button
     */
    TooltipText?: string;
    /**
     * Indicate if the button should be enabled or disabled
     */
    Enabled?: boolean;
}
/**
 * Information about possible button actions for the quote version dialog.
 */
export interface QuoteVersionStatusInformation extends Carrier {
    /**
     * Status information for the quote version: Ok / OkWithInfo / Warn / Error.
     */
    Status?: enums.QuoteStatus;
    /**
     * Icon hint for the associated message.
     */
    IconHint?: string;
    /**
     * Generated error message for the Quote Version. Will check for errors on quote lines, alternatives and the version itself.
     */
    DisplayMessage?: string;
    /**
     * Generated full tooltip for the Quote Version. Will check for errors on quote lines, alternatives and the version itself.
     */
    DisplayTooltip?: string;
}
/**
 * The QuoteVersionValidated is returned after a call to ValidateQuoteAlternative. It contains flags indicating changes to quote, quoteversion/quotealternative and quotelines.
 */
export interface QuoteVersionValidated extends Carrier {
    /**
     * Answer to the question / An indication if the operation went well. Equivalent to Status != Error.
     */
    IsOk?: boolean;
    /**
     * A localized explanation to the answer.
     */
    UserExplanation?: string;
    /**
     * Always in English
     */
    TechExplanation?: string;
    /**
     * An error code, if available.
     */
    ErrorCode?: string;
    /**
     * If the sale has been changed, the carrier will be added.
     */
    ChangedSale?: Sale;
    /**
     * The validated version is a member of Quote
     */
    ChangedQuote?: Quote;
    /**
     * The validated QuoteVersion
     */
    ChangedQuoteVersion?: QuoteVersion;
    /**
     * The changed QuoteAlternatives
     */
    ChangedQuoteAlternatives?: QuoteAlternativeRecalculated[];
    /**
     * QuoteStatus = Ok / OkWithInfo / Warn / Error. Error implies IsOk = false.
     */
    Status?: enums.QuoteStatus;
}
/**
 * Information about possible button actions for the quote version dialog.
 */
export interface QuoteVersionWorkflowState extends Carrier {
    /**
     * Array of visible buttons with defined actions in the quote verson dialog.
     */
    ActionButtons?: QuoteVersionButtonState[];
    /**
     * Information about the state image for the current quote version.
     */
    StateImage?: QuoteVersionButtonState;
    /**
     * Information about the action for the update prices button.
     */
    UpdatePricesButton?: QuoteVersionButtonState;
    /**
     * Status information for the Quote Version.
     */
    Status?: QuoteVersionStatusInformation;
}
/**
 * Information about a connection to the ERP system.
 */
export interface ErpConnection extends Carrier {
    /**
     * Primary key
     */
    ErpConnectionId?: number;
    /**
     * The connector that this connection should call
     */
    ErpConnectorId?: number;
    /**
     * Connection name shown to user; multi-language support
     */
    DisplayName?: string;
    /**
     * Tooltip/description shown to user; multi-language support
     */
    DisplayDescription?: string;
    /**
     * Is this connection currently active
     */
    Active?: boolean;
    /**
     * The GUID that uniquely identifies this connection; passed to the Connector in every call
     */
    ConnectionId?: string;
    /**
     * Datetime, transaction number or other identification of the point in time of the most-recently seen actor in the ERP system
     */
    MostRecentTimestamp?: string;
    /**
     * The config fields needed to establish a connection to the connector
     */
    ConfigFields?: StringDictionary;
    /**
     * If true, the connection has been deleted and should not be shown to the users.
     */
    Deleted?: boolean;
    /**
     * Is this connection accessible to everyone?  If not, then the ErpConnectionAccess table tells us who can access it
     */
    AllAccess?: boolean;
    /**
     * Array of ids containing usergroups that will have access to this connection.
     */
    UserGroupAccessIds?: number[];
    /**
     * Array of ids containing associates that will have access to this connection.
     */
    AssociateAccessIds?: number[];
}
/**
 * Returns the specified connection.
 * Returns ErpConnection
 */
export interface ErpSync_GetConnectionRequest {
    /**
     * Primary key of the connection
     */
    ErpConnectionId: number;
}
/**
 * Saves a connection to the database.
 * Returns ErpConnection
 */
export interface ErpSync_SaveConnectionRequest {
    /**
     * The connection to save.
     */
    Connection: ErpConnection;
}
/**
 * Deletes a connection from the database.
 */
export interface ErpSync_DeleteConnectionRequest {
    /**
     * Primary key of the connection
     */
    ErpConnectionId: number;
}
/**
 * Returns all fields needed to connect to the given connector
 * Returns FieldMetadata[]
 */
export interface ErpSync_GetConfigurationFieldsRequest {
    /**
     * The id of the erp connector
     */
    ErpConnectorId: number;
}
/**
 * Returns the config fields for the connection.
 * Returns StringDictionary
 */
export interface ErpSync_GetErpConnectionConfigFieldsRequest {
    /**
     * Primary key of the erp connection
     */
    ErpConnectionId: number;
}
/**
 * Toggles the Active state of the connection
 * Returns string[]
 */
export interface ErpSync_ToggleErpConnectionActiveRequest {
    /**
     * Primary key of the erp connection
     */
    ErpConnectionId: number;
}
/**
 * Tests to see if we can establish a connection with the given config fields
 * Returns boolean
 */
export interface ErpSync_TestConnectionByIdRequest {
    /**
     * The id of the connection
     */
    ErpConnectionId: number;
}
/**
 * Tests to see if the given connection has a valid connection to its connector
 * Returns boolean
 */
export interface ErpSync_TestConnectionByConfigRequest {
    /**
     * The id of the connector we try to connect to
     */
    ErpConnectionId: number;
    /**
     * The config fields used to test connection
     */
    ConfigFields: StringDictionary;
}
/**
 * Takes an array of the ErpConnection ids and saves these as ordered sync priorities
 * Returns boolean
 */
export interface ErpSync_SaveErpConnectionSyncPrioritiesRequest {
    /**
     * The id put in array in the same order as the priorities
     */
    ErpConnectionIds: number[];
}
/**
 * Moves the rank of the erp field up or down
 */
export interface ErpSync_MoveErpFieldItemRequest {
    /**
     * The id of the erp field to move
     */
    ErpFieldId: number;
    /**
     * Positive value to increase rank, negative to decrease.
     */
    Direction: number;
    /**
     * The id of the connection
     */
    ErpConnectionId: number;
    /**
     * The actor type for which we want to rank fields
     */
    ErpActorType: enums.ErpActorType;
}
/**
 * Indicates if the connection supports advanced search for the given erp actor
 * Returns boolean
 */
export interface ErpSync_SupportsAdvancedSearchRequest {
    /**
     * Ths id of the connection
     */
    ErpConnectionId: number;
    /**
     * The erp actor type to check for
     */
    ErpActorType: enums.ErpActorType;
}
/**
 * Returns all ERP Sync connectors. Uses the `ErpConnector` archive.
 * Returns ListItem[]
 */
export interface ErpSync_GetAllConnectorsRequest {
}
/**
 * Returns all ERP Sync connections without config field data. Uses the `ErpConnection` archive.
 * Returns ErpConnection[]
 */
export interface ErpSync_GetAllConnectionsRequest {
    /**
     * Include deleted connections in the result?
     */
    IncludeDeleted: boolean;
}
/**
 * Contains connection data and field labels for one connection
 */
export interface ErpConnectionData extends Carrier {
    /**
     * The id of the connection
     */
    ErpConnectionId?: number;
    /**
     * The name of the connection
     */
    ConnectionName?: string;
    /**
     * True if this entity instance has syncronized connection
     */
    Connected?: boolean;
    /**
     * The ERP fields that should be displayed
     */
    ErpFields?: FieldMetadata[];
    /**
     * The crm actor type which these fields belongs to
     */
    CrmActorType?: enums.CrmActorType;
    /**
     * The erp actor type which these fields belongs to
     */
    ErpActorType?: enums.ErpActorType;
    /**
     * Contains all mapped ErpActorType for this CrmActorType
     */
    ErpActorTypes?: enums.ErpActorType[];
}
/**
 * Get all connection statuses and fields for a given entity
 * Returns ErpConnectionData[]
 */
export interface ErpSync_GetConnectionsAndDisplayFieldsRequest {
    /**
     * The type of the CRM entity
     */
    CrmActorType: enums.CrmActorType;
    /**
     * The id of the entity
     */
    EntityId: number;
}
/**
 * Get the values for the specified fields from the ERP connection
 * Returns string[]
 */
export interface ErpSync_GetErpFieldValuesRequest {
    /**
     * The id of the connection
     */
    ErpConnectionId: number;
    /**
     * The type of the CRM entity
     */
    CrmActorType: enums.CrmActorType;
    /**
     * The id of the entity
     */
    EntityId: number;
    /**
     * The fields for which you want to get the values
     */
    FieldKeys: string[];
}
/**
 * Get the fields that must be filled out when creating a new ERP actor
 * Returns FieldMetadata[]
 */
export interface ErpSync_GetFieldsForNewErpActorRequest {
    /**
     * The id of the connection
     */
    ErpConnectionId: number;
    /**
     * The type of the ERP actor to create
     */
    ErpActorType: enums.ErpActorType;
}
/**
 * Information about a mapping between two lists between CRM and the ERP system.
 */
export interface ErpConnectionListMapping extends Carrier {
    /**
     * The SuperOffice listItem
     */
    CrmList?: MDOListItem;
    /**
     * The ERP list name, if the field has a list of values supplied by the ERP Connector
     */
    ErpListName?: string;
    /**
     * Array of all the list item mappings
     */
    ErpCrmListItemMappings?: ErpCrmListItemMapping[];
    /**
     * The actorType belonging to the ListMapping
     */
    ErpActorTypeName?: string;
    /**
     * The id of the field that is using the lists. Readonly
     */
    ErpFieldId?: number;
}
/**
 * Information about all list connections for a connection between CRM and the ERP system.
 */
export interface ErpConnectionListMappingContainer extends Carrier {
    /**
     * Array of ErpConnectionListMapping
     */
    ErpListItemMappings?: ErpConnectionListMapping[];
    /**
     * Primary key
     */
    ErpConnectionId?: number;
    /**
     * The name of the erp connection
     */
    ErpConnectionName?: string;
}
/**
 * Returns the listmappings for the specified connection.
 * Returns ErpConnectionListMappingContainer
 */
export interface ErpSync_GetConnectionListMappingsRequest {
    /**
     * Primary key of the connection
     */
    ErpConnectionId: number;
}
/**
 * Saves a connection to the database.
 * Returns ErpConnectionListMappingContainer
 */
export interface ErpSync_SaveConnectionListMappingsRequest {
    /**
     * The list item mappings to save.
     */
    ListMapping: ErpConnectionListMappingContainer;
}
/**
 * One list item mapping between erp and crm.
 */
export interface ErpCrmListItemMapping extends Carrier {
    /**
     * One Erp listItem id
     */
    ErpListItemId?: string;
    /**
     * One Erp listItem id
     */
    ErpListItemName?: string;
    /**
     * One mapped SuperOffice listItem
     */
    CrmListItem?: MDOListItem;
}
/**
 *
 */
export interface ErpSyncFieldValue extends Carrier {
    /**
     *
     */
    DisplayName?: string;
    /**
     * The CRM field name, as implemented by the Sync entities
     */
    CrmFieldKey?: string;
    /**
     *
     */
    Value?: string;
    /**
     *
     */
    DisplayValue?: string;
    /**
     * Should value changes in ERP be automatically transferred to CRM
     */
    SyncToCrm?: boolean;
    /**
     * Should value changes in CRM be automatically transferred to ERP
     */
    SyncToErp?: boolean;
}
/**
 * Create a link between Erp and Crm and set default values
 */
export interface ErpSync_ConnectActorRequest {
    /**
     * ErpConnectionId
     */
    ErpConnectionId: number;
    /**
     * CrmRecordId
     */
    CrmRecordId: number;
    /**
     * The Crm Actor type
     */
    CrmActorType: enums.CrmActorType;
    /**
     *
     */
    ErpKey: string;
    /**
     * The Erp Actor type
     */
    ErpActorType: enums.ErpActorType;
    /**
     * The Crm Fields
     */
    FieldValues: ErpSyncFieldValue[];
}
/**
 * Create a link between Erp and Crm and set default values
 * Returns boolean
 */
export interface ErpSync_TryConnectActorRequest {
    /**
     * ErpConnectionId
     */
    ErpConnectionId: number;
    /**
     * CrmRecordId
     */
    CrmRecordId: number;
    /**
     * The Crm Actor type
     */
    CrmActorType: enums.CrmActorType;
    /**
     *
     */
    ErpKey: string;
    /**
     * The Erp Actor type
     */
    ErpActorType: enums.ErpActorType;
    /**
     * The Crm Fields
     */
    FieldValues: ErpSyncFieldValue[];
}
/**
 * Get Crm Field values
 * Returns ErpSyncFieldValue[]
 */
export interface ErpSync_GetFieldValuesFromCrmRequest {
    /**
     * The id of the CRM entity
     */
    RecordId: number;
    /**
     * CRM Actor type
     */
    ActorTypeCrm: enums.CrmActorType;
}
/**
 * Get Erp Field values
 * Returns ErpSyncFieldValue[]
 */
export interface ErpSync_GetFieldValuesFromErpRequest {
    /**
     * Erp connection id
     */
    ErpConnectionId: number;
    /**
     * ERP Actor type
     */
    ActorTypeErp: enums.ErpActorType;
    /**
     * Primary key for the erp actor
     */
    ErpKey: string;
}
/**
 * Mapping information for one Actor, contains array of field mappings (ERP <-> SuperOffice)
 */
export interface ErpSyncActorTypeMapping extends Carrier {
    /**
     * Primary key
     */
    ErpConnectionId?: number;
    /**
     * Is this sync mapping active
     */
    IsActive?: boolean;
    /**
     * Array of individual field mappings; explicitly map to empty CrmFieldKey to indicate non-sync
     */
    FieldMappings?: ErpSyncFieldMapping[];
    /**
     * The actor type (ERP side)
     */
    ActorTypeErp?: enums.ErpActorType;
    /**
     * The actor type (CRM side)
     */
    ActorTypeCrm?: enums.CrmActorType;
}
/**
 * Get the current mappings for one connection/actor; connection+actor type = unique key
 * Returns ErpSyncActorTypeMapping
 */
export interface ErpSync_GetActorTypeMappingRequest {
    /**
     * The ERP connection ID
     */
    ErpConnectionId: number;
    /**
     * The actor type
     */
    ActorType: enums.ErpActorType;
}
/**
 * Link a crm entity to an erp entity
 * Returns boolean
 */
export interface ErpSync_CreateActorLinkRequest {
    /**
     * The ERP connection ID
     */
    ErpConnectionId: number;
    /**
     * The ID of the CRM entity to connect to
     */
    CrmRecordId: number;
    /**
     * Identifies the CRM actor type corresponding to this CRM entity
     */
    CrmActorType: enums.CrmActorType;
    /**
     * The ERP entity identifier
     */
    ErpKey: string;
    /**
     * The ERP actor type
     */
    ErpActorType: enums.ErpActorType;
}
/**
 * Remove the link between a CRM entity and an ERP entity
 * Returns boolean
 */
export interface ErpSync_BreakActorLinkRequest {
    /**
     * The ERP connection ID
     */
    ErpConnectionId: number;
    /**
     * The ID of the CRM entity to connect to
     */
    CrmRecordId: number;
    /**
     * Identifies the CRM actor type corresponding to this CRM entity
     */
    CrmActorType: enums.CrmActorType;
}
/**
 * Create ErpActor from crm entity
 * Returns boolean
 */
export interface ErpSync_CreateErpActorFromCrmRequest {
    /**
     * The connection ID
     */
    ConnectionId: number;
    /**
     * The ID of the CRM entity to create an ERP actor from
     */
    CrmEntityId: number;
    /**
     * The ERP actor type
     */
    ErpActorType: enums.ErpActorType;
    /**
     * The CRM actor type
     */
    CrmActorType: enums.CrmActorType;
    /**
     * A map of matching erp field keys and values to set for the new erp entity
     */
    ErpFieldKeyValues: StringDictionary;
}
/**
 * Save mappings for a connection/actor
 * Returns ErpSyncActorTypeMapping
 */
export interface ErpSync_SaveActorTypeMappingRequest {
    /**
     * The mapping to be saved; new mapping rows will be created in the database if needed
     */
    Mapping: ErpSyncActorTypeMapping;
}
/**
 * Clear field info from table SUPERLISTCOLUMNSIZE if field mapping changed on given connection
 */
export interface ErpSync_ValidateArchiveColumnConfigRequest {
    /**
     * GUI name used in archive control config
     */
    ListOwner: string;
    /**
     * The ERP connection ID
     */
    ErpConnectionId: number;
}
/**
 * Gets all supported actor types, and all fields for each actor type, and save this state to the CRM database
 * Returns boolean
 */
export interface ErpSync_UpdateConnectionFieldsRequest {
    /**
     * The ERP connection ID
     */
    ErpConnectionId: number;
}
/**
 * Retrieves the CrmActorType that are mapped to a specific ErpActorType for this connection
 * Returns CrmActorType
 */
export interface ErpSync_GetCrmActorTypeRequest {
    /**
     * The ERP connection ID
     */
    ErpConnectionId: number;
    /**
     * The ERP actor type
     */
    ErpActorType: enums.ErpActorType;
}
/**
 * Summary of the current setup of the ERP Integration, for one ERP connection
 */
export interface ErpSyncConnectionSummary extends Carrier {
    /**
     * Connection name shown to user; multi-language support
     */
    DisplayName?: string;
    /**
     * Tooltip/description shown to user; multi-language support
     */
    DisplayDescription?: string;
    /**
     * Is the connection currently active
     */
    Active?: boolean;
    /**
     * Is the connection deleted
     */
    Deleted?: boolean;
    /**
     * The time of the last sync
     */
    LastSync?: Date;
    /**
     * Summaries of the configuration of the actors configured for this connection
     */
    Actors?: ErpSyncActorSummary[];
}
/**
 * Get a summary of the current ErpSync configuration/setup
 * Returns ErpSyncConnectionSummary
 */
export interface ErpSync_GetErpSyncConnectionSummaryRequest {
    /**
     * The ID of the ErpSync connection for which information is sought
     */
    ErpSyncConnectionId: number;
}
/**
 * Erp connector information
 */
export interface ErpSyncConnectorEntity extends Carrier {
    /**
     * Primary key
     */
    ErpConnectorId?: number;
    /**
     * Name shown in the list
     */
    DisplayName?: string;
    /**
     * The URL where the connector is located and can be called
     */
    URL?: string;
    /**
     * True if the connector is deleted
     */
    Deleted?: boolean;
}
/**
 * Can we delete the connector?
 * Returns ErpSyncResponseCode
 */
export interface ErpSync_CanDeleteErpSyncConnectorEntityRequest {
    /**
     * The ID of the ErpSync connector to check if can be deleted
     */
    ErpSyncConnectorId: number;
}
/**
 * Test if connector urls anwers
 * Returns ErpSyncResponseCode
 */
export interface ErpSync_TestConnectorUrlRequest {
    /**
     * The url to test connection on
     */
    Url: string;
}
/**
 * Contains default value information for one ERP field
 */
export interface ErpSyncDefaultValue extends Carrier {
    /**
     * Primary key
     */
    ErpFieldId?: number;
    /**
     * Default value, stored using CultureDataFormatter format if it is not a string
     */
    DefaultValue?: string;
    /**
     * Should a default value be set on first sync
     */
    HasFirstSyncDefaultValue?: boolean;
    /**
     * The default value to be set, can be blank
     */
    FirstSyncDefaultValue?: string;
    /**
     * Should the field be shown in the first-sync GUI; independent of whether a default value should be set
     */
    PromptUser?: boolean;
    /**
     * Should the user be forced to set a value (the Erp Connector may declare fields mandatory as well)
     */
    Mandatory?: boolean;
    /**
     * The ERP field key
     */
    ErpFieldKey?: string;
    /**
     * Field type
     */
    FieldType?: enums.FieldMetadataType;
    /**
     * The ERP list name, if the field has a list of values supplied by the ERP Connector
     */
    ListName?: string;
    /**
     * Access restrictions for the field
     */
    Access?: enums.FieldAccess;
}
/**
 * Save information about a default value for an ERP field
 * Returns ErpSyncDefaultValue
 */
export interface ErpSync_SaveDefaultValueInfoRequest {
    /**
     * The id of the ERPfield to save
     */
    ErpSyncDefaultValue: ErpSyncDefaultValue;
}
/**
 * Get information about default value for an ERP field
 * Returns ErpSyncDefaultValue
 */
export interface ErpSync_GetDefaultValueInfoRequest {
    /**
     * The id of the ERP field
     */
    ErpFieldId: number;
}
/**
 * The ERP syncengine.
 */
export interface ErpSyncEngine extends Carrier {
}
/**
 * Sync all active connections
 * Returns PluginResponse
 */
export interface ErpSync_SyncAllRequest {
}
/**
 * Sync all active connections even when automatic sync is off
 * Returns PluginResponse
 */
export interface ErpSync_ForceSyncAllRequest {
}
/**
 * Force resync from CRM or given Erp connection to all other connections
 * Returns PluginResponse
 */
export interface ErpSync_ForceResyncRequest {
    /**
     * If positive, resync from the given erp connection
     */
    ErpConnectionId: number;
    /**
     * The internal keys of the entities to resync, or empty to resync all
     */
    InternalKeyIds: number[];
}
/**
 * Force resync from CRM or given Erp connection to all other connections and tell the sync that you don't want blank values to overwrite non-blank values. Useful on import.
 * Returns PluginResponse
 */
export interface ErpSync_ForceResyncNoBlankValuesRequest {
    /**
     * If positive, resync from the given erp connection
     */
    ErpConnectionId: number;
    /**
     * The internal keys of the entities to resync, or empty to resync all
     */
    InternalKeyIds: number[];
}
/**
 * Start batch task to force resync from CRM or given Erp connection to all other connections
 */
export interface ErpSync_ForceResyncBatchTaskRequest {
    /**
     * If positive, resync from the given erp connection
     */
    ErpConnectionId: number;
    /**
     * The internal keys of the entities to resync, or empty to resync all
     */
    InternalKeyIds: number[];
}
/**
 * Force resync from CRM or given Erp connection to all other connections, using external keys
 * Returns PluginResponse
 */
export interface ErpSync_ForceResyncExternalRequest {
    /**
     * Resync from the given erp connection
     */
    ErpConnectionId: number;
    /**
     * Which actor type the external keys are associated with
     */
    ErpActorType: enums.ErpActorType;
    /**
     * The internal keys of the entities to resync, or empty to resync all
     */
    ExternalKeys: string[];
}
/**
 * Force resync from CRM or given Erp connection to all other connections, using external keys, and tell the sync that you don't want blank values to overwrite non-blank values. Useful on import.
 * Returns PluginResponse
 */
export interface ErpSync_ForceResyncExternalNoBlankValuesRequest {
    /**
     * Resync from the given erp connection
     */
    ErpConnectionId: number;
    /**
     * Which actor type the external keys are associated with
     */
    ErpActorType: enums.ErpActorType;
    /**
     * The internal keys of the entities to resync, or empty to resync all
     */
    ExternalKeys: string[];
}
/**
 * Status of the Sync engine
 */
export interface ErpSyncEngineStatus extends Carrier {
    /**
     * Is the engine currently running
     */
    IsRunning?: boolean;
    /**
     * Current status message from the engine
     */
    StatusMessage?: string;
    /**
     * The interval for each iteration of the sync engine
     */
    Interval?: moment.Duration;
}
/**
 * Get the current status of the Sync engine
 * Returns ErpSyncEngineStatus
 */
export interface ErpSync_GetEngineStatusRequest {
}
/**
 * Change the current running/stopped status of the Sync engine
 * Returns ErpSyncEngineStatus
 */
export interface ErpSync_ChangeEngineStatusRequest {
    /**
     * If true, then start the engine; otherwise stop it (requests to the Batch system, may not be immediately reflected)
     */
    Run: boolean;
}
/**
 * Change the interval for each run of the Sync Engine
 */
export interface ErpSync_ChangeEngineIntervalRequest {
    /**
     * The run interval for the engine
     */
    Interval: moment.Duration;
}
/**
 * Mapping information for one field pair (ERP <-> SuperOffice)
 */
export interface ErpSyncFieldMapping extends Carrier {
    /**
     * Primary key
     */
    ErpFieldId?: number;
    /**
     * The CRM field name, as implemented by the Sync entities
     */
    CrmFieldKey?: string;
    /**
     * Display name of CRM field; ignored on Save
     */
    CrmDisplayName?: string;
    /**
     * Tooltip text for CRM field; ignored on Save
     */
    CrmDisplayTooltip?: string;
    /**
     * The ERP field key
     */
    ErpFieldKey?: string;
    /**
     * Field type
     */
    FieldType?: enums.FieldMetadataType;
    /**
     * Display name of ERP field; ignored on Save
     */
    ErpDisplayName?: string;
    /**
     * Tooltip text for ERP field; ignored on Save
     */
    ErpDisplayTooltip?: string;
    /**
     * Should value changes in ERP be automatically transferred to CRM
     */
    SyncToCrm?: boolean;
    /**
     * Should value changes in CRM be automatically transferred to ERP
     */
    SyncToErp?: boolean;
    /**
     * Should this field be shown as a (read-only!) field in the CRM Gui
     */
    ShowInGui?: boolean;
    /**
     * Should this field be shown in searches
     */
    ShowInSearch?: boolean;
    /**
     * Is this ERPField already mapped in some other connection? If so, then it cannot be one-way mapped TO SuperOffice here
     */
    AlreadyMapped?: boolean;
    /**
     * This field existed previously, but now the connection no longer supports it. Probably not a good sign, unmap it...
     */
    MissingInERP?: boolean;
    /**
     * This field existed previously, but now CRM no longer supports it (udef change?). Probably not a good sign, unmap it...
     */
    MissingInCRM?: boolean;
    /**
     * Access restrictions for the field
     */
    Access?: enums.FieldAccess;
    /**
     * Field is read-only, for lookup in gui
     */
    ListReference?: string;
}
/**
 * Summary of the current setup of the ERP Integration, for one ERP actor
 */
export interface ErpSyncActorSummary extends Carrier {
    /**
     * Actor type
     */
    ActorType?: enums.ErpActorType;
    /**
     * Does this actor type have field mappings
     */
    HasMappings?: boolean;
    /**
     * A summary of fields that have defaults/rules for link creation
     */
    Defaults?: string;
    /**
     * A summary of fields that have mappings to or from the ERP system
     */
    Mappings?: string;
}
/**
 * Override specifications for resources/labels
 */
export interface ResourceOverride extends Carrier {
    /**
     * The name of the resource, without any brackets or braces - example: SR_CONTACT
     */
    ResourceName?: string;
    /**
     * The value of the resource in the given culture
     */
    ResourceValue?: string;
    /**
     * .NET-style culture code, such as NB-NO or EN-UK
     */
    Culture?: string;
    /**
     * Is this override active
     */
    IsActive?: boolean;
}
/**
 * Create or update a resource substitution
 */
export interface Resource_SetResourceSubstitutionRequest {
    /**
     * The name of the resource, without any brackets
     */
    ResourceName: string;
    /**
     * The new value of the resource
     */
    ResourceValues: string;
    /**
     * The .NET culture string
     */
    Culture: string;
    /**
     * Is the subsitution now active
     */
    IsActive: boolean;
}
/**
 * Permanentely delete a resource substitution for one or more cultures
 */
export interface Resource_DeleteResourceSubstitutionRequest {
    /**
     * The name of the resource, without any brackets
     */
    ResourceName: string;
    /**
     * The .NET culture string; if blank, then ALL substitutions for this resource will be dropped
     */
    Culture: string;
}
/**
 * Activate or deactive a resource substitution for one or more cultures
 */
export interface Resource_ActivateResourceSubstitutionRequest {
    /**
     * The name of the resource, without any brackets; if blank then this is the MASTER SWITCH for the override system
     */
    ResourceName: string;
    /**
     * The .NET culture string; if blank, then ALL substitutions for this resource will be affected
     */
    Culture: string;
    /**
     * New status of override
     */
    IsActive: boolean;
}
/**
 * Get substitutions for some or all resources for one culture
 * Returns ResourceOverride[]
 */
export interface Resource_GetResourceSubstitutionsRequest {
    /**
     * Array of names of resources for which overrides are sought; if empty, then get all
     */
    ResourceNames: string[];
    /**
     * .NET culture string; if empty, then get all
     */
    Culture: string;
    /**
     * If true, then only resources with active substitutions will be returned; if false then ALL existing overrides will be returned
     */
    ActiveOnly: boolean;
}
/**
 * Determine if resource substitution/override is active, globally or for a subset of resources/cultures
 * Returns ResourceOverride[]
 */
export interface Resource_IsResourceSubstitutionActiveRequest {
    /**
     * Array of names of resources for which overrides are sought; if empty, then get the MASTER on/off
     */
    ResourceNames: string[];
    /**
     * .NET culture string; if empty, then get for all cultures (unless resourceName
     */
    Culture: string;
}
/**
 *
 */
export interface Contact extends Carrier {
    /**
     * Primary key
     */
    ContactId?: number;
    /**
     * Contact name
     */
    Name?: string;
    /**
     * VAT number or similar
     */
    OrgNr?: string;
    /**
     * Department
     */
    Department?: string;
    /**
     * The internet address to this contact
     */
    URL?: string;
    /**
     * City corresponding to zip code
     */
    City?: string;
    /**
     * The contacts phone
     */
    DirectPhone?: string;
    /**
     * Our contact
     */
    AssociateId?: number;
    /**
     * Country
     */
    CountryId?: number;
    /**
     * The contact email address
     */
    EmailAddress?: string;
    /**
     * Contact kana name, used in Japanese versions only
     */
    Kananame?: string;
    /**
     * Visible field
     */
    EmailAddressName?: string;
    /**
     * Visible field
     */
    URLName?: string;
    /**
     * The associate's culture formatted fullname (firstname, middleName and lastname)
     */
    AssociateFullName?: string;
    /**
     * The business list item name
     */
    BusinessName?: string;
    /**
     * The category list item name
     */
    CategoryName?: string;
    /**
     * Name of country in installed language
     */
    CountryName?: string;
    /**
     * Contact address as  a list of LocalizedFieldList objects. Used to store localized information such as formatted address data. Suitable for passing to an address control for display.
     */
    Address?: Address;
    /**
     * The contact's address, formatted with linebreaks and spaces into a single string.
     */
    FormattedAddress?: string;
    /**
     *
     */
    FullName?: string;
    /**
     * Is the contact an owner contact.  This means that all persons on this contact can on only be internal users and not external users.
     */
    IsOwnerContact?: boolean;
    /**
     * The number of active erp links
     */
    ActiveErpLinks?: number;
    /**
     * Alphanumeric user field
     */
    Number1?: string;
    /**
     * Alphanumeric user field
     */
    Number2?: string;
}
/**
 *
 */
export interface ContactActivity extends Carrier {
    /**
     * Primary key
     */
    ContactId?: number;
    /**
     * Department
     */
    Department?: string;
    /**
     * VAT number or similar
     */
    OrgNr?: string;
    /**
     * Contact name
     */
    Name?: string;
    /**
     * URL address
     */
    URL?: string;
    /**
     * The contact's owner
     */
    AssociateFullName?: string;
    /**
     * The activity that has occured on this contact.
     */
    Action?: enums.ContactAction;
    /**
     * The time of the activity. If more than one activity has occured on the contact, the last activity time is shown.
     */
    ActionTime?: Date;
    /**
     * The contact category.
     */
    Category?: string;
    /**
     * The person that carried out the activity on the contact.
     */
    ActivityPersonName?: string;
    /**
     * Id of the last element an activity was found on. I.e. AppointmentId, ContactId, or PersonId
     */
    ActionId?: number;
    /**
     * The person id
     */
    PersonId?: number;
    /**
     * Id of the person causing the activity.
     */
    ActivityPersonId?: number;
    /**
     * Our contact
     */
    AssociateId?: number;
}
/**
 * Returns the contacts where there has been activity since activityStartTime. If activityStartTime is larger than the current date, all contacts with activity since last log-out are returned. The result set can be filtered by category and action type.
 * Returns ContactActivity[]
 */
export interface Contact_GetMyActiveContactsRequest {
    /**
     * The start time of the activities. If the start time is set to a future date; activites since the user last logged out are returned.
     */
    ActivityStartTime: Date;
    /**
     * Integer array of categories to filter on. If the array is empty contacts from all categories will be selected.
     */
    ContactCategories: number[];
    /**
     * The type of action that has occured. E.g. updates, deletes, new appointments, etc.
     */
    ActionType: enums.ContactAction;
}
/**
 * The Contact Service. The service implements all services working with the Contact object
 */
export interface ContactEntity extends Carrier {
    /**
     * Primary key
     */
    ContactId?: number;
    /**
     * Contact name
     */
    Name?: string;
    /**
     * Department
     */
    Department?: string;
    /**
     * VAT number or similar
     */
    OrgNr?: string;
    /**
     * Alphanumeric user field
     */
    Number1?: string;
    /**
     * Alphanumeric user field
     */
    Number2?: string;
    /**
     * Date last updated
     */
    UpdatedDate?: Date;
    /**
     * Date registered
     */
    CreatedDate?: Date;
    /**
     * The contact's email
     */
    Emails?: EntityElement[];
    /**
     * The contact's available and selected interests.
     * Use MDO List name "contint" to get list items.
     */
    Interests?: SelectableMDOListItem[];
    /**
     * The contact's internet adresses
     */
    Urls?: EntityElement[];
    /**
     * The contact's phone numbers
     */
    Phones?: EntityElement[];
    /**
     * The contact's fax numbers
     */
    Faxes?: EntityElement[];
    /**
     * Description of the contact. Usually shown as a postit note.
     */
    Description?: string;
    /**
     * The user that last updated the contact
     */
    UpdatedBy?: Associate;
    /**
     * The user that created the contact
     */
    CreatedBy?: Associate;
    /**
     * The user that owns this contact.
     * Use MDO List name "associate" to get list items.
     */
    Associate?: Associate;
    /**
     * The business that the contact is associated with. The GUI forces the user to enter a business type.
     * Use MDO List name "business" to get list items.
     */
    Business?: Business;
    /**
     * The category that is set on the company. The GUI forces the user to enter a category type
     * Use MDO List name "category" to get list items.
     */
    Category?: Category;
    /**
     * The country this contact is located in. The country a contact is saved with, affects the phone number format, and the address layout.
     * Use MDO List name "country" to get list items.
     */
    Country?: Country;
    /**
     * The persons belonging to the contact.
     */
    Persons?: Person[];
    /**
     * Spam filter. Indicates if this contact should retrieve advertising.
     */
    NoMailing?: boolean;
    /**
     * Contact kana name, used in Japanese versions only
     */
    Kananame?: string;
    /**
     * STOP flag
     */
    Xstop?: boolean;
    /**
     * The number of active interests.
     */
    ActiveInterests?: number;
    /**
     * Group id of original owning associate, semantics like appnt.grp_id
     */
    GroupId?: number;
    /**
     * Active status monitor identity with the lowest rank for contact
     */
    ActiveStatusMonitorId?: number;
    /**
     *
     * Use MDO List name "associate" to get list items.
     */
    SupportAssociate?: Associate;
    /**
     *
     * Use MDO List name "ticketpriority" to get list items.
     */
    TicketPriority?: TicketPriority;
    /**
     * customerlanguage
     */
    CustomerLanguage?: CustomerLanguage;
    /**
     * If nonzero, then this contact is 'deleted' and should generally not be shown
     */
    Deleted?: number;
    /**
     * Integration agent (eJournal)
     */
    DbiAgentId?: number;
    /**
     * Last external syncronization.
     */
    DbiLastSyncronized?: Date;
    /**
     * The primary key for the integrated entry in the external datasource.
     */
    DbiKey?: string;
    /**
     * When the entry was last modified.
     */
    DbiLastModified?: Date;
    /**
     *
     */
    SupportPerson?: Person;
    /**
     *
     */
    Address?: Address;
    /**
     * How did we get this contact? For future integration needs
     */
    Source?: number;
    /**
     * The number of active erp links
     */
    ActiveErpLinks?: number;
    /**
     * Email addresses with a positive bounce counter.
     */
    BounceEmails?: string[];
    /**
     * Web domains for this contact, ordered in array by rank
     */
    Domains?: string[];
    /**
     * Dictionary of user defined field data.
     * The key string is the ProgId of the UdefField, or if the ProgId is empty it is a string of the format "SuperOffice:[UdefFieldIdentity]", e.g. "SuperOffice:1234"
     */
    UserDefinedFields?: StringDictionary;
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
}
/**
 * This entity supports Soft Delete. Call this method to Undelete a previously soft-deleted record
 */
export interface Contact_UndeleteRequest {
    /**
     * The primary key of the entity to undelete
     */
    Id: number;
}
/**
 * Returns an array of all the contact persons for the company card.
 * Returns Person[]
 */
export interface Contact_GetPersonsRequest {
    /**
     *
     */
    ContactId: number;
}
/**
 * Returns the contact with all the contact persons belonging to the contact
 * Returns ContactEntity
 */
export interface Contact_GetContactWithPersonsRequest {
    /**
     * The id of the contact.
     */
    ContactId: number;
}
/**
 * Gets the contact belonging to the currently logged on user.
 * Returns ContactEntity
 */
export interface Contact_GetMyContactRequest {
}
/**
 * Returns all data needed to display the logged on person's business card. That is company, person, and company interest data.
 * Returns ContactEntity
 */
export interface Contact_GetMyBizCardRequest {
}
/**
 * Change country regenerates the default values and localized information such as phone number and address format
 * Returns ContactEntity
 */
export interface Contact_ChangeCountryRequest {
    /**
     *
     */
    ContactEntity: ContactEntity;
    /**
     * The country to switch to
     */
    ToCountryId: number;
}
/**
 * Gets the contact's localized address.
 * Returns Address
 */
export interface Contact_GetAddressRequest {
    /**
     * The contact id
     */
    ContactId: number;
}
/**
 * Gets the contact's localized address.
 * Returns Address
 */
export interface Contact_GetAddressByCountryRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     *
     */
    CountryId: number;
}
/**
 * Add a person to the given contact
 * Returns PersonEntity
 */
export interface Contact_AddPersonRequest {
    /**
     * Contact to add person to
     */
    ContactId: number;
    /**
     * Person object to add
     */
    NewPersonEntity: PersonEntity;
}
/**
 * Get duplicates (exact or similar in the database) based on the name
 * Returns DuplicateEntry[]
 */
export interface Contact_GetDuplicatesRequest {
    /**
     * Name used for lookup
     */
    Name: string;
}
/**
 * Creates a new contact based on external duplicate
 * Returns number
 */
export interface Contact_CreateNewEntryRequest {
    /**
     * The duplicate to create a new entry based upon
     */
    Duplicate: DuplicateEntry;
}
/**
 * Retrieve all available duplicate rules for contact
 * Returns DuplicateRule[]
 */
export interface Contact_GetDuplicateRulesRequest {
}
/**
 * Set which duplicate rules should be active or not
 */
export interface Contact_SetDuplicateRulesStatusRequest {
    /**
     * Duplicate rules to update active status for
     */
    Rules: DuplicateRule[];
}
/**
 * Merge two contacts. The destination contact will remain.
 */
export interface Contact_MergeRequest {
    /**
     * Source contact to merge from. This contact will disappear after the merge.
     */
    SourceContactId: number;
    /**
     * Destination contact to merge into
     */
    DestinationContactId: number;
    /**
     * Persons with identical names will be merged
     */
    MergeIdenticalPersons: boolean;
    /**
     * If true, empty fields on destination will be replaced by values from source.
     */
    ReplaceEmptyFieldsOnDestination: boolean;
}
/**
 * Copy a contact. Activities and related data will be ignored
 * Returns number
 */
export interface Contact_CopyRequest {
    /**
     * The id of the contact to copy
     */
    SourceContactId: number;
    /**
     * The name of the destination contact
     */
    DestinationContactName: string;
    /**
     * The department of the destination contact
     */
    DestinationContactDepartment: string;
    /**
     * If true, persons will be copied from source contact
     */
    CopyPersons: boolean;
}
/**
 * Get duplicates based on the contact name and department
 * Returns DuplicateEntry[]
 */
export interface Contact_GetNameDepartmentDuplicatesRequest {
    /**
     * Name used for lookup
     */
    Name: string;
    /**
     * Department used for lookup (if any)
     */
    Department: string;
}
/**
 * Checks if the number is unique or required.  The setting is configured from admin under system options.
 * Returns boolean
 */
export interface Contact_IsNumberValidRequest {
    /**
     * Primary key
     */
    ContactId: number;
    /**
     * Number field value to check.
     */
    Number: string;
}
/**
 * Get the associated billing and invoice quote version addresses. These addresses might be address on the contact, or a custom address.
 * Returns Address[]
 */
export interface Contact_GetQuoteVersionAddressesRequest {
    /**
     * The version to get the addresses for.
     */
    QuoteVersionId: number;
}
/**
 * Save a custom quote version address.
 * Returns Address
 */
export interface Contact_SaveQuoteVersionAddressRequest {
    /**
     * The version to save the address on.
     */
    QuoteVersionId: number;
    /**
     * The address to save on the quote version.
     */
    Address: Address;
    /**
     * Should be either QuoteBillingAddress or QuoteShippingAddress
     */
    AddressType: enums.AddressType;
    /**
     * The country for the custom address
     */
    CountryId: number;
}
/**
 * Trigger deletion of contacts (companies) that has been (soft) deleted and have timed out the expiry period (the SoftDeleteRetention preference).
 */
export interface Contact_DeleteExpiredRequest {
}
/**
 * Get summary of contact and its recent activity.
 * Returns ContactSummary
 */
export interface Contact_GetContactSummaryRequest {
    /**
     * The contact id to summarize.
     */
    ContactId: number;
    /**
     * Max number of items to include in summary lists.
     */
    Limit: number;
}
/**
 * Check that entity is ready for saving, return error messages by field.
 * Returns StringDictionary
 */
export interface Contact_ValidateContactEntityRequest {
    /**
     * Entity to be checked for errors.
     */
    ContactEntity: ContactEntity;
}
/**
 * Getting the contacts where the user currently logged in is set as contact owner.
 * Returns Contact[]
 */
export interface Contact_GetMyContactsRequest {
}
/**
 * Method that returns a set of initial contacts. This could be the contacts in a favorites selection, the history list, the diary, or from all sources. If retrieved from the diary it will get appointments for the current and the next day.
 * Returns Contact[]
 */
export interface Contact_GetMyRecentContactsRequest {
    /**
     * The source where the contacts are retrieved from (Favorites, History, Diary)
     */
    SourceType: enums.ContactSourceType;
}
/**
 * Summary of contact with recent activities, chats, and requests included.
 */
export interface ContactSummary {
    /**
     * Simple Contact data.
     */
    Contact?: Contact;
    /**
     * Recent tickets on contact
     */
    Tickets?: TicketSummaryItem[];
    /**
     * Recent follow-ups on contact
     */
    Followups?: ActivitySummaryItem[];
    /**
     * Recent documents on contact
     */
    Documents?: ActivitySummaryItem[];
    /**
     * Recent sales on contact
     */
    Sales?: SaleSummaryItem[];
    /**
     * Recent chats with contact
     */
    Chats?: ChatSummaryItem[];
}
/**
 * Contact preview
 */
export interface PreviewContact {
    /**
     * Primary key
     */
    ContactId?: number;
    /**
     * Contact name
     */
    Name?: string;
    /**
     * Department
     */
    Department?: string;
    /**
     * Country
     */
    CountryId?: number;
    /**
     * Alphanumeric user field
     */
    Number2?: string;
    /**
     * The contacts phone
     */
    DirectPhone?: string;
    /**
     * The internet address to this contact
     */
    URL?: string;
    /**
     * The contact email address
     */
    EmailAddress?: string;
    /**
     * The business list item name
     */
    BusinessName?: string;
    /**
     * The category list item name
     */
    CategoryName?: string;
    /**
     * The associate's culture formatted fullname (firstname, middleName and lastname)
     */
    AssociateFullName?: string;
    /**
     * Contact address as a list of LocalizedFieldList objects. Used to store localized information such as formatted address data. Suitable for passing to an address control for display.
     */
    Address?: Address;
}
/**
 * Get a contact from its ID
 * Returns PreviewContact
 */
export interface Contact_GetPreviewContactRequest {
    /**
     * Contact ID
     */
    ContactId: number;
}
/**
 * Consent information for a give person. Consents are for a particular Purpose, and may be withdrawn (see LegalBase).
 */
export interface ConsentInfo extends Carrier {
    /**
     * Primary key
     */
    ConsentPersonId?: number;
    /**
     * Comment regarding this specific consent
     */
    Comment?: string;
    /**
     * When this consent record was created
     */
    Registered?: Date;
    /**
     * The ID of the associate who created this record
     */
    RegisteredAssociateId?: number;
    /**
     * When this consent record was last updated
     */
    Updated?: Date;
    /**
     * The ID of the associate who last updated this record
     */
    UpdatedAssociateId?: number;
    /**
     * Primary key for the LegalBase associated with this consent
     */
    LegalBaseId?: number;
    /**
     * Key for the LegalBase associated with this consent
     */
    LegalBaseKey?: string;
    /**
     * Name of the LegalBase associated with this consent
     */
    LegalBaseName?: string;
    /**
     * Primary key for the ConsentPurpose associated with this consent
     */
    ConsentPurposeId?: number;
    /**
     * Key of the ConsentPurpose associated with this consent
     */
    ConsentPurposeKey?: string;
    /**
     * Name of the ConsentPurpose associated with this consent
     */
    ConsentPurposeName?: string;
    /**
     * Primary key for the ConsentSource associated with this consent
     */
    ConsentSourceId?: number;
    /**
     * Key of the ConsentSource associated with this consent
     */
    ConsentSourceKey?: string;
    /**
     * Name of the ConsentSource associated with this consent
     */
    ConsentSourceName?: string;
}
/**
 *
 */
export interface ConsentPerson extends Carrier {
    /**
     * ConsentPerson ID
     */
    ConsentPersonId?: number;
    /**
     * The consent source
     */
    ConsentSource?: ConsentSource;
    /**
     * The legal base
     */
    LegalBase?: LegalBase;
    /**
     * Person ID
     */
    PersonId?: number;
    /**
     * The consent purpose
     */
    ConsentPurpose?: ConsentPurpose;
    /**
     * Comment regarding this specific consent
     */
    Comment?: string;
}
/**
 *
 */
export interface Person extends Carrier {
    /**
     * The position. This is a predefined SuperOffice value, different from Title
     */
    Position?: string;
    /**
     * Primary key
     */
    PersonId?: number;
    /**
     * e.g. Mrs   sex_title
     */
    Mrmrs?: string;
    /**
     * First name
     */
    Firstname?: string;
    /**
     * Last name
     */
    Lastname?: string;
    /**
     * Middle name or 'van' etc.
     */
    MiddleName?: string;
    /**
     * Title
     */
    Title?: string;
    /**
     * Info text/description on person.
     */
    Description?: string;
    /**
     * First email on contact person.
     */
    Email?: string;
    /**
     * Get the persons full name (internal name used in clients for employees).
     */
    FullName?: string;
    /**
     * Returns the direct phone that belong to the contact person.
     */
    DirectPhone?: string;
    /**
     * Get formal name for a person, as used in labels. (Full name + person title + academic title)
     */
    FormalName?: string;
    /**
     * Country
     */
    CountryId?: number;
    /**
     * Owning contact ID
     */
    ContactId?: number;
    /**
     * The persons company name
     */
    ContactName?: string;
    /**
     * 1 = the user is retired and should have no rights, not appear in lists, etc.
     */
    Retired?: number;
    /**
     * Display sort sequence for default sort order
     */
    Rank?: number;
    /**
     * Number of records in pintr table; select count(*) from pintr pi where pi.person_id = this.person_id == activeInterests is always true
     */
    ActiveInterests?: number;
    /**
     * The persons contact department
     */
    ContactDepartment?: string;
    /**
     * The persons contact country id
     */
    ContactCountryId?: number;
    /**
     * The persons contact organization number
     */
    ContactOrgNr?: string;
    /**
     * Returns the fax phone that belong to the contact person.
     */
    FaxPhone?: string;
    /**
     * Returns the mobile phone that belong to the contact person.
     */
    MobilePhone?: string;
    /**
     * Returns the direct phone that belong to the persons contact.
     */
    ContactPhone?: string;
    /**
     * Name of the person's owner
     */
    AssociateName?: string;
    /**
     * Id of the item's owner (Associate id)
     */
    AssociateId?: number;
    /**
     * If 1, use person's address for mailing instead of company address
     */
    UsePersonAddress?: boolean;
    /**
     * Actual phone number as eneterd by the user
     */
    ContactFax?: string;
    /**
     * Kana first name, used in Japanese versions only
     */
    Kanafname?: string;
    /**
     * Kana last name, used in Japanese versions only
     */
    Kanalname?: string;
    /**
     * Postal address, used in Japanese versions only
     */
    Post1?: string;
    /**
     * Postal address, used in Japanese versions only
     */
    Post2?: string;
    /**
     * Postal address, used in Japanese versions only
     */
    Post3?: string;
    /**
     * E-mail description
     */
    EmailName?: string;
    /**
     * Company full name + department
     */
    ContactFullName?: string;
    /**
     * How many active ERP links are there for this person?
     */
    ActiveErpLinks?: number;
    /**
     * Ticket priority ID
     */
    TicketPriorityId?: number;
    /**
     * Support priority ID
     */
    SupportLanguageId?: number;
    /**
     * Our support contact for this person
     */
    SupportAssociateId?: number;
    /**
     * The category list item name
     */
    CategoryName?: string;
}
/**
 * The Person Service. The service implements all services working with the Person object.
 */
export interface PersonEntity extends Carrier {
    /**
     * Primary key
     */
    PersonId?: number;
    /**
     * First name
     */
    Firstname?: string;
    /**
     * Middle name or 'van' etc.
     */
    MiddleName?: string;
    /**
     * Last name
     */
    Lastname?: string;
    /**
     * e.g. Mrs   sex_title
     * Use MDO List name "mrmrs" to get list items.
     */
    Mrmrs?: string;
    /**
     * Title
     */
    Title?: string;
    /**
     * Last updated date
     */
    UpdatedDate?: Date;
    /**
     * Registered date
     */
    CreatedDate?: Date;
    /**
     * The Person birth date as UTC Date. Year 1 = Null. Year 2 = unknown year.
     */
    BirthDate?: Date;
    /**
     * The user that created the person object
     */
    CreatedBy?: Associate;
    /**
     * A collection of the person's emails
     */
    Emails?: EntityElement[];
    /**
     * The actual text, max 2047 significant characters even though it is stored as a larger data type on some databases
     */
    Description?: string;
    /**
     * Checks if the person object is an associate. The property is read-only.
     */
    IsAssociate?: boolean;
    /**
     * Returns a collection of phone numbers that belong to the contact person.
     */
    PrivatePhones?: EntityElement[];
    /**
     * Returns a collection of fax numbers that belong to the contact person.
     */
    Faxes?: EntityElement[];
    /**
     * Returns a collection of mobile phone numbers that belong to the contact person.
     */
    MobilePhones?: EntityElement[];
    /**
     * Returns a collection of office phone numbers that belong to the contact person.
     */
    OfficePhones?: EntityElement[];
    /**
     * Returns a collection of pagers that belong to the contact person.
     */
    OtherPhones?: EntityElement[];
    /**
     * The position. This is a predefined SuperOffice value, different from Title
     * Use MDO List name "perspos" to get list items.
     */
    Position?: Position;
    /**
     * The person that last updated the person object
     */
    UpdatedBy?: Associate;
    /**
     * The contact the contact person is registered on. This is required unless the 'MandatoryContactOnPerson' preference is set.
     * Use MDO List name "contact_new" to get list items.
     */
    Contact?: Contact;
    /**
     * The country this contact person is located in.
     * Use MDO List name "country" to get list items.
     */
    Country?: Country;
    /**
     * The person's available and selected interests.
     * Use MDO List name "persint" to get list items.
     */
    Interests?: SelectableMDOListItem[];
    /**
     * Alphanumeric user field
     */
    PersonNumber?: string;
    /**
     * The person's full name localized to the current culture/country.  (internal name used in clients for employees)
     */
    FullName?: string;
    /**
     * Spam filter. Indicates if this person should retrieve advertising.
     */
    NoMailing?: boolean;
    /**
     * True if the person's address should be used as mailing address, instead of the contact's address.
     */
    UsePersonAddress?: boolean;
    /**
     * True if the user is retired and should have no rights, not appear in lists, etc.
     */
    Retired?: boolean;
    /**
     * The urls related to this person.
     */
    Urls?: EntityElement[];
    /**
     * Get formal name for a person, as used in labels. (Full name + person title + academic title)
     */
    FormalName?: string;
    /**
     * Structure holding formatted address data. The layout of the array structure indicates the layout of the localized address.
     */
    Address?: Address;
    /**
     * Postal address, used in Japanese versions only
     */
    Post3?: string;
    /**
     * Postal address, used in Japanese versions only
     */
    Post2?: string;
    /**
     * Postal address, used in Japanese versions only
     */
    Post1?: string;
    /**
     * Kana last name, used in Japanese versions only
     */
    Kanalname?: string;
    /**
     * Kana first name, used in Japanese versions only
     */
    Kanafname?: string;
    /**
     * The associate corresponding to this person. Will be empty if the person is not a user (internal associate user, external user).
     */
    CorrespondingAssociate?: Associate;
    /**
     * Person's category. Usually null. Refer to the Contact.Category instead.  Intended for use when individual persons are created. (i.e. when Person.Contact is blank)
     * Use MDO List name "category" to get list items.
     */
    Category?: Category;
    /**
     * Person's business - usually blank. Use Contact.Business instead. Intended for use when individual persons are created. (i.e. when Person.Contact is blank)
     * Use MDO List name "business" to get list items.
     */
    Business?: Business;
    /**
     * The associate owning this person (similar to contact.Associate) - usually blank. Use the Person.Contact.Associate instead.  Intended for use when individual persons are created (i.e. when Person.Contact is blank)
     * Use MDO List name "associate" to get list items.
     */
    Associate?: Associate;
    /**
     * Academic title, populated from Salutation list but can be overwritten with anything at all
     * Use MDO List name "salutation" to get list items.
     */
    Salutation?: string;
    /**
     * The number of active interests.
     */
    ActiveInterests?: number;
    /**
     *
     * Use MDO List name "associate" to get list items.
     */
    SupportAssociate?: Associate;
    /**
     *
     * Use MDO List name "ticketpriority" to get list items.
     */
    TicketPriority?: TicketPriority;
    /**
     *
     * Use MDO List name "customerlanguage" to get list items.
     */
    CustomerLanguage?: CustomerLanguage;
    /**
     * Integration agent (eJournal)
     */
    DbiAgentId?: number;
    /**
     * The primary key for the integrated entry in the external datasource.
     */
    DbiKey?: string;
    /**
     * When the entry was last modified.
     */
    DbiLastModified?: Date;
    /**
     * Last external syncronization.
     */
    DbiLastSyncronized?: Date;
    /**
     * Has information on username/password been sent (ejournal)
     */
    SentInfo?: number;
    /**
     * Should tickets related to the company be shown to this person
     */
    ShowContactTickets?: number;
    /**
     * Information about the user if this person is a user.  If IsAssociate (e.g. is user is true) the UserInfo will be provided.
     */
    UserInfo?: UserInfo;
    /**
     *
     */
    ChatEmails?: EntityElement[];
    /**
     *
     */
    InternetPhones?: EntityElement[];
    /**
     * How did we get this person? For future integration needs
     */
    Source?: number;
    /**
     * How many active ERP links are there for this person?
     */
    ActiveErpLinks?: number;
    /**
     * The person's available and selected shipment types.
     */
    ShipmentTypes?: SelectableMDOListItem[];
    /**
     * The person's available consent information. Missing consents are not deleted. To remove a consent, mark its legalbase as 'WITHDRAWN'
     */
    Consents?: ConsentInfo[];
    /**
     * Email addresses with a positive bounce counter.
     */
    BounceEmails?: string[];
    /**
     * Active status monitor identity with the lowest rank for person
     */
    ActiveStatusMonitorId?: number;
    /**
     * Dictionary of user defined field data.
     * The key string is the ProgId of the UdefField, or if the ProgId is empty it is a string of the format "SuperOffice:[UdefFieldIdentity]", e.g. "SuperOffice:1234"
     */
    UserDefinedFields?: StringDictionary;
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
}
/**
 * This entity supports Soft Delete. Call this method to Undelete a previously soft-deleted record
 */
export interface Person_UndeleteRequest {
    /**
     * The primary key of the entity to undelete
     */
    Id: number;
}
/**
 * Gets the person info belonging to the currently logged on user.
 * Returns PersonEntity
 */
export interface Person_GetMyPersonRequest {
}
/**
 * Returns the sales representative for an external user. If this method is accessed with anonymous authentication the external user is recognized by contact and name, or by email, or phone number. If the external user is recognized as an CRM5 user (internal or external) the input fields can be left blank.
 * Returns PersonEntity
 */
export interface Person_GetSalesRepRequest {
    /**
     * The company name of the person requesting his sales representative. May be empty if email or phone is provided.
     */
    ContactName: string;
    /**
     * The firstname of the person requesting his sales representative. May be empty if email or phone is provided.
     */
    PersonFirstname: string;
    /**
     * The lastname of the person requesting his sales representative. May be empty if email or phone is provided.
     */
    PersonLastname: string;
    /**
     * The email address of the person requesting his sales representative. May be empty if phone, or contact and person name is provided.
     */
    EmailAddress: string;
    /**
     * The phone number of the person requesting his sales representative. May be empty if email, or contact and person name is provided.
     */
    PhoneNumber: string;
}
/**
 * Returning all phones that belong to a person, ordered by the phone type.
 * Returns EntityElement[]
 */
export interface Person_GetPhonesRequest {
    /**
     * The person id
     */
    PersonId: number;
}
/**
 * Change country regenerates the default values and localized information such as phone number and address format for this entity.
 * Returns PersonEntity
 */
export interface Person_ChangeCountryRequest {
    /**
     * The PersonEntity to change country on
     */
    PersonEntity: PersonEntity;
    /**
     * The country to switch to
     */
    ToCountryId: number;
}
/**
 * Gets the person's localized address.
 * Returns Address
 */
export interface Person_GetAddressRequest {
    /**
     * The person id
     */
    PersonId: number;
}
/**
 * Gets the person's localized address.
 * Returns Address
 */
export interface Person_GetAddressByCountryRequest {
    /**
     * The person id
     */
    PersonId: number;
    /**
     *
     */
    CountryId: number;
}
/**
 * Returns the person image that is displayed in the CRM application.
 * Returns Blob
 */
export interface Person_GetPersonImageRequest {
    /**
     * The person id of the person the image belongs to.
     */
    PersonId: number;
}
/**
 * Stores the person image that is displayed in the CRM application.
 */
export interface Person_SetPersonImageRequest {
    /**
     * The person id of the person the image belongs to.
     */
    PersonId: number;
    /**
     * The image that is stored on the person (System.Drawing.Image)
     */
    Image: ArrayBuffer | string;
}
/**
 * Creates a PersonEntity with default values based on the contactId.
 * Returns PersonEntity
 */
export interface Person_CreateDefaultByContactIdRequest {
    /**
     * Contact id of the person
     */
    ContactId: number;
}
/**
 * Move a person to a specified contact. You must specify the date after which activities will be moved along with the person.
 */
export interface Person_MoveRequest {
    /**
     * The identifier for the person
     */
    PersonId: number;
    /**
     * The identifier for the contact which the person will be moved to
     */
    DestinationContactId: number;
    /**
     * Move activites after this date. Activities before this date are left alone.
     */
    MoveAfterDate: Date;
}
/**
 * Merge two persons. The destination person will remain. You must specify the date after which activities will be moved along with the person.
 */
export interface Person_MergeRequest {
    /**
     * The identifier for the person which will be merged into the destination person. The source person is deleted/marked retired after the merge.
     */
    SourcePersonId: number;
    /**
     * The identifier for the person which will remain after the merge. The target person is updated.
     */
    DestinationPersonId: number;
    /**
     * Merge activites after this date. Activities before this date are left alone.
     */
    MoveAfterDate: Date;
    /**
     * If true, the source person will be deleted after the merge. If false, it will have its retired flag set
     */
    DeleteSource: boolean;
    /**
     * If true, empty fields on destination will be replaced by values from source.
     */
    ReplaceEmptyFieldsOnDestination: boolean;
}
/**
 * Creates a PersonEntity with default values based on the contactId and credentials.
 * Returns PersonEntity
 */
export interface Person_CreateDefaultFromCredentialRequest {
    /**
     * Contact id of the person
     */
    ContactId: number;
    /**
     * Type of credentials, corresponding to name of plugin and type in the credentials table.
     */
    CredentialType: string;
    /**
     * This is the actuall value of the credentials.  This will typically be the password or teh users SID in active directory
     */
    CredentialValue: string;
    /**
     * The value displayed to the user. this will typically be the users login name in active directory.
     */
    CredentialDisplayValue: string;
}
/**
 * Checks if the number is unique or required.  The setting is configured from admin under system options.
 * Returns boolean
 */
export interface Person_IsNumberValidRequest {
    /**
     *
     */
    ContactId: number;
    /**
     * Number to check.
     */
    Number: string;
}
/**
 * Set a specified type of consent on the person.
 */
export interface Person_SetConsentRequest {
    /**
     * The person id
     */
    PersonId: number;
    /**
     * The Key of the purpose this affects. e.g. 'STORE' or 'EMARKETING'.
     */
    Purpose: string;
    /**
     * The Key of the source of this consent. e.g. 'USER', 'WEBFORM' or 'API'.
     */
    Source: string;
    /**
     * The Key of the legal base for this consent. e.g. '61A', '61B', '61F'
     */
    LegalBase: string;
    /**
     * A comment regarding this consent. May be null or empty.
     */
    Comment: string;
}
/**
 * Turn off consent for a specified person and purpose.
 */
export interface Person_RemoveConsentRequest {
    /**
     * The person id
     */
    PersonId: number;
    /**
     * The key of the purpose to remove. (e.g. 'STORE' or 'EMARKETING')
     */
    Purpose: string;
}
/**
 * Check if consent has been given by a specified person, for a specific purpose. Withdraw consents return FALSE.
 * Returns boolean
 */
export interface Person_HasConsentRequest {
    /**
     * The person id
     */
    PersonId: number;
    /**
     * The key of the purpose to check. (e.g. 'STORE' or 'EMARKETING')
     */
    Purpose: string;
}
/**
 * Get all consent information for a given person. May include withdrawn consents (check
 * Returns ConsentInfo[]
 */
export interface Person_GetConsentInfosRequest {
    /**
     * The person id to get consents for
     */
    PersonId: number;
}
/**
 * Send confirmation email to the provided person, email address (id), using the document template
 */
export interface Person_SendConsentConfirmationEmailRequest {
    /**
     * The person id
     */
    PersonId: number;
    /**
     * The email address to send to.
     */
    EmailAddress: string;
    /**
     * The id of the email template (doctmpl_id)
     */
    EmailTemplateId: number;
    /**
     * The id of the culture (LCID)
     */
    CultureLcidId: number;
    /**
     * Optional email subject
     */
    Subject: string;
}
/**
 * Get a person from the provided information. If the person does not exist, it will be created on demand.
 * Returns ResolvedPerson
 */
export interface Person_ResolvePersonFromInfoRequest {
    /**
     * The contact Id of the contact which the person belongs to. Cannot be 0.
     */
    ContactId: number;
    /**
     * The full name of the person to be resolved. Optional.
     */
    PersonName: string;
    /**
     * Phone numbers registered on the person. Optional.
     */
    PhoneNumbers: string[];
    /**
     * Email-addresses registered on the person. Optional.
     */
    Emails: string[];
}
/**
 * Sets the primary email address on person, possibly re-ranking email addresses accordingly.
 */
export interface Person_AddEmailAddressToPersonRequest {
    /**
     * Person id of the person
     */
    PersonId: number;
    /**
     * The email address to set as primary email address
     */
    EmailAddress: string;
    /**
     * True if the address shall be primary email address (have rank == 1)
     */
    SetAsPrimaryEmail: boolean;
}
/**
 * Create a temporary key in the database from the given parameters and return the key string. Used for temporary keys for accessing customer centric functionality, such as UpdateSubscriptions.
 * Returns string
 */
export interface Person_CreateTemporaryKeyRequest {
    /**
     * The domain this key is for
     */
    Domain: enums.TemporaryKeyDomain;
    /**
     * The primary key of the entity this is for. Depends on domain.
     */
    TargetId: number;
    /**
     * The person this key is for. May be null.
     */
    PersonId: number;
    /**
     * When the key will expire (servers local time)
     */
    Expires: Date;
}
/**
 * Check a temporary key for validity, and in case it is valid, return its domain, targetId and personId
 * Returns TemporaryKeyInfo
 */
export interface Person_CheckTemporaryKeyRequest {
    /**
     * The base64 encoded key value, as returned by CreateTemporaryKey
     */
    TemporaryKey: string;
}
/**
 * Delete all temporary keys for a given domain and person
 */
export interface Person_DeleteTemporaryKeysOfDomainRequest {
    /**
     * The domain type to delete
     */
    Domain: enums.TemporaryKeyDomain;
    /**
     * The person for which to delete the keys
     */
    PersonId: number;
}
/**
 * Trigger deletion of persons that has been (soft) deleted and have timed out the expiry period (the SoftDeleteRetention preference).
 */
export interface Person_DeleteExpiredRequest {
}
/**
 * Get summary of person and recent activity.
 * Returns PersonSummary
 */
export interface Person_GetPersonSummaryRequest {
    /**
     * The person id to summarize.
     */
    PersonId: number;
    /**
     * Max number of items to include in summary lists.
     */
    Limit: number;
}
/**
 * Add a bounce count on the email address if it exists
 */
export interface Person_AddBounceRequest {
    /**
     * The email address which we want to add a bounce count to
     */
    EmailAddress: string;
}
/**
 * Check that entity is ready for saving, return error messages by field.
 * Returns StringDictionary
 */
export interface Person_ValidatePersonEntityRequest {
    /**
     * Entity to be checked for errors.
     */
    PersonEntity: PersonEntity;
}
/**
 * Add a number of bounce counts on the email address if it exists
 */
export interface Person_AddBounceWithCountRequest {
    /**
     * The email address which we want to add bounce counts to
     */
    EmailAddress: string;
    /**
     * The number of bounce counts to add
     */
    Counts: number;
}
/**
 * Get the best language for this person on this template
 * Returns string
 */
export interface Person_GetBestSoLanguageForTemplateRequest {
    /**
     * The id of the person
     */
    PersonId: number;
    /**
     * The id of the template to find languages on
     */
    TemplateId: number;
}
/**
 * Add a number of bounce counts on the email address if it exists, and with possible bounce code and reason
 */
export interface Person_AddBounceWithDetailsRequest {
    /**
     * The email address which we want to add bounce counts to
     */
    EmailAddress: string;
    /**
     * The number of bounce counts to add
     */
    Counts: number;
    /**
     * A numeric code representing the bounce reason
     */
    Code: number;
    /**
     * A textual tag representing the bounce reason
     */
    Reason: string;
}
/**
 * Get the image for a set of persons scaled to a specific size. Returned images are in PNG format.
 * Returns PersonImage[]
 */
export interface Person_GetPersonImagesRequest {
    /**
     * List of persons to get images for.
     */
    PersonIds: number[];
    /**
     * Returned images are scaled to this width
     */
    ScaledWidth: number;
    /**
     * Returned images are scaled to this height
     */
    ScaledHeight: number;
}
/**
 * Creates a Customer Centre User (UserCandidate) for a given Contact (personId) with the supplied parameters. If the Customer Centre User already exists for a given Contact, the user is updated with the supplied parameters.
 * Returns UserCandidate
 */
export interface Person_CreateOrUpdateUserCandidateRequest {
    /**
     * Person to create UserCandidate for.
     */
    PersonId: number;
    /**
     * Desired username. Username must be unique. If the username is not unique, method will throw an error.
     */
    Username: string;
    /**
     * Determines if Custom Center User has access to all requests created for all Contacts in the company.
     */
    AccessAllRequests: boolean;
}
/**
 * Gets user candidate linked to a person.
 * Returns UserCandidate
 */
export interface Person_GetUserCandidateByPersonRequest {
    /**
     * Person related to requested UserCandidate.
     */
    PersonId: number;
}
/**
 * Gets a parsed Customer Centre password reply template for a particular customer
 * Returns ReplyTemplateParsed
 */
export interface Person_GetCustomerCentrePasswordReplyTemplateRequest {
    /**
     * Person/customer id to get the template for.
     */
    PersonId: number;
}
/**
 * Inserts into outbox an email with specified details.
 */
export interface Person_SendEmailRequest {
    /**
     * Sender's email address.
     */
    From: string;
    /**
     * Recipient's email address.
     */
    To: string;
    /**
     * Email's subject.
     */
    Subject: string;
    /**
     * Email's plain body.
     */
    PlainBody: string;
    /**
     * Email's html body.
     */
    HtmlBody: string;
    /**
     * Ids of email's attachments.
     */
    AttachmentIds: number[];
}
/**
 * Scaled person image
 */
export interface PersonImage {
    /**
     * Primary key
     */
    PersonId?: number;
    /**
     * Image data in PNG format.
     */
    ImageData?: ArrayBuffer | string;
}
/**
 * Returns all the persons belonging to a contact.
 * Returns Person[]
 */
export interface Person_GetPersonsFromContactRequest {
    /**
     * The project id
     */
    ContactId: number;
}
/**
 * Returns all the persons belonging to a project.
 * Returns Person[]
 */
export interface Person_GetPersonsFromProjectRequest {
    /**
     * The project id
     */
    ProjectId: number;
}
/**
 * Gets the persons working in the same company as the logged on user.
 * Returns Person[]
 */
export interface Person_GetColleaguesRequest {
}
/**
 * Gets the persons working in a specific department in the same company as the logged on user. Departments can be retrieved with the PhoneList.DepartmentList service.
 * Returns Person[]
 */
export interface Person_GetColleaguesByDepartmentRequest {
    /**
     * The department id.
     */
    DepartmentId: number;
}
/**
 * Gets the persons working in the same company as the logged on user. The list of person could be retrieved from the history list, the diary view list, or from all sources.
 * Returns Person[]
 */
export interface Person_GetColleaguesBySourceRequest {
    /**
     * The “source” the colleagues should be retrieved from. <see cref="AssociateSourceType"/> for more information.
     */
    SourceType: enums.AssociateSourceType;
    /**
     *
     */
    Count: number;
}
/**
 * Get the owner of the logged in person.
 * Returns Person
 */
export interface Person_GetMyOwnerRequest {
}
/**
 * Get the owner of the person by id.
 * Returns Person
 */
export interface Person_GetOwnerOnPersonIdRequest {
    /**
     *
     */
    PersonId: number;
}
/**
 * Move one person up or down in the ranking in the Person Archive, if possible.<para/>The person record that has rank = 1 is the primary contact for a company, and is the one used in situations where no person has been explicitly chosen (such as in selections).<para/>This method corresponds to the move up/move down functions in the person archive in the contact panel.<para/>This method always affects two records.
 * Returns number
 */
export interface Person_ChangePersonRankRequest {
    /**
     * Primary key of person record to move up or down. You must have write access both to this record AND to whatever record is adjacent in the direction you want to move.
     */
    PersonId: number;
    /**
     * If true, the given person is moved to an earlier rank (lower numeric rank value, down to a limit of 1; up in the GUI if sorted by ascending rank). If false, movement is to later priority (higher numeric rank value).
     */
    MoveUp: boolean;
}
/**
 * Directly set the rank field of a person record, adjusting all other person records under the same contact as needed.<para/>This call may affect multiple records, potentially all person records belonging to one contact.<para/>You must have write access for to affected records for this method to succeed.
 * Returns boolean
 */
export interface Person_SetPersonRankRequest {
    /**
     * Id of person to change
     */
    PersonId: number;
    /**
     * Desired rank to set, legal values are from 1 to the number of person records on this contact. Out of range values will be moved to the closest valid value and processed.
     */
    DesiredRank: number;
}
/**
 * Nomralize the ranks for all persons that belong to a contact. This means that the persons will be sorted according to their current rank values, and the ranks will be made monotonically increasing from 1.
 * Returns boolean
 */
export interface Person_NormalizeRanksRequest {
    /**
     * Id of contact whose persons are to be rank normalized
     */
    ContactId: number;
}
/**
 * Summary of person, with recent activities, chats, and requests included.
 */
export interface PersonSummary {
    /**
     * Simple Person data.
     */
    Person?: Person;
    /**
     * Recent tickets on person
     */
    Tickets?: TicketSummaryItem[];
    /**
     * Recent follow-ups on person
     */
    Followups?: ActivitySummaryItem[];
    /**
     * Recent documents on person
     */
    Documents?: ActivitySummaryItem[];
    /**
     * Recent sales on person
     */
    Sales?: SaleSummaryItem[];
    /**
     * Recent chats with person
     */
    Chats?: ChatSummaryItem[];
}
/**
 * The Person Service. The service implements all services working with the Person object.
 */
export interface ResolvedPerson extends Carrier {
    /**
     * The resolved PersonEntity instance.
     */
    Person?: PersonEntity;
    /**
     * Indicates if the resolved person was created or not.
     */
    PersonCreated?: boolean;
}
/**
 * The fields returned when checking a temporary key
 */
export interface TemporaryKeyInfo extends Carrier {
    /**
     * The domain for this key. Unknown if key is not valid.
     */
    Domain?: enums.TemporaryKeyDomain;
    /**
     * The primary key of the entity this temporary key is for, dependent of dmain
     */
    TargetId?: number;
    /**
     * The person id this key is related to. May be null.
     */
    PersonId?: number;
    /**
     * Whether the key is expired or not.
     */
    IsExpired?: boolean;
}
/**
 *
 */
export interface Sale extends Carrier {
    /**
     * Contact name
     */
    ContactName?: string;
    /**
     * (expected / lost / won) sales date
     */
    SaleDate?: Date;
    /**
     * Primary key
     */
    SaleId?: number;
    /**
     * Actual probability, may differ from the one in the list
     */
    Probability?: number;
    /**
     * Sale heading (short description?)
     */
    Title?: string;
    /**
     * Total sale amount
     */
    Amount?: number;
    /**
     * Currency the sale was made in.
     */
    Currency?: string;
    /**
     * Project name
     */
    ProjectName?: string;
    /**
     * The sale's owner
     */
    AssociateFullName?: string;
    /**
     * The sales description
     */
    Description?: string;
    /**
     * The sale's status, indicating wether the sale is open, sold or lost.
     */
    Status?: enums.SaleStatus;
    /**
     * The weighted amount ( amount *  probability / 100)
     */
    WeightedAmount?: number;
    /**
     * Optional project reference
     */
    ProjectId?: number;
    /**
     * Earning as percent of total
     */
    EarningPercent?: number;
    /**
     * Earning on sale
     */
    Earning?: number;
    /**
     * Optional contact reference
     */
    ContactId?: number;
    /**
     * The sale's owner id
     */
    AssociateId?: number;
    /**
     * The sale's contact persons id
     */
    PersonId?: number;
    /**
     * The sale's type id
     */
    SaleTypeId?: number;
    /**
     * The sale's type name
     */
    SaleTypeName?: string;
    /**
     * The name of the person this sale belongs to.
     */
    PersonFullName?: string;
    /**
     * The Sale completed state. The completed state is either Started or Completed. NotStarted is treated as Started. The value maps to the Done database field.
     */
    Completed?: enums.ActivityStatus;
    /**
     * The number of active erp links
     */
    ActiveErpLinks?: number;
    /**
     * Next due date, this is a denormalization of 'closest future activity date, or most recent if no future activities'. Maintained by the system, but very convenient for searching.
     */
    NextDueDate?: Date;
    /**
     * Alphanumeric user field
     */
    Number?: string;
}
/**
 * The Sale Entity contains the sale amount, currency, and sale members. Sales are linked to contacts, persons, and/or projects.
 */
export interface SaleEntity extends Carrier {
    /**
     *
     */
    Appointment?: Appointment;
    /**
     * The sale owner
     * Use MDO List name "associate" to get list items.
     */
    Associate?: Associate;
    /**
     * Who updated the sale
     */
    UpdatedBy?: Associate;
    /**
     * Who created to sale
     */
    CreatedBy?: Associate;
    /**
     * The contact associated with the sale. It may also be 0 if no contact is associated with the sale.
     * Use MDO List name "contact" to get list items.
     */
    Contact?: Contact;
    /**
     * A sale may also be connected to a project, so you see the sale both on the company card, and on the project card. This does not mean that a project is required.
     * Use MDO List name "project" to get list items.
     */
    Project?: Project;
    /**
     * Text describing the sale
     */
    SaleText?: string;
    /**
     * A sale may also be connected to a person - this must be a contact person registered on the current contact. This does not mean that a person is required.
     * Use MDO List name "person" to get list items.
     */
    Person?: Person;
    /**
     * The currency the sale object was sold in
     * Use MDO List name "currency" to get list items.
     */
    Currency?: Currency;
    /**
     * List of all possible competitors.
     * Use MDO List name "comptr" to get list items.
     */
    Competitor?: Competitor;
    /**
     * List of who is to be credited for the sale.
     * Use MDO List name "credited" to get list items.
     */
    Credited?: Credited;
    /**
     * The sale rating
     * Use MDO List name "prob" to get list items.
     */
    Rating?: Rating;
    /**
     * The sale reason
     * Use MDO List name "reason" to get list items.
     */
    Reason?: Reason;
    /**
     * The sale source
     * Use MDO List name "source" to get list items.
     */
    Source?: Source;
    /**
     * The state of the Sale: Open / Sold / Lost / Stalled
     */
    Status?: enums.SaleStatus;
    /**
     * (expected / lost / won) sales date
     */
    Saledate?: Date;
    /**
     * Total sale amount
     */
    Amount?: number;
    /**
     * Primary key
     */
    SaleId?: number;
    /**
     * Earning on sale
     */
    Earning?: number;
    /**
     * Earning as percent of total
     */
    EarningPercent?: number;
    /**
     * Sale heading (short description?)
     */
    Heading?: string;
    /**
     * Alphanumeric user field
     */
    Number?: string;
    /**
     * Actual probability, may differ from the one in the list
     */
    Probability?: number;
    /**
     * Registered date
     */
    CreatedDate?: Date;
    /**
     * Last updated
     */
    UpdatedDate?: Date;
    /**
     * The Sale completed state. The completed state is either Started or Completed. NotStarted is treated as Started. The value maps to the Done database field.
     */
    Completed?: enums.ActivityStatus;
    /**
     * Number of active links to sale, document, appointment.
     */
    ActiveLinks?: number;
    /**
     * List of all elements linked to the sale.
     */
    Links?: Link[];
    /**
     * Next due date, this is a denormalization of 'closest future activity date, or most recent if no future activities'. Maintained by the system, but very convenient for searching.
     */
    NextDueDate?: Date;
    /**
     * The actual text, max 2047 significant characters even though it is stored as a larger data type on some databases
     */
    Postit?: string;
    /**
     *
     * Use MDO List name "saletype" to get list items.
     */
    SaleType?: SaleType;
    /**
     *
     * Use MDO List name "reasonsold" to get list items.
     */
    ReasonSold?: ReasonSold;
    /**
     *
     * Use MDO List name "reasonstalled" to get list items.
     */
    ReasonStalled?: ReasonStalled;
    /**
     * Date the sale is to be reopened; valid only for status=stalled. Not necessarily the same as the nextDueDate.
     */
    ReopenDate?: Date;
    /**
     *
     */
    SaleStakeholders?: SaleStakeholder[];
    /**
     * The number of active erp links
     */
    ActiveErpLinks?: number;
    /**
     * Dictionary of user defined field data.
     * The key string is the ProgId of the UdefField, or if the ProgId is empty it is a string of the format "SuperOffice:[UdefFieldIdentity]", e.g. "SuperOffice:1234"
     */
    UserDefinedFields?: StringDictionary;
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
    /**
     * Publish event date
     */
    PublishEventDate?: Date;
    /**
     * Publication valid to (inclusive)
     */
    PublishTo?: Date;
    /**
     * Publication valid from (inclusive)
     */
    PublishFrom?: Date;
    /**
     * Publication is published
     */
    IsPublished?: boolean;
    /**
     * The set of users or groups the record is visible for
     */
    VisibleFor?: VisibleFor[];
}
/**
 * Does this sale have a sale guide associated with its sale type?
 * Returns boolean
 */
export interface Sale_HasGuideRequest {
    /**
     * Sale id
     */
    SaleId: number;
}
/**
 * Gets the next due date for a sale. The next due date is the next future appointment that is not completed.
 * Returns Date
 */
export interface Sale_GetNextDueDateRequest {
    /**
     * Sale id
     */
    SaleId: number;
}
/**
 * Re-calculate all the next due dates
 */
export interface Sale_BatchUpdateNextDueDateRequest {
}
/**
 * Gets the next (not deleted) sale stage id if the current stage is deleted. If the current stage is not deleted, the CurrentStageId is returned
 * Returns number
 */
export interface Sale_GetNextSaleStageRequest {
    /**
     *
     */
    SaleId: number;
    /**
     *
     */
    IncludeCurrentStage: boolean;
}
/**
 *
 * Returns boolean
 */
export interface Sale_HasGuideActivitiesRequest {
    /**
     *
     */
    SaleId: number;
}
/**
 *
 * Returns boolean
 */
export interface Sale_OfferAutoNextStageOnApppointmentCompletedRequest {
    /**
     *
     */
    AppointmentId: number;
}
/**
 * Get the probability percentage for a given sale stage
 * Returns number
 */
export interface Sale_GetProbabilityFromStageRequest {
    /**
     * Probability list id
     */
    StageId: number;
}
/**
 * Checks if the number is unique or required.  The setting is configured from admin under system options.
 * Returns boolean
 */
export interface Sale_IsNumberValidRequest {
    /**
     * SaleId
     */
    ContactId: number;
    /**
     * Number value to check for uniqueness/required
     */
    Number: string;
}
/**
 *
 */
export interface Sale_AddSaleStakeholdersRequest {
    /**
     *
     */
    SaleId: number;
    /**
     *
     */
    SaleStakeholders: SaleStakeholder[];
}
/**
 *
 */
export interface Sale_DeleteSaleStakeholdersRequest {
    /**
     *
     */
    SaleStakeholderIds: number[];
}
/**
 *
 * Returns boolean
 */
export interface Sale_HasStakeholderSettingRequest {
    /**
     *
     */
    SaleId: number;
}
/**
 * Check that entity is ready for saving, return error messages by field.
 * Returns StringDictionary
 */
export interface Sale_ValidateSaleEntityRequest {
    /**
     * Entity to be checked for errors.
     */
    SaleEntity: SaleEntity;
}
/**
 * Returning the opportunities (open sales) belonging to the user currently logged on
 * Returns Sale[]
 */
export interface Sale_GetMyOpportunitiesRequest {
    /**
     * The number of sales that is returned. -1 returns all.
     */
    Count: number;
}
/**
 * Returns the latest sales (that are sold) limited by their amount. The result is sorted descending with the latest first. If the amount is -1, the amount restriction is omitted.
 * Returns Sale[]
 */
export interface Sale_GetRecentSalesRequest {
    /**
     * The amount limit in the local currency.
     */
    AmountLimit: number;
    /**
     * The maximum number of items to return. If -1 all are returned.
     */
    Count: number;
}
/**
 * Returns all open sales, sorted descending with the latest first.  If the weigthed amount is -1, the amount restriction is omitted.
 * Returns Sale[]
 */
export interface Sale_GetUpcomingSalesRequest {
    /**
     * The amount weighted by the probability that the sale is closed (amount * probability).
     */
    WeightedAmountLimit: number;
    /**
     * The maximum number of items to return. If -1 all are returned.
     */
    Count: number;
}
/**
 * Returns all sales within a time period. The sales array can be limited by amount and status.
 * Returns Sale[]
 */
export interface Sale_GetSalesByDateRequest {
    /**
     * The beginning of the time interval.
     */
    FromDate: Date;
    /**
     * The end of the time interval.
     */
    ToDate: Date;
    /**
     * The amount limit in the local currency.  -1 means no amount limit
     */
    AmountLimit: number;
    /**
     * The sale status (Lost, Open, Sold, Unknown). SaleStatus.Unknown means no status filtering.
     */
    Status: enums.SaleStatus;
}
/**
 * Returns all open sales for the contact provided.
 * Returns Sale[]
 */
export interface Sale_GetOpenSalesForContactRequest {
    /**
     * The ID of the contact whose sales we want.
     */
    ContactId: number;
}
/**
 * Change the status of one or more Sales to Sold. Note that this does not mark them as Completed.
 */
export interface Sale_SetAsSoldRequest {
    /**
     * Array of sale ids to be marked as lost. All the normal write access rules apply.
     */
    SaleIds: number[];
}
/**
 * Change the status of one or more sales to Lost. Note that this does not affect the Completed state of the sale.
 */
export interface Sale_SetAsLostRequest {
    /**
     * Array of sale ids to be marked as lost. All normal write access rules apply.
     */
    SaleIds: number[];
}
/**
 * Returns all sales for the contact provided.
 * Returns Sale[]
 */
export interface Sale_GetSalesFromContactRequest {
    /**
     * The ID of the contact whose sales we want.
     */
    ContactId: number;
    /**
     * If true, only get open sales.
     */
    OnlyOpenSales: boolean;
}
/**
 * Returns all sales for the person provided.
 * Returns Sale[]
 */
export interface Sale_GetSalesFromPersonRequest {
    /**
     * The ID of the person whose sales we want.
     */
    PersonId: number;
    /**
     * If true, only get open sales.
     */
    OnlyOpenSales: boolean;
}
/**
 *
 */
export interface SaleStakeholder extends Carrier {
    /**
     * Stakeholder role name
     */
    StakeholderRoleName?: string;
    /**
     * Optional comment text
     */
    Comment?: string;
    /**
     * Stakeholde role list id - Primary key
     */
    StakeholderRoleId?: number;
    /**
     * Country id - primary key
     */
    CountryId?: number;
    /**
     * Person id - Primary key
     */
    PersonId?: number;
    /**
     * E-mail description
     */
    EmailDescription?: string;
    /**
     * E-mail address id - Primary key
     */
    EmailId?: number;
    /**
     * E-mail address
     */
    EmailAddress?: string;
    /**
     * Primary key
     */
    PhoneId?: number;
    /**
     * Contact name
     */
    ContactName?: string;
    /**
     * Contact ID of person or contact who is the sale stakeholder
     */
    ContactId?: number;
    /**
     * Parent sale
     */
    SaleId?: number;
    /**
     * e.g. Mrs, Mr, Ms, Dr.
     */
    Mrmrs?: string;
    /**
     * First name
     */
    Firstname?: string;
    /**
     * Middle name or 'van' etc.
     */
    MiddleName?: string;
    /**
     * Last name
     */
    Lastname?: string;
    /**
     * Primary key
     */
    SaleStakeholderId?: number;
    /**
     * Rank in list of stakeholders
     */
    Rank?: number;
    /**
     * Phone number
     */
    Phone?: string;
}
/**
 *
 * Returns SaleStakeholder[]
 */
export interface Sale_GetSaleStakeholdersRequest {
    /**
     *
     */
    SaleId: number;
}
/**
 *
 * Returns SaleStakeholder[]
 */
export interface Sale_UpdateSaleStakeholdersRequest {
    /**
     *
     */
    Stakeholders: SaleStakeholder[];
}
/**
 *
 * Returns SaleStakeholder[]
 */
export interface Sale_GetSaleStakeholderByIdRequest {
    /**
     *
     */
    SaleStakeholderIds: number[];
}
/**
 *
 */
export interface SaleSummary extends Carrier {
    /**
     * Default currency for the installation
     */
    BaseCurrency?: string;
    /**
     * Default currency for the current user
     */
    OwnCurrency?: string;
    /**
     * Summed amount for all sold within the period in default currency for the installation
     */
    SoldTotalBaseCurrency?: number;
    /**
     * Number of all sold within the period
     */
    Sold?: number;
    /**
     * Summed amount for all sold within the period in default currency for the current user
     */
    SoldTotalOwnCurrency?: number;
    /**
     * Number of all lost within the period
     */
    Lost?: number;
    /**
     * Summed amount for all lost within the period in default currency for the installation
     */
    LostTotalBaseCurrency?: number;
    /**
     * Summed amount for all lost within the period in default currency for the current user
     */
    LostTotalOwnCurrency?: number;
    /**
     * Number of all open within the period
     */
    Open?: number;
    /**
     * Summed amount for all open within the period in default currency for the installation
     */
    OpenTotalBaseCurrency?: number;
    /**
     * Summed amount for all open within the period in default currency for the current user
     */
    OpenTotalOwnCurrency?: number;
    /**
     * Weighted sum for all open within the period in default currency for the installation
     */
    OpenWeightedBaseCurrency?: number;
    /**
     * Weighted sum for all open within the period in default currency for the current user
     */
    OpenWeightedOwnCurrency?: number;
    /**
     * Number of all open sales with date before this period
     */
    PreviousOverdue?: number;
    /**
     * Summed amount for all open sales with date before this period in default currency for the installation
     */
    PreviousOverdueTotalBaseCurrency?: number;
    /**
     * Summed amount for all open sales with date before this period in default currency for the current user
     */
    PreviousOverdueTotalOwnCurrency?: number;
    /**
     * Weighted sum for all open sales with date before this period in default currency for the installation
     */
    PreviousOverdueWeightedBaseCurrency?: number;
    /**
     * Weighted sum for all open sales with date before this period in default currency for the current user
     */
    PreviousOverdueWeightedOwnCurrency?: number;
    /**
     * Number of all overdue sales within the period
     */
    CurrentOverdue?: number;
    /**
     * Summed amount for all overdue sales within the period in default currency for the installation
     */
    CurrentOverdueTotalBaseCurrency?: number;
    /**
     * Summed amount for all overdue sales within the period in default currency for the current user
     */
    CurrentOverdueTotalOwnCurrency?: number;
    /**
     * Weighted sum for all overdue sales within the period in default currency for the installation
     */
    CurrentOverdueWeightedBaseCurrency?: number;
    /**
     * Weighted sum for all overdue sales within the period in default currency for the current user
     */
    CurrentOverdueWeightedOwnCurrency?: number;
    /**
     * Number of all Future Pipe/All open sales with date after the period
     */
    FutureOpen?: number;
    /**
     * Summed amount for all Future Pipe/All open sales with date after the period in default currency for the installation
     */
    FutureOpenTotalBaseCurrency?: number;
    /**
     * Summed amount for all Future Pipe/All open sales with date after the period in default currency for the current user
     */
    FutureOpenTotalOwnCurrency?: number;
    /**
     * Weighted sum for all Future Pipe/All open sales with date after the period in default currency for the installation
     */
    FutureOpenWeightedBaseCurrency?: number;
    /**
     * Weighted sum for all Future Pipe/All open sales with date after the period in default currency for the current user
     */
    FutureOpenWeightedOwnCurrency?: number;
}
/**
 *
 * Returns SaleSummary
 */
export interface Sale_GetSummaryByAssociateRequest {
    /**
     *
     */
    AssociateId: number;
    /**
     *
     */
    FromDate: Date;
    /**
     *
     */
    ToDate: Date;
}
/**
 *
 * Returns SaleSummary
 */
export interface Sale_GetSummaryByGroupRequest {
    /**
     *
     */
    GroupId: number;
    /**
     *
     */
    FromDate: Date;
    /**
     *
     */
    ToDate: Date;
}
/**
 *
 * Returns SaleSummary
 */
export interface Sale_GetSummaryByContactRequest {
    /**
     *
     */
    ContactId: number;
    /**
     *
     */
    FromDate: Date;
    /**
     *
     */
    ToDate: Date;
}
/**
 * Sale Summary item
 */
export interface SaleSummaryItem {
    /**
     * Primary key
     */
    SaleId?: number;
    /**
     * Expected sales date
     */
    SaleDate?: Date;
    /**
     * Probability of sale succeess in percent (0-100)
     */
    Probability?: number;
    /**
     * Sale heading (short description?)
     */
    Heading?: string;
    /**
     * Total sale amount
     */
    Amount?: number;
    /**
     * Currency the sale amount is in.
     */
    Currency?: string;
    /**
     * Sale amount converted to the base currency.
     */
    AmountInBaseCurrency?: number;
    /**
     * The sale's status, indicating whether the sale is open(1), sold(2) or lost(3).
     */
    Status?: enums.SaleStatus;
    /**
     * The Completed state. NotStarted(1) or Completed(3)
     */
    Completed?: enums.ActivityStatus;
    /**
     * Registered date
     */
    Registered?: Date;
}
/**
 * Searching the phone list. Using default search preferences or the preferences already set by the PhoneListPreferences Service
 * Returns PhoneListItem[]
 */
export interface PhoneList_SearchRequest {
    /**
     * The search string
     */
    SearchString: string;
}
/**
 * Searching the phone list. Search is based on the supplied preferences.
 * Returns PhoneListItem[]
 */
export interface PhoneList_SearchWithPreferencesRequest {
    /**
     * The search string.
     */
    SearchString: string;
    /**
     * The search preferences
     */
    Preferences: PhoneListPreferences;
}
/**
 * Returns an array of phone list items with the in-parameter as restriction. The in-parameter must be a valid department id (UserGroupId).
 * Returns PhoneListItem[]
 */
export interface PhoneList_GetDepartmentPhonesRequest {
    /**
     * The department to get the phone list for
     */
    DepartmentId: number;
}
/**
 * Returns an array of phone list items with the Contacts in the users favorites dropdown list.
 * Returns PhoneListItem[]
 */
export interface PhoneList_GetFavoritesPhonesRequest {
}
/**
 * Returns an array of phone list items for all the persons belonging to a contact (company). The in-parameter must be a valid contact-id.
 * Returns PhoneListItem[]
 */
export interface PhoneList_GetContactPhonesRequest {
    /**
     * The contact id
     */
    ContactId: number;
}
/**
 * Adds a new contact to the history/favorites. Returns the rank of the new history item. If the contact already existed in the history, it isn't added but the rank is updated.
 * Returns number
 */
export interface PhoneList_AddToFavoritesRequest {
    /**
     * The contact id
     */
    ContactId: number;
}
/**
 *
 */
export interface PhoneListItem extends Carrier {
    /**
     * Person Direct Phone
     */
    PersonDirectPhone?: string;
    /**
     * Person Cell Phone
     */
    PersonCellPhone?: string;
    /**
     * Person Private Phone
     */
    PersonPrivatePhone?: string;
    /**
     * Actual phone number as eneterd by the user
     */
    PersonFaxNumber?: string;
    /**
     * Actual phone number as eneterd by the user
     */
    PersonPagerNumber?: string;
    /**
     * The address itself
     */
    PersonEmail?: string;
    /**
     * The contact or person's id
     */
    Id?: number;
    /**
     * The contact or person's name
     */
    Name?: string;
    /**
     *
     */
    Tooltip?: string;
    /**
     * Property setting a unique id indicating if this is a person or contact
     */
    UniqueId?: string;
}
/**
 * Search preferences for a phone list search
 */
export interface PhoneListPreferences extends Carrier {
    /**
     * True if you want to search for Companies by their name.
     */
    SearchCompany?: boolean;
    /**
     * True if you want to search for Persons by their firstname.
     */
    SearchFirstname?: boolean;
    /**
     * True if you want to search for Persons by their lastname.
     */
    SearchLastname?: boolean;
    /**
     * True if you want to search for Departments where your colleagues work.
     */
    SearchDepartment?: boolean;
    /**
     * The Company name search type, e.g. BeginsWith, Contains, Endswith, Matches
     */
    SearchModeCompany?: enums.StringSearchType;
    /**
     * The Department search type, e.g. BeginsWith, Contains, Endswith, Matches
     */
    SearchModeDepartment?: enums.StringSearchType;
    /**
     * The firstname search type, e.g. BeginsWith, Contains, Endswith, Matches
     */
    SearchModeFirstname?: enums.StringSearchType;
    /**
     * The lastname search type, e.g. BeginsWith, Contains, Endswith, Matches
     */
    SearchModeLastname?: enums.StringSearchType;
}
/**
 * Getting Phone List Preferences from the CRM 5 user preferences
 * Returns PhoneListPreferences
 */
export interface PhoneList_GetPreferencesRequest {
}
/**
 * Setting Phone List Preferences to the CRM 5 user preferences
 */
export interface PhoneList_SetPreferencesRequest {
    /**
     * The preference that is set as user preferences
     */
    Preferences: PhoneListPreferences;
}
/**
 *
 */
export interface Project extends Carrier {
    /**
     * Primary key
     */
    ProjectId?: number;
    /**
     * Project name
     */
    Name?: string;
    /**
     * The projects description
     */
    Description?: string;
    /**
     * URL address
     */
    URL?: string;
    /**
     * The project type.
     */
    Type?: string;
    /**
     * The project owner id (associate id)
     */
    AssociateId?: number;
    /**
     * The project owner
     */
    AssociateFullName?: string;
    /**
     *
     */
    TypeId?: number;
    /**
     * Last updated date
     */
    Updated?: Date;
    /**
     * The projects status id
     */
    StatusId?: number;
    /**
     * The projects status
     */
    Status?: string;
    /**
     * The id of the description
     */
    TextId?: number;
    /**
     * Publication valid to (inclusive)
     */
    PublishTo?: Date;
    /**
     * Publication valid from (inclusive)
     */
    PublishFrom?: Date;
    /**
     *
     */
    IsPublished?: boolean;
    /**
     * Visible field
     */
    URLName?: string;
    /**
     * Automatically generated number
     */
    ProjectNumber?: string;
    /**
     * The number of active erp links
     */
    ActiveErpLinks?: number;
}
/**
 * The Project Service. The service implements all services working with the Project object
 */
export interface ProjectEntity extends Carrier {
    /**
     * Primary key
     */
    ProjectId?: number;
    /**
     * Project name
     */
    Name?: string;
    /**
     * Automatically generated number
     */
    ProjectNumber?: string;
    /**
     * The persons which are members of the project
     */
    ProjectMembers?: ProjectMember[];
    /**
     * The project's internet adresses
     */
    Urls?: EntityElement[];
    /**
     * Registered date
     */
    CreatedDate?: Date;
    /**
     * Last updated date
     */
    UpdatedDate?: Date;
    /**
     * The actual text, max 2047 significant characters even though it is stored as a larger data type on some databases
     */
    Description?: string;
    /**
     * The actual text, max 2047 significant characters even though it is stored as a larger data type on some databases
     */
    Postit?: string;
    /**
     * The person that created the project
     */
    CreatedBy?: Associate;
    /**
     * The person that last updated the project
     */
    UpdatedBy?: Associate;
    /**
     * The person that created the project
     * Use MDO List name "associate" to get list items.
     */
    Associate?: Associate;
    /**
     * Project status is a list defined by the database administrator. Different statuses of a project may be: “In planning”, “Started”, “Finished” and so on
     * Use MDO List name "projectstatus" to get list items.
     */
    ProjectStatus?: ProjectStatus;
    /**
     * Project type is a list defined by the database admin. for example: 'Large', 'Small', 'Party'...
     * Use MDO List name "projecttype" to get list items.
     */
    ProjectType?: ProjectType;
    /**
     * True if the project has an image. (This is the image that is displayed in the CRM client)
     */
    HasImage?: boolean;
    /**
     * Description of the project image if it exists. (This is the image that is displayed in the CRM client)
     */
    ImageDescription?: string;
    /**
     * Active status monitor identity with the lowest rank for project
     */
    ActiveStatusMonitorId?: number;
    /**
     * List of all elements linked to the project
     */
    Links?: Link[];
    /**
     * Number of active links to documents, other appointments, and such
     */
    ActiveLinks?: number;
    /**
     * Done (0=false, 1=true). Status implies changes in which fields are shown in GUI, as well as which fields can be updated
     */
    Completed?: boolean;
    /**
     * Calculated date, reflects date of closest non-complete future milestone activity
     */
    NextMilestoneDate?: Date;
    /**
     * ID of appointment that "caused" the nextMilestoneDate, can be 0
     */
    NmdAppointmentId?: number;
    /**
     * Planned end date for project, inhertied from type and later editable
     */
    EndDate?: Date;
    /**
     * The number of active erp links
     */
    ActiveErpLinks?: number;
    /**
     * Dictionary of user defined field data.
     * The key string is the ProgId of the UdefField, or if the ProgId is empty it is a string of the format "SuperOffice:[UdefFieldIdentity]", e.g. "SuperOffice:1234"
     */
    UserDefinedFields?: StringDictionary;
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
    /**
     * Publish event date
     */
    PublishEventDate?: Date;
    /**
     * Publication valid to (inclusive)
     */
    PublishTo?: Date;
    /**
     * Publication valid from (inclusive)
     */
    PublishFrom?: Date;
    /**
     * Publication is published
     */
    IsPublished?: boolean;
}
/**
 * Add multiple project members to a project
 */
export interface Project_AddProjectMembersRequest {
    /**
     * Project to add members to
     */
    ProjectEntityId: number;
    /**
     * Project members to add
     */
    ProjectMembers: ProjectMember[];
}
/**
 * Delete the given project members from a project
 */
export interface Project_DeleteProjectMembersRequest {
    /**
     * Project to remove members from
     */
    ProjectEntityId: number;
    /**
     * Project member ids
     */
    MemberIds: number[];
}
/**
 * Returns the project image that is displayed in the CRM application.
 * Returns Blob
 */
export interface Project_GetProjectImageRequest {
    /**
     * The project id of the project the image belongs to.
     */
    ProjectId: number;
}
/**
 * Stores the project image that is displayed in the CRM application.
 */
export interface Project_SetProjectImageRequest {
    /**
     * The project id of the project the image belongs to.
     */
    ProjectId: number;
    /**
     * The image that is stored on the project (System.Drawing.Image)
     */
    Image: ArrayBuffer | string;
}
/**
 * Deletes projectmembers rows.
 */
export interface Project_DeleteProjectMemberByIdsRequest {
    /**
     * An Array of projectmember ids.
     */
    ProjectMemberIds: number[];
}
/**
 * Get duplicates(exact or similar in the database) based on the name
 * Returns DuplicateEntry[]
 */
export interface Project_GetDuplicatesRequest {
    /**
     * Name used for lookup
     */
    Name: string;
}
/**
 * Creates a new project based on external duplicate
 * Returns number
 */
export interface Project_CreateNewEntryRequest {
    /**
     * The duplicate to create a new entry based upon
     */
    Duplicate: DuplicateEntry;
}
/**
 * Set which duplicate rules should be active or not
 */
export interface Project_SetDuplicateRulesStatusRequest {
    /**
     * Duplicate rules to update active status for
     */
    Rules: DuplicateRule[];
}
/**
 * Retrieve all available duplicate rules for project
 * Returns DuplicateRule[]
 */
export interface Project_GetDuplicateRulesRequest {
}
/**
 * Merge two projects into one, removing the source project in the process
 */
export interface Project_MergeRequest {
    /**
     * Id of source project for merge. This project is removed after the merge is completed.
     */
    SourceProjectId: number;
    /**
     * Id of destination project to merge to. This project is updated with info from the source.
     */
    DestinationProjectId: number;
    /**
     * Fill in empty fields on destination from source?
     */
    ReplaceEmptyFieldsOnDestination: boolean;
}
/**
 * Checks if the number is unique or required.  The setting is configured from admin under system options.
 * Returns boolean
 */
export interface Project_IsNumberValidRequest {
    /**
     * The Project id
     */
    ContactId: number;
    /**
     * The number to check for uniqueness and validity
     */
    Number: string;
}
/**
 * Does this project have a guide associated with its project type?
 * Returns boolean
 */
export interface Project_HasGuideRequest {
    /**
     * Project id
     */
    ProjectId: number;
}
/**
 * Next upcoming milestone appointment
 * Returns Appointment
 */
export interface Project_GetNextMilestoneRequest {
    /**
     * Project id - primary key
     */
    ProjectId: number;
}
/**
 *
 * Returns boolean
 */
export interface Project_OfferAutoNextStatusOnApppointmentCompletedRequest {
    /**
     *
     */
    AppointmentId: number;
}
/**
 *
 * Returns number
 */
export interface Project_GetNextProjectStatusRequest {
    /**
     *
     */
    ProjectId: number;
}
/**
 *
 * Returns boolean
 */
export interface Project_HasGuideActivitiesRequest {
    /**
     *
     */
    ProjectId: number;
}
/**
 * Check that entity is ready for saving, return error messages by field.
 * Returns StringDictionary
 */
export interface Project_ValidateProjectEntityRequest {
    /**
     * Entity to be checked for errors.
     */
    ProjectEntity: ProjectEntity;
}
/**
 * A project that is also an event. Used by Audience
 */
export interface ProjectEvent extends Carrier {
    /**
     * Name of the person that ows the event (i.e. project)
     */
    AssociateFullName?: string;
    /**
     * The event description (i.e. the project text)
     */
    Description?: string;
    /**
     * Id of the project that represents the event
     */
    ProjectId?: number;
    /**
     * The name of the event (i.e. the project name)
     */
    EventName?: string;
    /**
     * Id of the person that ows the event (i.e. project)
     */
    AssociateId?: number;
    /**
     * True if the current user is signed on to the event (i.e. is project member)
     */
    IsSignedOn?: boolean;
    /**
     * Text shown as confirmation text before accepting sign off.
     */
    SignOffConfirmationText?: string;
    /**
     * Default text for the activity created when signing off.
     */
    SignOffText?: string;
    /**
     * Text shown as confirmation text before accepting sign on.
     */
    SignOnConfirmationText?: string;
    /**
     * Default text for the activity created when signing on.
     */
    SignOnText?: string;
    /**
     * Date of the event. Event is not visible after this date.
     */
    EventDate?: Date;
    /**
     * If true the event is enabled (visible)
     */
    Enabled?: boolean;
    /**
     * If true, it is possible to sign off the event.
     */
    SignOff?: boolean;
    /**
     * If true, a task should be created when the external user signs off an event
     */
    SignOffTaskEnable?: boolean;
    /**
     * If true, a task should be created when the external user signs on an event
     */
    SignOnTaskEnable?: boolean;
    /**
     * If true, it is possible to sign on the event.
     */
    SignOn?: boolean;
    /**
     * If not 0, sign off should cause an Activity of this type to be registered
     */
    SignOffTaskId?: number;
    /**
     * If not 0, sign on should cause an Activity of this type to be registered
     */
    SignOnTaskId?: number;
    /**
     * If true, the sign off task should be created as an Assigned task, triggering the invitation dialog
     */
    SignOffTriggersAssign?: boolean;
    /**
     * If true, the sign on task should be created as an Assigned task, triggering the invitation dialog
     */
    SignOnTriggersAssign?: boolean;
    /**
     * If 0, the signOn Activity should go into the persons Our Contact; if not 0, this is the Person whose diary should get the activity
     */
    SignOnPersonId?: number;
    /**
     * If 0, the signOn Activity should go into the persons Our Contact; if not 0, this is the Person whose diary should get the activity
     */
    SignOffPersonId?: number;
}
/**
 * Gets a ProjectEvent object from a project and a person.
 * Returns ProjectEvent
 */
export interface Project_GetProjectEventOnPersonRequest {
    /**
     * The project Id
     */
    ProjectId: number;
    /**
     * Id of the person the project events belong to.
     */
    PersonId: number;
}
/**
 * The ProjectEvent Service. The service implements all services working with the ProjectEvent object
 */
export interface ProjectEventEntity extends Carrier {
    /**
     * Text shown as confirmation text before accepting sign off.
     */
    SignOffConfirmationText?: string;
    /**
     * Default text for the activity created when signing off.
     */
    SignOffText?: string;
    /**
     * Text shown as confirmation text before accepting sign on.
     */
    SignOnConfirmationText?: string;
    /**
     * Default text for the activity created when signing on.
     */
    SignOnText?: string;
    /**
     * Dateof the event; publishing/visibility dates are in Publish, and restrictions are in AudienceVisibility
     */
    EventDate?: Date;
    /**
     * Is the event enabled
     */
    Enabled?: boolean;
    /**
     * Registered when
     */
    CreatedDate?: Date;
    /**
     * Is Sign Off functionality enabled?
     */
    SignOff?: boolean;
    /**
     * If not 0, a task should be created when the external user Signs Off an event
     */
    SignOffTaskEnable?: boolean;
    /**
     * If not 0, sign off should cause an Activity of this type to be registered
     */
    SignOffTaskId?: number;
    /**
     * If 1, the SignOff task should be created as an Assigned task, triggering the invitation dialog
     */
    SignOffTriggersAssign?: boolean;
    /**
     * Is Sign On functionality enabled
     */
    SignOn?: boolean;
    /**
     * If not 0, a task should be created when the external user Signs On to an event
     */
    SignOnTaskEnable?: boolean;
    /**
     * If not 0, sign on should cause an Activity of this type to be registered
     */
    SignOnTaskId?: number;
    /**
     * If 1, the SignOn task should be created as an Assigned task, triggering the invitation dialog
     */
    SignOnTriggersAssign?: boolean;
    /**
     * Last updated when
     */
    UpdatedDate?: Date;
    /**
     * The person that created the projectevent
     */
    CreatedBy?: Associate;
    /**
     * The person that last updated the projectevent
     */
    UpdatedBy?: Associate;
    /**
     * The projectId for the project this projectEvent belongs to
     */
    ProjectId?: number;
    /**
     * Id of the external event
     */
    Id?: number;
    /**
     * Publication valid from (inclusive)
     */
    PublishFrom?: Date;
    /**
     * Type of publishing action, 0 = Unknown, 1 = to external persons
     */
    PublishType?: enums.PublishType;
    /**
     * Publication valid to (inclusive)
     */
    PublishTo?: Date;
    /**
     * Array of categories that the event is visible for. MDO Table "category".
     */
    VisibleForCategories?: MDOListItem[];
    /**
     * Array of person interests (MDO table "persint") that this event is visible for.
     */
    VisibleForPersonInterests?: MDOListItem[];
    /**
     * Publish to external users? When true, the event/project information is visible to external users through the Audience portal. You can control the publish duration using the PublishFrom/PublishTo properties.
     */
    IsPublished?: boolean;
    /**
     *
     */
    IsVisibleForMembers?: boolean;
    /**
     *
     */
    IsVisibleForCategories?: boolean;
    /**
     *
     */
    IsVisibleForPersonInterests?: boolean;
    /**
     * Primary key
     */
    ProjectEventId?: number;
}
/**
 * Get a ProjectEventEntity based on a projectId.
 * Returns ProjectEventEntity
 */
export interface Project_GetProjectEventEntityFromProjectIdRequest {
    /**
     * The projectId to get a ProjectEventEntity for
     */
    ProjectId: number;
}
/**
 * Delete a project event based on a project id. Does not delete the project, but does delete the published and ExternalEvent and AudienceVisibility records.
 */
export interface Project_DeleteProjectEventEntityFromProjectIdRequest {
    /**
     * The project id of the external event to delete.
     */
    ProjectId: number;
}
/**
 * Gets all project events that belongs to the currently logged on user. The list of events are filtered by the Audience Visibility restrictions set when the project event is created.
 * Returns ProjectEvent[]
 */
export interface Project_GetMyProjectEventsRequest {
}
/**
 * Gets all project events that belongs to the person specified. The list of events are filtered by the Audience Visibility restrictions set when the project event is created.
 * Returns ProjectEvent[]
 */
export interface Project_GetProjectEventsOnPersonRequest {
    /**
     * Id of the person the project events belong to.
     */
    PersonId: number;
}
/**
 * Returning the projects belonging to an associate. If memberProjects is false only the projects where the associate is project responsible is returned, otherwise both the projects where the associate is project responsible and project member is returned.
 * Returns Project[]
 */
export interface Project_GetMyProjectsRequest {
    /**
     * True to include projects where the user is project member.
     */
    IncludeMemberProjects: boolean;
}
/**
 * Returning the projects where an user is project member.
 * Returns Project[]
 */
export interface Project_GetMyMemberProjectsRequest {
}
/**
 * Return all projects where the person is project member.
 * Returns Project[]
 */
export interface Project_GetProjectsFromPersonRequest {
    /**
     * The person id
     */
    PersonId: number;
}
/**
 * Returns all projects where the given contact has projectmembers.
 * Returns Project[]
 */
export interface Project_GetProjectsFromContactRequest {
    /**
     * The contact id
     */
    ContactId: number;
}
/**
 * Get published project by project id.
 * Returns Project
 */
export interface Project_GetPublishedProjectRequest {
    /**
     * The project id.
     */
    ProjectId: number;
}
/**
 * Get published projects by project ids.
 * Returns Project[]
 */
export interface Project_GetPublishedProjectsRequest {
    /**
     * The array of project ids
     */
    ProjectIds: number[];
}
/**
 * Get published projects from the logged in user.
 * Returns Project[]
 */
export interface Project_GetMyPublishedProjectsRequest {
}
/**
 * Get published projects where person  is a member
 * Returns Project[]
 */
export interface Project_GetPublishedProjectsOnPersonIdRequest {
    /**
     * The person id
     */
    PersonId: number;
}
/**
 * A person can be a member of multiple projects, with a different comment and member type in each project.
 */
export interface ProjectMember extends Carrier {
    /**
     * Primary key
     */
    ProjectmemberId?: number;
    /**
     * Contact ID of person who is the project member
     */
    ContactId?: number;
    /**
     * Parent project - the project this project member belongs to.
     */
    ProjectId?: number;
    /**
     * Contact name
     */
    ContactName?: string;
    /**
     * Contact department
     */
    ContactDepartment?: string;
    /**
     * Name of the project this project member belongs to.
     */
    ProjectName?: string;
    /**
     * The person's email address id
     */
    EmailId?: number;
    /**
     * The e-mail address
     */
    EmailAddress?: string;
    /**
     * Country
     */
    CountryId?: number;
    /**
     * First name
     */
    Firstname?: string;
    /**
     * Middle name or 'van' etc.
     */
    MiddleName?: string;
    /**
     * Last name
     */
    Lastname?: string;
    /**
     * The person's id - primary key
     */
    PersonId?: number;
    /**
     * e.g. Mrs, Dr, Ms.
     */
    Mrmrs?: string;
    /**
     * The projectmembers type name: 'secretary', 'member', etc.
     */
    ProjectMemberTypeName?: string;
    /**
     * Phone number
     */
    Phone?: string;
    /**
     * The phone id
     */
    PhoneId?: number;
    /**
     * ProjectMember Type Id - from the ProjectMemberType list.
     * Use MDO List name "PMembType" to get list items.
     */
    ProjectMemberTypeId?: number;
    /**
     * The e-mail address description
     */
    EmailAddressName?: string;
    /**
     * Comment text on the project membership
     */
    Comment?: string;
    /**
     * The person's full name localized to the current culture/country.  (internal name used in clients for employees)
     */
    FullName?: string;
}
/**
 * Returns an array of project members
 * Returns ProjectMember[]
 */
export interface Project_GetProjectMembersRequest {
    /**
     * The project id
     */
    ProjectId: number;
}
/**
 * Updates a ProjectMember row.
 * Returns ProjectMember
 */
export interface Project_UpdateProjectMemberRequest {
    /**
     * ProjectMember to update
     */
    ProjectMember: ProjectMember;
}
/**
 * Returns an array of project members
 * Returns ProjectMember[]
 */
export interface Project_GetProjectMembersByIdRequest {
    /**
     *
     */
    ProjectMemberIds: number[];
}
/**
 * Saves role and comment on an array of projectmembers represented by ids
 */
export interface Project_SaveProjectMembersFunctionAndCommentRequest {
    /**
     *
     */
    ProjectMemberIds: number[];
    /**
     *
     */
    RoleId: number;
    /**
     *
     */
    Comment: string;
}
/**
 *
 */
export interface ActivityInformationListItem extends Carrier {
    /**
     * Date that this item is valid for; there is exactly one item per date, ordered by date.
     */
    Date?: Date;
    /**
     * Activity information summary - number of free and busy activities.
     */
    ActivityInformation?: ActivitySummary;
}
/**
 * Activity information summary - number of free and busy activities.
 */
export interface ActivitySummary extends Carrier {
    /**
     * Number of activites and tasks in the diary that are of type 'busy'. Sales and documents are not activites in this case, only diary appointments and tasks.
     */
    NumBusyActivities?: number;
    /**
     * Number of activites of the type 'free'. Sales and documents are not activites in this case, only diary appointments and tasks.
     */
    NumFreeActivities?: number;
    /**
     * How much of the active work-day which is booked in appointments.
     */
    PercentageBusy?: number;
}
/**
 * Summary details about appointments and documents.
 */
export interface ActivitySummaryItem {
    /**
     * Primary key
     */
    AppointmentId?: number;
    /**
     * Document id - 0 if not a document
     */
    DocumentId?: number;
    /**
     * Start/Document date
     */
    Date?: Date;
    /**
     * The appointment's textbox; document title
     */
    Description?: string;
    /**
     * The Completed state. NotStarted(1) or Completed(3)
     */
    Completed?: enums.ActivityStatus;
    /**
     * Registered date
     */
    Registered?: Date;
}
/**
 *
 */
export interface AddressSyncData extends Carrier {
    /**
     * Primary key
     */
    AddressId?: number;
    /**
     *
     */
    AddressType?: enums.AddressType;
    /**
     *
     */
    Address1?: string;
    /**
     *
     */
    Address2?: string;
    /**
     *
     */
    Address3?: string;
    /**
     *
     */
    City?: string;
    /**
     *
     */
    County?: string;
    /**
     *
     */
    ZipCode?: string;
    /**
     *
     */
    State?: string;
    /**
     *
     */
    Latitude?: number;
    /**
     *
     */
    Longitude?: number;
    /**
     *
     */
    FormattedAddress?: string;
}
/**
 *
 */
export interface AlarmData extends Carrier {
    /**
     * Primary key
     */
    AppointmentId?: number;
    /**
     * date + start time planned
     */
    StartTime?: Date;
    /**
     * Date + end time planned
     */
    EndDate?: Date;
    /**
     *
     */
    AlarmTime?: Date;
    /**
     * Person ID of person the appointment is with, may be 0
     */
    PersonId?: number;
    /**
     * The associate's culture formatted fullname (firstname, middleName and lastname)
     */
    PersonFullName?: string;
    /**
     * Contact name
     */
    ContactName?: string;
    /**
     * ID of project referred to, may be 0
     */
    ProjectId?: number;
    /**
     * Project name
     */
    ProjectName?: string;
    /**
     * The actual text, max 2047 significant characters even though it is stored as a larger data type on some databases
     */
    AppointmentText?: string;
    /**
     * Owning sale, if any (may be 0)
     */
    SaleId?: number;
    /**
     *
     */
    SaleName?: string;
    /**
     * Location for appointment, defaulted from invited resource of type place and other rules, but you can write anything you want here
     */
    Location?: string;
    /**
     * where=no start time,note,docin, docout
     */
    AppointmentType?: enums.AppointmentType;
    /**
     * Contact ID of owning contact, may be 0
     */
    ContactId?: number;
    /**
     * Status if this appointment is in the process of being assigned to someone else
     */
    AssignmentStatus?: enums.AssignmentStatus;
    /**
     * Status if this appointment represents an invitation
     */
    InvitationStatus?: enums.InvitationStatus;
    /**
     * The type of booking the appointment represents
     */
    BookingType?: enums.BookingType;
    /**
     * The associate's culture formatted formalname (firstname, middleName and lastname, title, mrmrs)
     */
    FormalName?: string;
    /**
     *
     */
    TaskName?: string;
    /**
     * Department
     */
    ContactDepartment?: string;
    /**
     *
     */
    ContactFullName?: string;
    /**
     *
     */
    JoinVideomeetUrl?: string;
}
/**
 * Simple read-only appointment data.
 */
export interface Appointment extends Carrier {
    /**
     * Primary key
     */
    AppointmentId?: number;
    /**
     * date + start time planned
     */
    StartDate?: Date;
    /**
     * Date + end time planned
     */
    EndDate?: Date;
    /**
     * The different types of appointment, if the appointment is supposed to be shown in the diary or checklist, or if it's a document. See the different types of appointments in the database manual.
     */
    Type?: enums.AppointmentType;
    /**
     * Task comprises the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    Task?: string;
    /**
     * The owner of the appointment - the associate whose diary/checklist the appointment is in.
     */
    AssociateFullName?: string;
    /**
     * The contact associated with the appointment.
     */
    ContactName?: string;
    /**
     * The appointment's textbox; holds a descriptive text about the appointment. Filled out by the user.
     */
    Description?: string;
    /**
     * The full name of the person this appointment belongs to.
     */
    PersonFullName?: string;
    /**
     * Person ID of person the appointment is with, may be 0
     */
    PersonId?: number;
    /**
     * Contact ID of owning contact, may be 0
     */
    ContactId?: number;
    /**
     * ID of project referred to, may be 0
     */
    ProjectId?: number;
    /**
     * The name of the project this appointment belong to. Blank if no project is connected.
     */
    ProjectName?: string;
    /**
     * True if appointment have an entry in published table
     */
    IsPublished?: boolean;
    /**
     * ID of associate whose diary the appointment is in, REQUIRED
     */
    AssociateId?: number;
    /**
     * Appointment colour, used only in Japanese versions. Western versions take colour from Task
     */
    ColorIndex?: number;
    /**
     * True if free, false if busy
     */
    IsFree?: boolean;
    /**
     * Does this appointment have an alarm
     */
    HasAlarm?: boolean;
    /**
     * True if all day event
     */
    IsAlldayEvent?: boolean;
    /**
     * Obsolete, but still maintained field for appointment privacy; denormalization of visiblefor status
     */
    Private?: enums.AppointmentPrivate;
    /**
     * Link to priority list
     */
    PriorityId?: number;
    /**
     * Name of the appointments priority
     */
    PriorityName?: string;
    /**
     * The different task types of the appointment, if the activity is an appointment, task, phone. See the different types of appointments in the database manual.
     */
    TaskType?: enums.TaskType;
    /**
     * True if this appointment is a booking and current associate is the owner. False if it is a booking and current associate is a participant.
     */
    IsBookingMain?: boolean;
    /**
     * True if the appointment is part of a recurring pattern.
     */
    IsRecurrence?: boolean;
    /**
     * True if this appointment is a booking.
     */
    IsBooking?: boolean;
    /**
     * The date to be used for searching & showing
     */
    ActiveDate?: Date;
    /**
     * Status if this appointment is in the process of being assigned to someone else
     */
    AssignmentStatus?: enums.AssignmentStatus;
    /**
     * Status if this appointment represents an invitation
     */
    InvitationStatus?: enums.InvitationStatus;
    /**
     * The type of booking the appointment represents
     */
    BookingType?: enums.BookingType;
    /**
     * The Completed state.
     */
    Completed?: enums.ActivityStatus;
    /**
     *
     */
    RecurringPattern?: enums.RecurrencePattern;
    /**
     *
     */
    RecurringStartDate?: Date;
    /**
     *
     */
    RecurringEndDate?: Date;
    /**
     * ID of mother appointment; self if booking master, master ID if booking slave, 0 if normal appointment. However, if 0 and assoc_id != reg_id then this is an assigned appointment, indicated vt type = kBooking
     */
    MotherId?: number;
    /**
     * Who (last) assigned this appointment to associate_id?
     */
    AssignedBy?: number;
    /**
     * The associate's culture formatted fullname (firstname, middleName and lastname)
     */
    AssignedByFullName?: string;
    /**
     * Why was this booking or assignment rejected, the RejectReason list is a source of suggestions but you can write anything here
     */
    RejectReason?: string;
    /**
     * Location for appointment, defaulted from invited resource of type place and other rules, but you can write anything you want here
     */
    Location?: string;
    /**
     * Alarm lead time.
     */
    AlarmLeadTime?: moment.Duration;
    /**
     * Owning sale, if any (may be 0)
     */
    SaleId?: number;
    /**
     * Heading of Owning sale, if any. (may be blank)
     */
    SaleName?: string;
    /**
     * The associate's name
     */
    AssociateName?: string;
    /**
     * Appointment creation date
     */
    CreatedDate?: Date;
    /**
     * Who created the appointment. Associate name.
     */
    CreatedBy?: string;
    /**
     * Who created the appointment. Full name.
     */
    CreatedByFullName?: string;
    /**
     * Id of the associate that created the appointment
     */
    CreatedByAssociateId?: number;
    /**
     * Status field to indicate appointments that have some sort of problem
     */
    CautionWarning?: enums.AppointmentCautionWarning;
    /**
     * Blank when not a video meeting. Filled with Join Meeting URL when created.
     */
    JoinVideomeetUrl?: string;
    /**
     * The title of the appointment.
     */
    Title?: string;
    /**
     * The agenda of the appointment.
     */
    Agenda?: string;
    /**
     * Internal notes for the appointment.
     */
    InternalNotes?: string;
}
/**
 * Sets an appointment's status to Completed if the appointment had a different status, or sets the status to started if already set to completed.
 * Returns AppointmentStatus
 */
export interface Appointment_ToggleAppointmentStatusRequest {
    /**
     * The appointment id.
     */
    AppointmentId: number;
}
/**
 * Toggle the completed status for an activity. Activity may be sale, document or appointment. The changes are saved immediately.
 * Returns ActivityStatus
 */
export interface Appointment_ToggleActivityRequest {
    /**
     * May contain of a mix of appointment_id, sale_id, document_id and todo_id
     */
    ActivityIdentifier: string;
}
/**
 * Toggle the completed status for an array of activities.
 * Returns ActivityStatus
 */
export interface Appointment_ToggleActivitiesRequest {
    /**
     * Contain of a mix of appointment_id, sale_id, document_id and todo_id.
     */
    ActivityIdentifier: string[];
}
/**
 * Sets the completed status for an array of activities. The string activityIdentifier param may contain of a mix of appointment_id, sale_id, document_id and todo_id. The changes are saved immediately. If an invalid id is passed in (nonexistent record), no changes will be made. If there is no write access to the record being changed, a Sentry exception will be thrown in the usual manner.
 */
export interface Appointment_SetActivityStatusRequest {
    /**
     * Array of activity ids. ex. appointment_id=666
     */
    ActivityIdentifier: string[];
    /**
     * The status to set the activities
     */
    ActivityStatus: enums.ActivityStatus;
}
/**
 * Toggles the first activity and sets the rest of the activities to the result of the first toggle. However, there are some special rules for appointments that trigger a suggested appointment when they are completed. If more than one appointment in the set of identifiers triggers a suggestion, we will not toggle those appointments. This rule is only active when changing the status of an appointment to complete. There must be more than one appointment that triggers such an event for this rule to take effect.
 * Returns string[]
 */
export interface Appointment_ToggleAndSetActivitiesRequest {
    /**
     * Array of activity ids. ex. appointment_id=666
     */
    ActivityIdentifiers: string[];
}
/**
 * Appointments appear in the diary, and have links to a Contact/Person and possibly a Project or Sale. They have start and end time+date.
 */
export interface AppointmentEntity extends Carrier {
    /**
     * The owner of the appointment - the associate whose diary/checklist the appointment is in.
     * Use MDO List name "associate" to get list items.
     */
    Associate?: Associate;
    /**
     * The contact associated with the appointment. It may also be null if no contact is associated with the appointment.
     * Use MDO List name "contact_new" to get list items.
     */
    Contact?: Contact;
    /**
     * The associate that first created the appointment. The property is read-only.
     */
    CreatedBy?: Associate;
    /**
     * The person that last updated the appointment.
     */
    UpdatedBy?: Associate;
    /**
     * Registered date
     */
    CreatedDate?: Date;
    /**
     * Primary key
     */
    AppointmentId?: number;
    /**
     * Description of the appointment.
     */
    Description?: string;
    /**
     * date + start time planned
     */
    StartDate?: Date;
    /**
     * Date + end time planned
     */
    EndDate?: Date;
    /**
     * If the appointment is a booking, the invited persons may be your associates, but you are also able to invite contact persons from other companies to join your meeting. They do not receive an invitation, unless you send them one by email, but you can see in the appointment that persons other than your associates have been invited to a meeting. Each invited person will have an appointment slave record.
     */
    InvitedPerson?: Person;
    /**
     * An appointment may also be connected to a person; this must be a contact person registered on the current company. This does not mean however that a person is required.
     * Use MDO List name "person" to get list items.
     */
    Person?: Person;
    /**
     * ID of mother appointment; self if booking master, master ID if booking slave, 0 if normal appointment. However, if 0 and assoc_id != reg_id then this is an assigned appointment, indicated vt type = kBooking
     */
    MotherId?: number;
    /**
     * It's possible to give appointments different priorities. All the different priority types are saved in the priority table, and edited from the Admin. Client. An appointment does not require a priority.
     * Use MDO List name "priority" to get list items.
     */
    Priority?: Priority;
    /**
     * The confidentiality of appointments is shown as different types of “private” on the appointment. For an updated list of “private” types, see the database manual.
     */
    Private?: enums.AppointmentPrivate;
    /**
     * An appointment may also be connected to a project, so you see the appointment both on the company card, and on the project card. This does not mean however that a project is required.
     * Use MDO List name "project" to get list items.
     */
    Project?: Project;
    /**
     * The different types of appointment, if the appointment is supposed to be shown in the diary or checklist, or if it's a document. See the different types of appointments in the database manual.
     */
    Type?: enums.AppointmentType;
    /**
     * Updated date
     */
    UpdatedDate?: Date;
    /**
     * Appointment Completed state. This property is the part of the Status property that is the completed state. Could be three state if the three state user preference is set.
     */
    Completed?: enums.ActivityStatus;
    /**
     * Number of active links to sale, document, appointment.
     */
    ActiveLinks?: number;
    /**
     * List of all elements linked to the appointment.
     */
    Links?: Link[];
    /**
     * Alarm lead time.
     */
    AlarmLeadTime?: moment.Duration;
    /**
     * Does this appointment have an alarm
     */
    HasAlarm?: boolean;
    /**
     * Appointment colour, used only in Japanese versions. Western versions take colour from Task
     */
    ColorIndex?: number;
    /**
     * True if free, false if busy
     */
    IsFree?: boolean;
    /**
     * True if all day event
     */
    IsAlldayEvent?: boolean;
    /**
     * as leadtime, but after the end - time blocked for travel etc.
     */
    LagTime?: moment.Duration;
    /**
     * Time blocked (minutes) BEFORE starttime
     */
    LeadTime?: moment.Duration;
    /**
     * Location for appointment, defaulted from invited resource of type place and other rules, but you can write anything you want here
     */
    Location?: string;
    /**
     * How many invitees have rejected this appointment
     */
    RejectCounter?: number;
    /**
     * Why was this booking or assignment rejected, the RejectReason list is a source of suggestions but you can write anything here
     * Use MDO List name "rejectReason" to get list items.
     */
    RejectReason?: string;
    /**
     * The appointment recurrence.
     */
    Recurrence?: RecurrenceInfo;
    /**
     * List of id's of the participants to this appointment.
     */
    Participants?: ParticipantInfo[];
    /**
     * Status if this appointment is in the process of being assigned to someone else
     */
    AssignmentStatus?: enums.AssignmentStatus;
    /**
     * Status if this appointment represents an invitation
     */
    InvitationStatus?: enums.InvitationStatus;
    /**
     * The type of booking the appointment represents
     */
    BookingType?: enums.BookingType;
    /**
     * The date to be used for searching & showing
     */
    ActiveDate?: Date;
    /**
     * Does the appointment overlap with another appointment in the user's diary?
     */
    HasConflict?: boolean;
    /**
     * Who assigned this appointment to this user? Whose diary did the appointment come from?
     */
    AssignedBy?: Associate;
    /**
     * The owner of the mother appointment - the associate whose diary/checklist the mother appointment is in.  The mother appointment is the one identified by the mother_id. If the mother_id is 0 or the same as this appointment_id, then the master associate will be the same as the 'ordinary' associate.
     */
    MotherAssociate?: Associate;
    /**
     * Task comprises the different types of activities, like “Phone call”, “Meeting” and so on.
     * Use MDO List name "task" to get list items.
     */
    Task?: TaskListItem;
    /**
     * Appoinmtments preferred timezone location.
     */
    PreferredTZLocation?: number;
    /**
     * An appointment may also be connected to a sale, so you see the appointment on the company card, on the project card and on the sale card. This does not mean however that a sale is required.
     * Use MDO List name "sale" to get list items.
     */
    Sale?: Sale;
    /**
     * Suggested guide item that this appointment is an instance of (Note: NOT VALID for document-type appointments, they have their own link)
     */
    SuggestedAppointmentId?: number;
    /**
     * Is this appointment a milestone?
     */
    IsMileStone?: boolean;
    /**
     * Status field to indicate appointments that have some sort of problem
     */
    CautionWarning?: enums.AppointmentCautionWarning;
    /**
     * Blank when not a video meeting. Filled with Join Meeting URL when created.
     */
    JoinVideomeetUrl?: string;
    /**
     * GUID for video meeting in central services – this is set when we create meetings from SuperOffice. It is blank for incoming meetings created from inbox.
     */
    CentralserviceVideomeetId?: string;
    /**
     * The title of the appointment.
     */
    Title?: string;
    /**
     * The agenda of the appointment.
     */
    Agenda?: string;
    /**
     * Internal notes for the appointment.
     */
    InternalNotes?: string;
    /**
     * Dictionary of user defined field data.
     * The key string is the ProgId of the UdefField, or if the ProgId is empty it is a string of the format "SuperOffice:[UdefFieldIdentity]", e.g. "SuperOffice:1234"
     */
    UserDefinedFields?: StringDictionary;
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
    /**
     * Publish event date
     */
    PublishEventDate?: Date;
    /**
     * Publication valid to (inclusive)
     */
    PublishTo?: Date;
    /**
     * Publication valid from (inclusive)
     */
    PublishFrom?: Date;
    /**
     * Publication is published
     */
    IsPublished?: boolean;
    /**
     * The set of users or groups the record is visible for
     */
    VisibleFor?: VisibleFor[];
}
/**
 * Creates a AppointmentEntity populated with the default values for the specific type.
 * Returns AppointmentEntity
 */
export interface Appointment_CreateDefaultAppointmentEntityByTypeRequest {
    /**
     * The type of task requested.
     */
    Type: enums.TaskType;
}
/**
 * Accepting an appointment invitation.
 */
export interface Appointment_AcceptRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Creating an appointment from an emailItem invitation and accepting it.
 */
export interface Appointment_CreateAndAcceptRequest {
    /**
     * The emailItemId
     */
    EmailItemId: number;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Accepting an appointment invitation and send an email confirmation to the meeting organizer.
 */
export interface Appointment_AcceptWithEmailConfirmationRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Creating an appointment from an emailItem invitation and accepting it with email confirmation to the meeting organizer.
 */
export interface Appointment_CreateAndAcceptWithEmailConfirmationRequest {
    /**
     * The emailItemId
     */
    EmailItemId: number;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Rejecting an appointment invitation
 */
export interface Appointment_RejectRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * The reason the invitation was rejected.
     */
    RejectReason: string;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Rejecting an appointment invitation and send an email confirmation to the meeting organizer.
 */
export interface Appointment_RejectWithEmailConfirmationRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * The reason the invitation was rejected.
     */
    RejectReason: string;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Declining an appointment invitation where no tentative appointments have been created.
 */
export interface Appointment_DeclineInvitationFromEmailItemRequest {
    /**
     * The emailItemId.
     */
    EmailItemId: number;
    /**
     * The reason the invitation was rejected.
     */
    RejectReason: string;
}
/**
 * Lookup the name / email of an event-organizer
 * Returns string
 */
export interface Appointment_GetOrganizerNameRequest {
    /**
     * The id of the mother-appointment.
     */
    MotherAppointmentId: number;
}
/**
 * Saving a booking.
 * Returns AppointmentEntity
 */
export interface Appointment_SaveRequest {
    /**
     *
     */
    AppointmentEntity: AppointmentEntity;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
    /**
     * If true, emails will be sent to all participants that is marked with send email flag. If false no mails will be sent even if the send email flag is true.
     */
    SendEmailToParticipants: boolean;
    /**
     * Login information for outgoing smtp email server. Will be null if no login information is relevant.
     */
    SmtpEMailConnectionInfo: EMailConnectionInfo;
    /**
     * Login information for imap server. Will be null if no login information is relevant.
     */
    ImapEMailConnectionInfo: EMailConnectionInfo;
}
/**
 * Deleting a booking
 */
export interface Appointment_DeleteRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
    /**
     * If true, emails will be sent to all participants that is marked with send email flag. If false no mails will be sent even if the send email flag is true.
     */
    SendEmailToParticipants: boolean;
    /**
     * Login information for outgoing smtp email server. Will be null if no login information is relevant.
     */
    SmtpEMailConnectionInfo: EMailConnectionInfo;
    /**
     * Login information for imap server. Will be null if no login information is relevant.
     */
    ImapEMailConnectionInfo: EMailConnectionInfo;
}
/**
 * Calculates the set of dates that represents a recurrence pattern. Adds conflict information to each date.
 * Returns RecurrenceInfo
 */
export interface Appointment_CalculateDaysRequest {
    /**
     *
     */
    AppointmentEntity: AppointmentEntity;
}
/**
 * Validates the set of dates to calculate any conflicts.
 * Returns RecurrenceDate[]
 */
export interface Appointment_ValidateDaysRequest {
    /**
     *
     */
    AppointmentEntity: AppointmentEntity;
    /**
     * The dates to validate.
     */
    Dates: Date[];
}
/**
 * Creates a RecurrenceInfo object populated with the default values for the specific type.
 * Returns RecurrenceInfo
 */
export interface Appointment_CreateDefaultRecurrenceRequest {
}
/**
 * Assigning an appointment to another person.
 * Returns AppointmentEntity
 */
export interface Appointment_AssignToRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     *
     */
    Participant: ParticipantInfo;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Sets an appointment invitiation to seen.
 */
export interface Appointment_SetSeenRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Sets a list of appointment invitations to seen. The same update mode will be used for all appointments in this batch.
 */
export interface Appointment_SetSeenManyRequest {
    /**
     * List of appointment IDs
     */
    AppointmentIds: number[];
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Moving a booking to another start time.
 * Returns AppointmentEntity
 */
export interface Appointment_MoveRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * The new start time for the moved booking.
     */
    NewStartTime: Date;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Accept that an invited participant has rejected your invitation or assignment.
 * Returns AppointmentEntity
 */
export interface Appointment_AcceptRejectedRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Creates a RecurrenceInfo object populated with the default values for the specific type. Using startDate as start date for the recurreing pattern.
 * Returns RecurrenceInfo
 */
export interface Appointment_CreateDefaultRecurrenceByDateRequest {
    /**
     * Date of which the recurring pattern should start.
     */
    StartDate: Date;
}
/**
 * Deletes all appointments(within the appointmentIds array) with status BookingDeleted.
 * Returns number
 */
export interface Appointment_CleanUpBookingDeletedRequest {
    /**
     *
     */
    AppointmentIds: number[];
}
/**
 * Deletes all appointments(within the appointmentIds array) with status BookingDeleted. All appointments in the list will be deleted using the same recurrence update mode.
 */
export interface Appointment_CleanUpBookingDeletedWithUpdateModeRequest {
    /**
     * List of appointment IDs
     */
    AppointmentIds: number[];
    /**
     * Update mode
     */
    UpdateMode: enums.RecurrenceUpdateMode;
}
/**
 * Deletes all appointments with status BookingDeleted and for in logged user.
 * Returns number
 */
export interface Appointment_CleanUpRecurringBookingDeletedRequest {
}
/**
 * Creates a AppointmentEntity populated with the default values for the specific type and owner.
 * Returns AppointmentEntity
 */
export interface Appointment_CreateDefaultAppointmentEntityByTypeAndAssociateRequest {
    /**
     * The type of task requested.
     */
    Type: enums.TaskType;
    /**
     * The associateId of the appointment owner.
     */
    AssociateId: number;
}
/**
 * Check if current associate can create appointments in the diary of other associates.
 * Returns boolean[]
 */
export interface Appointment_GetCanInsertForAssociatesRequest {
    /**
     * Array of associate ids to check for.
     */
    AssociateIds: number[];
}
/**
 * GetAppointmentHaveParticipantsWithEmail will check if any of the participants is marked to receive emails on this appointment. If no participants are defined, false will be returned.
 * Returns boolean
 */
export interface Appointment_GetAppointmentHaveParticipantsWithEmailRequest {
    /**
     * The appointmentId.
     */
    AppointmentId: number;
}
/**
 * Creates an appointment based on a suggested appointment.
 * Returns AppointmentEntity
 */
export interface Appointment_CreateDefaultAppointmentEntityFromSaleSuggestionRequest {
    /**
     * The id of the suggested appointment
     */
    SuggestedAppointmentId: number;
    /**
     * This is the id of the sale the appointment is connected to. This will be used to give the appointment it's starting date. If the id is 0 or invalid, we assume the start date is now
     */
    SaleId: number;
    /**
     * If this parameter is true, we override the suggested start time and create the appointment with the current date and time
     */
    CreateNow: boolean;
    /**
     *
     */
    OwnerId: number;
}
/**
 * Gets the next suggested appointment for a given sale (or rather a given sale's guide).
 * Returns SuggestedAppointment
 */
export interface Appointment_GetNextSuggestedAppointmentBySaleRequest {
    /**
     * The identifier of the (guided) sale from which we want to find a suggested appointment
     */
    SaleId: number;
    /**
     * The identifier of the appointment from which we calculate the next suggestion. The next suggested appointment is the subsequent appointment defined in the SoAdmin's sales guide.
     */
    CurrentAppointmentId: number;
    /**
     * If you want to get the next appointment step in a sales guide for an appointment which is not completed, this value must be true. In all other cases, this value should be false, as it would return the value of null if the current appointment is not completes.
     */
    SkipCompleteCheck: boolean;
}
/**
 * A re-open appointment should be created as a reminder to re-open the sale at a certain date with information regarding the stalled sale.
 * Returns AppointmentEntity
 */
export interface Appointment_CreateDefaultReOpenAppointmentRequest {
    /**
     * The identifier of the stalled sale from which we create a re-open appointment
     */
    SaleId: number;
}
/**
 *
 * Returns AppointmentEntity
 */
export interface Appointment_CreateDefaultAppointmentEntityFromProjectSuggestionRequest {
    /**
     *
     */
    SuggestedAppointmentId: number;
    /**
     *
     */
    ProjectId: number;
    /**
     *
     */
    CreateNow: boolean;
    /**
     *
     */
    OwnerId: number;
}
/**
 * Create an invitation record and an appointment with a given UID to reserve it if the UID is unused, otherwise null.
 * Returns AppointmentEntity
 */
export interface Appointment_CreateAppointmentForUIDRequest {
    /**
     *
     */
    AppointmentEntity: AppointmentEntity;
    /**
     * The UID associated with the appointment
     */
    UID: string;
}
/**
 * Get the appointment that corresponds to the given UID.
 * Returns AppointmentEntity
 */
export interface Appointment_GetAppointmentFromUIDRequest {
    /**
     * The UID associated with the appointment
     */
    UID: string;
}
/**
 *
 * Returns boolean
 */
export interface Appointment_CanAssignToProjectMemberRequest {
    /**
     *
     */
    ProjectId: number;
    /**
     *
     */
    SuggestedAppointmentId: number;
}
/**
 * Get the UID associated with the appointment id in the Invitation table.
 * Returns string
 */
export interface Appointment_GetUIDFromAppointmentIdRequest {
    /**
     *
     */
    AppointmentId: number;
    /**
     * Uses motherId if no UID is found for appointmentId.
     */
    UseMotherId: boolean;
}
/**
 * Update the attendance to an appointment based on incoming ICS RSVPs.
 * Returns boolean
 */
export interface Appointment_UpdateAppointmentFromIcsResponseRequest {
    /**
     * The email-address of the person responding to our meeting-request.
     */
    EmailAddress: string;
    /**
     * The iCal ICS RSVP-content in byte-form.
     */
    IcsData: ArrayBuffer | string;
}
/**
 * Check that entity is ready for saving.
 * Returns StringDictionary
 */
export interface Appointment_ValidateAppointmentEntityRequest {
    /**
     * Entity to be checked.
     */
    AppointmentEntity: AppointmentEntity;
}
/**
 * Returns true if the changes will trigger email sending on Save, so you can inform the user.
 * Returns boolean
 */
export interface Appointment_WillSendEmailRequest {
    /**
     * The appointment carrier with changes made, before saving the changes.
     */
    Appointment: AppointmentEntity;
}
/**
 * Accepting an appointment invitation and send an email confirmation to the meeting organizer.
 */
export interface Appointment_AcceptWithSmtpEmailConfirmationRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
    /**
     * Login information for outgoing smtp email server. Will be null if no login information is relevant.
     */
    SmtpEMailConnectionInfo: EMailConnectionInfo;
}
/**
 * Rejecting an appointment invitation and send an email confirmation to the meeting organizer.
 */
export interface Appointment_RejectWithSmtpEmailConfirmationRequest {
    /**
     * The appointmentId. Both master and child record ids are accepted.
     */
    AppointmentId: number;
    /**
     * The reason the invitation was rejected.
     */
    RejectReason: string;
    /**
     * Update mode for a recurring appointment.
     */
    UpdateMode: enums.RecurrenceUpdateMode;
    /**
     * Login information for outgoing smtp email server. Will be null if no login information is relevant.
     */
    SmtpEMailConnectionInfo: EMailConnectionInfo;
}
/**
 * Method that returns a specified number of appointments within a time range. The appointments belong to the currently logged on user.
 * Returns Appointment[]
 */
export interface Appointment_GetMyAppointmentsRequest {
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of appointments within a time range. The appointments belong to the person specified. If the person not is a SuperOffice user (associate) or the logged on user is not allowed to view this persons appointments an exception is thrown.
 * Returns Appointment[]
 */
export interface Appointment_GetPersonAppointmentsRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectAppointments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user's diary. The appointments belong to the currently logged on user.
 * Returns Appointment[]
 */
export interface Appointment_GetMyDiaryRequest {
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user's task list. The appointments belong to the currently logged on user.
 * Returns Appointment[]
 */
export interface Appointment_GetMyTasksRequest {
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user's diary. The appointments belong to the person specified. If the person not is a SuperOffice user (associate) or the logged on user is not allowed to view this persons appointments an exception is thrown.
 * Returns Appointment[]
 */
export interface Appointment_GetPersonDiaryRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of appointments within a time range. It only returns appointments that would be displayed in the user's task list. The appointments belong to the person specified. If the person not is a SuperOffice user (associate) or the logged on user is not allowed to view this persons appointments an exception is thrown.
 * Returns Appointment[]
 */
export interface Appointment_GetPersonTasksRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the person specified.
 * Returns Appointment[]
 */
export interface Appointment_GetPersonAppointmentsByTypeRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectAppointments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The appointment type, e.g. inDiary, inChecklist etc.
     */
    AppointmentType: enums.AppointmentType;
}
/**
 * Method that returns a specified number of appointments within a time range. The appointments belong to the project specified. If the logged on user is not allowed to view this projects appointments an exception is thrown.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectAppointmentsRequest {
    /**
     * The project id
     */
    ProjectId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the project specified.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectAppointmentsByTypeRequest {
    /**
     * The project id
     */
    ProjectId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The appointment type, e.g. inDiary, inChecklist etc.
     */
    AppointmentType: enums.AppointmentType;
}
/**
 * Method that returns a specified number of appointments within a time range. The appointments belong to the contact specified. If the logged on user is not allowed to view this persons appointments an exception is thrown.
 * Returns Appointment[]
 */
export interface Appointment_GetContactAppointmentsRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the contact specified. If the logged on user is not allowed to view this contacts appointments an exception is thrown.
 * Returns Appointment[]
 */
export interface Appointment_GetContactAppointmentsByTypeRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The appointment type, e.g. inDiary, inChecklist etc.
     */
    AppointmentType: enums.AppointmentType;
}
/**
 * Method that returns a specified number of appointments within a time range. The appointments belong to the projects where the person specified is member.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectMemberAppointmentsRequest {
    /**
     * The project member's person id
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of appointments of a specific appointment type within a time range. The appointments belong to the projects where the person specified is member.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectMemberAppointmentsByTypeRequest {
    /**
     * The project member's person id
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The appointment type, e.g. inDiary, inChecklist etc.
     */
    AppointmentType: enums.AppointmentType;
}
/**
 * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the person specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
 * Returns Appointment[]
 */
export interface Appointment_GetPersonAppointmentsByTaskRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectAppointments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task id. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskId: number;
}
/**
 * Method that returns a specified number of appointments from a list of appointment task types within a time range. The appointments belong to the person specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
 * Returns Appointment[]
 */
export interface Appointment_GetPersonAppointmentsByTasksRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectAppointments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task ids as an integer array. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskIds: number[];
}
/**
 * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the person specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
 * Returns Appointment[]
 */
export interface Appointment_GetPersonAppointmentsByTaskHeadingRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectAppointments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskHeadingId: number;
}
/**
 * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the project specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectAppointmentsByTaskRequest {
    /**
     * The project id
     */
    ProjectId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task id. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskId: number;
}
/**
 * Method that returns a specified number of appointments matching the list of appointment task types within a time range. The appointments belong to the project specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectAppointmentsByTasksRequest {
    /**
     * The project id
     */
    ProjectId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task ids as an integer array. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskIds: number[];
}
/**
 * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the project specified.  Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectAppointmentsByTaskHeadingRequest {
    /**
     * The project id
     */
    ProjectId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskHeadingId: number;
}
/**
 * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the projects where the person specified is member. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectMemberAppointmentsByTaskRequest {
    /**
     * The project member's person id
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task id. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskId: number;
}
/**
 * Method that returns a specified number of appointments matching a set of appointment task types within a time range. The appointments belong to the projects where the person specified is member. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectMemberAppointmentsByTasksRequest {
    /**
     * The project member's person id
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task ids as an integer array. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskIds: number[];
}
/**
 * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the projects where the person specified is member. Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
 * Returns Appointment[]
 */
export interface Appointment_GetProjectMemberAppointmentsByTaskHeadingRequest {
    /**
     * The project member's person id
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskHeadingId: number;
}
/**
 * Method that returns a specified number of appointments of a specific appointment task type within a time range. The appointments belong to the contact specified. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
 * Returns Appointment[]
 */
export interface Appointment_GetContactAppointmentsByTaskRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task id. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskId: number;
}
/**
 * Method that returns a specified number of appointments belonging to an array of appointment task types within a time range. The appointments belong to the contact specified. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
 * Returns Appointment[]
 */
export interface Appointment_GetContactAppointmentsByTasksRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task ids as an integer array. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskIds: number[];
}
/**
 * Method that returns a specified number of appointments of a specific appointment task heading within a time range. The appointments belong to the contact specified. Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
 * Returns Appointment[]
 */
export interface Appointment_GetContactAppointmentsByTaskHeadingRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on.
     */
    TaskHeadingId: number;
}
/**
 * Get published appointment by appointment id.
 * Returns Appointment
 */
export interface Appointment_GetPublishedAppointmentRequest {
    /**
     * The appointment id
     */
    AppointmentId: number;
}
/**
 * Get published appointments by appointment ids.
 * Returns Appointment[]
 */
export interface Appointment_GetPublishedAppointmentsRequest {
    /**
     * The array of appointment ids
     */
    AppointmentIds: number[];
}
/**
 * Get published appointments from the logged in user.
 * Returns Appointment[]
 */
export interface Appointment_GetMyPublishedAppointmentsRequest {
}
/**
 * Get published appointments by project id.
 * Returns Appointment[]
 */
export interface Appointment_GetPublishedProjectAppointmentsRequest {
    /**
     * The project id
     */
    ProjectId: number;
}
/**
 * Method that returns appointments of a specific appointment task heading. Task represents the different types of activities, like “Phone call”, “Meeting” and so on. The heading represents a grouping or filtering of tasks.
 * Returns Appointment[]
 */
export interface Appointment_GetAppointmentsByTaskHeadingRequest {
    /**
     * The task heading id. The heading represents a grouping or filtering of tasks. Task represents the different types of activities, like “Phone call”, “Meeting” and so on
     */
    TaskHeadingId: number;
}
/**
 *
 * Returns Appointment[]
 */
export interface Appointment_GetAssociateDiaryRequest {
    /**
     *
     */
    AssociateId: number;
    /**
     *
     */
    StartTime: Date;
    /**
     *
     */
    EndTime: Date;
    /**
     *
     */
    Count: number;
}
/**
 *
 * Returns Appointment[]
 */
export interface Appointment_GetDiaryByGroupRequest {
    /**
     *
     */
    GroupId: number;
    /**
     *
     */
    GroupType: number;
    /**
     *
     */
    StartTime: Date;
    /**
     *
     */
    EndTime: Date;
    /**
     *
     */
    Count: number;
}
/**
 * Updates an appointment record.
 * Returns Appointment
 */
export interface Appointment_UpdateAppointmentRequest {
    /**
     *
     */
    Id: number;
    /**
     *
     */
    StartTime: Date;
    /**
     *
     */
    EndTime: Date;
    /**
     *
     */
    Status: number;
    /**
     *
     */
    Type: number;
    /**
     * The appointment owner's id (associate id)
     */
    AssociateId: number;
}
/**
 *
 * Returns Appointment[]
 */
export interface Appointment_GetAssociatesDiaryRequest {
    /**
     *
     */
    AssociateIds: number[];
    /**
     *
     */
    StartTime: Date;
    /**
     *
     */
    EndTime: Date;
}
/**
 * Get all records involved in a booking and/or recurring appointments. MotherId can be zero for repeating appointments or bookings, and recurrenceRuleId can be zero for bookings that are not repeating.
 * Returns Appointment[]
 */
export interface Appointment_GetAppointmentRecordsRequest {
    /**
     * Appointment id of the owner of a booking
     */
    MotherId: number;
    /**
     * RecurrenceId of a recuring appointment
     */
    RecurrenceRuleId: number;
}
/**
 *
 */
export interface AppointmentSyncData extends Carrier {
    /**
     * Date and time at which to show alarm
     */
    AlarmTime?: Date;
    /**
     * Primary key
     */
    AppointmentId?: number;
    /**
     * The appointment's textbox; holds a descriptive text about the appointment. Filled out by the user.
     */
    AppointmentText?: string;
    /**
     * The department of the contact connected to the appointment
     */
    ContactDepartment?: string;
    /**
     * The entire name of the contact, including department name
     */
    ContactFullName?: string;
    /**
     * The contact associated with the appointment.
     */
    ContactName?: string;
    /**
     * The contacts identifier
     */
    ContactId?: number;
    /**
     * Date + end time planned
     */
    EndDate?: Date;
    /**
     * Does this appointment have an alarm
     */
    HasAlarm?: boolean;
    /**
     *
     */
    IsAllDay?: boolean;
    /**
     *
     */
    IsAssignment?: boolean;
    /**
     *
     */
    IsBusy?: boolean;
    /**
     *
     */
    IsCompleted?: boolean;
    /**
     *
     */
    IsInvitation?: boolean;
    /**
     *
     */
    IsTentative?: boolean;
    /**
     * Location for appointment, defaulted from invited resource of type place and other rules, but you can write anything you want here
     */
    Location?: string;
    /**
     *
     */
    Participants?: ParticipantSyncData[];
    /**
     *
     */
    PersonFormalName?: string;
    /**
     * The full name of the person this appointment belongs to.
     */
    PersonFullName?: string;
    /**
     * Person ID of person the appointment is with, may be 0
     */
    PersonId?: number;
    /**
     * ID of project referred to, may be 0
     */
    ProjectId?: number;
    /**
     * Project name
     */
    ProjectName?: string;
    /**
     * Owning sale, if any (may be 0)
     */
    SaleId?: number;
    /**
     * Sale heading (short description?)
     */
    SaleName?: string;
    /**
     * date + start time planned
     */
    StartDate?: Date;
    /**
     *
     */
    TaskName?: string;
}
/**
 * Method that returns a specified number of appointments within a time range. The appointments belong to the currently logged on user.
 * Returns AppointmentSyncData[]
 */
export interface Appointment_GetMySyncAppointmentsRequest {
    /**
     * The start of the time interval in which we want appointments. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
}
/**
 * Get combined day information (activity + redletter summary) for one or more days according to the given date interval. The time portion of the dates is ignored. Private appointments are counted, but may not be visible through tooltips or other more detailed services.
 * Returns DayInformationListItem[]
 */
export interface Appointment_GetDayInformationListByDatesAndAssociateRequest {
    /**
     * Start date of interval. Time portion is ignored.
     */
    StartDate: Date;
    /**
     * End date of interval. Time portion is ignored.
     */
    EndDate: Date;
    /**
     * Associate id to identify the calendar to scan. If 0 is passed in, the currently authenticated associate is used instead.
     */
    AssociateId: number;
}
/**
 * Get activity information for one or more days according to the given date interval. The time portion of the dates is ignored. Private appointments are counted, but may not be visible through tooltips or other more detailed services.
 * Returns ActivityInformationListItem[]
 */
export interface Appointment_GetActivityInformationListByDatesAndAssociateRequest {
    /**
     * Start date of interval. Time portion is ignored.
     */
    StartDate: Date;
    /**
     * End date of interval. Time portion is ignored.
     */
    EndDate: Date;
    /**
     * Associate id to identify the calendar to scan. If 0 is passed in, the currently authenticated associate is used instead.
     */
    AssociateId: number;
}
/**
 * Get detailed red letter day information (redletter summary + individual day texts) for one or more days according to the given date interval. The time portion of the dates is ignored.
 * Returns RedLetterInformationListItem[]
 */
export interface Appointment_GetRedLetterInformationListByDatesAndAssociateRequest {
    /**
     * Start date of interval. Time portion is ignored.
     */
    StartDate: Date;
    /**
     * End date of interval. Time portion is ignored.
     */
    EndDate: Date;
    /**
     * Associate id to identify the calendar to scan. If 0 is passed in, the currently authenticated associate is used instead.
     */
    AssociateId: number;
}
/**
 * Summary information about the activites and holidaysfor one day
 */
export interface DayInformationListItem extends Carrier {
    /**
     * Activity information summary - number of free and busy activities.
     */
    ActivityInformation?: ActivitySummary;
    /**
     * Summary of redletter day information - holiday in own country, and in other countries known to the system.
     */
    RedLetterInformation?: RedLetterSummary;
    /**
     * Date that this item is valid for; there is exactly one item per date, ordered by date.
     */
    Date?: Date;
}
/**
 *
 */
export interface MultiAlarmData extends Carrier {
    /**
     *
     */
    Alarms?: AlarmData[];
    /**
     *
     */
    PollingInterval?: number;
    /**
     *
     */
    SilentAfter?: number;
}
/**
 *
 * Returns MultiAlarmData
 */
export interface Appointment_GetAlarmsRequest {
    /**
     *
     */
    IncludeInvitations: boolean;
    /**
     *
     */
    IncludeAllAppointments: boolean;
    /**
     *
     */
    DefaultAlarmLeadTimeInMinutes: number;
}
/**
 * Class representing an appointment participant.
 */
export interface ParticipantInfo {
    /**
     * Associate id of the participant if the participant is an associate (or resource)
     */
    AssociateId?: number;
    /**
     * Person id of the participant if the participant is a person
     */
    PersonId?: number;
    /**
     * Contact id of the participant if the participant is an associate or person
     */
    ContactId?: number;
    /**
     * The email id of the email belonging to the appointment record belonging to this person
     */
    EmailId?: number;
    /**
     * True if the participant has been sent an email or should be sent an email
     */
    SendEmail?: boolean;
    /**
     * The participant status for the appointment
     */
    InvitationStatus?: enums.InvitationStatus;
}
/**
 *
 */
export interface ParticipantSyncData extends Carrier {
    /**
     * Person ID of person the appointment is with, may be 0
     */
    PersonId?: number;
    /**
     * First name
     */
    PersonFirstName?: string;
    /**
     * Middle name or 'van' etc.
     */
    PersonMiddleName?: string;
    /**
     * Last name
     */
    PersonLastname?: string;
    /**
     * e.g. Mrs   sex_title
     */
    PersonMrmrs?: string;
    /**
     * Title
     */
    PersonTitle?: string;
    /**
     * The position. This is a predefined SuperOffice value, different from Title
     */
    PersonPosition?: string;
    /**
     * Academic title, populated from Salutation list but can be overwritten with anything at all
     */
    PersonAcademicTitle?: string;
    /**
     * Get formal name for a person, as used in labels. (Full name + person title + academic title)
     */
    PersonFormalName?: string;
    /**
     * The person's full name localized to the current culture/country.  (internal name used in clients for employees)
     */
    PersonFullName?: string;
    /**
     * Contact ID of owning contact, may be 0
     */
    ContactId?: number;
    /**
     * Contact name
     */
    ContactName?: string;
    /**
     * Department
     */
    ContactDepartment?: string;
    /**
     * The business that the contact is associated with. The GUI forces the user to enter a business type.
     */
    ContactBusiness?: string;
    /**
     *
     */
    ContactCountry?: string;
    /**
     * The category that is set on the company. The GUI forces the user to enter a category type
     */
    ContactCategory?: string;
    /**
     *
     */
    ContactFullName?: string;
    /**
     *
     */
    EMail?: string[];
    /**
     * Returns a collection of phone numbers that belong to the contact person.
     */
    PhonePrivate?: string[];
    /**
     * Returns a collection of fax numbers that belong to the contact person.
     */
    PhoneFax?: string[];
    /**
     * Returns a collection of mobile phone numbers that belong to the contact person.
     */
    PhoneMobile?: string[];
    /**
     *
     */
    PhoneDirect?: string[];
    /**
     * Returns a collection of office phone numbers that belong to the contact person.
     */
    PhoneContact?: string[];
    /**
     *
     */
    Messenger?: string[];
    /**
     *
     */
    Voip?: string[];
    /**
     * The contact's internet adresses
     */
    ContactUrl?: string[];
    /**
     * The urls related to this person.
     */
    Url?: string[];
    /**
     *
     */
    StreetAddress?: AddressSyncData;
    /**
     *
     */
    PostalAddress?: AddressSyncData;
    /**
     * The country this contact is located in. The country a contact is saved with, affects the phone number format, and the address layout.
     */
    Country?: string;
    /**
     *
     */
    PersonAddress?: AddressSyncData;
    /**
     * The country this contact person is located in.
     */
    PersonCountry?: string;
    /**
     * The appointment status for this participant.
     */
    ParticipantStatus?: enums.AppointmentStatus;
}
/**
 * Red letter day text details, all the texts related to the given day.
 */
export interface RedLetterDetails extends Carrier {
    /**
     * Array - possibly empty - of the texts related to one day in the redletter system.
     */
    OwnCountryDayTexts?: string[];
    /**
     * Red letter day texts for other countries than the associates' own country
     */
    OtherCountryDayTexts?: string[];
}
/**
 * Detailed information on red-letter days, including both holidays and other days with their individual texts.
 */
export interface RedLetterInformationListItem extends Carrier {
    /**
     * Date that this item is valid for; there is exactly one item per date, ordered by date.
     */
    Date?: Date;
    /**
     * Summary of redletter day information - holiday in own country, and in other countries known to the system.
     */
    RedLetterInformation?: RedLetterSummary;
    /**
     * Red letter day text details, all the texts related to the given day.
     */
    RedLetterDetails?: RedLetterDetails;
}
/**
 * Summary of redletter day information - holiday in own country, and in other countries known to the system.
 */
export interface RedLetterSummary extends Carrier {
    /**
     * If true, this day is a holiday in the country of the given associate.
     */
    IsOwnCountryHoliday?: boolean;
    /**
     * If true, this day is a holiday in at least one of the countries that has defined associates in the system, but not in the country of the associate whose diary is being scanned.
     */
    IsOtherCountryHoliday?: boolean;
}
/**
 *
 */
export interface SalesActivity extends Carrier {
    /**
     * The companies that match the request
     */
    RequestedContacts?: Contact[];
    /**
     * The person that matches the request.
     */
    RequestedPerson?: Person;
    /**
     * The sales representative for the person that matches the request.
     */
    SalesRep?: Person;
}
/**
 * Adds a sales lead (task) to a contact in SuperOffice. If the contact or person is known, the sales lead is added to the current contact. If not, a new contact is created, with the associate with ownerIdForNewContact as responsible (Our Contact). A relation is created between the contact and the person submitting the lead. Based on wether the person the request is made for is found or not, the following happens: If the person is found, the person, person's contact and sales representative is returned. If neither the person nor the contact is found a new person and contact is created (if sufficient data is supplied), and the person, person's contact and sales representative is returned. If the contact and not the person is found a new person is created on this contact, and the contact, salesrep, and person is returned (if there was enough data to return the person). If more than one contact is found a list of contacts is returned.
 * Returns SalesActivity
 */
export interface Appointment_GenerateLeadRequest {
    /**
     * Associate id of the person set as "Our Contact" if a new Contact is created. Ensures that the sales lead is assigned to the correct salesman.
     */
    AssociateIdForNewContact: number;
    /**
     * Description of the lead. The lead text as shown in SuperOffice
     */
    LeadDescription: string;
    /**
     * The relation the person submitting the lead has to the contact.
     */
    Relation: string;
    /**
     * Id of the relation type. Database specific.
     */
    RelationId: number;
    /**
     * Name of the new or existing contact (company) the lead is created for.
     */
    LeadContact: string;
    /**
     * Firstname of the contact's person.
     */
    LeadPersonFirstname: string;
    /**
     * Lastname of the contact's person.
     */
    LeadPersonLastname: string;
    /**
     * Email to the contact's person.
     */
    LeadPersonEmail: string;
    /**
     * Phone number of the contact or contact's person.
     */
    LeadPhoneNumber: string;
    /**
     * The contact (company) of the person creating the lead
     */
    CreatorsContact: string;
    /**
     * The firstname of the person creating the lead
     */
    CreatorsFirstname: string;
    /**
     * The lastname of the person creating the lead
     */
    CreatorsLastname: string;
}
/**
 * Submits a request for information. The request is added to the task list of the user that is responsible for this contact. Based on wether the person the request is made for is found or not, the following happens: If the person is found, the person, person's contact and sales representative is returned. If neither the person nor the contact is found a new person and contact is created (if sufficient data is supplied), and the person, person's contact and sales representative is returned. If the contact and not the person is found a new person is created on this contact, and the contact, salesrep, and person is returned (if there was enough data to return the person). If more than one contact is found a list of contacts is returned.
 * Returns SalesActivity
 */
export interface Appointment_RequestForInfoRequest {
    /**
     * Associate id of the person set as "Our Contact" if a new Contact is created. Ensures that the request is assigned to the correct salesman.
     */
    AssociateIdForNewContact: number;
    /**
     * The requested channel, e.g. "Phone"
     */
    Channel: string;
    /**
     * The text submitted by the user.
     */
    Regarding: string;
    /**
     * The name of the contact that the RFI will be added to. May be empty.
     */
    ContactName: string;
    /**
     * The firstname of the person that the RFI will be added to. May be empty.
     */
    PersonFirstname: string;
    /**
     * The lastname of the person that the RFI will be added to. May be empty.
     */
    PersonLastname: string;
    /**
     * The email address of the person that the RFI will be added to.
     */
    EmailAddress: string;
    /**
     * Phone number of the contact or contact's person.
     */
    PhoneNumber: string;
}
/**
 *
 */
export interface SuggestedAppointment extends Carrier {
    /**
     * Should this appointment be auto-suggested
     */
    AutoSuggest?: number;
    /**
     * 0 -> record is active 1 -> record is 'deleted' and should not be shown in lists
     */
    Deleted?: number;
    /**
     * How many days into the future the appointment should be scheduled
     */
    DaysFuture?: number;
    /**
     * Tooltip / description
     */
    Tooltip?: string;
    /**
     * The suggested text of the new appointment
     */
    Text?: string;
    /**
     * Type of the suggested appointment
     */
    TaskId?: number;
    /**
     * Primary key
     */
    SuggestedAppointmentId?: number;
    /**
     * Link to saleTypeStageLink, the anchor for sale guide items. Either this OR projectAnchorId should be set, not both at the same time.
     */
    SaleTypeStageLinkId?: number;
    /**
     * Registered by whom
     */
    RegisteredAssociateId?: number;
    /**
     * Rank, controls rank of non-instantiated items in Guide
     */
    Rank?: number;
    /**
     * Link to projectTypeStatusLink, the anchor for project guide items. Either this OR saleAnchorId should be set, not both at the same time.
     */
    ProjectTypeStatusLinkId?: number;
    /**
     * Item name, visible in Guide
     */
    Name?: string;
    /**
     * Duration in minutes of suggested appointment
     */
    Duration?: number;
    /**
     * The owner of the suggested activity. Always the same as the sales owner.
     */
    Associate?: Associate;
}
/**
 *
 */
export interface SuggestedAppointmentEntity extends Carrier {
    /**
     * Primary key
     */
    SuggestedAppointmentId?: number;
    /**
     * Item name, visible in Guide
     */
    Name?: string;
    /**
     * Tooltip / description
     */
    Tooltip?: string;
    /**
     * Rank, controls rank of non-instantiated items in Guide
     */
    Rank?: number;
    /**
     * 0 -> record is active 1 -> record is 'deleted' and should not be shown in lists
     */
    Deleted?: boolean;
    /**
     * How many days into the future the appointment should be scheduled
     */
    DaysFuture?: number;
    /**
     * Duration in minutes of suggested appointment
     */
    Duration?: moment.Duration;
    /**
     * Should this appointment be auto-suggested
     */
    AutoSuggest?: boolean;
    /**
     * Is this a milestone activity
     */
    IsMilestone?: boolean;
    /**
     * Should this appointment be assigned to project member
     */
    AssignToMember?: boolean;
    /**
     * The suggested text of the new appointment
     */
    Text?: string;
    /**
     * Project type and project status link info
     */
    ProjectTypeStatusLink?: ProjectTypeStatusLink;
    /**
     * Sale type and stage link info
     */
    SaleTypeStageLink?: SaleTypeStageLink;
    /**
     * Type of the suggested appointment
     */
    Type?: Task;
}
/**
 *
 */
export interface TaskListItem extends Carrier {
    /**
     * Primary key
     */
    TaskListItemId?: number;
    /**
     * The list item
     */
    Value?: string;
    /**
     * 1 = incoming, 2 = outgoing, see EAppntDirection
     */
    Direction?: enums.TaskDirection;
    /**
     * 1 = app, 2 = doc, 3 = email, 4 = fax, 5 = phone, 6 = todo - see EAppntRecordTypes
     */
    Type?: enums.TaskType;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * If true, the Task list item is deleted
     */
    Deleted?: boolean;
    /**
     * Link to the intention of this kind of task (used by SAINT)
     */
    IntentId?: number;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * True if all day event
     */
    IsDefaultAlldayEvent?: boolean;
    /**
     * True if free, false if busy
     */
    IsDefaultFree?: boolean;
    /**
     * Published to external persons
     */
    IsDefaultPublished?: boolean;
    /**
     * JAP
     */
    ColorIndex?: enums.ColorIndex;
    /**
     * Default video-meeting status for meetings created in SuperOffice CRM.
     */
    DefaultVideomeetingStatus?: enums.VideoMeetingStatus;
}
/**
 * Gets all takslist items
 * Returns TaskListItem[]
 */
export interface Appointment_GetTaskListItemsRequest {
    /**
     * Include deleted items
     */
    IncludeDeleted: boolean;
}
/**
 *
 */
export interface ForeignAppEntity extends Carrier {
    /**
     * Primary key
     */
    ForeignAppId?: number;
    /**
     * Name of foreign application
     */
    Name?: string;
    /**
     * Registered when
     */
    CreatedDate?: Date;
    /**
     * Last updated when
     */
    UpdatedDate?: Date;
    /**
     * The person that created the foreign application.
     */
    CreatedBy?: Associate;
    /**
     * The person that last updated this foreign application.
     */
    UpdatedBy?: Associate;
    /**
     * The devices that belong to this foreign app.
     */
    Devices?: ForeignDevice[];
}
/**
 * Gets the ForeignApp with the given name.
 * Returns ForeignAppEntity
 */
export interface ForeignSystem_GetAppByNameRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
}
/**
 * Gets all devices that belong to a foreign application.
 * Returns ForeignDevice[]
 */
export interface ForeignSystem_GetApplicationDevicesRequest {
    /**
     * The foreign application name
     */
    ApplicationName: string;
}
/**
 * Gets a ForeignDevice with deviceName that belongs to the application with applicationName.
 * Returns ForeignDevice
 */
export interface ForeignSystem_GetDeviceByNameRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
}
/**
 * Gets a ForeignDevice with deviceName and deviceIdentifier that belongs to the application with applicationName.
 * Returns ForeignDevice
 */
export interface ForeignSystem_GetDeviceByIdentifierRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * Optional unique id of device (Palm pilot device ID, version number, etc)
     */
    DeviceIdentifier: string;
}
/**
 * Adds a new ForeignDevice with deviceName that belongs to the application with applicationName, with an optional device-specific identifier.
 * Returns ForeignDevice
 */
export interface ForeignSystem_AddDeviceByIdentifierRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * Unique id of device (Palm pilot device ID, version number, etc)
     */
    DeviceIdentifier: string;
}
/**
 * Updates a ForeignDevice with deviceName that belongs to the application with applicationName.
 * Returns ForeignDevice
 */
export interface ForeignSystem_SaveDeviceByIdentifierRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * Unique id of device (Palm pilot device ID, version number, etc)
     */
    DeviceIdentifier: string;
    /**
     * Foreign device to save. Can be null if adding new device.
     */
    ForeignDevice: ForeignDevice;
}
/**
 * Delete a ForeignDevice with deviceName and deviceIdentifier that belongs to the application with applicationName.
 */
export interface ForeignSystem_DeleteDeviceByIdentifierRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * Unique id of device (Palm pilot device ID, version number, etc)
     */
    DeviceIdentifier: string;
}
/**
 * Returning a foreign key by its key name, that belongs to the specified device and application. A table name and record ID can also be specified.
 * Returns ForeignKey
 */
export interface ForeignSystem_GetKeyRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The name of the foreign key.
     */
    KeyName: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to indicate that your key is not bound to any specific table.
     */
    TableName: string;
    /**
     * Id of record that this key refers to. If the table name was blank, then this parameter must be 0. It can also be 0 to mean that the foreign key record was not bound to any particular record of the target table.
     */
    RecordId: number;
}
/**
 * Gets the string value of a ForeignKey, that belongs to the specified device and application. The table name and record ID must also be specified.
 * Returns string
 */
export interface ForeignSystem_GetKeyValueRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The name of the foreign key.
     */
    KeyName: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to indicate that your key is not bound to any specific table.
     */
    TableName: string;
    /**
     * Id of record that this key refers to. If the table name was blank, then this parameter must be 0. It can also be 0 to mean that the foreign key record was not bound to any particular record of the target table.
     */
    RecordId: number;
}
/**
 * Returning a foreign key by its key name and device identifier, that belongs to the specified device and application. A table name and record ID can also be specified.
 * Returns ForeignKey
 */
export interface ForeignSystem_GetKeyOnDeviceIdentifierRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The device identifier.
     */
    DeviceIdentifier: string;
    /**
     * The name of the foreign key.
     */
    KeyName: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to indicate that your key is not bound to any specific table.
     */
    TableName: string;
    /**
     * Id of record that this key refers to. If the table name was blank, then this parameter must be 0. It can also be 0 to mean that the foreign key record was not bound to any particular record of the target table.
     */
    RecordId: number;
}
/**
 * Returning a foreign key string value by its key name and device identifier, that belongs to the specified device and application. A table name and record ID can also be specified.
 * Returns string
 */
export interface ForeignSystem_GetKeyValueOnDeviceIdentifierRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The device identifier.
     */
    DeviceIdentifier: string;
    /**
     * The name of the foreign key.
     */
    KeyName: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to indicate that your key is not bound to any specific table.
     */
    TableName: string;
    /**
     * Id of record that this key refers to. If the table name was blank, then this parameter must be 0. It can also be 0 to mean that the foreign key record was not bound to any particular record of the target table.
     */
    RecordId: number;
}
/**
 * Add a new key belonging to the ForeignApp and ForeignDevice specified.
 * Returns ForeignKey
 */
export interface ForeignSystem_AddForeignKeyRequest {
    /**
     * Foreign key to save
     */
    ForeignKey: ForeignKey;
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The device identifier. Optional if device identifier is not used.
     */
    DeviceIdentifier: string;
}
/**
 * Saves a key belonging to the ForeignApp and ForeignDevice specified.
 * Returns ForeignKey
 */
export interface ForeignSystem_SaveForeignKeyRequest {
    /**
     * Foreign key to save
     */
    ForeignKey: ForeignKey;
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The device identifier. Optional if device identifier is not used.
     */
    DeviceIdentifier: string;
}
/**
 * Deletes all specified occurrences of a key, belonging to the ForeignApp and ForeignDevice, table and record specified. Specifying a blank table name will delete ALL keys of the given name; specifying a recordId of 0 will delete ALL keys of the given name for the given table.
 */
export interface ForeignSystem_DeleteForeignKeyOnNameRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The device identifier. Optional if device identifier is not used.
     */
    DeviceIdentifier: string;
    /**
     * The name of the foreign key to delete.
     */
    KeyName: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to delete ALL keys that otherwise match; this may be dangerous and can take a long time if there are many items to delete.
     */
    TableName: string;
    /**
     * Id of record that this key refers to. If the table name was blank, then this parameter must be 0. It can also be 0 to mean that the foreign key record was not bound to any particular record of the target table.<p/>Specifying a zero recordId will remove the recordId restriction and delete all keys that otherwise match.
     */
    RecordId: number;
}
/**
 * Get a foreignkey based on its name and value, that belongs to the specified device and application.
 * Returns ForeignKey
 */
export interface ForeignSystem_GetKeyByValueRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The name of the foreign key.
     */
    KeyName: string;
    /**
     * Foreignkey value
     */
    KeyValue: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to indicate that your key is not bound to any specific table.
     */
    TableName: string;
}
/**
 * Get a foreignkey based on its name and value, that belongs to the specified deviceId, device, and application.
 * Returns ForeignKey
 */
export interface ForeignSystem_GetKeyByValueAndIdentifierRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The device identifier. Optional if device identifier is not used.
     */
    DeviceIdentifier: string;
    /**
     * The name of the foreign key.
     */
    KeyName: string;
    /**
     * Foreignkey value
     */
    KeyValue: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to indicate that your key is not bound to any specific table.
     */
    TableName: string;
}
/**
 * Get a list of foreignkeys ('app.device.key') and their values ('123') that belong to the specified entity.
 * Returns StringDictionary
 */
export interface ForeignSystem_GetAllForeignKeysOnEntityRequest {
    /**
     * Entity type (table name): 'contact', 'project' etc.
     */
    EntityType: string;
    /**
     * Primary key of Entity
     */
    EntityId: number;
}
/**
 * Saves a foreign device belonging to the ForeignDevice and application name specified.
 */
export interface ForeignDevice extends Carrier {
    /**
     * Primary key
     */
    ForeignDeviceId?: number;
    /**
     * Name of device
     */
    Name?: string;
    /**
     * Registered when
     */
    CreatedDate?: Date;
    /**
     * Last updated when
     */
    UpdatedDate?: Date;
    /**
     * The person owning the Foreign Device
     */
    AssociateFullName?: string;
    /**
     * The person that created the device.
     */
    CreatedBy?: string;
    /**
     * The person that last updated this device.
     */
    UpdatedBy?: string;
    /**
     * Optional unique id of device (Palm pilot device ID, etc)
     */
    DeviceIdentifier?: string;
    /**
     * Reference to foregin application (device type)
     */
    ForeignAppId?: number;
}
/**
 * Saves a foreign device for an foreign application
 * Returns ForeignDevice
 */
export interface ForeignSystem_SaveForeignDeviceRequest {
    /**
     * Foreign device to save
     */
    ForeignDevice: ForeignDevice;
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
}
/**
 * Deletes a foreign device from an application
 */
export interface ForeignSystem_DeleteForeignDeviceRequest {
    /**
     * foreign device to delete
     */
    ForeignDevice: ForeignDevice;
    /**
     * Name of application to delete from
     */
    ApplicationName: string;
}
/**
 *
 */
export interface ForeignKey extends Carrier {
    /**
     * Subkey (optional)
     */
    Key?: string;
    /**
     * Key value
     */
    Value?: string;
    /**
     * Record in the referenced table
     */
    RecordId?: number;
    /**
     * Registered when
     */
    CreatedDate?: Date;
    /**
     * Last updated when
     */
    UpdatedDate?: Date;
    /**
     * Name of the person that last updated the foreign key
     */
    UpdatedBy?: string;
    /**
     * Name of the person that created the foreign key
     */
    CreatedBy?: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer
     */
    TableName?: string;
}
/**
 * Deletes all specified occurrences of a key, belonging to the ForeignApp and ForeignDevice, table and record specified. Specifying a blank table name will delete ALL keys of the given name; specifying a recordId of 0 will delete ALL keys of the given name for the given table.
 */
export interface ForeignSystem_DeleteForeignKeyRequest {
    /**
     * Key name to delete.
     */
    ForeignKey: ForeignKey;
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * The device identifier. Optional if device identifier is not used.
     */
    DeviceIdentifier: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to delete ALL keys that otherwise match; this may be dangerous and can take a long time if there are many items to delete.
     */
    TableName: string;
    /**
     * Id of record that this key refers to. If the table name was blank, then this parameter must be 0. It can also be 0 to mean that the foreign key record was not bound to any particular record of the target table.<p/>Specifying a zero recordId will remove the recordId restriction and delete all keys that otherwise match.
     */
    RecordId: number;
}
/**
 * Returns all ForeignKeys that belong to a device.
 * Returns ForeignKey[]
 */
export interface ForeignSystem_GetDeviceKeysRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
}
/**
 * Returns all ForeignKeys that belong to an application.
 * Returns ForeignKey[]
 */
export interface ForeignSystem_GetApplicationKeysRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
}
/**
 * Returns all ForeignKeys that belong to a device with a given deviceIdentifier.
 * Returns ForeignKey[]
 */
export interface ForeignSystem_GetDeviceKeysOnDeviceIdentifierRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * Identifier for a unique grouping of keys within a device.
     */
    DeviceIdentifier: string;
}
/**
 * Returns all ForeignKeys that belong to a device with a given deviceIdentifier and table name.
 * Returns ForeignKey[]
 */
export interface ForeignSystem_GetDeviceKeysOnDeviceIdentifierTableRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * Identifier for a unique grouping of keys within a device.
     */
    DeviceIdentifier: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to indicate that your key is not bound to any specific table.
     */
    TableName: string;
}
/**
 * Returns all ForeignKeys that belong to a device with a given deviceIdentifier and table name, as well as record id.
 * Returns ForeignKey[]
 */
export interface ForeignSystem_GetDeviceKeysOnDeviceIdentifierTableRecordIdRequest {
    /**
     * The name of the foreign application.
     */
    ApplicationName: string;
    /**
     * The name of the foreign device.
     */
    DeviceName: string;
    /**
     * Identifier for a unique grouping of keys within a device.
     */
    DeviceIdentifier: string;
    /**
     * Table name, transformed to and from numeric table id by the service layer.<p/>Use an empty string to indicate that your key is not bound to any specific table.
     */
    TableName: string;
    /**
     * Id of record that this key refers to. If the table name was blank, then this parameter must be 0. It can also be 0 to mean that the foreign key record was not bound to any particular record of the target table.
     */
    RecordId: number;
}
/**
 * Information about the checked-out state of one document, describing whether it is checked out, and to whom.
 */
export interface CheckoutInfo {
    /**
     * Checkout state
     */
    State?: enums.CheckoutState;
    /**
     * Id of associate who has currently checked out the document; 0 if it is not checked out,  or is checked out by someone who is not a SuperOffice user
     */
    AssociateId?: number;
    /**
     * Name of person who has currently checked out the document; blank if it is not checked out. This property may also be blank if the AssociateId is nonzero; NetServer will retrieve the associates' name as needed.
     */
    Name?: string;
}
/**
 * An instance of this class describes a custom command, declared and implemented by a document plugin
 */
export interface CommandInfo {
    /**
     * The programmatic name of the command, uniquely identifying this command for the document plugin.
     */
    Name?: string;
    /**
     * Display name, shown in menus, command lists and similar GUI elements.
     */
    DisplayName?: string;
    /**
     * Tooltip string associate with the command - can be a literal or a tooltip hint.
     */
    DisplayTooltip?: string;
    /**
     * Icon hint, which should resolve to an icon that is compatible in size with a standard menu or dropdown list font. May be blank.
     */
    IconHint?: string;
    /**
     * Declaration of what kind of return type the execution of this command will give.
     */
    ReturnType?: enums.ReturnType;
}
/**
 *
 */
export interface Document extends Carrier {
    /**
     * Primary key
     */
    DocumentId?: number;
    /**
     * Attention/salutation
     */
    Attention?: string;
    /**
     * Visible document name
     */
    Header?: string;
    /**
     * File name
     */
    Name?: string;
    /**
     * Our reference, searchable field from freetext search
     */
    OurRef?: string;
    /**
     * Your reference
     */
    YourRef?: string;
    /**
     * The actual text, max 2047 significant characters even though it is stored as a larger data type on some databases
     */
    Description?: string;
    /**
     *
     */
    DocumentTemplate?: string;
    /**
     * True if document have an entry in published table
     */
    IsPublished?: boolean;
    /**
     * Person ID of person the appointment is with, may be 0
     */
    PersonId?: number;
    /**
     * The full name of the person this document belongs to.
     */
    PersonFullName?: string;
    /**
     * The associate's culture formatted fullname (firstname, middleName and lastname)
     */
    AssociateFullName?: string;
    /**
     * Contact ID of owning contact, may be 0
     */
    ContactId?: number;
    /**
     * Contact name
     */
    ContactName?: string;
    /**
     * ID of project referred to, may be 0
     */
    ProjectId?: number;
    /**
     * Project name
     */
    ProjectName?: string;
    /**
     * ID of associate whose diary the appointment is in, REQUIRED
     */
    AssociateId?: number;
    /**
     * The sequence number allocated from refcount on used template when creating the document
     */
    Snum?: number;
    /**
     * Owning sale, if any (may be 0)
     */
    SaleId?: number;
    /**
     * Heading of Owning sale, if any. (may be blank)
     */
    SaleName?: string;
}
/**
 *
 */
export interface DocumentEntity extends Carrier {
    /**
     * Primary key
     */
    DocumentId?: number;
    /**
     * The person that last updated the appointment.
     */
    UpdatedBy?: Associate;
    /**
     * The person that first created the document. The property is read-only.
     */
    CreatedBy?: Associate;
    /**
     * Attention/salutation
     */
    Attention?: string;
    /**
     * Visible document name
     */
    Header?: string;
    /**
     * File name
     */
    Name?: string;
    /**
     * Our reference, searchable field from freetext search
     */
    OurRef?: string;
    /**
     * Your reference
     */
    YourRef?: string;
    /**
     * Registered when
     */
    CreatedDate?: Date;
    /**
     * Last updated when
     */
    UpdatedDate?: Date;
    /**
     * The actual text, max 2047 significant characters even though it is stored as a larger data type on some databases
     */
    Description?: string;
    /**
     * The template type of the document.
     * Use MDO List name "doctmpl" to get list items.
     */
    DocumentTemplate?: DocumentTemplate;
    /**
     * A document may also be connected to a person; this must be a contact person registered on the current company. This does not mean however that a person is required.
     * Use MDO List name "person" to get list items.
     */
    Person?: Person;
    /**
     * The owner of the document - the associate whose checklist the document is in.
     * Use MDO List name "associate" to get list items.
     */
    Associate?: Associate;
    /**
     * The contact associated with the document. It may also be null if no contact is associated with the document.
     * Use MDO List name "contact" to get list items.
     */
    Contact?: Contact;
    /**
     * A document may also be connected to a project, so you see the document both on the company card, and on the project card. This does not mean however that a project is required.
     * Use MDO List name "project" to get list items.
     */
    Project?: Project;
    /**
     * date + start time planned
     */
    Date?: Date;
    /**
     * External reference for document plugin to resolve document identity (Notes ID, e-mail message ID, whatever)
     */
    ExternalRef?: string;
    /**
     * Document Completed state. This is the part of the Status property.
     */
    Completed?: enums.ActivityStatus;
    /**
     * Number of active links to sale, document, appointment.
     */
    ActiveLinks?: number;
    /**
     * Is this a normal document or a mail-merge or report?
     */
    Type?: enums.AppointmentType;
    /**
     * List of all elements linked to the document.
     */
    Links?: Link[];
    /**
     *
     */
    LockSemantics?: enums.DocumentLockSemantics;
    /**
     * A document may also be connected to a sale, so you see the document on the company card, on the project card and on the sale card. This does not mean however that a sale is required. May be null.
     * Use MDO List name "sale" to get list items.
     */
    Sale?: Sale;
    /**
     * Suggested guide item that this document is an instance of (Note: NOT valid for appointments, they have their own link)
     */
    SuggestedDocumentId?: number;
    /**
     * The sequence number allocated from refcount on used template when creating the document
     */
    Snum?: number;
    /**
     * Dictionary of user defined field data.
     * The key string is the ProgId of the UdefField, or if the ProgId is empty it is a string of the format "SuperOffice:[UdefFieldIdentity]", e.g. "SuperOffice:1234"
     */
    UserDefinedFields?: StringDictionary;
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
    /**
     * Publish event date
     */
    PublishEventDate?: Date;
    /**
     * Publication valid to (inclusive)
     */
    PublishTo?: Date;
    /**
     * Publication valid from (inclusive)
     */
    PublishFrom?: Date;
    /**
     * Publication is published
     */
    IsPublished?: boolean;
    /**
     * The set of users or groups the record is visible for
     */
    VisibleFor?: VisibleFor[];
}
/**
 * Get the document as a stream
 * Returns Blob
 */
export interface Document_GetDocumentStreamFromEntityRequest {
    /**
     * The document entity object that refers to the binary data (document)
     */
    DocumentEntity: DocumentEntity;
}
/**
 * Store a document's contents from its stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
 * Returns DocumentEntity
 */
export interface Document_SetDocumentStreamRequest {
    /**
     * The document entity object that the binary data (document) should be stored to. Its file name may be amended by this call, see the return value
     */
    DocumentEntity: DocumentEntity;
    /**
     * The document as a stream.
     */
    Stream: ArrayBuffer | string;
    /**
     * If true, the stream will overwrite existing data stored for this record in the document archive; this works only for documents that already have a physical document in existence. If false, the call will only work for a document that has no physical document in the archive, and such a physical document will be created.
     */
    OverwriteExistingData: boolean;
}
/**
 * Creates a new Stream that can be used to store the document in the file archive.
 * Returns Blob
 */
export interface Document_CreateDocumentStreamRequest {
    /**
     * The document the stream belongs to
     */
    DocumentEntity: DocumentEntity;
    /**
     * If true, the stream will overwrite existing data stored for this record in the document archive
     */
    OverwriteExistingData: boolean;
}
/**
 * Retrieve a stream to a mail template based on its name
 * Returns Blob
 */
export interface Document_GetTemplateStreamRequest {
    /**
     * Filename of mail template to retrieve
     */
    TemplateName: string;
    /**
     * If true, try looking up template in personal area before looking in shared document template area
     */
    AllowPersonal: boolean;
    /**
     * Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    UiCulture: string;
}
/**
 * Retrieve a stream to a mail template based on its name. Sanitizes the contents if possible.
 * Returns Blob
 */
export interface Document_GetSanitizedTemplateStreamRequest {
    /**
     * Filename of mail template to retrieve
     */
    TemplateName: string;
    /**
     * If true, try looking up template in personal area before looking in shared document template area
     */
    AllowPersonal: boolean;
    /**
     * Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    UiCulture: string;
}
/**
 * Retrieve a stream to a document template based on its id
 * Returns Blob
 */
export interface Document_GetTemplateStreamFromIdRequest {
    /**
     * Id of template to retrieve
     */
    TemplateId: number;
    /**
     * Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    UiCulture: string;
}
/**
 * Retrieve a stream to a document template based on its id. Sanitizes the contents if possible.
 * Returns Blob
 */
export interface Document_GetSanitizedTemplateStreamFromIdRequest {
    /**
     * Id of template to retrieve
     */
    TemplateId: number;
    /**
     * Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    UiCulture: string;
}
/**
 * Get the document content as a stream
 * Returns Blob
 */
export interface Document_GetDocumentStreamRequest {
    /**
     * SuperOffice document id
     */
    DocumentId: number;
}
/**
 * Get the document content as a stream. Retrieves a sanitized version if possible
 * Returns Blob
 */
export interface Document_GetSanitizedDocumentStreamRequest {
    /**
     * SuperOffice document id
     */
    DocumentId: number;
}
/**
 * Get the preview version of the document content as a stream. Retrieves a sanitized version if possible
 * Returns DocumentPreview
 */
export interface Document_GetPreviewDocumentStreamRequest {
    /**
     * SuperOffice document id
     */
    DocumentId: number;
}
/**
 * Get the preview version of the document content as a stream. Retrieves an unsanitized version. This has less CPU impact but the caller must sanitize the content before presenting it to the user.
 * Returns DocumentPreview
 */
export interface Document_GetUnsanitizedPreviewDocumentStreamRequest {
    /**
     * SuperOffice document id
     */
    DocumentId: number;
}
/**
 * Create a new physical document based on the documents template. Do not replace template tags, as the document is going to be used as a mail merge source. Use GetDocumentStream to obtain the created documents. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
 * Returns DocumentEntity
 */
export interface Document_CreateNewPhysicalMailMergeDocumentFromTemplateRequest {
    /**
     * Identifier for a document. The template to use is stored in the document entity.
     */
    DocumentId: number;
    /**
     * Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    UiCulture: string;
}
/**
 * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id's.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
 * Returns DocumentEntity
 */
export interface Document_CreateNewPhysicalDocumentFromTemplateWithCustomTagsRequest {
    /**
     * Identifier for a contact. Defaults to document's contact if 0
     */
    ContactId: number;
    /**
     * Identifier for a person. Defaults to document's person if 0
     */
    PersonId: number;
    /**
     * identifier for an appointment. Defaults to document if 0
     */
    AppointmentId: number;
    /**
     * Identifier for the document
     */
    DocumentId: number;
    /**
     * Identifier for sale. Defaults to document's sale if 0.
     */
    SaleId: number;
    /**
     * identifier for selection.
     */
    SelectionId: number;
    /**
     * identifier for project. Defaults to document's project if 0
     */
    ProjectId: number;
    /**
     * Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     */
    CustomTags: string[];
    /**
     * Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     */
    CustomValues: string[];
    /**
     * Language variation of template to use when creating document. (ISO code - "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    UiCulture: string;
}
/**
 * Create a new physical document based on a document template and store it in the document archive.  Tags are substituted according to the provided id's.  Use GetDocumentStream to obtain the created document content. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
 * Returns DocumentEntity
 */
export interface Document_CreateNewPhysicalDocumentFromTemplateWithCustomTags2Request {
    /**
     * Identifier for a contact. Defaults to document's contact if 0
     */
    ContactId: number;
    /**
     * Identifier for a person. Defaults to document's person if 0
     */
    PersonId: number;
    /**
     * identifier for an appointment. Defaults to document if 0
     */
    AppointmentId: number;
    /**
     * Identifier for the document
     */
    DocumentId: number;
    /**
     * Identifier for sale. Defaults to document's sale if 0.
     */
    SaleId: number;
    /**
     * identifier for selection.
     */
    SelectionId: number;
    /**
     * identifier for project. Defaults to document's project if 0
     */
    ProjectId: number;
    /**
     * Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag.
     */
    CustomTags: StringDictionary;
    /**
     * Language variation of template to use when creating document. (ISO code - "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    UiCulture: string;
}
/**
 * Parse the source string, and replace any template variable tags with their values, based on the ID's given in the other parameters.
 * Returns string
 */
export interface Document_SubstituteTemplateVariablesRequest {
    /**
     * Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.<p/>Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     */
    Source: string;
    /**
     * Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     */
    GeneratorEncoding: enums.GeneratorEncoding;
    /**
     * Identifier for a contact
     */
    ContactId: number;
    /**
     * Identifier for a person
     */
    PersonId: number;
    /**
     * Identifier for an appointment
     */
    AppointmentId: number;
    /**
     * Identifier for a document
     */
    DocumentId: number;
    /**
     * Identifier for a sale
     */
    SaleId: number;
    /**
     * Identifier for a selection
     */
    SelectionId: number;
    /**
     * Identifier for a project
     */
    ProjectId: number;
    /**
     * Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     */
    CultureName: string;
}
/**
 * Parse the source string, and replace any template variable tags with their values, based on the ID's given in the other parameters.<p/>This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
 * Returns string
 */
export interface Document_SubstituteTemplateVariablesWithCustomTagsRequest {
    /**
     * Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.<p/>Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     */
    Source: string;
    /**
     * Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     */
    GeneratorEncoding: enums.GeneratorEncoding;
    /**
     * Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     */
    CustomTags: string[];
    /**
     * Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     */
    CustomValues: string[];
    /**
     * Identifier for a contact
     */
    ContactId: number;
    /**
     * Identifier for a person
     */
    PersonId: number;
    /**
     * Identifier for an appointment
     */
    AppointmentId: number;
    /**
     * Identifier for a document
     */
    DocumentId: number;
    /**
     * Identifier for a sale
     */
    SaleId: number;
    /**
     * Identifier for a selection
     */
    SelectionId: number;
    /**
     * Identifier for a project
     */
    ProjectId: number;
    /**
     * Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     */
    CultureName: string;
}
/**
 * Parse the source string, and replace any template variable tags with their values, based on the ID's given in the other parameters.<p/>This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
 * Returns string
 */
export interface Document_SubstituteTemplateVariablesWithCustomTags2Request {
    /**
     * Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.<p/>Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     */
    Source: string;
    /**
     * Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     */
    GeneratorEncoding: enums.GeneratorEncoding;
    /**
     * Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag.
     */
    CustomTags: StringDictionary;
    /**
     * Identifier for a contact
     */
    ContactId: number;
    /**
     * Identifier for a person
     */
    PersonId: number;
    /**
     * Identifier for an appointment
     */
    AppointmentId: number;
    /**
     * Identifier for a document
     */
    DocumentId: number;
    /**
     * Identifier for a sale
     */
    SaleId: number;
    /**
     * Identifier for a selection
     */
    SelectionId: number;
    /**
     * Identifier for a project
     */
    ProjectId: number;
    /**
     * Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     */
    CultureName: string;
}
/**
 * Create a new temporary file based on the provided stream.  Specified filename may be overridden, and actual name is returned.
 * Returns string
 */
export interface Document_CreateTempFileRequest {
    /**
     * Wanted name of file.
     */
    Filename: string;
    /**
     * Data to be added to the file.
     */
    DataStream: ArrayBuffer | string;
}
/**
 * Get data stream for temporary file created with CreateTempFile.
 * Returns Blob
 */
export interface Document_GetTempFileRequest {
    /**
     * Name of temporary file to retrieve.
     */
    Filename: string;
}
/**
 * Delete a temporary file created with CreateTempFile.
 */
export interface Document_DeleteTempFileRequest {
    /**
     * Name of temporary file to delete.
     */
    Filename: string;
}
/**
 * Save a mail signature template to the document archive
 */
export interface Document_SetTemplateStreamRequest {
    /**
     * Filename of template.
     */
    Filename: string;
    /**
     * If true, save the template in the user area, instead of in shared template area.
     */
    Personal: boolean;
    /**
     * The signature template content as a stream.
     */
    Stream: ArrayBuffer | string;
}
/**
 * Create a new document content based on a document template and store it in the document archive.  Tags are substituted according to the provided id's.  Use GetDocumentStream to obtain the created document. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
 * Returns DocumentEntity
 */
export interface Document_CreateNewPhysicalDocumentFromTemplateRequest {
    /**
     * Identifier for a contact. Defaults to document's contact if 0
     */
    ContactId: number;
    /**
     * Identifier for a person. Defaults to document's person if 0
     */
    PersonId: number;
    /**
     * identifier for an appointment. Defaults to document if 0
     */
    AppointmentId: number;
    /**
     * Identifier for a document. The document defines the template to use.
     */
    DocumentId: number;
    /**
     * Identifier for sale. Defaults to document's sale if 0.
     */
    SaleId: number;
    /**
     * identifier for selection.
     */
    SelectionId: number;
    /**
     * identifier for project. Defaults to document's project if 0
     */
    ProjectId: number;
    /**
     * Language variation of template to use when creating document content. (ISO code "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    UiCulture: string;
}
/**
 * Parse the source document, and replace any template variable tags with their values, based on the associate Id.<p/> The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
 * Returns Blob
 */
export interface Document_SubstituteMergeDocumentTemplateVariablesRequest {
    /**
     * The document id that refers to the binary data (document)
     */
    DocumentId: number;
    /**
     * The associateId used to subsitute tags in the document.
     */
    AssociateId: number;
    /**
     * Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     */
    CustomTags: string[];
    /**
     * Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     */
    CustomValues: string[];
}
/**
 * Parse the source document, and replace any template variable tags with their values, based on the associate Id.<p/> The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
 * Returns Blob
 */
export interface Document_SubstituteMergeDocumentTemplateVariables2Request {
    /**
     * The document id that refers to the binary data (document)
     */
    DocumentId: number;
    /**
     * The associateId used to subsitute tags in the document.
     */
    AssociateId: number;
    /**
     * Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag.
     */
    CustomTags: StringDictionary;
}
/**
 * Parse the source string, and replace any template variable tags with their values, based on the identities, custom values and entities specified in the other parameters.
 * Returns string
 */
export interface Document_SubstituteTemplateVariablesExRequest {
    /**
     * Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept whatever current culture is set on the server (possibly not a good choice in multinational organizations with a single server).
     */
    Parameters: TemplateVariablesParameters;
}
/**
 * Verify that the requested document stream exists, and that we can access it, without actually getting the stream.
 */
export interface Document_VerifyGetDocumentStreamRequest {
    /**
     * The document id that refers to the binary data (document)
     */
    DocumentId: number;
}
/**
 * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.<p/> The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
 * Returns Blob
 */
export interface Document_SubstituteMergeDocumentTemplateVariablesExRequest {
    /**
     * The document id that refers to the binary data (document)
     */
    MergeDocumentId: number;
    /**
     * The contact identifier to use for template substitution
     */
    ContactId: number;
    /**
     * The person identifier to use for template substitution
     */
    PersonId: number;
    /**
     * The project identifier to use for template substitution
     */
    ProjectId: number;
    /**
     * The selection identifier to use for template substitution
     */
    SelectionId: number;
    /**
     * The appointment identifier to use for template substitution
     */
    AppointmentId: number;
    /**
     * The document identifier to use for template substitution
     */
    DocumentId: number;
    /**
     * The sale identifier to use for template substitution
     */
    SaleId: number;
    /**
     * Array of custom tag names. Each name should have exactly four characters. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     */
    CustomTags: string[];
    /**
     * Array of values for custom tags. There should be exactly one value for each tag, i.e., the lengths of the customTags and customValues arrays should be the same.
     */
    CustomValues: string[];
}
/**
 * Parse the source document, and replace any template variable tags with their values, based on the provided identifiers.<p/> The source document should be of type MergeDraft. This method also takes a pair of arrays specifying custom tags and their values; these tags will be available during substitution in addition to all the existing tags. Custom values will override values otherwise set.
 * Returns Blob
 */
export interface Document_SubstituteMergeDocumentTemplateVariablesEx2Request {
    /**
     * The document id that refers to the binary data (document)
     */
    MergeDocumentId: number;
    /**
     * The contact identifier to use for template substitution
     */
    ContactId: number;
    /**
     * The person identifier to use for template substitution
     */
    PersonId: number;
    /**
     * The project identifier to use for template substitution
     */
    ProjectId: number;
    /**
     * The selection identifier to use for template substitution
     */
    SelectionId: number;
    /**
     * The appointment identifier to use for template substitution
     */
    AppointmentId: number;
    /**
     * The document identifier to use for template substitution
     */
    DocumentId: number;
    /**
     * The sale identifier to use for template substitution
     */
    SaleId: number;
    /**
     * Dictionary of custom tag names and values. Each name should have exactly four characters. There should be exactly one value for each tag
     */
    CustomTags: StringDictionary;
}
/**
 * Get a URL referring to the given document content.<para/>This URL may be passed to the ultimate client (text editor of some kind?), which is then responsible for all further operations.<para/>The returned string is a fully qualified URL.<para/>Not all documents and document plugins support this feature.
 * Returns string
 */
export interface Document_GetDocumentUrlRequest {
    /**
     * SuperOffice document primary key
     */
    DocumentId: number;
    /**
     * Version ID if applicable/desired; a blank value implies "latest" version and is always acceptable.
     */
    VersionId: string;
    /**
     * If true, then a URL that supports saving is requested. Som edocument plugins may not support read-only URLs, so there is no guarantee that a False value will actually yield a read-only URL, and vice versa.
     */
    WriteableUrl: boolean;
}
/**
 * Delete the document contents
 * Returns ReturnInfo
 */
export interface Document_DeletePhysicalDocumentRequest {
    /**
     * document primary key
     */
    DocumentId: number;
    /**
     * List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing. Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests
     */
    AllowedReturnType: string[];
}
/**
 * Rename the physical document, i.e., change the file name or equivalent concept in the document archive.
 * Returns string
 */
export interface Document_RenameDocumentRequest {
    /**
     * SuperOffice document ID
     */
    DocumentId: number;
    /**
     * Suggested new file name. The document archive may amend this to conform to uniqueness constraints, character range limitations etc.
     */
    NewFilename: string;
}
/**
 * Get the current checkout state for a document, relative to the user perforing the call.
 * Returns CheckoutInfo
 */
export interface Document_GetCheckoutStateRequest {
    /**
     * SuperOffice document ID
     */
    DocumentId: number;
}
/**
 * Check out a document for editing by the current user.
 * Returns ReturnInfo
 */
export interface Document_CheckoutDocumentRequest {
    /**
     * SuperOffice document ID
     */
    DocumentId: number;
    /**
     * List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     */
    AllowedReturnTypes: string[];
}
/**
 * Check in a currently checked-out document
 * Returns ReturnInfo
 */
export interface Document_CheckinDocumentRequest {
    /**
     * SuperOffice document Id
     */
    DocumentId: number;
    /**
     * List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     */
    AllowedReturnTypes: string[];
    /**
     * Optional textual description related to this version of the document; may be blank, and is discarded if the document/plugin do not support versioning.
     */
    VersionDescription: string;
    /**
     * Optional extra metadata related to the new version (as opposed to metadata related to the document as a whole). Discarded if the document/plugin do not support versioning.
     */
    VersionExtraFields: string[];
}
/**
 * Undo (abandon) a checkout
 * Returns ReturnInfo
 */
export interface Document_UndoCheckoutDocumentRequest {
    /**
     * SuperOffice document ID
     */
    DocumentId: number;
    /**
     * List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     */
    AllowedReturnTypes: string[];
}
/**
 * Get a list of existing, committed  versions for a given document
 * Returns VersionInfo[]
 */
export interface Document_GetVersionListRequest {
    /**
     * SuperOffice document Id
     */
    DocumentId: number;
}
/**
 * Get a list of installed document plugins
 * Returns StringDictionary
 */
export interface Document_GetPluginListRequest {
}
/**
 * Get a list of plugin-dependent capabilities for a given document archive plugin.<br/>A standard set of properties is defined in SuperOffice.CRM.Documents.Constants.Capabilities.
 * Returns StringDictionary
 */
export interface Document_GetPluginCapabilitiesRequest {
    /**
     * Numeric document plugin id, corresponding to the document.archiveProvider id or doctmpl.autoeventid.
     */
    PluginId: number;
}
/**
 * Get plugin-dependent properties for the document. A number of standard properties that should be supported by all plugins are defined in SuperOffice.CRM.Documents.Constants.Properties.
 * Returns StringDictionary
 */
export interface Document_GetDocumentPropertiesRequest {
    /**
     * SuperOffice document ID
     */
    DocumentId: number;
    /**
     * Array of property names whose values are being requested.
     */
    RequestedProperties: string[];
}
/**
 * Get a list of custom commands valid for the specific document at this time. This information should not be cached by clients, as it may change between documents and over time.
 * Returns CommandInfo[]
 */
export interface Document_GetDocumentCommandsRequest {
    /**
     * SuperOffice document ID
     */
    DocumentId: number;
    /**
     * List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.<br/>In this context the parameter is used to filter the returned command list, so that commands that require return actions not supported, will not be included by the document plugin.
     */
    AllowedReturnTypes: string[];
}
/**
 * Execute a custom command on a particular document, optionally a particular version
 * Returns ReturnInfo
 */
export interface Document_ExecuteDocumentCommandRequest {
    /**
     * SuperOffice document ID
     */
    DocumentId: number;
    /**
     * Version ID if applicable/desired; a blank value implies "latest" version and is always acceptable.
     */
    VersionId: string;
    /**
     * List of return types that the client is prepared to handle, in case the document plugin needs to request additional processing.<br/>Standard allowed return types include 'None', 'Message', 'SoProtocol', 'CustomGui', 'Other'.<br/>An empty array implies that the client places no restriction on possible return action requests.
     */
    AllowedReturnTypes: string[];
    /**
     * Command name, generally matching one of those returned from the GetDocumentCommands service. However, it is legal for document plugins to support commands that are not declared through GetDocumentCommands, for instance if a custom GUI needs to access plugin functionality.
     */
    Command: string;
    /**
     * Any additional data that the document command needs. This parameter can be used as a tunnel between a custom-programmed GUI and its plugin.<br/>It is suggested that the format is name=value, with one such pair per array item.
     */
    AdditionalData: string[];
}
/**
 *
 * Returns DocumentEntity
 */
export interface Document_CreateDefaultDocumentEntityFromSuggestionRequest {
    /**
     *
     */
    SuggestedDocumentId: number;
}
/**
 * Saves content in stream to document template file
 * Returns TemplateInfo
 */
export interface Document_SaveDocumentTemplateStreamRequest {
    /**
     * Identifier for document template
     */
    DocumentTemplateId: number;
    /**
     * Stream containing content to be saved to document template file
     */
    Content: ArrayBuffer | string;
    /**
     * Language variation of template to update. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    LanguageCode: string;
    /**
     * Plugin id. Use -1 to use the plugin specified in the template.
     */
    PluginId: number;
}
/**
 * Store document content from stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
 * Returns DocumentEntity
 */
export interface Document_SetDocumentStreamFromIdRequest {
    /**
     * The document entity object that the binary data (document) should be stored to. Its file name may be amended by this call, see the return value.
     */
    DocumentId: number;
    /**
     * The document content as a stream.
     */
    Stream: ArrayBuffer | string;
}
/**
 * Generates a Pdf from HTML and makes a document
 * Returns number
 */
export interface Document_SavePrivacyReportRequest {
    /**
     * Html to convert
     */
    HtmlReport: string;
    /**
     * Title of report
     */
    Title: string;
    /**
     * Person id associated with the report
     */
    PersonId: number;
}
/**
 * Check that entity is ready for saving, return error messages by field.
 * Returns StringDictionary
 */
export interface Document_ValidateDocumentEntityRequest {
    /**
     * Entity to be checked for errors.
     */
    DocumentEntity: DocumentEntity;
}
/**
 * Get length of the document content in bytes.
 * Returns number
 */
export interface Document_GetDocumentLengthRequest {
    /**
     * SuperOffice document id
     */
    DocumentId: number;
    /**
     * Version ID if applicable; a blank value implies "latest" version and is always acceptable.
     */
    VersionId: string;
}
/**
 * Get all documents that are linked to the appointment. I.e. the documents that are listed in the appointment dialog.
 * Returns Document[]
 */
export interface Document_GetAppointmentDocumentsRequest {
    /**
     * The appointment id.
     */
    AppointmentId: number;
}
/**
 * Get all documents that are linked to the sale. I.e. the documents that are listed in the sale dialog.
 * Returns Document[]
 */
export interface Document_GetSaleDocumentsRequest {
    /**
     * The sale id.
     */
    SaleId: number;
}
/**
 * Get all documents that are linked to the person. I.e. the documents that are listed in the person dialog.
 * Returns Document[]
 */
export interface Document_GetPersonDocumentsRequest {
    /**
     * The person id.
     */
    PersonId: number;
}
/**
 * Get the document if it's published
 * Returns Document
 */
export interface Document_GetPublishedDocumentRequest {
    /**
     * The document id
     */
    DocumentId: number;
}
/**
 * Get the published documents from an array of doucment ids.
 * Returns Document[]
 */
export interface Document_GetPublishedDocumentsRequest {
    /**
     * Array of document ids.
     */
    DocumentIds: number[];
}
/**
 *
 * Returns Document[]
 */
export interface Document_GetMyPublishedDocumentsRequest {
}
/**
 * Method that returns a specified number of published document appointments within a time range. The document appointments is visible to the person specified or the document is in a project the person belongs to.
 * Returns Document[]
 */
export interface Document_GetPublishedDocumentsByDateRequest {
    /**
     * The personId
     */
    PersonId: number;
    /**
     * Include projectDocuments to select documents in projects person is a member of.
     */
    IncludeProjectDocuments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the contact specified.
 * Returns Document[]
 */
export interface Document_GetContactDocumentsByTemplateTypesRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * Ids of the document template types to filter on.
     */
    DocumentTemplateIds: number[];
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the contact specified.
 * Returns Document[]
 */
export interface Document_GetContactDocumentsByTemplateTypeRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * Id of the document template type to filter on.
     */
    DocumentTemplateId: number;
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by the document template heading. The document appointments belong to the contact specified. The heading represents a grouping or filtering of document templates.
 * Returns Document[]
 */
export interface Document_GetContactDocumentsByTemplateHeadingRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The document template heading id. The heading represents a grouping or filtering of document templates.
     */
    TemplateHeadingId: number;
}
/**
 * Method that returns a specified number of document appointments within a time range. The document appointments belong to the contact specified.
 * Returns Document[]
 */
export interface Document_GetContactDocumentsRequest {
    /**
     * The contact id
     */
    ContactId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of published document appointments within a time range. The document appointments belong to the person specified or the document is in a project the person belongs to.
 * Returns Document[]
 */
export interface Document_GetPublishedPersonDocumentsByDateRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectDocuments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Get published appointment documents by project id.
 * Returns Document[]
 */
export interface Document_GetPublishedProjectDocumentsRequest {
    /**
     * The project id
     */
    ProjectId: number;
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project member specified.
 * Returns Document[]
 */
export interface Document_GetProjectMemberDocumentsByTemplateTypesRequest {
    /**
     * The project member's person id
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * Ids of the document template types to filter on.
     */
    DocumentTemplateIds: number[];
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project member specified.
 * Returns Document[]
 */
export interface Document_GetProjectMemberDocumentsByTemplateTypeRequest {
    /**
     * The project member's person id
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * Id of the document template type to filter on.
     */
    DocumentTemplateId: number;
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project member specified. The heading represents a grouping or filtering of document templates.
 * Returns Document[]
 */
export interface Document_GetProjectMemberDocumentsByTemplateHeadingRequest {
    /**
     * The project member's person id
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The document template heading id. The heading represents a grouping or filtering of document templates.
     */
    TemplateHeadingId: number;
}
/**
 * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project member specified.
 * Returns Document[]
 */
export interface Document_GetProjectMemberDocumentsRequest {
    /**
     * The project member's person id
     */
    PersonId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the project specified.
 * Returns Document[]
 */
export interface Document_GetProjectDocumentsByTemplateTypesRequest {
    /**
     * The project id
     */
    ProjectId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * Ids of the document template types to filter on.
     */
    DocumentTemplateIds: number[];
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the project specified.
 * Returns Document[]
 */
export interface Document_GetProjectDocumentsByTemplateTypeRequest {
    /**
     * The project id
     */
    ProjectId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * Id of the document template type to filter on.
     */
    DocumentTemplateId: number;
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the project specified. The heading represents a grouping or filtering of document templates.
 * Returns Document[]
 */
export interface Document_GetProjectDocumentsByTemplateHeadingRequest {
    /**
     * The project id
     */
    ProjectId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The document template heading id. The heading represents a grouping or filtering of document templates.
     */
    TemplateHeadingId: number;
}
/**
 * Method that returns a specified number of document appointments within a time range. The document appointments belong to the project specified.
 * Returns Document[]
 */
export interface Document_GetProjectDocumentsRequest {
    /**
     * The project id
     */
    ProjectId: number;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template types. The document appointments belong to the person specified.
 * Returns Document[]
 */
export interface Document_GetPersonDocumentsByTemplateTypesRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectDocuments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * Ids of the document template types to filter on.
     */
    DocumentTemplateIds: number[];
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template type. The document appointments belong to the person specified.
 * Returns Document[]
 */
export interface Document_GetPersonDocumentsByTemplateTypeRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectDocuments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * Id of the document template type to filter on.
     */
    DocumentTemplateId: number;
}
/**
 * Method that returns a specified number of document appointments within a time range, filtered by document template heading. The document appointments belong to the person specified. The heading represents a grouping or filtering of document templates.
 * Returns Document[]
 */
export interface Document_GetPersonDocumentsByTemplateHeadingRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectDocuments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
    /**
     * The document template heading id. The heading represents a grouping or filtering of document templates.
     */
    TemplateHeadingId: number;
}
/**
 * Method that returns a specified number of document appointments within a time range. The document appointments belong to the person specified.
 * Returns Document[]
 */
export interface Document_GetPersonDocumentsByDateRequest {
    /**
     * The person id of the SuperOffice user (associate).
     */
    PersonId: number;
    /**
     * If true, all appointments that belong to projects where the user is a project member are included as well as the appointments belonging to the person.
     */
    IncludeProjectDocuments: boolean;
    /**
     * The start of the time interval we want appointments from. This will usually be the current time.
     */
    StartTime: Date;
    /**
     * The end of the time interval.
     */
    EndTime: Date;
    /**
     * The maximum number of appointments that should be returned. -1 means no count restrictions.
     */
    Count: number;
}
/**
 * Method that returns document appointments, filtered by the document template heading. The heading represents a grouping or filtering of document templates.
 * Returns Document[]
 */
export interface Document_GetDocumentsByTemplateHeadingRequest {
    /**
     * The document template heading id. The heading represents a grouping or filtering of document templates.
     */
    TemplateHeadingId: number;
}
/**
 * Document data intended for preview purposes
 */
export interface DocumentPreview extends Carrier {
    /**
     * The documents name
     */
    Name?: string;
    /**
     * The mimetype of the stream
     */
    Type?: string;
    /**
     * Size of the stream
     */
    Size?: number;
    /**
     * Document data
     */
    Stream?: ArrayBuffer | string;
}
/**
 * Return value object for Document Plugin API calls
 */
export interface ReturnInfo {
    /**
     * The document plugin's key that uniquely identifies a document; stored in the externalReference field of the document table
     */
    ExternalReference?: string;
    /**
     * The document plugin's version id that uniquely identifies one version of a document. If versioning is not supported, this will be blank. When versioning is supported, blank values imply the latest checked-in version.
     */
    VersionId?: string;
    /**
     * id the call succeed. A successful call may still return a message or other return value.
     */
    Success?: boolean;
    /**
     * How is the return value to be understood by the caller
     */
    Type?: enums.ReturnType;
    /**
     * Return value, may be blank.
     */
    Value?: string;
    /**
     * Optional, additional information meant for further processing. This member is ignored for return types None, Message and SoProtocol. It can be used to pass execution-dependent information to the code that handles CustomGui and Other.
     */
    AdditionalInfo?: string;
}
/**
 *
 */
export interface SuggestedDocumentEntity extends Carrier {
    /**
     * Primary key
     */
    SuggestedDocumentId?: number;
    /**
     * Item name, visible in Guide
     */
    Name?: string;
    /**
     * Tooltip / description
     */
    Tooltip?: string;
    /**
     * Rank, controls rank of non-instantiated items in Guide
     */
    Rank?: number;
    /**
     * Type of the suggested document
     */
    DoctmplId?: number;
    /**
     * Suggested 'header'
     */
    Header?: string;
    /**
     * Suggested 'our reference'
     */
    OurRef?: string;
    /**
     * 0 -> record is active 1 -> record is 'deleted' and should not be shown in lists
     */
    Deleted?: boolean;
    /**
     * Document template
     */
    DocTmpl?: DocumentTemplate;
    /**
     * Project type and project status link info
     */
    ProjectTypeStatusLink?: ProjectTypeStatusLink;
    /**
     * Sale type and stage link info.
     */
    SaleTypeStageLink?: SaleTypeStageLink;
}
/**
 * Information about a document template, i.e., a document that generally contains unresolved merge tags and that is used as the source for creating new documents
 */
export interface TemplateInfo {
    /**
     * Name of the document, shown in lists etc to the user
     */
    Name?: string;
    /**
     * Document description, shown as a tooltip or in some extended description area
     */
    Description?: string;
    /**
     * Unique key that identifies the document so it can be retrieved
     */
    ExternalReference?: string;
    /**
     * ID of plugin that stores this template, so it can be retrieved
     */
    PluginId?: number;
}
/**
 * Parameters specifying source and properties for template variable substitution.
 */
export interface TemplateVariablesParameters extends Carrier {
    /**
     * Source string to parse for template variables. Such variables must have delimiters corresponding to the standard for the given generator encoding.Non-text source data (such as the binary content of a .doc file) should be passed in as Base64.
     */
    SourceInput?: string;
    /**
     * Encoding of source string. Non-text formats such as MsWord or Excel should be Base64 encoded in the source string.
     */
    Encoding?: enums.GeneratorEncoding;
    /**
     * Name of culture to be used for culture-sensitive data, such as dates or multi-language texts. Use a blank string to accept current culture that is set on the server.
     */
    CultureName?: string;
    /**
     * Identifier for a contact
     */
    ContactId?: number;
    /**
     * Identifier for a person
     */
    PersonId?: number;
    /**
     * Identifier for a project
     */
    ProjectId?: number;
    /**
     * Identifier for a selection
     */
    SelectionId?: number;
    /**
     * Identifier for an appointment
     */
    AppointmentId?: number;
    /**
     * Identifier for a document
     */
    DocumentId?: number;
    /**
     * Identifier for a sale
     */
    SaleId?: number;
    /**
     * Quote line id
     */
    QuoteLineId?: number;
    /**
     * Quote alternative id
     */
    QuoteAlternativeId?: number;
    /**
     * Product key
     */
    ProductKey?: string;
    /**
     * Array with custom tags and values. Array may be of unlimited height, but need to be exactly 2 in width.
     */
    CustomTags?: string[][];
    /**
     * Identifier for ticket
     */
    TicketId?: number;
    /**
     * Custom document entity to use for data retrieval. Useful for unsaved data.  DocumentEntity.DocumentId need to match the DocumentId specified in separate property.
     */
    DocumentEntity?: DocumentEntity;
}
/**
 * An instance of this class represents information about one version of one document
 */
export interface VersionInfo {
    /**
     * The document plugin's key that uniquely identifies a document; stored in the externalReference field of the document table
     */
    ExternalReference?: string;
    /**
     * The document Id that uniquely identifies the document within the SuperOffice database
     */
    DocumentId?: number;
    /**
     * The document plugin's version id that uniquely identifies one version of a document. If versioning is not supported, this will be blank. When versioning is supported, blank values imply the latest checked-in version.
     */
    VersionId?: string;
    /**
     * The date that this version was checked in and became official
     */
    CheckedInDate?: Date;
    /**
     * Name (nicely formatted) of the user/person who performed the checkin
     */
    CheckedInByName?: string;
    /**
     * Associate id of the user who performed the checkin
     */
    CheckedInByAssociateId?: number;
    /**
     * Arbitrary description string
     */
    Description?: string;
    /**
     * A short description, suitable for display in a popup menu or dropdown list of versions.
     */
    DisplayText?: string;
    /**
     * Private metadata, owned by the document plugin. This set of metadata is related directly to the version that  this VersioNinfo structure describes; metadata related to the document as a whole is retrieved using the SuperOffice.CRM.Documents.IDocumentPlugin2.LoadMetaData method.  The string should be formatted like a query string, i.e., name1=value1&amp;name2=value2... - this format, instead of a string/string dictionary avoids serialization problems, even though it is somewhat less efficient
     */
    ExtraFields?: string[];
}
/**
 *
 */
export interface AmountClassEntity extends Carrier {
    /**
     * Primary key
     */
    AmountClassId?: number;
    /**
     * The list item
     */
    Name?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Lower limit of this amount class
     */
    AmountFrom?: number;
    /**
     * Upper limit of this amount class
     */
    AmountTo?: number;
    /**
     * 0 -> record is active 1 -> record is 'deleted' and should not be shown in lists
     */
    Deleted?: boolean;
    /**
     * Currency the limits in this amount class refer to. Mixing currencies between classes can give rise to overlapping intervals and thus unpredictable classifications.
     */
    CurrencyId?: number;
}
/**
 *
 */
export interface Business extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all available businesses that a contact could have.
 * Returns Business[]
 */
export interface List_GetBusinessesRequest {
}
/**
 *
 */
export interface Category extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all categories a contact could belong to
 * Returns Category[]
 */
export interface List_GetCategoriesRequest {
}
/**
 *
 */
export interface Competitor extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all competitors
 * Returns Competitor[]
 */
export interface List_GetCompetitorsRequest {
}
/**
 * Configurable Menu Items are items that will be merged into menus in given area and entity
 */
export interface TaskMenu extends Carrier {
    /**
     * Primary key
     */
    TaskMenuId?: number;
    /**
     * The list item
     */
    Name?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * The name of entity that this task item can be used at
     */
    TableName?: string;
    /**
     * Can be Task or other that can identify which menu recipe to merge the item into
     */
    Area?: string;
    /**
     * The url or soprotocol
     */
    UrlOrSoprotocol?: string;
    /**
     * Type of task item Url, SoProtocol or CRMScript.
     */
    TaskType?: enums.TaskListItemType;
    /**
     * The CRMScript or Macro which will be run task item is selected.
     */
    CrmScriptId?: number;
    /**
     * Show task list item in which clients (web, mobile)
     */
    ShowInClient?: enums.ShowTaskItemInClient;
    /**
     * None, rightclick on, multiselect
     */
    ArchiveBehaviour?: enums.ArchiveBehaviour;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Encoding for url
     */
    Encoding?: enums.UrlEncoding;
    /**
     * String key that can be used to uniquely retrieve the task menu; particularly useful for partners and others who do not wish to store database ID's
     */
    ProgId?: string;
    /**
     * True if deleted
     */
    Deleted?: boolean;
}
/**
 * Get all task menus owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken
 * Returns TaskMenu[]
 */
export interface List_GetAppTaskMenusRequest {
}
/**
 * Permanentely delete all task menus owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken; otherwise nothing happens
 */
export interface List_DeleteAppTaskMenusRequest {
}
/**
 * Get a task menu using the ProgId key that was specified when it was created
 * Returns TaskMenu
 */
export interface List_GetTaskMenuByProgIdRequest {
    /**
     * String key that can be used to uniquely retrieve the taskmenu, set in the TaskMenu when saving
     */
    ProgId: string;
}
/**
 *
 */
export interface ConsentPurpose extends Carrier {
    /**
     * Primary key
     */
    ConsentPurposeId?: number;
    /**
     * Name of consent purpose
     */
    Name?: string;
    /**
     * Form text used for the actual checkbox
     */
    ConsentText?: string;
    /**
     * Text for the consent form, the long text to be shown when asking the end-user for this kind of consent
     */
    FormText?: string;
    /**
     * The key used to refer to this purpose, like #Process, #Emarketing etc.
     */
    Key?: string;
    /**
     * List item tooltip
     */
    Tooltip?: string;
    /**
     * Is the consent purpose active or not
     */
    Active?: number;
    /**
     * The date the consent purpose was last updated
     */
    UpdatedDate?: Date;
    /**
     * The associate that last updated the consent purpose
     */
    UpdatedBy?: Associate;
    /**
     * true if the ConsentPurpose is deleted
     */
    Deleted?: boolean;
    /**
     * Rank of this consent source
     */
    Rank?: number;
    /**
     * Name or description for the privacy statement
     */
    PrivacyStatementDesc?: string;
    /**
     * Url referencing the actual privacy statement
     */
    PrivacyStatementUrl?: string;
}
/**
 * Save a ConsentPurpose object
 * Returns ConsentPurpose
 */
export interface List_SaveConsentPurposeRequest {
    /**
     * The ConsentPurpose object to save
     */
    ConsentPurpose: ConsentPurpose;
}
/**
 * Turn on the Emarketing strict mode, which will enable full GDPR rules concerning Emarketing consents and subscriptions
 */
export interface List_SetEmarketingStrictModeRequest {
    /**
     * Set to true to enable strict mode
     */
    Enable: boolean;
}
/**
 * Get the value of the Emarketing strict mode setting
 * Returns boolean
 */
export interface List_GetEmarketingStrictModeRequest {
}
/**
 * Returns all defined purposes.
 * Returns ConsentPurpose[]
 */
export interface List_GetConsentPurposesRequest {
}
/**
 *
 */
export interface ConsentSource extends Carrier {
    /**
     * Primary key
     */
    ConsentSourceId?: number;
    /**
     * Name of consent source
     */
    Name?: string;
    /**
     * Tooltip for this consent source
     */
    Tooltip?: string;
    /**
     * Rank of this consent source
     */
    Rank?: number;
    /**
     * The key used to uniquely identify this consent source
     */
    Key?: string;
    /**
     * The mail template to use when automatically sending emails to new persons created with this consent source.
     */
    MailTemplateId?: number;
    /**
     * true if the ConsentSource is deleted
     */
    Deleted?: boolean;
}
/**
 *
 * Returns ConsentSource
 */
export interface List_SaveConsentSourceRequest {
    /**
     *
     */
    ConsentSource: ConsentSource;
}
/**
 * Returns all defined Sources.
 * Returns ConsentSource[]
 */
export interface List_GetConsentSourcesRequest {
}
/**
 *
 */
export interface Country extends Carrier {
    /**
     * Primary key
     */
    CountryId?: number;
    /**
     * Name of country in installed language
     */
    Name?: string;
    /**
     * Default currency for this country
     */
    CurrencyId?: number;
    /**
     * Name of country in english
     */
    EnglishName?: string;
    /**
     * Two-letter country-code according to ISO3166
     */
    TwoLetterISOCountry?: string;
    /**
     * Three-letter country-code according to ISO3166
     */
    ThreeLetterISOCountry?: string;
    /**
     * Description of the country's flag image. (This is the country flag that is displayed in the CRM client)
     */
    ImageDescription?: string;
    /**
     * Lead text for organisation field
     */
    OrgNrText?: string;
    /**
     * International prefix
     */
    InterAreaPrefix?: string;
    /**
     * Dial in prefix
     */
    DialInPrefix?: string;
    /**
     * Post prefix
     */
    ZipPrefix?: string;
    /**
     * Domain name of the country
     */
    DomainName?: string;
    /**
     * Address layout of the country
     */
    AddressLayoutId?: number;
    /**
     * Domestic address layout of the country
     */
    DomesticAddressLayoutId?: number;
    /**
     * Foreign address layout of the country
     */
    ForeignAddressLayoutId?: number;
    /**
     * The rank of the country
     */
    Rank?: number;
    /**
     * The tooltip of the country
     */
    Tooltip?: string;
    /**
     * true if the country is deleted
     */
    Deleted?: boolean;
}
/**
 * Saves a country
 * Returns Country
 */
export interface List_SaveCountryRequest {
    /**
     * The country to save
     */
    Country: Country;
}
/**
 * Gets a new country
 * Returns Country
 */
export interface List_CreateDefaultCountryRequest {
}
/**
 * Returns all available countries a contact or person could belong to.
 * Returns Country[]
 */
export interface List_GetCountriesRequest {
}
/**
 * Returns all available countries a contact or person could belong to.
 * Returns Country[]
 */
export interface List_GetAllCountriesRequest {
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 *
 */
export interface Credited extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all credited
 * Returns Credited[]
 */
export interface List_GetCreditedsRequest {
}
/**
 *
 */
export interface Currency extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Gets the Our currency object if currency is enabled
 * Returns Currency
 */
export interface List_GetOurCurrencyRequest {
}
/**
 * Recalculates the amount to the new currency.
 * Returns number
 */
export interface List_ChangeCurrencyRequest {
    /**
     * The amount in the old currency
     */
    Amount: number;
    /**
     * The old currency name
     */
    FromCurrency: string;
    /**
     * The new currency name
     */
    ToCurrency: string;
}
/**
 * Get the currency of the user's owner company
 * Returns Currency
 */
export interface List_GetOwnerCompanysCurrencyRequest {
}
/**
 *
 */
export interface CurrencyEntity extends Carrier {
    /**
     * Primary key
     */
    CurrencyId?: number;
    /**
     * The list item
     */
    Name?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Exchange rate
     */
    Rate?: number;
    /**
     * Exchange unit scale (0.01, 0.1, 1, 10, 100 etc)
     */
    Units?: number;
    /**
     * 0 -> record is active 1 -> record is 'deleted' and should not be shown in lists
     */
    Deleted?: boolean;
}
/**
 * Get the base currency, used for calculating exchange rates
 * Returns CurrencyEntity
 */
export interface List_GetBaseCurrencyRequest {
}
/**
 * Returns all currencies
 * Returns Currency[]
 */
export interface List_GetCurrenciesRequest {
}
/**
 * Returns all currencies
 * Returns CurrencyEntity[]
 */
export interface List_GetAllCurrenciesRequest {
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 * Customer languages that customer center supports.
 */
export interface CustomerLanguage extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 *
 * Returns CustomerLanguage[]
 */
export interface List_GetCustomerLanguagesRequest {
}
/**
 * The built-in delivery terms list. Used by the SuperOffice Quote Connector in quote versions.
 */
export interface DeliveryTerm extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all DeliveryTerms in SuperOffice db.
 * Returns DeliveryTerm[]
 */
export interface List_GetDeliveryTermsRequest {
}
/**
 * The built-in delivery types list. Used by the SuperOffice Quote Connector in quote versions.
 */
export interface DeliveryType extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all DeliveryTypes in SuperOffice db.
 * Returns DeliveryType[]
 */
export interface List_GetDeliveryTypesRequest {
}
/**
 * a.k.a. User Group
 */
export interface Department extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Getting all departments/user groups for the internal phone list with the user's colleagues.
 * Returns Department[]
 */
export interface List_GetDepartmentsRequest {
}
/**
 * The template a document is based on is stored in the SO_arc\template folder on the server. This will return the name as displayed in the GUI, and not the physical document name, of the template the document object is based on.
 */
export interface DocumentTemplate extends Carrier {
    /**
     * Primary key
     */
    DocumentTemplateId?: number;
    /**
     * The list item
     */
    Name?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * 1 = save document records in DB; otherwise not.
     */
    SaveInDb?: number;
    /**
     * Relative to TemplatePath
     */
    Filename?: string;
    /**
     * Processed via tag substitution to give document reference
     */
    DefaultOref?: string;
    /**
     * 1 = app, 2 = doc, 3 = email, 4 = fax, 5 = phone, 6 = todo - see EAppntRecordTypes
     */
    RecordType?: enums.DocTmplType;
    /**
     * 0 -> record is active 1 -> record is 'deleted' and should not be shown in lists
     */
    Deleted?: number;
    /**
     * 1 = incoming, 2 = outgoing, see EAppntDirection
     */
    Direction?: enums.DocTmplDirection;
    /**
     * Which document plugin is responsible for the documents generated from this template
     */
    AutoeventId?: number;
    /**
     * What type of quote document is this.
     */
    QuoteDocType?: enums.DocTmplQuoteType;
}
/**
 * The template a document is based on is stored in the SO_arc\template folder on the server. This will return the name as displayed in the GUI, and not the physical document name, of the template the document object is based on.
 */
export interface DocumentTemplateEntity extends Carrier {
    /**
     * Primary key
     */
    DocumentTemplateId?: number;
    /**
     * The template list item
     */
    Name?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * 1 = save document records in DB; otherwise not.
     */
    SaveInDb?: number;
    /**
     * Relative to TemplatePath, or extref for other document plugins. i.e URL or full path.
     */
    Filename?: string;
    /**
     * Processed via tag substitution to give document reference
     */
    DefaultOref?: string;
    /**
     * 1 = app, 2 = doc, 3 = email, 4 = fax, 5 = phone, 6 = todo - see EAppntRecordTypes
     */
    RecordType?: enums.DocTmplType;
    /**
     * True if deleted
     */
    Deleted?: boolean;
    /**
     * 1 = incoming, 2 = outgoing, see EAppntDirection
     */
    Direction?: enums.DocTmplDirection;
    /**
     * Which document plugin is responsible for the documents generated from this template
     */
    AutoeventId?: number;
    /**
     * What is the intention of this document (used by SAINT)
     */
    IntentId?: number;
    /**
     * Published to external persons
     */
    IsDefaultPublished?: boolean;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Which document plugin is responsible for this template's contents
     */
    LoadTemplateFromPlugin?: number;
    /**
     * The mime type
     */
    MimeType?: string;
    /**
     * True if the template is in use in a project or sales guide
     */
    IsInUseInGuides?: boolean;
    /**
     * The document type to use when creating a blank document. Plugin-specific. Used when not creating template from a local file.
     */
    DocumentTypeKey?: number;
    /**
     * The role this document plays in the Quote system, if any
     */
    QuoteDocType?: enums.DocTmplQuoteType;
    /**
     * Indicator that this document template has a functional role, related to privacy/GDPR
     */
    PrivacyDocType?: enums.DocTmplPrivacyType;
    /**
     * Subject to use if document template is an email.
     */
    EmailSubject?: string;
    /**
     * True if the email signature should be added in bottom of mail if this an email template
     */
    IncludeSignature?: boolean;
    /**
     * True if when using this template there should be shown a place for editing current choices of person, compant, sale, project etc
     */
    ShowCurrents?: boolean;
    /**
     * If email template, when DocType is Privacy or quote email, it is possible to make sender address like our contact, or our support contact, or always one address
     */
    SenderEmailMode?: enums.SenderMailMode;
    /**
     * If email template, default senderaddress when template is of type quote email or privacy email.
     */
    SenderEmailAddress?: string;
    /**
     * Type for sending email meeting invitation. Not an invitation type template = 0, New = 1, Changed = 2, Cancelled = 3
     */
    InvitationDocType?: enums.DocTmplInvitationType;
}
/**
 * Store a document template from its stream. Since there is a potential for a name conflict (the file name stored by the document entity earlier may prove to be invalid), the (possibly amended) document entity is returned. The client should not assume that any earlier, cached entity information is valid.
 * Returns DocumentTemplateEntity
 */
export interface List_SetDocumentTemplateStreamRequest {
    /**
     * The document entity object that the binary data (document) should be stored to. Its file name may be amended by this call, see the return value
     */
    DocumentTemplateEntity: DocumentTemplateEntity;
    /**
     * The document as a stream.
     */
    Stream: ArrayBuffer | string;
    /**
     * The language code ('en-US', 'nb-NO', etc). Use empty string if not supported or used.
     */
    LanguageCode: string;
    /**
     * The plugin id to store the template with. 0 for SOArc
     */
    PluginId: number;
}
/**
 * Get a String array of names in sales guide that this template is used in
 * Returns string[]
 */
export interface List_GetDocumentTemplateUsedInSalesStageRequest {
    /**
     * The id of the template
     */
    DocumentTemplateId: number;
}
/**
 * Get a String array of names in project guide that this template is used in
 * Returns string[]
 */
export interface List_GetDocumentTemplateUsedInProjectStageRequest {
    /**
     * The id of the template
     */
    DocumentTemplateId: number;
}
/**
 * Get a url to the document template
 * Returns string
 */
export interface List_GetDocumentTemplateUrlRequest {
    /**
     * The id of the template
     */
    DocumentTemplateId: number;
    /**
     * Get a writeable url to the document template?
     */
    WritableUrl: boolean;
    /**
     * The language code ('en-US', 'nb-NO', etc). Use empty string if not supported or used.
     */
    LanguageCode: string;
}
/**
 * Get document template properties
 * Returns StringDictionary
 */
export interface List_GetDocumentTemplatePropertiesRequest {
    /**
     * The primary key id of the document template
     */
    DocumentTemplateId: number;
    /**
     * An array of properties to get the values for
     */
    RequestedProperties: string[];
}
/**
 * Get the supported language variations for a document template
 * Returns string[]
 */
export interface List_GetDocumentTemplateLanguagesRequest {
    /**
     * The id of the document template
     */
    DocumentTemplateId: number;
}
/**
 * Create a new document template language based on an existing template
 */
export interface List_CreateDefaultDocumentTemplateLanguageRequest {
    /**
     * The id of the document template
     */
    DocumentTemplateId: number;
    /**
     * The language code ('en-US, 'nb-NO', etc)
     */
    LanguageCode: string;
}
/**
 * Deletes language variant of the document template
 */
export interface List_DeleteDocumentTemplateLanguageRequest {
    /**
     * The id of the document template
     */
    DocumentTemplateId: number;
    /**
     * The language code ('en-US, 'nb-NO', etc)
     */
    LanguageCode: string;
}
/**
 * Get the file extension for the document template
 * Returns string
 */
export interface List_GetDocumentTemplateExtensionRequest {
    /**
     * The primary key of the document template
     */
    DocumentTemplateId: number;
}
/**
 * Create a new document template based on another template
 * Returns DocumentTemplateEntity
 */
export interface List_SetDocumentTemplateFromDocumentTemplateRequest {
    /**
     * The document template to copy contents from.
     */
    SourceDocumentTemplateId: number;
    /**
     * The new document template entity
     */
    DocumentTemplateEntity: DocumentTemplateEntity;
}
/**
 * Retrieve a stream to a document template based on its id
 * Returns Blob
 */
export interface List_GetDocumentTemplateStreamFromIdRequest {
    /**
     * Id of template to retrieve
     */
    DocumentTemplateId: number;
    /**
     * Language variation of template to use. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    LanguageCode: string;
}
/**
 * Writes content in stream to document template file
 * Returns TemplateInfo
 */
export interface List_SaveDocumentTemplateStreamRequest {
    /**
     * Identifier for document template
     */
    DocumentTemplateId: number;
    /**
     * Stream containing content to be saved to document template file
     */
    Content: ArrayBuffer | string;
    /**
     * Language variation of template to update. (ISO code: "en-US" or "nb-NO" etc). Used to select a template of the appropriate language. Can be overridden in SO ARC by user preference "PreferDocLang".
     */
    LanguageCode: string;
    /**
     * Plugin to use for storing document content. 0 = SOARC. Use -1 to use the plugin specified in the template.
     */
    PluginId: number;
}
/**
 * Get a list of installed document plugins
 * Returns StringDictionary
 */
export interface List_GetPluginListRequest {
}
/**
 * Get a list of plugin-dependent capabilities for a given document archive plugin.<br/>A standard set of properties is defined in SuperOffice.CRM.Documents.Constants.Capabilities.
 * Returns StringDictionary
 */
export interface List_GetPluginCapabilitiesRequest {
    /**
     * Numeric document plugin id, corresponding to the document.archiveProvider id or doctmpl.AutoeventId.
     */
    PluginId: number;
}
/**
 * Get a list of document types supported by a given document plugin. Use the document template type when creating a new template.
 * Returns IntStringDictionary
 */
export interface List_GetDocumentTypesForPluginRequest {
    /**
     * Numeric document plugin id, corresponding to the doctmpl.AutoeventId, doctmpl.LoadTemplateFromPlugin.
     */
    PluginId: number;
}
/**
 * Returns all available document templates
 * Returns DocumentTemplate[]
 */
export interface List_GetDocumentTemplatesRequest {
}
/**
 * Returns all templates
 * Returns DocumentTemplateEntity[]
 */
export interface List_GetAllDocumentTemplatesRequest {
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 * Sets the document-plugin to be used for all templates of type 'document'.
 */
export interface List_SetDocumentPluginForAllDocumentTemplatesRequest {
    /**
     * The numerical ID of the document-plugin to use.
     */
    DocumentPluginId: number;
}
/**
 * The ext app entity contains information on an external application
 */
export interface ExtAppEntity extends Carrier {
    /**
     * The identity of the external app
     */
    ExtAppId?: number;
    /**
     * The name of the web panel
     */
    Name?: string;
    /**
     * The tooltip of the web panel
     */
    Tooltip?: string;
    /**
     * True if the application is marked as deleted
     */
    Deleted?: boolean;
    /**
     * The rank of the application
     */
    Rank?: number;
    /**
     * Filename of the programfile
     */
    Filename?: string;
    /**
     * <template variable> <other template variable>
     */
    Parameters?: string;
    /**
     * Directory set to current when loading the application, if different from application's own
     */
    Workdir?: string;
    /**
     * The application is shown in which state Minimized, Maximized or Restored
     */
    ShowState?: enums.ShowState;
    /**
     * The application is visible in
     */
    VisibleIn?: enums.Navigation;
    /**
     * Is the application visible when user is on central database
     */
    OnCentral?: boolean;
    /**
     * Is the application visible when user is on a satellite
     */
    OnSatellite?: boolean;
    /**
     * Is the application visible when user is on travel
     */
    OnTravel?: boolean;
    /**
     * Is the webpanel visible when user is on pocket client
     */
    OnSalesMarketingPocket?: boolean;
    /**
     * Does the application have a menu bar
     */
    ShowInMenuBar?: boolean;
    /**
     * Does the webpanel have a toolbar
     */
    ShowInToolBar?: boolean;
    /**
     * Does the webpanel have an address bar
     */
    ShowInAddressBar?: boolean;
    /**
     * Does the webpanel have a status bar
     */
    ShowInStatusBar?: boolean;
    /**
     * The id of the icon of the external app
     */
    Icon?: number;
    /**
     * True if the application shall wait for fininsh event
     */
    WaitToFinish?: boolean;
    /**
     * Events that cause automatic execution of this app
     */
    ExecuteOnEvent?: enums.ExecuteOnEvent;
    /**
     * Path where the programfile is located; if empty, PATH is used
     */
    Path?: string;
}
/**
 * The heading entity contains generic list item information
 */
export interface HeadingEntity extends Carrier {
    /**
     * Primary key
     */
    HeadingId?: number;
    /**
     * The visible heading
     */
    Name?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * True if the heading is marked as deleted
     */
    Deleted?: boolean;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * The id of the list which this heading belongs to
     */
    UdListDefinitionId?: number;
}
/**
 * Get a heading for the specified list defintion
 * Returns HeadingEntity
 */
export interface List_CreateDefaultHeadingFromListDefinitionRequest {
    /**
     * The id of the list definition, indicating which list to get the item from
     */
    UdListDefinitionId: number;
}
/**
 * Folder structures
 */
export interface HierarchyEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    HierarchyId?: number;
    /**
     * Domain seperating the different hierarchy
     */
    Domain?: enums.Domain;
    /**
     * Name of this hierarchy folder.
     */
    Name?: string;
    /**
     * The full name of this category, i.e. Foo/bar/test.
     */
    Fullname?: string;
    /**
     * Parent table
     */
    ParentId?: number;
    /**
     * Sub-items, if any.
     */
    Children?: HierarchyEntity[];
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Registered by whom
     */
    RegisteredAssociateId?: number;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Last updated by whom
     */
    UpdatedAssociateId?: number;
}
/**
 * Get list of all domains
 * Returns Domain[]
 */
export interface List_GetAllDomainsRequest {
}
/**
 * Get all items in a domain
 * Returns HierarchyEntity[]
 */
export interface List_GetAllInDomainRequest {
    /**
     * Type of items to get (scripts, extra tables, etc)
     */
    Domain: enums.Domain;
    /**
     * Include sub-items?
     */
    Children: boolean;
}
/**
 * Get a hierarchy item from a path
 * Returns HierarchyEntity
 */
export interface List_GetHierarchyFromPathRequest {
    /**
     * Type of items to get
     */
    Domain: enums.Domain;
    /**
     * Hierarchy path to item
     */
    Path: string;
    /**
     * Include sub-items?
     */
    Children: boolean;
}
/**
 * Add a hierarchy item to a path
 * Returns HierarchyEntity
 */
export interface List_AddHierarchyToPathRequest {
    /**
     * Type of items to get
     */
    Domain: enums.Domain;
    /**
     * Hierarchy path to parent item
     */
    Path: string;
    /**
     * Name of node to add
     */
    Name: string;
}
/**
 * Update a hierarchy item from a path
 * Returns HierarchyEntity
 */
export interface List_UpdateHierarchyFromPathRequest {
    /**
     * Type of items to get
     */
    Domain: enums.Domain;
    /**
     * Hierarchy path to item
     */
    Path: string;
    /**
     * The hierarchy node to update.
     */
    Entity: HierarchyEntity;
}
/**
 * Remove a hierarchy item and its children from a path
 */
export interface List_DeleteHierarchyFromPathRequest {
    /**
     * Type of items to get
     */
    Domain: enums.Domain;
    /**
     * Hierarchy path to item to delete
     */
    Path: string;
}
/**
 *
 */
export interface LanguageInfo extends Carrier {
    /**
     * Primary key
     */
    LanguageInfoId?: number;
    /**
     * Language/culture id as a numeric .NET code
     */
    LCID?: number;
    /**
     * English name of this language (Norwegian)
     */
    EnglishName?: string;
    /**
     * The native name of this language (Norsk Bokmål)
     */
    NativeName?: string;
    /**
     * ISO 3-letter abbreviation
     */
    ThreeLetterISOLanguageName?: string;
    /**
     * ISO 2-letter abbreviation
     */
    TwoLetterISOLanguageName?: string;
    /**
     * Has this row been inserted by SuperOffice priming data
     */
    IsBuiltIn?: boolean;
}
/**
 * Returns the list of all languages installed in this database.
 * Returns LanguageInfo[]
 */
export interface List_GetInstalledLanguagesRequest {
}
/**
 *
 */
export interface LegalBase extends Carrier {
    /**
     * Primary key
     */
    LegalBaseId?: number;
    /**
     * Name of legal base
     */
    Name?: string;
    /**
     * Tooltip for this consent source
     */
    Tooltip?: string;
    /**
     * Rank of this consent source
     */
    Rank?: number;
    /**
     * The key used to uniquely identify this legal base
     */
    Key?: string;
    /**
     * true if the LegalBase is deleted
     */
    Deleted?: boolean;
}
/**
 *
 * Returns LegalBase
 */
export interface List_SaveLegalBaseRequest {
    /**
     *
     */
    LegalBase: LegalBase;
}
/**
 * Returns all defined bases.
 * Returns LegalBase[]
 */
export interface List_GetLegalBasesRequest {
}
/**
 * Links two entities (contacts/projects/sales/URLs) together.
 */
export interface Link extends Carrier {
    /**
     * Name of the entity the link points to (The destination/target entity)
     */
    EntityName?: string;
    /**
     * Id of the entity the link points to (The destination/target entity primary key)
     */
    Id?: number;
    /**
     * Link description.
     */
    Description?: string;
    /**
     * Extrainfo for link. Use for information that does not have a primary key
     */
    ExtraInfo?: string;
    /**
     * Primary key
     */
    LinkId?: number;
}
/**
 * The list entity contains information about a specific list
 */
export interface ListEntity extends Carrier {
    /**
     * The identity of the list
     */
    Id?: number;
    /**
     * The name of the list
     */
    Name?: string;
    /**
     * The tooltip of the list
     */
    Tooltip?: string;
    /**
     * True if the list item is marked as deleted
     */
    Deleted?: boolean;
    /**
     * The rank of the list
     */
    Rank?: number;
    /**
     * Indicates if this is a custom list or a standard list
     */
    IsCustomList?: boolean;
    /**
     * Indicates if this is a MDO list
     */
    IsMDOList?: boolean;
    /**
     * Indicates if this list should use groups and headings
     */
    UseGroupsAndHeadings?: boolean;
    /**
     * The type of this list, often indicated by the database name, but not necessarily
     */
    ListType?: string;
    /**
     * True if this in use by one or more udfields
     */
    InUseByUserDefinedFields?: boolean;
}
/**
 * Get a list of the lists - built-in and user-defined.
 * Returns ListEntity[]
 */
export interface List_GetListDefinitionsRequest {
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 * Gets a ListEntity resolved by the provided name.
 * Returns ListEntity
 */
export interface List_GetListEntityByNameRequest {
    /**
     * The name of the list to look up.
     */
    Name: string;
}
/**
 * Save a ListEntity resolved by the provided name.
 * Returns ListEntity
 */
export interface List_SaveListEntityByNameRequest {
    /**
     * The name of the list to save.
     */
    Name: string;
    /**
     * The ListEntity to save.
     */
    ListEntity: ListEntity;
}
/**
 * Delete a ListEntity resolved by the provided name.
 */
export interface List_DeleteListEntityByNameRequest {
    /**
     * The name of the list to delete.
     */
    Name: string;
}
/**
 * Lightweight generic list item - similar to MDOListItem but without child items and stuff
 */
export interface ListItem {
    /**
     * Primary key
     */
    Id?: number;
    /**
     * Display text name
     */
    Name?: string;
    /**
     * Description
     */
    ToolTip?: string;
}
/**
 * The list item entity contains generic list item information
 */
export interface ListItemEntity extends Carrier {
    /**
     * The identity of the list item
     */
    Id?: number;
    /**
     * The name of the list item
     */
    Name?: string;
    /**
     * The tooltip of the list item
     */
    Tooltip?: string;
    /**
     * True if the list item is marked as deleted
     */
    Deleted?: boolean;
    /**
     * The id of the list which this list item belongs to
     */
    UdListDefinitionId?: number;
    /**
     * The rank of the list item
     */
    Rank?: number;
}
/**
 * Save the ListItemEntity.
 * Returns ListItemEntity
 */
export interface List_SaveListItemEntityRequest {
    /**
     * The ListItemEntity to save.
     */
    ListItemEntity: ListItemEntity;
}
/**
 * Sort the list items in a given list alphabetically
 */
export interface List_SortListItemsRequest {
    /**
     * Id of the list you want to sort. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * Sort list in this language
     */
    CultureName: string;
}
/**
 * Move a list item up or down in the list based on rank
 */
export interface List_MoveListItemRequest {
    /**
     * Id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * Id of the list item
     */
    ListItemId: number;
    /**
     * -1 moves the item up one position, 1 moves the item down one position
     */
    Direction: number;
}
/**
 * List of User groups that this list item is visible for
 * Returns SelectableMDOListItem[]
 */
export interface List_GetVisibleForUserGroupsRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The id of the list item
     */
    ListItemId: number;
}
/**
 * List of User groups that this list item is visible for
 * Returns SelectableMDOListItem[]
 */
export interface List_GetVisibleForUserGroupsFromListNameRequest {
    /**
     * The name of the list definition.
     */
    UdListDefinitionName: string;
    /**
     * The id of the list item
     */
    ListItemId: number;
}
/**
 * Update User groups that this list item is visible for
 * Returns SelectableMDOListItem[]
 */
export interface List_SetVisibleForUserGroupsRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The id of the list item
     */
    ListItemId: number;
    /**
     * The selectable user groups.
     */
    UserGroups: SelectableMDOListItem[];
}
/**
 * Update User groups that this list item is visible for
 * Returns SelectableMDOListItem[]
 */
export interface List_SetVisibleForUserGroupsFromListNameRequest {
    /**
     * The name of the list definition, indicating which list to update the items from.
     */
    UdListDefinitionName: string;
    /**
     * The id of the list item
     */
    ListItemId: number;
    /**
     * The selectable user groups.
     */
    UserGroups: SelectableMDOListItem[];
}
/**
 * Set a group which this list item should be visible for
 */
export interface List_SetVisibleForUserGroupRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The id of the list item
     */
    ListItemId: number;
    /**
     * The id of the user groups to set for this list item
     */
    UserGroupId: number[];
    /**
     * Set to true to enable, false to disable
     */
    Enable: boolean;
}
/**
 * List of list items that is visible in the usergroup
 * Returns SelectableMDOListItem[]
 */
export interface List_GetListItemsForUserGroupRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The id of the usergroup
     */
    GroupId: number;
}
/**
 * List of list items that is visible in the usergroup
 * Returns SelectableMDOListItem[]
 */
export interface List_GetListItemsForUserGroupFromListNameRequest {
    /**
     * The name of the list definition.
     */
    UdListDefinitionName: string;
    /**
     * The id of the usergroup
     */
    GroupId: number;
}
/**
 * Update listItems that will be visible for this usergroup
 */
export interface List_SetListItemsForUserGroupRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The id of the userGroup
     */
    UsergroupId: number;
    /**
     * The id of the list items.
     */
    ListItemIds: number[];
    /**
     * True to enable, false to disable
     */
    Enable: boolean;
}
/**
 * Update listItems that will be visible for this usergroup
 */
export interface List_SetListItemsForUserGroupFromListNameRequest {
    /**
     * The name of the list definition.
     */
    UdListDefinitionName: string;
    /**
     * The id of the userGroup
     */
    UsergroupId: number;
    /**
     * The id of the list items.
     */
    ListItemsID: number[];
    /**
     * True to enable, false to disable
     */
    Enable: boolean;
}
/**
 * Gets a selectable MDO list of the headings for this list item
 * Returns SelectableMDOListItem[]
 */
export interface List_GetHeadingsRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The id of the list item
     */
    ListItemId: number;
    /**
     * Set to true if you want deleted headings
     */
    ShowDeleted: boolean;
}
/**
 * Gets a selectable MDO list of the headings for this list item
 * Returns SelectableMDOListItem[]
 */
export interface List_GetHeadingsForListItemFromListNameRequest {
    /**
     * The name of the list definition, indicating which list to delete the items from.
     */
    UdListDefinitionName: string;
    /**
     * The id of the list item
     */
    ListItemId: number;
    /**
     * Set to true if you want deleted headings
     */
    ShowDeleted: boolean;
}
/**
 * Saves the active headings for the list item.
 * Returns SelectableMDOListItem[]
 */
export interface List_SaveHeadingsForListItemFromListDefinitionRequest {
    /**
     * The id of the list definition, indicating which list to delete the items from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The identity of the list item to delete
     */
    ListItemId: number;
    /**
     * The headings to save.
     */
    Headings: SelectableMDOListItem[];
}
/**
 * Saves the headings for the list item.
 * Returns SelectableMDOListItem[]
 */
export interface List_SaveHeadingsForListItemFromListNameRequest {
    /**
     * The name of the list definition, indicating which list to update.
     */
    UdListDefinitionName: string;
    /**
     * The identity of the list item
     */
    ListItemId: number;
    /**
     * The headings to save.
     */
    Headings: SelectableMDOListItem[];
}
/**
 * List of list items that is selected if under this heading
 * Returns SelectableMDOListItem[]
 */
export interface List_GetListItemsForHeadingRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The id of the heading
     */
    HeadingId: number;
}
/**
 * List of list items that is selected if under this heading
 * Returns SelectableMDOListItem[]
 */
export interface List_GetListItemsForHeadingFromListNameRequest {
    /**
     * The name of the list definition.
     */
    UdListDefinitionName: string;
    /**
     * The id of the heading
     */
    HeadingId: number;
}
/**
 * Update listItems that will be visible for this usergroup
 */
export interface List_SetListItemsForHeadingRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The id of the heading
     */
    HeadingId: number;
    /**
     * The ids of the list items.
     */
    ListItemIds: number[];
    /**
     * True to enable, false to disable
     */
    Enable: boolean;
}
/**
 * Update listItems under this heading
 */
export interface List_SetListItemsForHeadingFromListNameRequest {
    /**
     * The name of the list definition.
     */
    UdListDefinitionName: string;
    /**
     * The id of the heading
     */
    HeadingId: number;
    /**
     * The ids of the list items.
     */
    ListItemIds: number[];
    /**
     * True to enable, false to disable
     */
    Enable: boolean;
}
/**
 * Set headings which this list item should be listed under
 */
export interface List_SetHeadingsForListItemRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The id of the list item
     */
    ListItemId: number;
    /**
     * The ids of the headings to set for this list item
     */
    HeadingIds: number[];
    /**
     * Set to true to enable, false to disable
     */
    Enable: boolean;
}
/**
 * Set rank order on headings
 */
export interface List_SetRankOnHeadingsRequest {
    /**
     * The id of the list. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The ids of the headings in the order you want
     */
    HeadingIds: number[];
}
/**
 * Set rank order on sale activity
 */
export interface List_SetRankOnSaleActivityRequest {
    /**
     * The id of the list
     */
    SaleTypeStageLinkId: number;
    /**
     * The ids of the items in the order you want
     */
    ItemsIds: number[];
}
/**
 * Set rank order on project document
 */
export interface List_SetRankOnSaleDocumentRequest {
    /**
     * The id of the list
     */
    SaleTypeStageLinkId: number;
    /**
     * The ids of the items in the order you want
     */
    ItemsIds: number[];
}
/**
 * Set rank order on project activity
 */
export interface List_SetRankOnProjectActivityRequest {
    /**
     * The id of the list
     */
    ProjectTypeStatusLinkId: number;
    /**
     * The ids of the items in the order you want
     */
    ItemsIds: number[];
}
/**
 * Set rank order on project document
 */
export interface List_SetRankOnProjectDocumentRequest {
    /**
     * The id of the list
     */
    ProjectTypeStatusLinkId: number;
    /**
     * The ids of the items in the order you want
     */
    ItemsIds: number[];
}
/**
 * Get all list items for the specified list defintion
 * Returns ListItemEntity[]
 */
export interface List_GetAllFromListDefinitionRequest {
    /**
     * The id of the list definition, indicating which list to get the item from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 * Get all list items for the specified list defintion
 * Returns ListItemEntity[]
 */
export interface List_GetAllFromListNameRequest {
    /**
     * The name of the list definition, indicating which list to get the item from.
     */
    UdListDefinitionName: string;
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 * Save all list items for the specified list defintion
 * Returns ListItemEntity[]
 */
export interface List_SaveAllFromListDefinitionRequest {
    /**
     * The id of the list definition, indicating which list to save the items to. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The list items
     */
    Items: ListItemEntity[];
}
/**
 * Save all list items for the specified list defintion
 * Returns ListItemEntity[]
 */
export interface List_SaveAllFromListNameRequest {
    /**
     * The name of the list definition, indicating which list to save the items to.
     */
    UdListDefinitionName: string;
    /**
     * The list items
     */
    Items: ListItemEntity[];
}
/**
 * Save a new list item for the specified list defintion
 * Returns ListItemEntity
 */
export interface List_AddFromListDefinitionRequest {
    /**
     * The name of the list definition, indicating which list to save the item to.
     */
    UdListDefinitionId: number;
    /**
     * The item to save
     */
    Item: ListItemEntity;
}
/**
 * Save a new list item for the specified list defintion
 * Returns ListItemEntity
 */
export interface List_AddFromListNameRequest {
    /**
     * The name of the list definition, indicating which list to save the item to.
     */
    UdListDefinitionName: string;
    /**
     * The item to save
     */
    Item: ListItemEntity;
}
/**
 * Marks all items in the list deleted
 */
export interface List_DeleteAllFromListDefinitionRequest {
    /**
     * The id of the list definition, indicating which list to delete the items from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
}
/**
 * Marks all items in the list deleted
 */
export interface List_DeleteAllFromListNameRequest {
    /**
     * The name of the list definition, indicating which list to delete the items from.
     */
    UdListDefinitionName: string;
}
/**
 * Get a list item for the specified list defintion
 * Returns ListItemEntity
 */
export interface List_GetFromListDefinitionRequest {
    /**
     * The identity of the list item to load
     */
    Id: number;
    /**
     * The id of the list definition, indicating which list to get the item from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
}
/**
 * Get a list item for the specified list defintion
 * Returns ListItemEntity
 */
export interface List_GetFromListNameRequest {
    /**
     * The identity of the list item to load
     */
    Id: number;
    /**
     * The name of the list definition, indicating which list to get the item from.
     */
    UdListDefinitionName: string;
}
/**
 * Save a list item for the specified list defintion
 * Returns ListItemEntity
 */
export interface List_SaveFromListDefinitionRequest {
    /**
     * The identity of the list item to load
     */
    Id: number;
    /**
     * The id of the list definition, indicating which list to save the item to. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
    /**
     * The item to save
     */
    Item: ListItemEntity;
}
/**
 * Save a list item for the specified list defintion
 * Returns ListItemEntity
 */
export interface List_SaveFromListNameRequest {
    /**
     * The identity of the list item to load
     */
    Id: number;
    /**
     * The name of the list definition, indicating which list to save the item to.
     */
    UdListDefinitionName: string;
    /**
     * The item to save
     */
    Item: ListItemEntity;
}
/**
 * Delete a list item from the specified list defintion
 */
export interface List_DeleteFromListDefinitionRequest {
    /**
     * The identity of the list item to delete
     */
    Id: number;
    /**
     * The id of the list definition, indicating which list to delete the items from. Negative numbers indicate TableNumber value instead of UDListDefId. e.g. -64 = category.
     */
    UdListDefinitionId: number;
}
/**
 * Delete a list item from the specified list defintion
 */
export interface List_DeleteFromListNameRequest {
    /**
     * The identity of the list item to delete
     */
    Id: number;
    /**
     * The name of the list definition, indicating which list to delete the items from.
     */
    UdListDefinitionName: string;
}
/**
 * Gets headings for list resolved by the provided name.
 * Returns HeadingEntity[]
 */
export interface List_GetHeadingsFromNameRequest {
    /**
     * The name of the list to look up.
     */
    Name: string;
}
/**
 * Gets headings for list resolved by the provided id.
 * Returns HeadingEntity[]
 */
export interface List_GetHeadingsFromListDefinitionRequest {
    /**
     * The id of the list to look up.
     */
    Id: number;
}
/**
 * Save headings for list resolved by the provided name.
 * Returns HeadingEntity[]
 */
export interface List_SaveHeadingsFromNameRequest {
    /**
     * The name of the list to look up.
     */
    Name: string;
    /**
     * The headings to save
     */
    Entities: HeadingEntity[];
}
/**
 * Save headings for list resolved by the provided id.
 * Returns HeadingEntity[]
 */
export interface List_SaveHeadingsFromListDefinitionRequest {
    /**
     * The id of the list to look up.
     */
    Id: number;
    /**
     * The headings to save
     */
    Entities: HeadingEntity[];
}
/**
 * Save new heading for list resolved by the provided name.
 * Returns HeadingEntity
 */
export interface List_SaveHeadingFromNameRequest {
    /**
     * The name of the list to look up.
     */
    Name: string;
    /**
     * The new heading to save
     */
    Entity: HeadingEntity;
}
/**
 * Save new heading for list resolved by the provided id.
 * Returns HeadingEntity
 */
export interface List_SaveHeadingFromListDefinitionRequest {
    /**
     * The id of the list to look up.
     */
    Id: number;
    /**
     * The new heading to save
     */
    Entity: HeadingEntity;
}
/**
 * Delete all headings for list resolved by the provided name.
 */
export interface List_DeleteAllHeadingsFromNameRequest {
    /**
     * The name of the list to look up.
     */
    Name: string;
}
/**
 * Delete all headings for list resolved by the provided id.
 */
export interface List_DeleteAllHeadingsFromListDefinitionRequest {
    /**
     * The id of the list to look up.
     */
    Id: number;
}
/**
 *
 */
export interface LocalizedText extends Carrier {
    /**
     * Language id as LCID value
     */
    LanguageId?: number;
    /**
     * Resource ID
     */
    ResourceId?: number;
    /**
     * The text string itself
     */
    Text?: string;
    /**
     * The type of the text string, e.g. Field label, Udef label, etc.
     */
    Type?: enums.LocalizedTextType;
    /**
     * Primary key
     */
    LocalizedTextId?: number;
    /**
     * 1 = this row is populated and maintained by SuperOffice
     */
    IsBuiltIn?: boolean;
}
/**
 * Returns a localized text based on the resource id for the selected language.
 * Returns LocalizedText
 */
export interface List_GetLocalizedTextByTypeRequest {
    /**
     * Type of the localized text
     */
    TextType: enums.LocalizedTextType;
    /**
     * The resource id. This id has different meaning based on the LocalizedTextType.
     */
    ResourceId: number;
    /**
     * The LCID number of the language.
     */
    LanguageId: number;
}
/**
 * Gets all localized texts in the CRM database.
 * Returns LocalizedText[]
 */
export interface List_GetLocalizedTextsRequest {
}
/**
 * Gets all localized text belonging to a specific language.
 * Returns LocalizedText[]
 */
export interface List_GetLocalizedTextsByLanguageIdRequest {
    /**
     * The LCID number of the language.
     */
    LanguageId: number;
}
/**
 * Gets localized text by their type
 * Returns LocalizedText[]
 */
export interface List_GetLocalizedTextsByTypeRequest {
    /**
     * Array of LocalizedTextTypes. If null all texts are returned.
     */
    TextTypes: enums.LocalizedTextType[];
}
/**
 *
 */
export interface MrMrs extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all Items from the MrMrs table sorted by their value.
 * Returns MrMrs[]
 */
export interface List_GetMrMrsesRequest {
}
/**
 * The built-in payment terms list. Used by the SuperOffice Quote Connector to categorize quote versions.
 */
export interface PaymentTerm extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all PaymentTerms in SuperOffice db.
 * Returns PaymentTerm[]
 */
export interface List_GetPaymentTermsRequest {
}
/**
 * The built-in payment types list. Used by the SuperOffice Quote Connector in quote versions.
 */
export interface PaymentType extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all PaymentTypes in SuperOffice db.
 * Returns PaymentType[]
 */
export interface List_GetPaymentTypesRequest {
}
/**
 *
 */
export interface Position extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all the positions a person could have.
 * Returns Position[]
 */
export interface List_GetPositionsRequest {
}
/**
 *
 */
export interface Priority extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all priorities an appointment could have.
 * Returns Priority[]
 */
export interface List_GetPrioritiesRequest {
}
/**
 * The built-in product category list. Used by the SuperOffice Quote Connector to categorize products.
 */
export interface ProductCategory extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all ProductCategories in SuperOffice list.
 * Returns ProductCategory[]
 */
export interface List_GetProductCategoriesRequest {
}
/**
 * The built-in product family list. Used by the SuperOffice Quote Connector to categorize products.
 */
export interface ProductFamily extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all ProductFamily in SuperOffice list.
 * Returns ProductFamily[]
 */
export interface List_GetProductFamiliesRequest {
}
/**
 * The built-in product type list. Used by the SuperOffice Quote Connector to categorize products.
 */
export interface ProductType extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all ProductTypes in SuperOffice list.
 * Returns ProductType[]
 */
export interface List_GetProductTypesRequest {
}
/**
 *
 */
export interface ProjectStatus extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Deletes a project status
 */
export interface List_DeleteProjectStatusRequest {
    /**
     * The project status id to delete
     */
    ProjectStatusId: number;
}
/**
 * Gets all items from the Project Status (ProjStatus) table.
 * Returns ProjectStatus[]
 */
export interface List_GetProjectStatusesRequest {
}
/**
 *
 */
export interface ProjectType extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 *
 */
export interface ProjectTypeEntity extends Carrier {
    /**
     * Primary key
     */
    ProjTypeId?: number;
    /**
     * The list item
     */
    Name?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Units for the duration
     */
    DurationUnit?: enums.DurationUnit;
    /**
     * Expected duration of project, in given units
     */
    ProjectDuration?: number;
    /**
     * 0 -> record is active 1 -> record is 'deleted' and should not be shown in lists
     */
    Deleted?: boolean;
    /**
     * Does this project type have a guide attached
     */
    HasGuide?: boolean;
    /**
     * Does the project status advance automatically, when the last guided activity in a status is completed?
     */
    IsAutoAdvance?: boolean;
    /**
     * Stages (project statuses), those associated with this ProjType are selected.
     */
    Stages?: SelectableMDOListItem[];
}
/**
 * Gets all items from the Project Type (ProjType) table.
 * Returns ProjectType[]
 */
export interface List_GetProjectTypesRequest {
}
/**
 *
 */
export interface QuickReply extends Carrier {
    /**
     * Primary key
     */
    QuickReplyId?: number;
    /**
     * The short name of the quick reply
     */
    Name?: string;
    /**
     * The html body of the quick reply
     */
    HtmlBody?: string;
}
/**
 * Method to save all quick replies for a given associate
 */
export interface List_SaveQuickRepliesRequest {
    /**
     * Array of quick replies
     */
    QuickReplies: QuickReply[];
}
/**
 * Method to return all quick replies for a given associate
 * Returns QuickReply[]
 */
export interface List_GetQuickRepliesRequest {
}
/**
 * Sale Stage with probability percent.
 */
export interface Rating extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all ratings
 * Returns Rating[]
 */
export interface List_GetRatingsRequest {
}
/**
 * Returns all ratings
 * Returns SaleStageEntity[]
 */
export interface List_GetAllSaleStagesRequest {
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 * Reason for a lost sale
 */
export interface Reason extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all reasons
 * Returns Reason[]
 */
export interface List_GetReasonsRequest {
}
/**
 * List of quote approval reasons
 */
export interface QuoteApproveReason extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all available QuoteApproveReasons.
 * Returns QuoteApproveReason[]
 */
export interface List_GetQuoteApproveReasonsRequest {
}
/**
 * List of quote denial reasons
 */
export interface QuoteDenyReason extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all available QuoteDenyReasons.
 * Returns QuoteDenyReason[]
 */
export interface List_GetQuoteDenyReasonsRequest {
}
/**
 * Reason for a succesfully sold sale
 */
export interface ReasonSold extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 *
 */
export interface ReasonStalled extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * A relation definition entity with source and destination tables
 */
export interface RelationDefinitionEntity extends Carrier {
    /**
     * Primary key
     */
    ReldefId?: number;
    /**
     * Active text
     */
    Name?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * Text used in passive direction
     */
    PassiveText?: string;
    /**
     * True if deleted
     */
    Deleted?: boolean;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * The source of the relation
     */
    Source?: enums.RelationTarget;
    /**
     * The destination of the relation
     */
    Destination?: enums.RelationTarget;
}
/**
 * The resource entity contains resource information
 */
export interface ResourceEntity extends Carrier {
    /**
     * Primary key
     */
    ResourceId?: number;
    /**
     * Initials, also login name, possibly database user name
     */
    Name?: string;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * If true, the resource is deleted.
     */
    Deleted?: boolean;
    /**
     * If true the resource is a location
     */
    IsLocation?: boolean;
    /**
     * Address of location, if this is a resource that is a location
     */
    LocationAddress?: string;
}
/**
 * This entity represents a sale stage with a default percentage rating.
 */
export interface SaleStageEntity extends Carrier {
    /**
     * Primary key
     */
    SaleStageId?: number;
    /**
     * The sale stage
     */
    Value?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * The numeric probability of the sale
     */
    Probability?: number;
    /**
     * If true, the Sale stage is deleted
     */
    Deleted?: boolean;
    /**
     * Rank order
     */
    Rank?: number;
}
/**
 *
 */
export interface SaleType extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 *
 */
export interface SaleTypeEntity extends Carrier {
    /**
     * Primary key
     */
    SaleTypeId?: number;
    /**
     * The list item
     */
    Name?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Units for the duration (day, week, whatever)
     */
    DurationUnit?: enums.DurationUnit;
    /**
     * Expected number of dales from initiation to close of sale
     */
    SaleDuration?: number;
    /**
     * Category of sale type, copied to sale
     */
    SaleTypeCatId?: number;
    /**
     * 0 -> record is active 1 -> record is 'deleted' and should not be shown in lists
     */
    Deleted?: boolean;
    /**
     * Does this sale type have a guide attached
     */
    HasGuide?: boolean;
    /**
     * Does this sale type have stakeholders
     */
    HasStakeholders?: boolean;
    /**
     * Does the sale stage advance automatically, when the last guided activity in a stage is completed?
     */
    IsAutoAdvance?: boolean;
    /**
     * Can quotes linked to sales of this type, have multiple Alternatives
     */
    AllowQuoteAlternatives?: boolean;
    /**
     * Default valid days for quotes linked to sales of this type (valid from quote transmission)
     */
    DefaultQuoteValidity?: number;
    /**
     * The template that this sale type should use when producing the product lines offer document; the template must have DocTmplQuoteType=QuoteLines
     */
    QuoteLinesTemplate?: number;
    /**
     * The template that this sale type should use when producing the order confirmation lines document; the template must have DocTmplQuoteType=ConfirmationLines
     */
    ConfirmationLinesTemplate?: number;
    /**
     * Is there a limit, in percent, to the total discount on quotes linked to sales of this type
     */
    MaxDiscountPercentSet?: boolean;
    /**
     * Is there a limit, in earning as percent of total, on quotes linked to sales of this type
     */
    MinEarningPercentSet?: boolean;
    /**
     * The maximum discount in percent of total, if set, on quotes linked to sales of this type
     */
    MaxDiscountPercent?: number;
    /**
     * The minimum earning in percent of total, if set, on quotes linked to sales of this type
     */
    MinEarningPercent?: number;
    /**
     * Group quote lines by this field
     */
    GroupQuoteLinesBy?: number;
    /**
     * Sort group lines by this field
     */
    SortGroupLinesBy?: number;
    /**
     * Stages, those associated with this SaleType are selected.
     * Use MDO List name "salestage" to get list items.
     */
    Stages?: SelectableMDOListItem[];
}
/**
 * Returns all sale types as simple list items
 * Returns SaleType[]
 */
export interface List_GetAllSaleTypeRequest {
}
/**
 * Returns all sale types as entities with stakeholders, guide and quote properties
 * Returns SaleTypeEntity[]
 */
export interface List_GetAllSaleTypeEntitiesRequest {
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 *
 */
export interface SelectionCategory extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Source of a sale
 */
export interface Source extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns all sources
 * Returns Source[]
 */
export interface List_GetSourcesRequest {
}
/**
 *
 */
export interface Tag extends Carrier {
    /**
     * The Id of the ListItem
     */
    Id?: number;
    /**
     * The name of the ListItem
     */
    Name?: string;
    /**
     * The tooltip of the ListItem
     */
    ToolTip?: string;
}
/**
 * Type of an appointment
 */
export interface Task extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Returns a Document Template list item as a TaskListItem. The appointment's task is a Document template item when the appointment is a document.
 * Returns Task
 */
export interface List_GetDocumentTemplateTaskRequest {
    /**
     * Id of the document template, i.e. the Appointment.TaskIdx
     */
    DocumentTemplateId: number;
}
/**
 * Returns all appointment tasks
 * Returns Task[]
 */
export interface List_GetTasksRequest {
}
/**
 * The appointment's task is a Document template item when the appointment is a document.
 * Returns Task[]
 */
export interface List_GetDocumentTemplatesTasksRequest {
}
/**
 * Returns all appointment tasks
 * Returns TaskListItem[]
 */
export interface List_GetAllTasksRequest {
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 * Ticket Category - light read-only version of TicketCategoryEntity.
 */
export interface TicketCategory extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * This entity describes the meta data for a ticket category, and provides special operations on it.
 */
export interface TicketCategoryEntity extends Carrier {
    /**
     * The id of the ticket category. (primary key)
     */
    TicketCategoryId?: number;
    /**
     * The parent category for this category. -1 if this is a toplevel category.
     */
    ParentId?: number;
    /**
     * The (short) name of this category. E.g. &apos;support&apos;.
     */
    Name?: string;
    /**
     * The fullname (compiled from parents&apos; names) for this category. E.g. &apos;norway/product A/support&apos;.
     */
    Fullname?: string;
    /**
     * The user associated with this category.
     */
    CategoryMaster?: number;
    /**
     * A bitmask representing flags for this category.
     */
    Flags?: enums.TicketCategoryFlags;
    /**
     * An integer indicating the delegation method for this category.
     */
    DelegateMethod?: enums.TicketCategoryDelegateMethod;
    /**
     * The external name for this category, used for the customer frontend.
     */
    ExternalName?: string;
    /**
     * Determines the default status used in the GUI when creating a ticket
     */
    ClosingStatus?: enums.TicketCategoryClosingStatus;
    /**
     * Determines the default status used in the GUI when adding a request to a ticket
     */
    MsgClosingStatus?: enums.TicketCategoryClosingStatus;
    /**
     * Number of minutes we shall override the assignment if a customer sends consecutive messages to this category
     */
    AssignmentLag?: number;
    /**
     * Reply template to merge with messages posted in this category
     */
    ReplyTemplate?: number;
    /**
     * Comma separated list of addresses to notify when requests are redelegated to (unassigned) in this category.
     */
    NotificationEmail?: string;
    /**
     * Default status for new tickets, if 0 then there is a fallback to a user-dependent value
     */
    DefaultTicketStatus?: TicketStatusEntity;
    /**
     * Default status for new messages, if 0 then there is a fallback to a user-dependent value
     */
    DefaultMessageStatus?: TicketStatusEntity;
    /**
     * Id of reply template to merge into messages, whose ticket belongs to this category. Also takes into account 'Apply to subcategories' on parent categories. This is a calculated, readonly field.
     */
    EffectiveReplyTemplateId?: number;
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
}
/**
 * Move all tickets from one ticket category to another
 */
export interface List_MoveAllTicketsRequest {
    /**
     * The id of the category we want to move tickets from
     */
    FromTicketCategoryId: number;
    /**
     * The id of the category we want to move the tickets to
     */
    ToTicketCategoryId: number;
}
/**
 * Update the fullname field of all categories. Use this e.g. when changing parentId or renaming a category with children.
 */
export interface List_RebuildFullnamesRequest {
}
/**
 *
 * Returns TicketCategoryEntity[]
 */
export interface List_GetTicketCategoriesRequest {
}
/**
 * Ticket categories for user groups
 * Returns MDOListItem[]
 */
export interface List_GetTicketCategoriesForUserGroupsRequest {
    /**
     * The ids of the user groups we want tickets categories from
     */
    UserGroupIds: number[];
}
/**
 * Set ticket categories for one user group
 */
export interface List_SetTicketCategoriesForUserGroupRequest {
    /**
     * The ids of the user groups we want tickets categories from
     */
    UserGroupId: number;
    /**
     * The ids of the user groups we want tickets categories from
     */
    CategoryIds: number[];
}
/**
 * This entity describes ticket category membership.
 */
export interface TicketCategoryMembershipEntity extends Carrier {
    /**
     * User
     */
    User?: Associate;
    /**
     * Weight
     */
    Weight?: number;
}
/**
 * Updates category memberships
 */
export interface List_UpdateCategoryMembershipsRequest {
    /**
     * Id of ticket category to update memberships for
     */
    TicketCategoryId: number;
    /**
     * List of memberships to add
     */
    MembershipsToAdd: TicketCategoryMembershipEntity[];
    /**
     * List of memberships to update
     */
    MembershipsToUpdate: TicketCategoryMembershipEntity[];
    /**
     * List of memberships to delete
     */
    MembershipsToDelete: TicketCategoryMembershipEntity[];
}
/**
 *
 */
export interface TicketPriority extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * Entity for a ticket priority. This entity describes the meta data for a ticket priority, and provides special operations on it.
 */
export interface TicketPriorityEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    TicketPriorityId?: number;
    /**
     * The name of the priority.
     */
    Name?: string;
    /**
     * The status (normal/deleted) of the priority.
     */
    Status?: enums.TicketPriorityStatus;
    /**
     * A bitmask of flags.
     */
    Flags?: enums.TicketPriorityFlags;
    /**
     * Indicates the sort order for this priority. 1 is first, 100 is last
     */
    SortOrder?: number;
    /**
     * This field indicates what to do with the escalation chain when the request is read
     */
    TicketRead?: enums.TicketPriorityEscalateEvent;
    /**
     * This field indicates what to do with the escalation chain when the request changes owner (manually)
     */
    ChangedOwner?: enums.TicketPriorityEscalateEvent;
    /**
     * This field indicates what to do with the escalation chain when the request gets new info
     */
    TicketNewinfo?: enums.TicketPriorityEscalateEvent;
    /**
     * This field indicates what to do with the escalation chain when the request is closed
     */
    TicketClosed?: enums.TicketPriorityEscalateEvent;
    /**
     * This field indicates what to do with the escalation chain when the request is changed into this priority
     */
    TicketChangedPriority?: enums.TicketPriorityEscalateEvent;
    /**
     * This field indicates what to do with the escalation chain when a new request is registered
     */
    TicketNew?: enums.TicketPriorityEscalateEvent;
    /**
     * Deadline to add if escalated (minutes)
     */
    Deadline?: number;
    /**
     * The work hour start for Mondays. Note that only the time part of the DateTime is used
     */
    MonStart?: Date;
    /**
     * The work hour start for Mondays. Note that only the time part of the DateTime is used
     */
    MonStop?: Date;
    /**
     * The work hour start for Tuesdays. Note that only the time part of the DateTime is used
     */
    TueStart?: Date;
    /**
     * The work hour stop for Tuesdays. Note that only the time part of the DateTime is used
     */
    TueStop?: Date;
    /**
     * The work hour start for Wednesdays. Note that only the time part of the DateTime is used
     */
    WedStart?: Date;
    /**
     * The work hour stop for Wednesdays. Note that only the time part of the DateTime is used
     */
    WedStop?: Date;
    /**
     * The work hour start for Thursdays. Note that only the time part of the DateTime is used
     */
    ThuStart?: Date;
    /**
     * The work hour stop for Thursdays. Note that only the time part of the DateTime is used
     */
    ThuStop?: Date;
    /**
     * The work hour start for Fridays. Note that only the time part of the DateTime is used
     */
    FriStart?: Date;
    /**
     * The work hour stop for Fridays. Note that only the time part of the DateTime is used
     */
    FriStop?: Date;
    /**
     * The work hour start for Saturdays. Note that only the time part of the DateTime is used
     */
    SatStart?: Date;
    /**
     * The work hour stop for Saturdays. Note that only the time part of the DateTime is used
     */
    SatStop?: Date;
    /**
     * The work hour start for Sundays. Note that only the time part of the DateTime is used
     */
    SunStart?: Date;
    /**
     * The work hour stop for Sundays. Note that only the time part of the DateTime is used
     */
    SunStop?: Date;
    /**
     * Dates which the escalation time should not be running. Note that only the day of the year (day and month) is used. So the year and time part is not used even if this is a DateTime. Exception - it IS possible to include a year here, for dates that should not repeat every year
     */
    NonDates?: Date[];
    /**
     * Escalation levels bound to the parent priority
     */
    EscalationLevels?: TicketPriorityEscalationLevelEntity[];
}
/**
 * This method will set sort order of ticket priority in a list
 */
export interface List_SetTicketPrioritySortOrderRequest {
    /**
     * Id of ticket priority
     */
    TicketPriorityId: number;
    /**
     * Indicates the sort order for this priority. 1 is first. Any records following this one will be renumbered automatically
     */
    SortOrder: number;
}
/**
 * Entity for ticket priority escalation level. Entity describes properties/actions when escalation(alert) happens. Alert is raised according to TicketPriority timing intervals
 */
export interface TicketPriorityEscalationLevelEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    TicketAlertId?: number;
    /**
     * The alert level (strictly ascending number).
     */
    AlertLevel?: number;
    /**
     * The time (in minutes) before ticket is escalated to next level.
     */
    AlertTimeout?: number;
    /**
     * Bitmap indicating what should be done when escalating *to* this level.
     */
    Action?: number;
    /**
     * If ticket should be redelegated on escalation, this field contains the id of the target user.
     */
    DelegateTo?: number;
    /**
     * Script that can be executed then the ticket alert action occur.
     */
    ScriptId?: number;
    /**
     * If an email should be sent when escalating, this field will contain the recipient email address.
     */
    EmailTo?: string;
    /**
     * If an sms should be sent when escalating, this field will contain the recipient email address.
     */
    SmsTo?: string;
    /**
     * Reference to the reply template used in this alert, for mail to customer
     */
    ReplyTemplateIdCustomer?: number;
    /**
     * Reference to the reply template used in this alert, for mail to owner of ticket
     */
    ReplyTemplateIdUser?: number;
    /**
     * Reference to the reply template used in this alert, for mail to category master
     */
    ReplyTemplateIdCatmast?: number;
    /**
     * Reference to the reply template used in this alert, for mail to custom address
     */
    ReplyTemplateIdEmail?: number;
    /**
     * Reference to the reply template used in this alert, for sms to customer
     */
    RtiCustomerSms?: number;
    /**
     * Reference to the reply template used in this alert, for sms to owner of ticket
     */
    ReplyTemplateIdUserSms?: number;
    /**
     * Reference to the reply template used in this alert, for sms to category master
     */
    ReplyTemplateIdCatmastSms?: number;
    /**
     * Reference to the reply template used in this alert, for sms to custom address
     */
    ReplyTemplateIdSms?: number;
}
/**
 *
 * Returns TicketPriority[]
 */
export interface List_GetTicketPrioritiesRequest {
}
/**
 * Returns all available ticket priorities.
 * Returns TicketPriorityEntity[]
 */
export interface List_GetAllTicketPrioritiesRequest {
    /**
     * Include deleted items in result?
     */
    IncludeDeleted: boolean;
}
/**
 * Entity for a ticket status. This entity describes the meta data for a ticket status, and provides special operations on it.
 */
export interface TicketStatusEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    TicketStatusId?: number;
    /**
     * Name of user defined ticket status
     */
    Name?: string;
    /**
     * The &apos;classic&apos; ticket status. I.e. active/closed/postponed/deleted
     */
    Status?: enums.TicketBaseStatus;
    /**
     * Which field in ticket we count time spent on (queue, internal, external)
     */
    TimeCounter?: enums.TicketStatusTimeCounter;
    /**
     * Whether inbound emails can reopen requests with this status or not
     */
    NoEmailReopen?: boolean;
    /**
     * Indicates if status is default one as there might be more than one status with same internal status
     */
    IsDefault?: boolean;
    /**
     * If set, status is used in GetNext calculations
     */
    UsedInQueue?: boolean;
}
/**
 * This method will change all references from one ticket status to another. Typically used in conjuction with delete
 */
export interface List_GlobalChangeTicketStatusRequest {
    /**
     * The id of the ticket status to change from
     */
    FromTicketStatusId: number;
    /**
     * The id of the ticket status to change to
     */
    ToTicketStatusId: number;
}
/**
 * This method will set sort order of ticket status in a list
 */
export interface List_SetTicketStatusSortOrderRequest {
    /**
     * Id of ticket status
     */
    TicketStatusId: number;
    /**
     * Indicates the sort order for this status. 1 is first. Any records following this one will be renumbered automatically
     */
    SortOrder: number;
}
/**
 *
 * Returns TicketStatusEntity[]
 */
export interface List_GetTicketStatusesRequest {
}
/**
 * The web panel entity contains information on a web panel
 */
export interface WebPanelEntity extends Carrier {
    /**
     * The identity of the web panel
     */
    WebPanelId?: number;
    /**
     * The name of the web panel
     */
    Name?: string;
    /**
     * The tooltip of the web panel
     */
    Tooltip?: string;
    /**
     * True if the web panel is marked as deleted
     */
    Deleted?: boolean;
    /**
     * The rank of the web panel
     */
    Rank?: number;
    /**
     * The encoding of the URL
     */
    UrlEncoding?: enums.UrlEncoding;
    /**
     * The webpanel is visible in
     */
    VisibleIn?: enums.Navigation;
    /**
     * Is the webpanel visible when user is on central database
     */
    OnCentral?: boolean;
    /**
     * Is the webpanel visible when user is on a satellite
     */
    OnSatellite?: boolean;
    /**
     * Is the webpanel visible when user is on travel
     */
    OnTravel?: boolean;
    /**
     * Is the webpanel visible when user is on web client
     */
    OnSalesMarketingWeb?: boolean;
    /**
     * Is the webpanel visible when user is on pocket client
     */
    OnSalesMarketingPocket?: boolean;
    /**
     * Does the webpanel have a menu bar
     */
    ShowInMenuBar?: boolean;
    /**
     * Does the webpanel have a toolbar
     */
    ShowInToolBar?: boolean;
    /**
     * Does the webpanel have an address bar
     */
    ShowInAddressBar?: boolean;
    /**
     * Does the webpanel have a status bar
     */
    ShowInStatusBar?: boolean;
    /**
     * The window which the URL address is to open in (webpanel only)
     */
    WindowName?: string;
    /**
     * The url
     */
    Url?: string;
    /**
     * String key that can be used to uniquely retrieve the panel; particularly useful for partners and others who do not wish to store database ID's
     */
    ProgId?: string;
    /**
     * The icon of the webpanel
     */
    Icon?: number;
    /**
     * If set to true, the content will reload every time the panel is shown
     */
    AlwaysReloadOnShow?: boolean;
}
/**
 * This methods generates the navigation URL to be used to navigate to the panel
 * Returns string
 */
export interface List_GenerateNavigationUrlRequest {
    /**
     * The visble in/navigation to generate for
     */
    VisibleIn: enums.Navigation;
    /**
     * The name of the web panel window
     */
    WindowName: string;
}
/**
 * Return a list of all web panels.
 * Returns WebPanelEntity[]
 */
export interface List_GetWebPanelListRequest {
}
/**
 * Hard-delete (real, permanent DELETE in the database) the given web panel. Use with care!
 */
export interface List_DeleteWebPanelRequest {
    /**
     * Database id of web panel to delete
     */
    Id: number;
}
/**
 * Get all web panels owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken
 * Returns WebPanelEntity[]
 */
export interface List_GetAppWebPanelsRequest {
}
/**
 * Permanentely delete all web panels owned by your app; works in Online only, for registered Apps that send a valid ApplicationToken; otherwise nothing happens
 */
export interface List_DeleteAppWebPanelsRequest {
}
/**
 * Get a web panel using the ProgId key that was specified when it was created
 * Returns WebPanelEntity
 */
export interface List_GetWebPanelByProgIdRequest {
    /**
     * String key that can be used to uniquely retrieve the panel, set in the WebPanelEntity when saving
     */
    ProgId: string;
}
/**
 *
 */
export interface BlobEntity extends Carrier {
    /**
     * Primary key
     */
    BlobId?: number;
    /**
     * The length, in bytes, of the binary data AS STORED after any encryption and/or zipping. Important to get right, since some databases will not tell us just based on the blob itself!
     */
    BlobSize?: number;
    /**
     * A description that is entered by the user, and visible to the user
     */
    Description?: string;
    /**
     * Extra information, spare field, can be used for anything that makes sense. Should not refer to any particular context, that is something for the BinaryObjectLInk
     */
    ExtraInfo?: string;
    /**
     * Has the data been encrypted.
     */
    IsEncrypted?: boolean;
    /**
     * Has the data been zipped.
     */
    IsZipped?: boolean;
    /**
     * Mime type, describing the technical type (image/jpeg) of the data
     */
    MimeType?: string;
    /**
     * Original size of the binary data, before encryption and/or zipping. This is what the ultimate client will get
     */
    OriginalSize?: number;
    /**
     * Registered when
     */
    CreatedDate?: Date;
    /**
     * Last updated when
     */
    UpdatedDate?: Date;
    /**
     * The person that first created the document. The property is read-only.
     */
    CreatedBy?: Associate;
    /**
     * The person that last updated the appointment.
     */
    UpdatedBy?: Associate;
    /**
     * The type, for instance PHOTO, PERSONPHOTO, or whatever, that is descriptive of what kind of image or data this is
     */
    ConceptualType?: string;
}
/**
 * Store a binary object from it's stream
 */
export interface BLOB_SetBlobStreamRequest {
    /**
     * Id of the BLOB entity object that the binary data should be stored to.
     */
    BlobEntityId: number;
    /**
     * The binary object as a Stream
     */
    Stream: ArrayBuffer | string;
}
/**
 * Get the binary object as a stream
 * Returns Blob
 */
export interface BLOB_GetBlobStreamRequest {
    /**
     * The ID of the BLOB entity object that refers to the binary data
     */
    BlobEntityId: number;
}
/**
 * Returns the project image that is displayed in the CRM application.
 * Returns Blob
 */
export interface BLOB_GetProjectImageRequest {
    /**
     * The project id of the project the image belongs to.
     */
    ProjectId: number;
}
/**
 * Returns the person image that is displayed in the CRM application.
 * Returns Blob
 */
export interface BLOB_GetPersonImageRequest {
    /**
     * The person id of the person the image belongs to.
     */
    PersonId: number;
}
/**
 * Stores the project image that is displayed in the CRM application.
 */
export interface BLOB_SetProjectImageRequest {
    /**
     * The project id of the project the image belongs to.
     */
    ProjectId: number;
    /**
     * The image that is stored on the project (System.Drawing.Image)
     */
    Image: ArrayBuffer | string;
}
/**
 * Stores the person image that is displayed in the CRM application.
 */
export interface BLOB_SetPersonImageRequest {
    /**
     * The person id of the person the image belongs to.
     */
    PersonId: number;
    /**
     * The image that is stored on the person (System.Drawing.Image)
     */
    Image: ArrayBuffer | string;
}
/**
 * Changes the project image link. If the Binary object id is 0, any image link is removed from the project.
 */
export interface BLOB_ChangeProjectImageRequest {
    /**
     * The project the image is linked to
     */
    ProjectId: number;
    /**
     * The Binary object id. If the Binary object id is 0, any image link is removed from the project.
     */
    BlobId: number;
}
/**
 * Saves a project image that is displayed in the CRM application's project image selection dialog to the database.
 */
export interface BLOB_SaveProjectImageRequest {
    /**
     * Image description. Should be image name (e.g. winter.jpg) for project images
     */
    Description: string;
    /**
     * The project image (System.Drawing.Image)
     */
    Image: ArrayBuffer | string;
}
/**
 * Gets the blob entity that represents the project image binary object.
 * Returns BlobEntity
 */
export interface BLOB_GetBlobEntityOnProjectRequest {
    /**
     * The project id
     */
    ProjectId: number;
}
/**
 * Gets the blob entity that represents the person image binary object.
 * Returns BlobEntity
 */
export interface BLOB_GetBlobEntityOnPersonRequest {
    /**
     * The person id
     */
    PersonId: number;
}
/**
 * Gets the blob entity that represents the country flag binary object.
 * Returns BlobEntity
 */
export interface BLOB_GetBlobEntityOnCountryRequest {
    /**
     * The country id
     */
    CountryId: number;
}
/**
 * Gets the blob entity that represents the product image binary object.
 * Returns BlobEntity
 */
export interface BLOB_GetBlobEntityOnProductRequest {
    /**
     * The product id
     */
    ProductId: number;
}
/**
 *
 */
export interface BLOB_ChangePersonImageRequest {
    /**
     * The person the image is linked to
     */
    PersonId: number;
    /**
     * The Binary object id. If the Binary object id is 0, any image link is removed from the person.
     */
    BlobId: number;
}
/**
 * Stores an image in the database without linking it to a project or a person. It is possible to ChangePersonImage or ChangeProjectImage to attach image later.
 * Returns number
 */
export interface BLOB_SaveImageStreamRequest {
    /**
     * The type of the image.
     */
    Type: enums.BlobLinkType;
    /**
     * Image to store
     */
    Image: ArrayBuffer | string;
    /**
     * Image description
     */
    Description: string;
}
/**
 * Returns the product image (rank=1) that is displayed in the CRM application.
 * Returns Blob
 */
export interface BLOB_GetProductImageRequest {
    /**
     * The product id of the product the image belongs to.
     */
    ProductId: number;
}
/**
 * Stores the product image that is displayed in the CRM application. The image is scaled down to max 1000x1000. This method operates only the main (rank=1) image; future extensions may support multiple images. A thumbnail of size 75x75 is also automatically set.
 */
export interface BLOB_SetProductImageRequest {
    /**
     * The product id of the product the image belongs to.
     */
    ProductId: number;
    /**
     * The image that is stored on the product (System.Drawing.Image), scaled down to no more than 1000x1000
     */
    Image: ArrayBuffer | string;
}
/**
 * Returns the product thumbnail that is displayed in the CRM application.
 * Returns Blob
 */
export interface BLOB_GetProductThumbnailRequest {
    /**
     * The product id of the product the thumbnail belongs to.
     */
    ProductId: number;
}
/**
 * Stores the product thumbnail that is displayed in the CRM application. The image is scaled down to max 200x200 pixels.
 */
export interface BLOB_SetProductThumbnailRequest {
    /**
     * The product id of the product the image belongs to.
     */
    ProductId: number;
    /**
     * The image that is stored on the product (System.Drawing.Image); scaled down to no more than 200x200
     */
    Image: ArrayBuffer | string;
}
/**
 *
 */
export interface BLOB_ChangeProductImageRequest {
    /**
     * The product the image is linked to
     */
    ProductId: number;
    /**
     * The Binary object id. If the Binary object id is 0, any image link is removed from the product.
     */
    BlobId: number;
}
/**
 * Returns the quoteline image (rank=1) that is displayed in the CRM application.
 * Returns Blob
 */
export interface BLOB_GetQuoteLineImageRequest {
    /**
     * The product id of the quoteline the image belongs to.
     */
    QuoteLineId: number;
}
/**
 * Get a CLOB (limited to a reasonable size by the mechanics of Web Services) according to a string key; ALSO limits to the current ApplicationToken if any
 * Returns string
 */
export interface BLOB_GetAppDataRequest {
    /**
     * The key string, less than 200 characters. Must be unique within each application.
     */
    Key: string;
}
/**
 * Get a CLOB (limited to a reasonable size by the mechanics of Web Services) according to a string key; ALSO limits to the current ApplicationToken if any. Existing data, if any, will be overwritten. Overwrite with a blank value to delete.
 */
export interface BLOB_SetAppDataRequest {
    /**
     * The key string, less than 200 characters. Must be unique within each application.
     */
    Key: string;
    /**
     * The applications value, suggested to be a JSON, XML or other readable structure
     */
    Data: string;
}
/**
 * Returns the person image that is displayed in the CRM application with a specified maximum size.
 * Returns Blob
 */
export interface BLOB_GetPersonImageWithSizeRequest {
    /**
     * The person id of the person the image belongs to.
     */
    PersonId: number;
    /**
     * The maximum with of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     */
    Width: number;
    /**
     * The maximum height of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     */
    Height: number;
}
/**
 * Returns the project image that is displayed in the CRM application with a specified maximum size.
 * Returns Blob
 */
export interface BLOB_GetProjectImageWithSizeRequest {
    /**
     * The project id of the project the image belongs to.
     */
    ProjectId: number;
    /**
     * The maximum with of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     */
    Width: number;
    /**
     * The maximum height of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     */
    Height: number;
}
/**
 * Returns the chat image that is displayed in chat with a specified maximum size.
 * Returns Blob
 */
export interface BLOB_GetChatImageWithSizeRequest {
    /**
     * The project id of the project the image belongs to.
     */
    ChatTopicId: number;
    /**
     * The maximum with of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     */
    Width: number;
    /**
     * The maximum height of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     */
    Height: number;
}
/**
 * Returns the contact image that is displayed in the CRM application.
 * Returns Blob
 */
export interface BLOB_GetContactImageRequest {
    /**
     * The contact id of the contact the image belongs to.
     */
    ContactId: number;
}
/**
 * Stores the contact image that is displayed in the CRM application.
 */
export interface BLOB_SetContactImageRequest {
    /**
     * The contact id of the contact the image belongs to.
     */
    ContactId: number;
    /**
     * The image that is stored on the contact (System.Drawing.Image)
     */
    Image: ArrayBuffer | string;
}
/**
 * Changes the contact image link. If the Binary object id is 0, any image link is removed from the contact.
 */
export interface BLOB_ChangeContactImageRequest {
    /**
     * The Contact the image is linked to
     */
    ContactId: number;
    /**
     * The Binary object id. If the Binary object id is 0, any image link is removed from the Contact.
     */
    BlobId: number;
}
/**
 * Gets the blob entity that represents the contact image binary object.
 * Returns BlobEntity
 */
export interface BLOB_GetBlobEntityOnContactRequest {
    /**
     * The Contact id
     */
    ContactId: number;
}
/**
 * Returns the contact image that is displayed in the CRM application with a specified maximum size.
 * Returns Blob
 */
export interface BLOB_GetContactImageWithSizeRequest {
    /**
     * The contact id of the Contact the image belongs to.
     */
    ContactId: number;
    /**
     * The maximum with of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     */
    Width: number;
    /**
     * The maximum height of the returned image. Specify <= 0 to preserve aspect ratio of existing image
     */
    Height: number;
}
/**
 * Get the output of a batchtask as a stream
 * Returns Blob
 */
export interface BLOB_GetOutputFromBatchRequest {
    /**
     * The ID of the batchtask that created the output data
     */
    BatchTaskId: number;
}
/**
 * Removes the binary objects linked to the batch task, the links themselves and the batch task.
 */
export interface BLOB_CleanupBatchTaskRequest {
    /**
     * The ID of the batchtask that created the output data
     */
    BatchTaskId: number;
}
/**
 *
 */
export interface NavigatorCompany extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 *
 * Returns NavigatorCompany[]
 */
export interface Navigator_GetNavigatorCompaniesRequest {
    /**
     *
     */
    Name: string;
}
/**
 * Method to get a MDO list.
 * Returns MDOListItem[]
 */
export interface MDO_GetListRequest {
    /**
     * Conceptual name of the MDO list-
     */
    Name: string;
    /**
     * Force the list to be flat
     */
    ForceFlatList: boolean;
    /**
     * Additional info to the MDO provider
     */
    AdditionalInfo: string;
    /**
     * If true, return only history items
     */
    OnlyHistory: boolean;
}
/**
 * Method to get a MDO list with own history list.
 * Returns MDOListItem[]
 */
export interface MDO_GetListWithHistoryRequest {
    /**
     * Conceptual name of the MDO list-
     */
    Name: string;
    /**
     * Force the list to be flat
     */
    ForceFlatList: boolean;
    /**
     * Additional info to the MDO provider
     */
    AdditionalInfo: string;
    /**
     * An array of ids, used to get the history list
     */
    HistoryItems: number[];
    /**
     * If true, return only history items
     */
    OnlyHistory: boolean;
}
/**
 * Method to get a MDO list with restrictions.
 * Returns MDOListItem[]
 */
export interface MDO_GetListWithRestrictionRequest {
    /**
     * Conceptual name of the MDO list-
     */
    Name: string;
    /**
     * Additional info to the MDO provider
     */
    AdditionalInfo: string;
    /**
     * the value used to restrict the list
     */
    SearchValue: string;
}
/**
 * Method returns a simple flat MDO List.
 * Returns MDOListItem[]
 */
export interface MDO_GetSimpleListRequest {
    /**
     * Conceptual name of the MDO list-
     */
    Name: string;
}
/**
 * Returns a single list item
 * Returns MDOListItem
 */
export interface MDO_GetListItemRequest {
    /**
     * Conceptual name of the MDO list
     */
    ListName: string;
    /**
     * Id of list item
     */
    Id: number;
}
/**
 * Returns a list of all MDO List names. These names can also be used with the Archive agent as ProviderNames.
 * Returns string[]
 */
export interface MDO_GetListNamesRequest {
}
/**
 * Retrieve the UdListDefinition id of a list, by its name. Not all lists have such an ID, but those that are based on tables do (the list name is then the same as the table name)
 * Returns number
 */
export interface MDO_GetListIdByListNameRequest {
    /**
     * The list name, same as the table name for lists that are backed by tables
     */
    Name: string;
}
/**
 *
 */
export interface MDOListItem extends Carrier {
    /**
     * The Id of the ListItem
     */
    Id?: number;
    /**
     * The name of the ListItem
     */
    Name?: string;
    /**
     * The tooltip of the ListItem
     */
    ToolTip?: string;
    /**
     * The deleted status of the ListItem
     */
    Deleted?: boolean;
    /**
     * The rank of the ListItem
     */
    Rank?: number;
    /**
     * The type of the ListItem. Custom field.
     */
    Type?: string;
    /**
     * The child items of the MDOListItem
     */
    ChildItems?: MDOListItem[];
    /**
     * The Icon hint of the ListItem. Custom field.
     */
    IconHint?: string;
    /**
     * The color indicator of the ListItem color block
     */
    ColorBlock?: number;
    /**
     * Extra information added to the ListItem. Could be information such as sort order etc or other meta data. Custom field.
     */
    ExtraInfo?: string;
    /**
     * Style hint indicating, information such as background color etc. Custom field.
     */
    StyleHint?: string;
    /**
     * The name of the ListItem in its context
     */
    FullName?: string;
}
/**
 * Method returns a flat Selectable MDO List.
 * Returns SelectableMDOListItem[]
 */
export interface MDO_GetSelectableSimpleListRequest {
    /**
     * Conceptual name of the MDO list
     */
    Name: string;
}
/**
 * Method to get a Selectable MDO list with restrictions.
 * Returns SelectableMDOListItem[]
 */
export interface MDO_GetSelectableListWithRestrictionRequest {
    /**
     * Conceptual name of the MDO list
     */
    Name: string;
    /**
     * Additional info to the MDO provider
     */
    AdditionalInfo: string;
    /**
     * the value used to restrict the list
     */
    SearchValue: string;
}
/**
 * Method to get a Selectable MDO list with own history list.
 * Returns SelectableMDOListItem[]
 */
export interface MDO_GetSelectableListWithHistoryRequest {
    /**
     * Conceptual name of the MDO list.
     */
    Name: string;
    /**
     * Force the list to be flat
     */
    ForceFlatList: boolean;
    /**
     * Additional info to the MDO provider
     */
    AdditionalInfo: string;
    /**
     * An array of ids, used to get the history list
     */
    HistoryItems: number[];
    /**
     * If true, return only history items
     */
    OnlyHistory: boolean;
}
/**
 * Method to get a Selectable MDO list.
 * Returns SelectableMDOListItem[]
 */
export interface MDO_GetSelectableListRequest {
    /**
     * Conceptual name of the MDO list.
     */
    Name: string;
    /**
     * Force the list to be flat
     */
    ForceFlatList: boolean;
    /**
     * Additional info to the MDO provider
     */
    AdditionalInfo: string;
    /**
     * If true, return only history items
     */
    OnlyHistory: boolean;
}
/**
 * Saves the selected values as selected by their given list representation.
 * Returns SelectableMDOListItem[]
 */
export interface MDO_SetSelectedRequest {
    /**
     * Conceptual name of the MDO list
     */
    Name: string;
    /**
     * Additional info to the MDO provider
     */
    AdditionalInfo: string;
    /**
     * Items to be updated
     */
    SelectableMDOList: SelectableMDOListItem[];
}
/**
 *
 */
export interface SelectableMDOListItem extends Carrier {
    /**
     * The Id of the ListItem
     */
    Id?: number;
    /**
     * The name of the ListItem
     */
    Name?: string;
    /**
     * The tooltip of the ListItem
     */
    ToolTip?: string;
    /**
     * The deleted status of the ListItem
     */
    Deleted?: boolean;
    /**
     * The rank of the ListItem
     */
    Rank?: number;
    /**
     * The type of the ListItem. Custom field.
     */
    Type?: string;
    /**
     * The color indicator of the ListItem color block
     */
    ColorBlock?: number;
    /**
     * The Icon hint of the ListItem. Custom field.
     */
    IconHint?: string;
    /**
     * True if the ListItem is selected
     */
    Selected?: boolean;
    /**
     * Time of last change.
     */
    LastChanged?: Date;
    /**
     * The child items of the SelectableMDOListItem
     */
    ChildItems?: SelectableMDOListItem[];
    /**
     * Extra information added to the ListItem. Could be information such as sort order etc or other meta data. Custom field.
     */
    ExtraInfo?: string;
    /**
     * Style hint indicating, information such as background color etc. Custom field.
     */
    StyleHint?: string;
    /**
     * True if the ListItem is hidden
     */
    Hidden?: boolean;
    /**
     * The name of the ListItem in its context
     */
    FullName?: string;
}
/**
 * Configurable Screen Delta represents a list of changes to a SCIL recipe.
 */
export interface ConfigurableScreenDelta extends Carrier {
    /**
     * The delta database id
     */
    ConfigurableScreenDeltaId?: number;
    /**
     * The name of the delta
     */
    Name?: string;
    /**
     * The description of the delta
     */
    Description?: string;
    /**
     * The delta as a JSON
     */
    DeltaJson?: string;
    /**
     * The delta type, like webpanel, udef, system
     */
    DeltaType?: enums.DeltaType;
    /**
     * The delta state, like draft, published
     */
    DeltaState?: enums.DeltaState;
    /**
     * Name to identify the recipe that the deltas will modify
     */
    RecipeId?: string;
    /**
     * Date last updated
     */
    UpdatedDate?: Date;
    /**
     * Date registered
     */
    CreatedDate?: Date;
    /**
     * The user that last updated the ConfigurableScreenDelta
     */
    UpdatedBy?: Associate;
    /**
     * The user that created the ConfigurableScreenDelta
     */
    CreatedBy?: Associate;
    /**
     * Ids to which type will have this delta applied to their resulting ui. Type depends on configuration. Like project type, more types probably to come
     */
    AppliesToIds?: number[];
    /**
     * What property to use to differ on configs. Like UserGroup or ProjectType. (Read only, can only be set on recipe level)
     */
    AppliesToKey?: string;
}
/**
 * This method will return a json with all deltas for screen
 * Returns string
 */
export interface Configuration_GetScreenConfigurationDeltasRequest {
}
/**
 * This method will return a json with all deltas for screen
 * Returns string
 */
export interface Configuration_GetScreenConfigurationDeltaRequest {
    /**
     * The recipe in json for this DeltaType: System, WebPanel, CustomFields, Custom...
     */
    DeltaType: enums.DeltaType;
    /**
     * Draft or published or None
     */
    DeltaState: enums.DeltaState;
}
/**
 * This method will return a configurablescreen delta matching the properties received from the incomming delta
 * Returns ConfigurableScreenDelta[]
 */
export interface Configuration_GetConfigurableScreenDeltasByDeltaRequest {
    /**
     * A delta populated with wanted properties
     */
    ConfigurableScreenDelta: ConfigurableScreenDelta;
}
/**
 * This method will return a configurablescreen delta matching the properties received from the incomming query
 * Returns ConfigurableScreenDelta[]
 */
export interface Configuration_GetConfigurableScreenDeltasByQueryRequest {
    /**
     * An object populated with wanted properties for the deltas to return
     */
    DeltaQuery: DeltaQuery;
}
/**
 * Flush and rebuild userdefined field deltas. Mostly used after publishing udefs or adding/editing Customer Service extrafields
 */
export interface Configuration_RebuildUdefDeltasRequest {
}
/**
 * Flush and rebuild webpanel deltas. Mostly used after adding/editing webpanels or change group visibility of them
 */
export interface Configuration_RebuildWebpanelDeltasRequest {
}
/**
 * Save the incomming draft and publish
 * Returns ConfigurableScreenDelta
 */
export interface Configuration_SaveAndPublishRequest {
    /**
     * The ConfigurableScreenDelta draft that is going to be published
     */
    ConfigurableScreenDelta: ConfigurableScreenDelta;
}
/**
 * Set the type of assignTo the deltas of the given recipe should have
 */
export interface Configuration_SetAppliesToKeyRequest {
    /**
     * The recipeId that will use this apply to type
     */
    RecipeId: string;
    /**
     * The type we should use for differencing between delta layout. Like usergroup or project type. Saved in table ConfigurableScreenAppliesTo
     */
    AppliesToKey: string;
}
/**
 * Return the a  dictionary with recipeId as key, and chosen appliesTo for that recipe, Like projecttype for projectcardrecipe
 * Returns StringDictionary
 */
export interface Configuration_GetRecipeAppliesToMappingsRequest {
}
/**
 * This service supports fetching of client interface configuration data. Client configuration data include Application configuration, which defines how an application is composed out of pages; and page configuration that defines how a page is built out of panels, cards, views and controls. <para/> Separate access points also exist for fetching object mappings and filter lists.
 */
export interface Configuration extends Carrier {
}
/**
 * Return the application configuration. This is a list of pages, with information about the name, main panel and preference mappings of each page.
 * Returns string
 */
export interface Configuration_GetApplicationConfigurationRequest {
    /**
     * The application name, for instance 'SixWeb'
     */
    Application: string;
    /**
     * The instance name for the application, like 'MainInstance'
     */
    Instance: string;
}
/**
 * Get the configuration for one whole web page, including all its panels etc.  totally asynchronous items like menus are not included, but all references are resolved and all special processing is applied.
 * Returns string
 */
export interface Configuration_GetPageConfigurationRequest {
    /**
     * The application name, for instance 'SixWeb
     */
    Application: string;
    /**
     * The instance name for the application, like 'MainInstance'
     */
    Instance: string;
    /**
     * Page name, must correspond to one of the pages in the Application Configuration
     */
    Page: string;
}
/**
 * Get the object mappings, i.e., the what code objects should be instantiated to handle the entities of the client configuration.
 * Returns string
 */
export interface Configuration_GetObjectMappingRequest {
    /**
     * The application name, for instance 'SixWeb'
     */
    Application: string;
    /**
     * The instance name for the application, like 'MainInstance'
     */
    Instance: string;
}
/**
 * Get the list of filters to be used for processing the configuration data for this application.
 * Returns string
 */
export interface Configuration_GetFilterListRequest {
    /**
     * The application name, for instance 'SixWeb'
     */
    Application: string;
    /**
     * The instance name for the application, like 'MainInstance'
     */
    Instance: string;
}
/**
 * Configuration XML's may be expensive to build and parse, and are therefore cached to the database. <para/>Cahcing is per application/instance/associate, and can be turned off through the config file. <para/>If caching is on, and the configuration is changed, it is necessary to clear the cached configurations from the database, through this call.<para/>Note that changes to the externalapplication table require cache invalidation. SoAdmin will do so automatically.
 */
export interface Configuration_ClearConfigurationCacheRequest {
    /**
     * The application name, for instance 'SixWeb'
     */
    Application: string;
    /**
     * The instance name for the application, like 'MainInstance'
     */
    Instance: string;
    /**
     * If false, only the current associate's configuration is cleared. If true, configurations are cleared for all associates.
     */
    ForAllAssociates: boolean;
}
/**
 * Get one defined configuration fragment, with full reference resolution and parsing applied. This is essentially the same service as the GetPageConfiguration, except that this service is not locked to objects of type Page.
 * Returns string
 */
export interface Configuration_GetAnyConfigurationRequest {
    /**
     * The application name, for instance Six.Web
     */
    Application: string;
    /**
     * The instance name, for instance Main
     */
    Instance: string;
    /**
     * The configuration item name (first component of file name)
     */
    Item: string;
    /**
     * The configuration item type (second component of file name)
     */
    Type: string;
}
/**
 *
 * Returns string
 */
export interface Configuration_GetEMarketingUrlRequest {
    /**
     *
     */
    Language: string;
}
/**
 * This method will convert a module name into a CS URL.
 * Returns string
 */
export interface Configuration_GetCsProgramUrlRequest {
    /**
     * By setting this parameter, you can change the CS language for the current user.
     */
    Language: string;
    /**
     * In this parameter you must specify which CS program you want to create an URL for. Valid examples are "ticket", "rms", "spm" etc.
     */
    ProgramName: string;
    /**
     * Here you can optionally specify the action for the current program. This will enable you to go to a specific screen.
     */
    Action: string;
    /**
     * If an action is specified, you can specify extra parameters here. This can be used to set specific behaviour for the chosen screen/action. If an empty action is supplied, this parameter will be ignored.
     */
    ExtraParameters: string;
}
/**
 * Will generate an url to the emarketing module
 * Returns string
 */
export interface Configuration_GetCSAuthUrlRequest {
    /**
     * By setting this parameter, you can change the CS language for the current user.
     */
    Language: string;
    /**
     * In this parameter you must specify which CS program you want to create an URL for. Valid examples are "ticket", "rms", "spm" etc.
     */
    ProgramName: string;
    /**
     * Here you can optionally specify the action for the current program. This will enable you to go to a specific screen.
     */
    Action: string;
    /**
     * If an action is specified, you can specify extra parameters here. This can be used to set specific behaviour for the chosen screen/action. If an empty action is supplied, this parameter will be ignored.
     */
    ExtraParameters: string;
}
/**
 * This method will get a value from the CS Registry table.
 * Returns string
 */
export interface Configuration_GetCSRegistryValueRequest {
    /**
     * The Registry entry to get
     */
    Entry: number;
}
/**
 * This method will get the www folder for CS
 * Returns string
 */
export interface Configuration_GetCSWwwFolderRequest {
}
/**
 * Get the configuration for one whole web page, including all its panels etc.  totally asynchronous items like menus are not included, but all references are resolved and all special processing is applied. Does not use cache for fetching, but updates the cache with refreshed configuration.
 * Returns string
 */
export interface Configuration_GetRefreshedPageConfigurationRequest {
    /**
     * The application name, for instance 'SixWeb
     */
    Application: string;
    /**
     * The instance name for the application, like 'MainInstance'
     */
    Instance: string;
    /**
     * Page name, must correspond to one of the pages in the Application Configuration
     */
    Page: string;
}
/**
 * Will get the default URL used for the logo, from the [NetServices] PageUrl preferencec, with tags substituted.
 * Returns string
 */
export interface Configuration_GetWwwUrlRequest {
    /**
     * The name for the client application, like 'CS' or 'SM.web', used for the <clie> variable
     */
    Client: string;
}
/**
 * Will get the GetHelpDispatcherUrl used by the help system
 * Returns string
 */
export interface Configuration_GetHelpDispatcherUrlRequest {
}
/**
 * Returns the URL used for the logo by the SM.web client. Uses urldispatch.aspx
 * Returns string
 */
export interface Configuration_GetWwwUrlForSMWebRequest {
}
/**
 * This method will get the host name for CS
 * Returns string
 */
export interface Configuration_GetCsCgiUrlInternalRequest {
}
/**
 * Returns a valid url based in the soprotocol provided
 * Returns string
 */
export interface Configuration_GetCRMUrlRequest {
    /**
     * SoProtocol to display. Eg. contact.activityarchive.minipreview
     */
    SoProtocol: string;
    /**
     * currents to set. Eg. contact_id=100&person_id=299
     */
    Currents: string;
    /**
     * If true frame is not rendered( Navigationbar, buttonbar and menu )
     */
    Frameless: boolean;
}
/**
 *
 * Returns number
 */
export interface Configuration_GetEmailNumberOfDaysRequest {
}
/**
 * This method will get the URL for the external access to the customer center
 * Returns string
 */
export interface Configuration_GetCustomerUrlRequest {
}
/**
 * Get the SPF domain defined for the mail cluster for this tenant (Online only)
 * Returns string
 */
export interface Configuration_GetSpfDomainRequest {
}
/**
 * Query object to use to fetch configruablescreendeltas matching this object
 */
export interface DeltaQuery extends Carrier {
    /**
     * The id of the recipe the deltas belong to
     */
    RecipeId?: string;
    /**
     * The deltas returned has to be in one of these states
     */
    DeltaStates?: enums.DeltaState[];
    /**
     * The deltas returned has to be in one of these types
     */
    DeltaTypes?: enums.DeltaType[];
    /**
     * Layouts with appliesToKey in these ids will have this delta applied to the resulting ui
     */
    AppliesToIds?: number[];
}
/**
 * The DiaryView Service. The service implements all services working with the DiaryView object.
 */
export interface DiaryViewEntity extends Carrier {
    /**
     * Id of the DiaryView
     */
    DiaryViewId?: number;
    /**
     * Name of the DiaryView.
     */
    Name?: string;
    /**
     * Tooltip/description of the DiaryView
     */
    Tooltip?: string;
    /**
     * Number of columns that should be visible simultanously.
     */
    VisibleColumns?: number;
    /**
     * DiaryView rank.
     */
    Rank?: number;
    /**
     * Owning associate id for the DiaryView.
     */
    AssocId?: number;
    /**
     *
     */
    AssociateList?: SelectableMDOListItem[];
    /**
     * Default timezone location for this view
     */
    TzLocationId?: number;
}
/**
 * Entity for system events
 */
export interface SystemEventEntity extends Carrier {
    /**
     * Primary key
     */
    SystemEventId?: number;
    /**
     * 1 = system-wide, 2= database, 3 = group, 4 = user
     */
    Scope?: enums.SystemEventScope;
    /**
     * Estimated Time of Arrival, i.e., when will this event finish?
     */
    Eta?: Date;
    /**
     * Event key, predefined in code
     */
    Eventkey?: string;
    /**
     * Message to be shown, entered by administrator
     */
    Eventmess?: string;
    /**
     * Extra information (area id for prototype rebuild, etc)
     */
    ExtraInfo?: number;
    /**
     * 0, 0, group_id, assoc id (see over)
     */
    Owner?: number;
    /**
     * Number of updates made to this record
     */
    UpdatedCount?: number;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * The associate that first created the SystemEvent.
     */
    ActivatedBy?: Associate;
}
/**
 * Is there a system event with the given key?
 * Returns boolean
 */
export interface Configuration_ExistsSystemEventRequest {
    /**
     * The key to match on
     */
    Key: string;
}
/**
 * Window and dialog position and size settings
 */
export interface WindowPosSize extends Carrier {
    /**
     * The dialog, panel or whatever that owns this record
     */
    OwnerWindow?: string;
    /**
     * Person id of the associate owning this window setting
     */
    PersonId?: number;
    /**
     * Associate id of the Associate/Person owning this window setting
     */
    AssociateId?: number;
    /**
     * Spare ID, not yet in use
     */
    ExtraId?: number;
    /**
     * Extra information - show state, or whatever is required
     */
    ExtraInfo?: string;
    /**
     * The height of the widget
     */
    Height?: number;
    /**
     * X of origin, left edge of widget
     */
    LeftX?: number;
    /**
     * Normal = 0, Maximized = 1, Minimized = 2
     */
    State?: enums.ShowWindowState;
    /**
     * Y of origin, upper edge of widget
     */
    UpperY?: number;
    /**
     * The width of the widget
     */
    Width?: number;
    /**
     * Primary key
     */
    WindowPosSizeId?: number;
}
/**
 * Saves a window and dialog position and size setting.
 * Returns WindowPosSize
 */
export interface Configuration_SaveWindowPosSizeRequest {
    /**
     * The item that is saved
     */
    WindowPosSize: WindowPosSize;
}
/**
 * Deletes a window and dialog position and size setting.
 */
export interface Configuration_DeleteWindowPosSizeRequest {
    /**
     * Id of the window and dialog position and size settings item.
     */
    WindowPosSizeId: number;
}
/**
 * Gets the window and dialog position and size settings belonging to the currently logged on user
 * Returns WindowPosSize[]
 */
export interface Configuration_GetMyWindowPosSizesRequest {
}
/**
 * Gets the window and dialog position and size settings belonging to the specified person
 * Returns WindowPosSize[]
 */
export interface Configuration_GetWindowPosSizesOnPersonIdRequest {
    /**
     * Person id of the associate owning these window settings
     */
    PersonId: number;
}
/**
 * Gets the window and dialog position and size settings belonging to the specified associate
 * Returns WindowPosSize[]
 */
export interface Configuration_GetWindowPosSizesOnAssociateIdRequest {
    /**
     * Associate id of the Associate/Person owning these window settings
     */
    AssociateId: number;
}
/**
 * Saves a set of window and dialog position and size settings.
 * Returns WindowPosSize[]
 */
export interface Configuration_SaveWindowPosSizesRequest {
    /**
     * The items that are saved
     */
    WindowPosSizes: WindowPosSize[];
}
/**
 * A config containing parameters for live UI
 */
export interface LiveUiConfig extends Carrier {
    /**
     * Indicates whether live UI is enabled
     */
    IsEnabled?: boolean;
    /**
     * Interval (in seconds) defining how often UI events should be polled.
     */
    PollingInterval?: number;
}
/**
 * Gets live UI configuration
 * Returns LiveUiConfig
 */
export interface ViewState_GetLiveUiConfigRequest {
}
/**
 * The usage history of the currently logged in user is represented as History objects.
 */
export interface History extends Carrier {
    /**
     * Sort order, indexed so it can used for sorting in the query
     */
    Rank?: number;
    /**
     * Id of the history item, for instance a contact id. Represents the history table's RecordId field, if the item is based on a history table record
     */
    Id?: number;
    /**
     * The name of the history list, for instance contact. Represents the history table's TableId field
     */
    HistoryName?: string;
    /**
     * Primary key
     */
    HistoryId?: number;
    /**
     * Owner of history list
     */
    AssociateId?: number;
    /**
     * Name of the history item, for instance contact name
     */
    Name?: string;
    /**
     * Extra information on the history item, e.g. The Associate Type for an associate or other relevant info.
     */
    ItemInfo?: string;
}
/**
 * Get the current (most recent) value of the history list. This is the item with rank = 1. If no item exists a default value is returned. This is usually the first item in the table representing the history list.
 * Returns History
 */
export interface ViewState_GetCurrentRequest {
    /**
     * Name of the history list, e.g. contact, project
     */
    HistoryName: string;
}
/**
 * Saving the current history item. This history item is saved with Rank = 1, and all the remaining elements rank values are shifted one down. The list is maintained with the max lenght of the History list length preference.
 * Returns History
 */
export interface ViewState_SaveCurrentRequest {
    /**
     * The new current history element.
     */
    Current: History;
}
/**
 * Returns the next current item. If no item exists a default value is returned. This is usually the first item in the table representing the history list.
 * Returns History
 */
export interface ViewState_GetNextCurrentRequest {
    /**
     * Name of the history list, e.g. contact, project
     */
    HistoryName: string;
    /**
     * Id of the history element, e.g. Contact id
     */
    Id: number;
}
/**
 * Returns the previous current item. If no item exists a default value is returned. This is usually the first item in the table representing the history list.
 * Returns History
 */
export interface ViewState_GetPreviousCurrentRequest {
    /**
     * Name of the history list, e.g. contact, project
     */
    HistoryName: string;
    /**
     * Id of the history element, e.g. Contact id
     */
    Id: number;
}
/**
 * Deletes the history element
 */
export interface ViewState_DeleteHistoryRequest {
    /**
     * Name of the history list, e.g. contact, project
     */
    HistoryName: string;
    /**
     * Id of the history element, e.g. Contact id
     */
    Id: number;
}
/**
 * Returns all history items that belong to the currently logged in user
 * Returns History[]
 */
export interface ViewState_GetHistoriesRequest {
}
/**
 * Returns the named history list that belong to the currently logged in user
 * Returns History[]
 */
export interface ViewState_GetHistoriesByNameRequest {
    /**
     * Name of the history list
     */
    HistoryName: string;
}
/**
 * Returns the named history lists that belong to the currently logged in user
 * Returns History[]
 */
export interface ViewState_GetHistoriesByNamesRequest {
    /**
     * String array of list names
     */
    HistoryNames: string[];
}
/**
 * Replaces the existing history-list for the currently logged in user. All elements must belong to the same history list. If not they are ignored.
 * Returns History[]
 */
export interface ViewState_SaveHistoriesRequest {
    /**
     *
     */
    HistoryName: string;
    /**
     * Array of new history items to save.
     */
    History: History[];
}
/**
 * Get the logged on user's preferred history list length. Will return the system preference if no user preferences are available.
 * Returns number
 */
export interface ViewState_GetHistoryLengthPrefValueRequest {
}
/**
 * Set the logged on user's preferred history list length.
 */
export interface ViewState_SetHistoryLengthPrefValueRequest {
    /**
     * The new history list lenght
     */
    Length: number;
}
/**
 * Saves the history elements as the current value for their respective lists. If more than one item is submitted for the same list, they are added sequently, meaning that the last one is the most current.
 * Returns History[]
 */
export interface ViewState_SaveCurrentsRequest {
    /**
     * Array of new history items to save.
     */
    Currents: History[];
}
/**
 * Returns history data for the named entities and the given ids - which may not directly correspond to the current history records in the database.<para/>Use this method if you know exactly which items you need, regardless of whether they are in the current history or not.<para/>The history in the database is not changed or even looked at by this method.
 * Returns History[]
 */
export interface ViewState_GetHistoriesByNamesAndIdsRequest {
    /**
     * Array of request objects that define what entities we are requesting history information for
     */
    Requests: HistoryRequest[];
}
/**
 * Specification for a request for history information, by id. It is possible to ask for rights for a new record (insert), but then you need to supply the parent ID for entities that have parents (projectmember, selectionmember, person)
 */
export interface HistoryRequest extends Carrier {
    /**
     * Name of entity to get history for
     */
    EntityName?: string;
    /**
     * ID of entity to get history for, or parent entity id if requesting insert rights for an entity that has a parent
     */
    EntityOrParentId?: number;
    /**
     * Are we requesting insert rights? If true, then EntityorParentId is taken to mean parent id
     */
    RequestForNewRecord?: boolean;
}
/**
 * An event that the user interface should know about. The origin may be something that happens in the user interface (in any session), or in the database (for instance, background process)
 */
export interface UiEvent extends Carrier {
    /**
     * Id of event, increasing in chronological order, assigned by server
     */
    EventId?: number;
    /**
     * Name of event, for instance 'change' or 'edit'
     */
    EventName?: string;
    /**
     * Name of entity, for instance 'ticket'
     */
    EntityType?: string;
    /**
     * Primary key of entity the event concerns
     */
    EntityKey?: number;
    /**
     * The ID of the associate causing the event
     */
    AssociateId?: number;
    /**
     * The full person name of the associate causing the event
     */
    AssociateName?: string;
    /**
     * When did the event happen
     */
    EventDateTime?: Date;
}
/**
 * Publish zero or more events, and return any new events since the given event id. The initial implementation is in-memory only; applies solely to the front-end web server; and anything older than 20 minutes is discarded
 * Returns UiEvent[]
 */
export interface ViewState_PublishAndRetrieveUiEventsRequest {
    /**
     * The last event ID that this client knows about. The return value will be any events occurring /after/ that point, numbered by the server. Clients need to keep track themselves of this number between calls
     */
    LatestKnownEventId: number;
    /**
     * Array of events to publish. This can be empty if the client only wants to retrieve information
     */
    PublishEvents: UiEvent[];
    /**
     * Optional statistical and performance metrics collected by the frontend. Can be null or empty. Metrics are sum-accumulated and reported once a minute; please do not report the same logical event twice
     */
    Metrics: MetricPair[];
}
/**
 *
 */
export interface Associate extends Carrier {
    /**
     * Primary key
     */
    AssociateId?: number;
    /**
     * Initials, also login name, possibly database user name
     */
    Name?: string;
    /**
     * Owning person record
     * Use MDO List name "person" to get list items.
     */
    PersonId?: number;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * User type - 1 = internal user, 2 = resource, 3 = external user, 4 = anonymous, 5 = system
     */
    Type?: enums.UserType;
    /**
     * Primary group membership, see UserGroupLink for secondary memberships
     */
    GroupIdx?: number;
    /**
     * The associate's culture formatted fullname (firstname, middleName and lastname)
     */
    FullName?: string;
    /**
     * The associate's culture formatted formalname (firstname, middleName and lastname, title, mrmrs)
     */
    FormalName?: string;
    /**
     * If true, the user is retired and should have no rights, not appear in lists, etc.
     */
    Deleted?: boolean;
    /**
     * ID of the ej user record corresponding to this associate; 0 for associates that are not ej users
     */
    EjUserId?: number;
    /**
     * User name
     */
    UserName?: string;
}
/**
 * Returns the associate that belongs to this person if the person is an associate.
 * Returns Associate
 */
export interface Associate_GetAssociateByPersonIdRequest {
    /**
     * The person id
     */
    PersonId: number;
}
/**
 * Returns an array of strings(notepad pages).
 * Returns string[]
 */
export interface Associate_GetNoteRequest {
    /**
     * The associate id
     */
    AssociateId: number;
}
/**
 * Saves an array of strings(notepad pages).
 */
export interface Associate_SaveNoteRequest {
    /**
     * The associate id
     */
    AssociateId: number;
    /**
     * The array of strings(notepad pages).
     */
    Note: string[];
}
/**
 * Get unique key made from AssociateId and dbTag used for local storage encryption operations.
 * Returns string
 */
export interface Associate_GetEncryptionKeyRequest {
}
/**
 * Method that returns a array of associate , based on DiaryGroupType and groupId. The differernt types are, Userdefined, Usergroup and ResourceHeadings
 * Returns Associate[]
 */
export interface Associate_GetAssociatesByGroupRequest {
    /**
     * Id of the group
     */
    GroupId: number;
    /**
     * The type of group. See DiaryGroupType
     */
    Type: number;
}
/**
 * Method that logs off associates that are logged on to the win client
 */
export interface Associate_LogOffWindowsUsersRequest {
    /**
     * The ids of the associates that shall be logged off
     */
    AssociateIds: number[];
}
/**
 * Cache maintenance
 */
export interface Cache extends Carrier {
}
/**
 * Flushes all NetServer caches
 */
export interface Diagnostics_FlushCachesRequest {
}
/**
 * Get the name of the caches that can be flushed
 * Returns string[]
 */
export interface Diagnostics_GetCacheNamesRequest {
}
/**
 * Flushes all NetServer caches named
 */
export interface Diagnostics_FlushCachesByNameRequest {
    /**
     * Name of the cachnes to flush
     */
    CacheNames: string[];
}
/**
 * Get the current generation value of the named caches. State is opaque.
 * Returns string
 */
export interface Diagnostics_GetCacheStateRequest {
    /**
     * Names of the caches to check
     */
    CacheNames: string[];
}
/**
 *
 */
export interface EntityCounts extends Carrier {
    /**
     * The entity measured by this tile
     */
    EntityName?: string;
    /**
     * Number of entities (EntityName) an associate has created
     */
    Records?: number;
}
/**
 * Get an array of entities and number of entities created for the current associate
 * Returns EntityCounts[]
 */
export interface Diagnostics_GetEntityCountsForCurrentUserRequest {
}
/**
 * Change NetServer logging settings
 */
export interface Logging extends Carrier {
}
/**
 * Log a change in view state. The granularity of the logging depends on the current configuration. This call returns asynchronously, leaving the server to finish processing later on.
 */
export interface Diagnostics_LogViewStateRequest {
    /**
     * Current view state to be logged
     */
    ViewState: string;
}
/**
 * Change NetServer log settings.
 */
export interface Diagnostics_ChangeLogSettingsRequest {
    /**
     * Turn on warning log
     */
    LogWarning: boolean;
    /**
     * Turn on information log
     */
    LogInformation: boolean;
    /**
     * Turn on success audit log
     */
    LogSuccessAudit: boolean;
    /**
     * Turn on failure audit log
     */
    LogFailureAudit: boolean;
    /**
     * Log to event log
     */
    LogToEventLog: boolean;
    /**
     * Log to SuperOffice
     */
    LogToSuperOffice: boolean;
    /**
     * Log to file
     */
    LogToFile: boolean;
    /**
     * Log to trace
     */
    LogToTrace: boolean;
}
/**
 *
 */
export interface UsageStats extends Carrier {
}
/**
 * Collect and transmit usage statistics: Database Additions. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
 */
export interface Diagnostics_CollectDataAdditionsRequest {
}
/**
 * Collect and transmit usage statistics: Windows CRM Client Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
 */
export interface Diagnostics_CollectWinUsageRequest {
}
/**
 * Collect and transmit usage statistics: Web-based clients Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
 */
export interface Diagnostics_CollectWebUsageRequest {
}
/**
 * Collect and transmit usage statistics: Table Sizes. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
 */
export interface Diagnostics_CollectTableSizesRequest {
}
/**
 * Resynchronize user information with SuperOffice Community, if opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
 */
export interface Diagnostics_ResyncUsersRequest {
}
/**
 * Operations related to installation, upgrade and maintenance
 */
export interface Installation extends Carrier {
}
/**
 * After upgrading to a new fileset, there may be tasks that need to be done. Examples - import new TypicalSearches, if present. Tasks performed here need to be idempotent and independent of the actual upgrade jump (what was the previous version). They should complete in a reasonable time, not more than a few minutes maximum.
 * Returns string
 */
export interface Diagnostics_PerformTasksAfterUpgradeRequest {
}
/**
 *
 */
export interface WebAppUsage extends Carrier {
    /**
     * Primary Key
     */
    WebAppUsageId?: number;
    /**
     * Associate Id
     */
    AssocId?: number;
    /**
     * Which day the usage was logged
     */
    Timestamp?: Date;
    /**
     * The SoProtocol(ViewState)
     */
    ViewState?: string;
    /**
     * Number of times the specific soprotocol is accessed
     */
    AggregateCount?: number;
    /**
     * ??
     */
    AggregateBin?: number;
    /**
     * ??
     */
    Version?: number;
}
/**
 * Adds WebApp usage to existing log
 */
export interface Diagnostics_AddWebAppUsageRequest {
    /**
     * Web app usage.
     */
    WebAppUsages: WebAppUsage[];
}
/**
 * Returns true if viewState has been clicked at least once since FromDate, if asscoiateId < 0 or FromDate is DateTime.MinValue no restriction given for those parameters
 * Returns boolean
 */
export interface Diagnostics_WebAppUsageExistsInPeriodRequest {
    /**
     * The asscoiate id to look for webapp usage
     */
    AssociateId: number;
    /**
     * The viewState to search for
     */
    ViewState: string;
    /**
     * The datetime to restrict webapp usage on
     */
    FromDate: Date;
}
/**
 * Get all WebAppUsages for a given period, that match an optional search term
 * Returns WebAppUsage[]
 */
export interface Diagnostics_GetWebAppUsagesForPeriodRequest {
    /**
     *
     */
    FromDate: Date;
    /**
     *
     */
    ToDate: Date;
    /**
     * ViewState search term. '%' is the wildcard character, for example 'Pocket%' will match all viewstates starting with 'Pocket'. If empty, all viewstates will be matched
     */
    SearchTerm: string;
}
/**
 * This service provides tooltips. It is based on 'tooltip hints', strings that may eiehter be a tooltip text (if provided by someone else), or a set of key/value pairs or other specification.<para />The tooltip implementation is plugin based, and tooltip hints are passed to all registered plugin providers according to certain rules. It is therefore up to providers to parse and process tooltip hints as they see fit.
 */
export interface Tooltips extends Carrier {
}
/**
 * Parse a tooltip hint and return a tooltip. The returned tooltip string may contain resource string identifiers (in square brackets), to be processed by the resource manager.<para />The tooltip hint is either a literal text, representing itself, or a set of key/value pairs enclosed in curly braces. Each key is separated from its value by an equals sign, and each pair from the next by an ampersand, according to usual conventions.<para />A typical tooltip hint could be {contact_id=123} or {appointment_id=222&amp;mode=simple}
 * Returns string
 */
export interface Tooltips_GetTooltipRequest {
    /**
     *
     */
    TooltipHint: string;
}
/**
 * This service provides Previews. It is based on 'Preview hints', strings that may eiehter be a Preview text (if provided by someone else), or a set of key/value pairs or other specification.<para />The Preview implementation is plugin based, and Preview hints are passed to all registered plugin providers according to certain rules. It is therefore up to providers to parse and process Preview hints as they see fit.
 */
export interface Previews extends Carrier {
}
/**
 * Parse a Preview hint and return a Preview. The returned Preview string may contain resource string identifiers (in square brackets), to be processed by the resource manager.<para />The Preview hint is either a literal text, representing itself, or a set of key/value pairs enclosed in curly braces. Each key is separated from its value by an equals sign, and each pair from the next by an ampersand, according to usual conventions.<para />A typical Preview hint could be {contact_id=123} or {appointment_id=222&amp;mode=simple}
 * Returns string
 */
export interface Previews_GetPreviewRequest {
    /**
     *
     */
    PreviewHint: string;
}
/**
 * Settings specifying what selection to perform the mailmerge on, what merge document to use etc.
 */
export interface MailMergeSettings extends Carrier {
    /**
     * Identity of selection to use as source for recipients.
     */
    SelectionId?: number;
    /**
     * Identity of document to be used as merge draft.
     */
    DocumentId?: number;
    /**
     * How the merged document is delivered to the recipients.
     */
    MailMergeDeliveryType?: enums.EMailMergeTargetType;
    /**
     * Custom value for attention.
     */
    CustomAttention?: string;
    /**
     * Should custom attention always be used? If false, only use custom attention where there is no default.
     */
    AlwaysUseCustomAttention?: boolean;
    /**
     * Should we save a reference to the merge document on each recipient.
     */
    SaveDocument?: boolean;
    /**
     * If specified, use this value as default mail body.
     */
    CustomMailBody?: string;
    /**
     * If specified, register a task on recipients using properties from this object.
     */
    TaskEntity?: MailMergeTask;
    /**
     * Add this company interest to each company recipient.
     */
    AddCompanyInterest?: number;
    /**
     * Add this person interest to each person recipient.
     */
    AddPersonInterest?: number;
    /**
     * Remove this company interest on each company recipient.
     */
    RemoveCompanyInterest?: number;
    /**
     * Remove this person interest on each person recipient.
     */
    RemovePersonInterest?: number;
    /**
     * Include recipients that are marked with NoMailings
     */
    IncludeNoMailingsRecipient?: boolean;
    /**
     * If true, do the merge task, but use current user as target, instead of selection members
     */
    TestOnly?: boolean;
    /**
     * Identity of project to use as source for recipients.
     */
    ProjectId?: number;
    /**
     * Include recipients that are marked as retired
     */
    IncludeRetiredRecipients?: boolean;
    /**
     * Include recipients that are marked with stop
     */
    IncludeStoppedRecipients?: boolean;
    /**
     * If specified, use this value as default mail subject.
     */
    CustomMailSubject?: string;
    /**
     * Used to store additional information for the delivery systems.
     */
    ExtraInfo?: string;
    /**
     *
     */
    Synchronous?: boolean;
    /**
     * If true, the selection is a temporary selection that can be deleted later.
     */
    IsTemporarySelection?: boolean;
}
/**
 * Properties describing a task to create on recipients of a mail merge
 */
export interface MailMergeTask extends Carrier {
    /**
     * Project identity to set on task
     */
    ProjectId?: number;
    /**
     * Type identity to set on task
     */
    TypeId?: number;
    /**
     * When the task should start
     */
    StartDate?: Date;
    /**
     * Duration of task
     */
    Duration?: number;
    /**
     * Text describing task
     */
    Description?: string;
    /**
     * Priority of task
     */
    PriorityId?: number;
    /**
     * Who the task should be visible for
     */
    VisibleFor?: VisibleFor;
    /**
     * Completed status for task
     */
    Completed?: enums.ActivityStatus;
    /**
     * Associate identity of who should be set as owner of the task.  If value is 0, the recipient owner(our contact) will be used.
     */
    OwnerAssociateId?: number;
    /**
     * Should we only create one task on each company? If false, separate tasks will be created for all persons from the same company.
     */
    SingleEntryOnEachCompany?: boolean;
    /**
     * Sale identity to set on task
     */
    SaleId?: number;
}
/**
 *
 */
export interface SelectionEntity extends Carrier {
    /**
     * The actual text, max 2047 significant characters even though it is stored as a larger data type on some databases
     */
    Description?: string;
    /**
     * The actual text, max 2047 significant characters even though it is stored as a larger data type on some databases
     */
    Postit?: string;
    /**
     * Owner of the selection
     */
    Associate?: Associate;
    /**
     * Who created the selection
     */
    CreatedBy?: Associate;
    /**
     * Who last modified the selection
     */
    UpdatedBy?: Associate;
    /**
     * Selection category type (list item)
     * Use MDO List name "searchCat" to get list items.
     */
    SelectionCategory?: SelectionCategory;
    /**
     * Original primary user group of associate
     */
    GroupIdx?: number;
    /**
     * 0 = Include first person, 1 = Include all persons, 2 = Include no persons
     */
    IncludePerson?: number;
    /**
     * How many selectionmembers (for progress bar calculations) - estimate, -1 (or 4294967295) means we don't know
     */
    MemberCount?: number;
    /**
     * Name of selection, freetext indexed
     */
    Name?: string;
    /**
     * Postit text record id.
     */
    PostitTextId?: number;
    /**
     * Registered when
     */
    CreatedDate?: Date;
    /**
     * Primary key
     */
    SelectionId?: number;
    /**
     * What the name sounds like, for duplicate detection
     */
    SoundEx?: string;
    /**
     * How did we get this selection? For future integration needs
     */
    Source?: number;
    /**
     * Description text record id
     */
    TextId?: number;
    /**
     * Last updated when
     */
    UpdatedDate?: Date;
    /**
     * Number of updates made to this record
     */
    UpdatedCount?: number;
    /**
     * Obsolete, but still maintained denormalization of visiblefor
     */
    Visibility?: number;
    /**
     * Static/Dynamic/Combined?
     */
    SelectionType?: enums.SelectionType;
    /**
     * Filter out duplicate members based on company?
     */
    CompanyUnique?: boolean;
    /**
     * TargetTableNumber defines the type of selection members this selection contains. e.g. the table number for 'contact', or 'project' or 'sale'
     */
    TargetTableNumber?: number;
    /**
     * TargetTableName contains the name of the table in lowercase. defines the type of selection members this selection contains. e.g. 'contact', or 'project' or 'sale'
     */
    TargetTableName?: string;
    /**
     * The Completed state.
     */
    Completed?: boolean;
    /**
     * LeftSelectionId is used in combination with RightSelectionId and CombinationType to define an union of two selections when SelectionType=Combined.
     */
    LeftSelectionId?: number;
    /**
     * RightSelectionId  is used in combination with LeftSelectionId and CombinationType to define an union of two selections when SelectionType=Combined.
     */
    RightSelectionId?: number;
    /**
     * How to combine the two selections when SelectionType = Combined.
     */
    SelectionUnionType?: enums.SelectionUnionType;
    /**
     * The name of the Archive Provider that will deliver the content of the archive - the actual entity rows
     */
    MainProviderName?: string;
    /**
     * The name, if relevant, of the Archive Provider that will deliver the Shadow rows: contact/person rows related to the actual entity. Can be blank, indicating that there is no shadow archive
     */
    ShadowProviderName?: string;
    /**
     * ID/key of the last-used chart tile on this selection
     */
    ChartKey?: string;
    /**
     * The date/time this selection was last loaded (selectionentity fetched)
     */
    LastLoaded?: Date;
    /**
     * Who last loaded this selection
     */
    LastLoadedBy?: number;
    /**
     * Associate that last looked at the selection members; only date (not time) is valid
     */
    LastLoadedByAssociate?: Associate;
    /**
     * The date/time the membership the selection last changed. Dynamic: change of criteria; Static: add/remove members; Combined: change of algorithm
     */
    LastMembershipChange?: Date;
    /**
     * Who last changed the membership
     */
    LastMembershipChangeBy?: number;
    /**
     * Associate that last changed the selection membership (static members, dynamic criteria, combined parameters); only date (not time) is valid
     */
    LastMembershipChangeByAssociate?: Associate;
    /**
     * 'Static selection of Companies', or whatever else is appropriate, made by combining text resources for the type and the entity (plural form); this string will contain resource references
     */
    MainHeading?: string;
    /**
     * 'Companies', or whatever else is appropriate - the plural form of the entity name; this string will contain resource references
     */
    MemberTabHeading?: string;
    /**
     * The name of the provider for the Mailings tab, if relevant; this string will contain resource references
     */
    MailingsProviderName?: string;
    /**
     * The associated tile definition
     */
    DashboardTileDefinitionId?: number;
    /**
     * The set of users or groups the record is visible for
     */
    VisibleFor?: VisibleFor[];
}
/**
 * Create (but do not save) a new selection entity, for the current user and the given target table; other fields populated as by CreateDefaultSelectionEntity()
 * Returns SelectionEntity
 */
export interface Selection_CreateSelectionEntityRequest {
    /**
     * The name of the target table, such as 'contact' or 'appointment'; any table for which Selection functionality is enabled
     */
    TargetTableName: string;
}
/**
 * Creates a new selection based on selection members from an existing selection.
 * Returns SelectionEntity
 */
export interface Selection_CreateContactSelectionFromSelectionRequest {
    /**
     * The id of the selection to copy members from.
     */
    SelectionId: number;
    /**
     * The name of the new selection.
     */
    Name: string;
    /**
     * The type of ContactSelection to create. The type can be static or dynamic. If the original selection to copy from is static, the SelectionType can only be static. If the original selection is dynamic, both a static and dynamic selection can be created.
     */
    TargetSelectionType: enums.SelectionType;
    /**
     * If true, the members from the original selection will be added to the newly created selection.
     */
    CopyMembers: boolean;
}
/**
 * Creates a temporary selection with members from a collection of ContactPerson id's.
 * Returns SelectionEntity
 */
export interface Selection_CreateTemporaryContactSelectionFromContactPersonIdsRequest {
    /**
     * A collection of ContactPersonId to copy into the temporary contact selection as members.
     */
    ContactPersonIds: ContactPersonId[];
}
/**
 * Creates a temporary selection with members from an existing project.
 * Returns SelectionEntity
 */
export interface Selection_CreateTemporaryContactSelectionFromProjectMembersRequest {
    /**
     * The id of the project to add members from.
     */
    ProjectId: number;
}
/**
 * Copy contact selection members from selection into an existing selection.
 */
export interface Selection_CopyContactSelectionMembersRequest {
    /**
     * The id of the selection to copy members from.
     */
    FromSelectionId: number;
    /**
     * The id of the selection to copy members to.
     */
    ToSelectionId: number;
}
/**
 * Returns a RecipientStatistics object with a count of addresses, emailaddresses and emailaddresses.
 * Returns RecipientStatistics
 */
export interface Selection_GetRecipientStatisticsRequest {
    /**
     * The id of the selection to get the statistics for.
     */
    SelectionId: number;
}
/**
 * Returns a RecipientStatistics object with a count of addresses, emailaddresses and emailaddresses based on members in a project.
 * Returns RecipientStatistics
 */
export interface Selection_GetRecipientStatisticsFromProjectMembersRequest {
    /**
     * The id of the project to get the member statistics for.
     */
    ProjectId: number;
}
/**
 * Returns a RecipientStatistics object with a count of addresses, emailaddresses and emailaddresses based on contact and persons in a collection of ContactPersonId.
 * Returns RecipientStatistics
 */
export interface Selection_GetRecipientStatisticsFromContactPersonIdsRequest {
    /**
     * A collection of ContactPersonId to get the statistics for.
     */
    ContactPersonIds: ContactPersonId[];
}
/**
 * Adds the collection of ContactPersonId as members to the static selection
 */
export interface Selection_AddContactSelectionMembersRequest {
    /**
     * The id of the selection where to members will be added to.
     */
    SelectionId: number;
    /**
     * A collection of ContactPersonId to add to the selection.
     */
    ContactPersonIds: ContactPersonId[];
}
/**
 * Removes members from the selection as  specified in the collection of ContactPersonId.
 */
export interface Selection_RemoveContactSelectionMembersRequest {
    /**
     * The id of the selection where to members will be removed.
     */
    SelectionId: number;
    /**
     * A collection of ContactPersonId to remove from the static selection.
     */
    ContactPersonIds: ContactPersonId[];
}
/**
 * Removes members from the selection using a collection a selectionmember id's. Members can only be removed from single selection.
 */
export interface Selection_RemoveContactSelectionMembersFromIdsRequest {
    /**
     * The id of the selection where to members will be removed.
     */
    SelectionId: number;
    /**
     * An array of selectionmember id's to remove from the selection.
     */
    SelectionMembersIds: number[];
}
/**
 * Adds members to the selection from the search result.
 * Returns number
 */
export interface Selection_AddContactSelectionMembersFromSearchRequest {
    /**
     * The id of the selection to add members
     */
    SelectionId: number;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
}
/**
 * Removes members from the selection using the search result.
 * Returns number
 */
export interface Selection_RemoveContactSelectionMembersFromSearchRequest {
    /**
     * The id of the selection to remove members.
     */
    SelectionId: number;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search.
     */
    StorageKey: string;
}
/**
 * Creates a temporary selection.
 * Returns SelectionEntity
 */
export interface Selection_CreateTemporaryContactSelectionRequest {
}
/**
 * Creates a temporary selection with members from a collection of selectionmember id's.
 * Returns SelectionEntity
 */
export interface Selection_CreateTemporaryContactSelectionFromSelectionMemberIdsRequest {
    /**
     * The selectionId the selectionmembers is a part of.
     */
    SelectionId: number;
    /**
     * A collection of int ids to copy into the temporary contact selection as members.
     */
    SelectionMemberIds: number[];
}
/**
 * Adds or removes interests on companies and persons in a selection.
 */
export interface Selection_AddRemoveContactSelectionMemberInterestsRequest {
    /**
     * The id of the selection to add or remove interests members from.
     */
    SelectionId: number;
    /**
     * Array of int containing the id's of the interests to add to the company.
     */
    AddCompanyInterests: number[];
    /**
     * Array of int containing the id's of the interests to remove from the company.
     */
    RemoveCompanyInterests: number[];
    /**
     * Array of int containing the id's of the interests to add to the contact.
     */
    AddContactInterests: number[];
    /**
     * Array of int containing the id's of the interests to remove from the contact.
     */
    RemoveContactInterests: number[];
}
/**
 * Edit company and contact details in a selection based on contents in selectionMemberEditValues.
 */
export interface Selection_EditContactSelectionMemberDetailsRequest {
    /**
     * The id of the selection to edit members from.
     */
    SelectionId: number;
    /**
     * An object of <see cref="SelectionMemberEditValues"/> describing what should be changed for companys and contacts.
     */
    SelectionMemberEditValues: SelectionMemberEditValues;
}
/**
 * Generate follow-ups for members in the selection.
 */
export interface Selection_GenerateFollowUpsRequest {
    /**
     * The id of the selection to generate the follow-ups for.
     */
    SelectionId: number;
    /**
     * The AppointmentEntity with information about the appointment.
     */
    AppointmentEntity: AppointmentEntity;
    /**
     * The associate to save the appointments on. If saveOnContactOwner is true, this id will be ignored. Appointments wil be saved on current user if associateId = 0.
     */
    AssociateId: number;
    /**
     * If true, the appointments will be saved on contact owner (Our contact). This parameter will override associateId if true.
     */
    SaveOnContactOwner: boolean;
    /**
     * If true, only one appointment will be created for each contact.
     */
    UniqueContact: boolean;
}
/**
 * ExportSelectionMembers will generate a string that is the result of substituting the template variables with values from selectionmembers.
 * Returns number[]
 */
export interface Selection_ExportSelectionMembersRequest {
    /**
     * The id of the selection to generate the exported file.
     */
    SelectionId: number;
    /**
     * The templateName parameter is the relative path of a .sxf file template. The .sxf files can be found in \template or in the user folder of the so archive.
     */
    TemplateName: string;
    /**
     * If the selection contains other members than contacts, setting this to true will export the contact archive of the selection.
     */
    UseContacts: boolean;
}
/**
 * ExportSelectionMembers will generate a string that is the result of substituting the template variables with values from selectionmembers.
 * Returns number[]
 */
export interface Selection_ExportSelectionMembersWithOrderByRequest {
    /**
     * The id of the selection to generate the exported file.
     */
    SelectionId: number;
    /**
     * The templateName parameter is the relative path of a .sxf file template. The .sxf files can be found in \template or in the user folder of the so archive.
     */
    TemplateName: string;
    /**
     * If the selection contains other members than contacts, setting this to true will export the contact archive of the selection.
     */
    UseContacts: boolean;
    /**
     * OrderBy. <Column,OrderBySortType>
     */
    OrderBy: string;
}
/**
 * Start a mailmerge operation with specified settings.
 */
export interface Selection_StartMailMergeRequest {
    /**
     * All settings needed to perform the mailmerge operation.
     */
    Settings: MailMergeSettings;
}
/**
 * Set which duplicate rules should be active or not
 */
export interface Selection_SetDuplicateRulesStatusRequest {
    /**
     * Duplicate rules to update active status for
     */
    Rules: DuplicateRule[];
}
/**
 * Get duplicates(exact or similar in the database) based on the name
 * Returns DuplicateEntry[]
 */
export interface Selection_GetDuplicatesRequest {
    /**
     * Name used for lookup
     */
    Name: string;
}
/**
 * Retrieve all available duplicate rules for selection
 * Returns DuplicateRule[]
 */
export interface Selection_GetDuplicateRulesRequest {
}
/**
 * Creates a new selection based on external duplicate
 * Returns number
 */
export interface Selection_CreateNewEntryRequest {
    /**
     * The duplicate to create a new entry based upon
     */
    Duplicate: DuplicateEntry;
}
/**
 * Deletes all contacts from a selection. If a contact does not have delete rights, it will be skipped.
 */
export interface Selection_DeleteContactsRequest {
    /**
     * Id of the selection the delete operation will be performed.
     */
    SelectionId: number;
}
/**
 * Add selection members to a static selection of type others than contacts.
 * Returns number
 */
export interface Selection_AddSelectionMembersRequest {
    /**
     * The selection id to add the members to.
     */
    SelectionId: number;
    /**
     * Collection of ids to add to the selection.
     */
    Ids: number[];
}
/**
 * Removes members from the selection as  specified in the collection of entity ids. The ids are selection member ids (selection member primary key)
 */
export interface Selection_RemoveSelectionMembersRequest {
    /**
     * The id of the selection where to members will be removed.
     */
    SelectionId: number;
    /**
     * Selection member primary keys
     */
    SelectionMemberIds: number[];
}
/**
 * Removes members from the selection as specified in the collection of entity ids. The ids can be a collection of sale ids, or other supported types.
 */
export interface Selection_RemoveSelectionMembersByIdRequest {
    /**
     * The id of the selection where to members will be removed.
     */
    SelectionId: number;
    /**
     * A collection of sale/project/contact ids to remove from the selection. The ids can be a collection of sale ids, or other supported types.
     */
    Ids: number[];
}
/**
 * Adds members from the selection using the search result.
 * Returns number
 */
export interface Selection_AddSelectionMembersFromSearchRequest {
    /**
     * The id of the selection to add members
     */
    SelectionId: number;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
}
/**
 * Removes members from the selection using the search result.
 * Returns number
 */
export interface Selection_RemoveSelectionMembersFromSearchRequest {
    /**
     * The id of the selection to remove members.
     */
    SelectionId: number;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search.
     */
    StorageKey: string;
}
/**
 * Copy selection members from selection into an existing selection.
 */
export interface Selection_CopySelectionMembersRequest {
    /**
     * The id of the selection to copy members from.
     */
    FromSelectionId: number;
    /**
     * The id of the selection to copy members to.
     */
    ToSelectionId: number;
}
/**
 * Creates a temporary selection with members from a collection of entity id's.
 * Returns SelectionEntity
 */
export interface Selection_CreateTemporarySelectionFromIdsRequest {
    /**
     * A collection of Ids to copy into the temporary selection as members. The ids are primary keys of entities defined by the targetTableNumber parameter.
     */
    Ids: number[];
    /**
     * The type of selection to create.
     */
    TargetTableNumber: number;
}
/**
 * Creates a new selection based on selection members from an existing selection.
 * Returns SelectionEntity
 */
export interface Selection_CreateSelectionFromSelectionRequest {
    /**
     * The id of the selection to copy members from.
     */
    SelectionId: number;
    /**
     * The name of the new selection.
     */
    Name: string;
    /**
     * The type of Selection to create. The type can be static or dynamic. If the original selection to copy from is static, the SelectionType can only be static. If the original selection is dynamic, both a static and dynamic selection can be created.
     */
    TargetSelectionType: enums.SelectionType;
    /**
     * If true, the members from the original selection will be added to the newly created selection.
     */
    CopyMembers: boolean;
}
/**
 * Creates a new contact selection based on contact selection members from an existing shadow sale, appointment, project or document selection. The new selection will always be static even if the original selection is dynamic.
 * Returns SelectionEntity
 */
export interface Selection_CreateContactSelectionFromShadowSelectionRequest {
    /**
     * The id of the selection to copy members from.
     */
    SelectionId: number;
    /**
     * The name of the new selection.
     */
    Name: string;
}
/**
 * Deletes all entities from a selection. If an entity does not have delete rights, it will be skipped.
 */
export interface Selection_DeleteEntitiesRequest {
    /**
     * Id of the selection the delete operation will be performed.
     */
    SelectionId: number;
}
/**
 * Get a list of all selection ids where the given selection is used to create a combined selection.
 * Returns number[]
 */
export interface Selection_GetParentCombinedSelectionsRequest {
    /**
     * The selectionId to query for.
     */
    SelectionId: number;
}
/**
 * Get the list of members in this selection. The type of members depends on the target table of the selection.
 * Returns ArchiveListItem[]
 */
export interface Selection_GetSelectionMembersArchiveRowsRequest {
    /**
     * The selectionId we want selection members for.
     */
    SelectionId: number;
    /**
     * (optional) Comma separated Column names to include in result. List of columns varies depending on the selection's TargetTable. e.g. 'name', 'firstname', 'startTime'
     */
    Select: string;
}
/**
 * Get the list of members in this selection's shadow (i.e. the list of contacts + persons referenced in the main selection).
 * Returns ArchiveListItem[]
 */
export interface Selection_GetSelectionShadowMembersArchiveRowsRequest {
    /**
     * The selectionId we want selection members for.
     */
    SelectionId: number;
    /**
     * (optional) Comma separated Column names to include in result. List of columns varies depending on the selection's TargetTable. e.g. 'name', 'firstname,name', 'startTime,firstname,name'
     */
    Select: string;
}
/**
 * Get the criteria for this dynamic selection.
 * Returns ArchiveRestrictionInfo[]
 */
export interface Selection_GetDynamicSelectionCriteriaRequest {
    /**
     * The id of the selection to add members
     */
    SelectionId: number;
}
/**
 * Update the criteria for this dynamic selection. Replaces existing criteria with the new values.
 * Returns ArchiveRestrictionInfo[]
 */
export interface Selection_SetDynamicSelectionCriteriaRequest {
    /**
     * The id of the selection to add members
     */
    SelectionId: number;
    /**
     * Criteria defining the selection result.
     */
    Criteria: ArchiveRestrictionInfo[];
}
/**
 * Update the criteria for this dynamic selection using string. Criteria are parsed from the OData filter form: ''name startswith 'foo' and category in (1,2,3)''
 * Returns ArchiveRestrictionInfo[]
 */
export interface Selection_SetDynamicSelectionCriteria2Request {
    /**
     * The id of the selection to add members
     */
    SelectionId: number;
    /**
     * Criteria defining the selection result in OData filter form: `category in (1,2,3) and name = 'foo'`
     */
    Filter: string;
}
/**
 * Update the criteria for this dynamic selection. Use criteria as either restriction objects or OData string format. Criteria are parsed from the OData filter form: ''name startswith 'foo' and category in (1,2,3)''
 * Returns ArchiveRestrictionInfo[]
 */
export interface Selection_SetDynamicSelectionCriteria3Request {
    /**
     * The id of the selection to add members
     */
    SelectionId: number;
    /**
     * Criteria defining the selection result. Pass NULL if using the filter string instead.
     */
    Criteria: ArchiveRestrictionInfo[];
    /**
     * Criteria defining the selection result in OData filter form: `category in (1,2,3) and name = 'foo'`. Pass NULL or empty string '' if using the criteria objects.
     */
    Filter: string;
}
/**
 * Deletes all persons from a selection. If a person does not have delete rights, it will be skipped.
 */
export interface Selection_DeletePersonsRequest {
    /**
     * Id of the selection the delete operation will be performed.
     */
    SelectionId: number;
}
/**
 * Get the criteria for this dynamic selection. This call supports multiple criteria groups.
 * Returns ArchiveRestrictionGroup[]
 */
export interface Selection_GetDynamicSelectionCriteriaGroupsRequest {
    /**
     * The id of the selection to add members
     */
    SelectionId: number;
}
/**
 * Update the criteria for this dynamic selection. Replaces existing criteria with the new values. This call supports multiple criteria groups.
 * Returns ArchiveRestrictionGroup[]
 */
export interface Selection_SetDynamicSelectionCriteriaGroupsRequest {
    /**
     * The id of the selection to add members
     */
    SelectionId: number;
    /**
     * Criteria groups defining the selection result. Empty array is legal, simply means no criteria have been set
     */
    Criteria: ArchiveRestrictionGroup[];
}
/**
 * Provider name and selection id for a Find temporary selection
 */
export interface SelectionForFind extends Carrier {
    /**
     * The name of the Archive Provider to use when working with this selection; this is the main entity provider, never Shadow, Combined or anything else fancy
     */
    ProviderName?: string;
    /**
     * Primary key
     */
    SelectionId?: number;
    /**
     * Most Find entities support saving the search as a Dynamic Selection: this bool indicates if that is the case
     */
    CanSaveAsSelection?: boolean;
    /**
     * 'Sale', intended for the main headings in the Find front page; this string will contain resource references
     */
    MainHeading?: string;
    /**
     * 'Find sale', or whatever is appropriate for the Find <entity> filter page; this string will contain resource references
     */
    FilterScreenHeading?: string;
    /**
     * 'Companies', or whatever else is appropriate - the plural form of the entity name, intended for the Selection.Details tab before it is saved (!!); this string will contain resource references
     */
    SelectionEntityHeading?: string;
}
/**
 * Obtain a selection for the given entity, for the current user, of type WorkingSetForFind. Optionally populate criteria from the TypicalSearches system
 * Returns SelectionForFind
 */
export interface Selection_GetSelectionForFindRequest {
    /**
     * The name of the entity to make a selection for; examples 'sale', 'project', 'y_equipment'
     */
    EntityName: string;
    /**
     * If 0, keep existing criteria; if -1, reset to entity default; > 0 get criteria from given TypicalSearch
     */
    TypicalSearchId: number;
}
/**
 * The selection summary, for tabs or other concise views.
 */
export interface SelectionSummaryItem {
    /**
     * Primary key
     */
    SelectionId?: number;
    /**
     * Name, freetext indexed
     */
    Name?: string;
    /**
     * The main table this is a selection of
     */
    TargetTable?: string;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Provider name for this selection
     */
    ProviderName?: string;
}
/**
 * Get an array of summaryitem for the given selections
 * Returns SelectionSummaryItem[]
 */
export interface Selection_GetSelectionSummariesRequest {
    /**
     * The selections to fetch summaries for
     */
    SelectionIds: number[];
}
/**
 * Complete information about a TypicalSearch (including criteria)
 */
export interface TypicalSearch extends Carrier {
    /**
     * Primary key
     */
    TypicalSearchId?: number;
    /**
     * The title of the typical search (multilingual)
     */
    Title?: string;
    /**
     * The tooltip for the typical search (multilingual)
     */
    Tooltip?: string;
    /**
     * The name of the entity the typical search links to
     */
    EntityName?: string;
    /**
     * Indicates if this is the default set of criteria for an entity
     */
    IsEntityDefault?: number;
    /**
     * For selection-of-company: state of the Include Main Contact checkbox
     */
    IncludePerson?: number;
    /**
     * Name of organisation that sources and maintains this TypicalSearch. Allows for both SuperOffice and partners to maintain sets of typical searches without conflict
     */
    Source?: string;
    /**
     * The current downloaded version of this typical search
     */
    VersionNumber?: number;
    /**
     * The restrictions (can be multiple groups) that make up the TypicalSearch
     */
    RestrictionGroups?: ArchiveRestrictionGroup[];
}
/**
 * Full set of all TypicalSearch elements maintained by one source (including criteria)
 */
export interface TypicalSearches extends Carrier {
    /**
     * Name of organisation that sources and maintains this TypicalSearch. Allows for both SuperOffice and partners to maintain sets of typical searches without conflict
     */
    Source?: string;
    /**
     * The master version number in this update, at least the highest of those in the searches, but can be higher to force an update (and delete of missing elements)
     */
    MasterVersion?: number;
    /**
     * If true, then any TypicalSearch records in the database that are NOT referenced in this call, should be deleted
     */
    DeleteLeftovers?: boolean;
    /**
     * The TypicalSearch structures (including criteria) to import
     */
    Searches?: TypicalSearch[];
}
/**
 * Update (import) TypicalSearch information in the database
 * Returns string
 */
export interface Selection_UpdateTypicalSearchRequest {
    /**
     * TypicalSearch structures to import. If null, then the fileset is scanned for *TypicalSearch.json files and those are imported instead
     */
    Searches: TypicalSearches;
}
/**
 *
 */
export interface ContactOrPersonFromEmail extends Carrier {
    /**
     * The id of the person
     */
    PersonId?: number;
    /**
     * The person fullname
     */
    FullName?: string;
    /**
     * The emailAddress
     */
    EmailAddress?: string;
    /**
     * The id of the contact
     */
    ContactId?: number;
    /**
     * The contact name
     */
    ContactName?: string;
    /**
     * Department
     */
    ContactDepartment?: string;
    /**
     * Contact category
     */
    ContactCategory?: string;
    /**
     * If person ? The person name, else contact name
     */
    SortName?: string;
}
/**
 * Properties for an email account
 */
export interface EMailAccount extends Carrier {
    /**
     * The account primary key
     */
    EMailAccountId?: number;
    /**
     * The account (from) address
     */
    EMailAddress?: string;
    /**
     * Id of the associate who owns this account
     */
    AssociateId?: number;
    /**
     * Account credentials for imap
     */
    IncomingCredentials?: ServiceAuth;
    /**
     * Account credentials for smtp
     */
    OutgoingCredentials?: ServiceAuth;
    /**
     * The account status (Disabled or...) Readonly field
     */
    AccountStatus?: number;
    /**
     * Count of concurring errors of fetching email. Readonly field
     */
    ErrorCount?: number;
    /**
     * Reason/Error message. Readonly field
     */
    ErrorReason?: string;
    /**
     * Inbox folder name if available in the db
     */
    InboxFolder?: string;
    /**
     * Sent email folder name if available in the db
     */
    SentFolder?: string;
}
/**
 * Returns the email account corresponding to this email address (for the current associate).
 * Returns EMailAccount
 */
export interface EMail_GetEMailAccountFromEMailAddressRequest {
    /**
     * The address associated with this email account
     */
    FromAddress: string;
}
/**
 * Get current accountId (last logged into should normally be current) for logged in associate
 * Returns number
 */
export interface EMail_GetCurrentAccountIdRequest {
}
/**
 * Get current account (last logged into should normally be current) for logged in associate
 * Returns EMailAccount
 */
export interface EMail_GetCurrentAccountRequest {
}
/**
 *
 */
export interface EMailAddress extends Carrier {
    /**
     * Primary key
     */
    ContactId?: number;
    /**
     *
     */
    ContactName?: string;
    /**
     * Primary key
     */
    PersonId?: number;
    /**
     *
     */
    PersonName?: string;
    /**
     * Primary key
     */
    AssociateId?: number;
    /**
     *
     */
    Address?: string;
    /**
     * Primary key
     */
    EmailId?: number;
    /**
     * All persons with this EmailAddress stored in db is listed here
     */
    DuplicatePersonIds?: number[];
    /**
     * The name on the email address
     */
    Name?: string;
}
/**
 * Get all persons and contacts with the given email address
 * Returns PersonEntity[]
 */
export interface EMail_GetPersonEntitiesFromEmailAddressRequest {
    /**
     * The emailAddress to find persons and contacts for
     */
    EmailAddress: string;
}
/**
 * Get all persons and contacts with the given email address
 * Returns Person[]
 */
export interface EMail_GetPersonsFromEmailAddressRequest {
    /**
     * The emailAddress to find persons and contacts for
     */
    EmailAddress: string;
}
/**
 * Return true if there is one or more MX records in DNS for the given mail domain
 * Returns boolean
 */
export interface EMail_HasMXRecordRequest {
    /**
     * The mail domain to check. Normally this is the part after @ in an email address
     */
    MailDomain: string;
}
/**
 * Return true if target domain contains a SPF record which is under the given SPF record
 * Returns boolean
 */
export interface EMail_HasSPFRecordRequest {
    /**
     * The SPF to match from
     */
    SourceSpf: string;
    /**
     * The domain to verify if it has at least one SPF record contained in the source SPF
     */
    TargetDomain: string;
}
/**
 * Resolve separate emails from single string. Also lookup persons by emails.
 * Returns EMailAddress[]
 */
export interface EMail_ResolveEMailRecipientsRequest {
    /**
     * The string to lookup emails from
     */
    EmailAddress: string;
}
/**
 * Information about an email appointment received as iCal data
 */
export interface EMailAppointment extends Carrier {
    /**
     * Appointment information
     */
    Appointment?: Appointment;
    /**
     * Method field stored in ICS file.
     */
    CalMethod?: enums.CalMethod;
    /**
     * List of participants in the iCal file - first one being the organizer
     */
    Participants?: string[];
    /**
     * Comment attached to the calendar event (accept / reject reason etc.)
     */
    Comment?: string;
    /**
     * Sequence number in ICS file.
     */
    Sequence?: number;
    /**
     * Start date/time in ICS file.
     */
    DtStart?: Date;
    /**
     * End date/time in ICS file.
     */
    DtEnd?: Date;
    /**
     * A newer invitation exists
     */
    Superseded?: boolean;
}
/**
 * Information about an attachment
 */
export interface EMailAttachment extends Carrier {
    /**
     * Name/description
     */
    Description?: string;
    /**
     * Filename
     */
    Filename?: string;
    /**
     * Size of attachment
     */
    Size?: number;
    /**
     * Attachment Content-Type
     */
    Type?: string;
    /**
     * Content-Transfer-Encoding
     */
    Encoding?: string;
    /**
     * Content-ID
     */
    Id?: string;
    /**
     * Content-Disposition
     */
    Disposition?: string;
    /**
     * Binary stream for outgoing attachments. This property will not be populated for existing e-mail items.
     */
    Stream?: ArrayBuffer | string;
}
/**
 * All information needed to connect to a mailserver
 */
export interface EMailConnectionInfo extends Carrier {
    /**
     * Hostname or ip to server to connect to. Custom ports may be specified by adding ':' and the port number after the name/ip. Ex: '127.0.0.1:6543'
     */
    ServerName?: string;
    /**
     * Name of user to log in with
     */
    UserName?: string;
    /**
     * Password for the username
     */
    Password?: string;
    /**
     * Optional folder to set as current after logging in
     */
    Folder?: string;
    /**
     * Use a secure connection with the server
     */
    UseSSL?: boolean;
}
/**
 *
 */
export interface EMailConnectionInfoExtended extends Carrier {
    /**
     *
     */
    Port?: number;
    /**
     * Hostname or ip to server to connect to. Custom ports may be specified by adding ':' and the port number after the name/ip. Ex: '127.0.0.1:6543'
     */
    ServerName?: string;
    /**
     *
     */
    Protocol?: string;
    /**
     * Name of user to log in with
     */
    UserName?: string;
    /**
     * Password for the username
     */
    Password?: string;
    /**
     * Use a secure connection with the server
     */
    UseSSL?: boolean;
    /**
     * Optional folder to set as current after logging in
     */
    Folder?: string;
}
/**
 *
 */
export interface EMailCustomHeader extends Carrier {
    /**
     * Name of header
     */
    Name?: string;
    /**
     *
     */
    Values?: string[];
}
/**
 * All information about an e-mail
 */
export interface EMailEntity extends Carrier {
    /**
     * To recipients of e-mail
     */
    To?: EMailAddress[];
    /**
     * Cc recipients of e-mail
     */
    Cc?: EMailAddress[];
    /**
     * Bcc recipient of e-mail
     */
    Bcc?: EMailAddress[];
    /**
     * Subject of the e-mail
     */
    Subject?: string;
    /**
     * Body formatted in HTML
     */
    HTMLBody?: string;
    /**
     * Who did the e-mail originate from
     */
    From?: EMailAddress;
    /**
     * When was the e-mail sent
     */
    Sent?: Date;
    /**
     * Total size of the e-mail
     */
    Size?: number;
    /**
     * Importance of the e-mail
     */
    Priority?: enums.EMailPriority;
    /**
     * Flag status of this mail (unread, replied, deleted )
     */
    Flags?: enums.EMailFlags;
    /**
     * Unique id of e-mails
     */
    MessageID?: string;
    /**
     * Body formatted in plain text
     */
    PlainBody?: string;
    /**
     * Is this a sent e-mail (not new)
     */
    IsSent?: boolean;
    /**
     * Glue between SuperOffice data and an e-mail.
     */
    EMailSOInfo?: EMailSOInfo;
    /**
     * Unique id for the e-mail on the server
     */
    ServerId?: number;
    /**
     *
     */
    Attachments?: EMailAttachment[];
    /**
     * Non standard e-mail headers
     */
    CustomHeaderList?: EMailCustomHeader[];
    /**
     * Name of folder the e-mail belongs in
     */
    FolderName?: string;
    /**
     * Primary key
     */
    EmailItemId?: number;
    /**
     * Account Id
     */
    AccountId?: number;
    /**
     * Received date time
     */
    ReceivedAt?: Date;
    /**
     * The envelope of the email this email is a reply to, if it exists
     */
    InReplyTo?: EMailEnvelope;
    /**
     * When this email was replied at
     */
    RepliedAt?: Date;
    /**
     * If this email contains exactly one iCal appointment
     */
    HasCalendarData?: boolean;
    /**
     * Method stored in the associated iCal appointment. Indicates if the iCal data is a reply, counter proposal etc.
     */
    CalMethod?: enums.CalMethod;
    /**
     * Reply status stored in calendar data for the ical method is REPLY
     */
    CalReplyStatus?: enums.CalReplyStatus;
}
/**
 * Get en e-mail based on its unique id
 * Returns EMailEntity
 */
export interface EMail_GetEMailFromIdRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * Unique ID for the e-mail to retrieve
     */
    MessageServerId: number;
    /**
     * If true try to look up e-mail addresses in from/to/cc/bcc fields against superoffice contacts
     */
    LookupAddresses: boolean;
    /**
     * Any flags to apply to the fetched item. Ex: Seen/Answered
     */
    Flags: enums.EMailFlags;
    /**
     * Should we retrieve attachments embedded in the e-mail from the server
     */
    IncludeAttachments: boolean;
}
/**
 * Send the provided e-mails
 * Returns EMailEntity[]
 */
export interface EMail_SendEMailsRequest {
    /**
     * All information needed to connect to the mailserver
     */
    OutgoingConnectionInfo: EMailConnectionInfo;
    /**
     * The e-mails to send
     */
    Emails: EMailEntity[];
    /**
     * If provided, save sent item(s) in the folder specified.  May be null.
     */
    SentItemsConnectionInfo: EMailConnectionInfo;
}
/**
 * Save the passed e-mail back to the server
 * Returns EMailEntity
 */
export interface EMail_SaveEMailRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * The e-mail to save
     */
    Email: EMailEntity;
}
/**
 * Authenticate against a mail-server to retrieve e-mails from
 * Returns boolean
 */
export interface EMail_AuthenticateIncomingRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
}
/**
 * Authenticate against a mail server to send items with
 * Returns boolean
 */
export interface EMail_AuthenticateOutgoingRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
}
/**
 * Retrieve all folders for the mail account. String is separated in sections by the paragraph character.  First section contains the folder delimeter char. Next is folder name. Additional sections may be unread and total items.
 * Returns string[]
 */
export interface EMail_GetFolderListRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * If true, unread and total items are added to the foldername separated by a comma
     */
    IncludeItemCount: boolean;
}
/**
 * Retrieve an attachment from an e-mail
 * Returns EMailAttachment
 */
export interface EMail_GetAttachmentRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * Unique ID for the e-mail to retrieve the attachment from
     */
    MessageServerId: number;
    /**
     * Id of the attachment in the e-mail
     */
    AttachmentId: string;
}
/**
 * Mark one or more e-mails as (un)read
 */
export interface EMail_MarkAsReadRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * The e-mails to handle
     */
    MessageServerIds: number[];
    /**
     * If true mails are marked as read. If false mails are marked as unread.
     */
    Read: boolean;
}
/**
 * Retrieve total/unread mail items in current folder
 * Returns number
 */
export interface EMail_GetFolderEMailCountRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * If true, only unread items are counted
     */
    OnlyUnread: boolean;
}
/**
 * Delete specified mail items
 */
export interface EMail_DeleteRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * The e-mails to handle
     */
    MessageServerIds: number[];
    /**
     * If set, move deleted items to this folder
     */
    MoveToFolder: string;
}
/**
 * Moved specified items from current folder to targetFolder
 */
export interface EMail_MoveToFolderRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * The e-mails to handle
     */
    MessageServerIds: number[];
    /**
     * Name of folder to move items to
     */
    TargetFolder: string;
}
/**
 * Delete all items in folder specified in the connection object
 */
export interface EMail_EmptyFolderRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * If set, move deleted items to this folder
     */
    MoveToFolder: string;
}
/**
 * Retrieve an e-mail optionally stripping attachments as a stream
 * Returns Blob
 */
export interface EMail_GetEMailAsStreamRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * Unique ID for the e-mail to retrieve
     */
    MessageServerId: number;
    /**
     * If true, do not include attachments in stream
     */
    StripAttachments: boolean;
}
/**
 * Search for contacts and persons with the specified e-mail address (exact match on the email address string required)
 * Returns EMailAddress[]
 */
export interface EMail_FindAddressRequest {
    /**
     * E-mail address to look for
     */
    Address: string;
}
/**
 * Get an e-mail based on an archived document
 * Returns EMailEntity
 */
export interface EMail_GetEMailFromDocumentIdRequest {
    /**
     * Unique id of the document
     */
    DocumentId: number;
}
/**
 * Get an e-mail based on an archived document. The returned value is not sanitized.
 * Returns EMailEntity
 */
export interface EMail_GetUnsanitizedEMailFromDocumentIdRequest {
    /**
     * Unique id of the document
     */
    DocumentId: number;
}
/**
 * Get an e-mail based on an email and attachment id
 * Returns EMailEntity
 */
export interface EMail_GetEMailFromAttachmentIdRequest {
    /**
     * The primary key of the email row in the DB
     */
    EmailId: number;
    /**
     * Id of the attachment. If multiple elements this is treated as attachment in attachemnts, e.g. [1, 2] means attachment 2 in attachment 1 of email.
     */
    AttachmentIds: string[];
    /**
     * Should we retrieve attachments embedded in the e-mail from the server
     */
    IncludeAttachments: boolean;
}
/**
 * Get an e-mail based on an email and attachment id. The returned value is not sanitized.
 * Returns EMailEntity
 */
export interface EMail_GetUnsanitizedEMailFromAttachmentIdRequest {
    /**
     * The primary key of the email row in the DB
     */
    EmailId: number;
    /**
     * Id of the attachment. If multiple elements this is treated as attachment in attachemnts, e.g. [1, 2] means attachment 2 in attachment 1 of email.
     */
    AttachmentIds: string[];
    /**
     * Should we retrieve attachments embedded in the e-mail from the server
     */
    IncludeAttachments: boolean;
}
/**
 * Get an e-mail based on an email in the archive system and attachment id
 * Returns EMailEntity
 */
export interface EMail_GetEMailFromDocumentAttachmentIdRequest {
    /**
     * The primary key of the document row in the DB
     */
    DocId: number;
    /**
     * Id of the attachment. If multiple elements this is treated as attachment in attachemnts, e.g. [1, 2] means attachment 2 in attachment 1 of email.
     */
    AttachmentIds: string[];
    /**
     * Should we retrieve attachments embedded in the e-mail from the server
     */
    IncludeAttachments: boolean;
}
/**
 * Get an e-mail based on an email in the archive system and attachment id. The returned value is not sanitized.
 * Returns EMailEntity
 */
export interface EMail_GetUnsanitizedEMailFromDocumentAttachmentIdRequest {
    /**
     * The primary key of the document row in the DB
     */
    DocId: number;
    /**
     * Id of the attachment. If multiple elements this is treated as attachment in attachemnts, e.g. [1, 2] means attachment 2 in attachment 1 of email.
     */
    AttachmentIds: string[];
    /**
     * Should we retrieve attachments embedded in the e-mail from the server
     */
    IncludeAttachments: boolean;
}
/**
 * Retrieve a set of e-mail envelopes
 * Returns EMailEnvelope[]
 */
export interface EMail_GetEMailEnvelopesRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * Unique identitifiers for the e-mails to retrieve envelopes for
     */
    MessageServerIds: number[];
}
/**
 * Set subscription on or off on a set of folders
 */
export interface EMail_SetSubscriptionRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * Folders to set subscription value on
     */
    Folders: EMailFolder[];
}
/**
 * Create a new folder on the server
 */
export interface EMail_CreateFolderRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
}
/**
 * Delete a folder from the server
 */
export interface EMail_DeleteFolderRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
}
/**
 * Get an e-mail based on the provided DocumentEntity
 * Returns EMailEntity
 */
export interface EMail_CreateEMailFromDocumentEntityRequest {
    /**
     * DocumentEntity data
     */
    DocumentEntity: DocumentEntity;
}
/**
 * Get an e-mail based on the provided MIME-message
 * Returns EMailEntity
 */
export interface EMail_CreateEMailFromMimeMessageRequest {
    /**
     * string representing a MIME-formatted message
     */
    MimeMessage: string;
}
/**
 * Retrieve information about folders.  If folders parameter is not specified(null), information about all subscribed folders will be returned.
 * Returns EMailFolder[]
 */
export interface EMail_GetFolderInfoRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * Folders to get information about.
     */
    Folders: string[];
}
/**
 * Check if folder has received new items since previous access.
 * Returns boolean
 */
export interface EMail_GetFolderHasNewEMailRequest {
    /**
     * All information needed to connect to the mailserver
     */
    ConnectionInfo: EMailConnectionInfo;
}
/**
 * Get information about one or more email addresses, identified by IDs
 * Returns EMailAddress[]
 */
export interface EMail_GetEMailAddressesRequest {
    /**
     * Array of IDs from the email table, each identifying one email address
     */
    EmailIds: number[];
}
/**
 * Refresh the given folders - i.e., fetch data from the mail server and update the in-database cache. This may happen synchronously or as a batch task, the return value will be 0 if the processing was synchronous, or the batch task id if a batch task is used.
 * Returns number
 */
export interface EMail_RefreshFolderRequest {
    /**
     * Email connection info credentials
     */
    ConnectionInfo: EMailConnectionInfo;
    /**
     * List of folder names to refresh
     */
    Folders: string[];
}
/**
 *
 * Returns EMailEntity
 */
export interface EMail_GetEMailFromTempRequest {
    /**
     *
     */
    FileName: string;
}
/**
 *
 * Returns boolean
 */
export interface EMail_AuthenticateRequest {
    /**
     *
     */
    ConnectionInfoExtended: EMailConnectionInfoExtended;
}
/**
 *
 * Returns string[]
 */
export interface EMail_GetEmailMessageIdsRequest {
    /**
     *
     */
    ConnectionInfoExtended: EMailConnectionInfoExtended;
}
/**
 * Gets not only the Message-Id's but also the UID's and the uniquevalidity property in this format-> uvalidity:uid:MsgId - and this format should be understood by GetEmailsAsString() and DeleteExtended().
 * Returns string[]
 */
export interface EMail_GetExtendedEmailMessageIdsRequest {
    /**
     *
     */
    ConnectionInfoExtended: EMailConnectionInfoExtended;
}
/**
 *
 * Returns string[]
 */
export interface EMail_GetEmailsAsStringRequest {
    /**
     *
     */
    ConnectionInfoExtended: EMailConnectionInfoExtended;
    /**
     *
     */
    MessageIds: string[];
}
/**
 *
 */
export interface EMail_DeleteExtendedRequest {
    /**
     *
     */
    ConnectionInfoExtended: EMailConnectionInfoExtended;
    /**
     *
     */
    MessageIds: string[];
}
/**
 *
 */
export interface EMail_RelayMessageRequest {
    /**
     *
     */
    ConnectionInfoExtended: EMailConnectionInfoExtended;
    /**
     *
     */
    Rfc822: string;
    /**
     *
     */
    From: string;
    /**
     *
     */
    Recipients: string[];
}
/**
 * Get en e-mail based on its primary key in the DB
 * Returns EMailEntity
 */
export interface EMail_GetEMailRequest {
    /**
     * The primary key of the email row in the DB
     */
    Id: number;
    /**
     * Should we retrieve attachments embedded in the e-mail from the server
     */
    IncludeAttachments: boolean;
}
/**
 * Get en e-mail based on its primary key in the DB. The returned value is not sanitized.
 * Returns EMailEntity
 */
export interface EMail_GetUnsanitizedEMailRequest {
    /**
     * The primary key of the email row in the DB
     */
    Id: number;
    /**
     * Should we retrieve attachments embedded in the e-mail from the server
     */
    IncludeAttachments: boolean;
}
/**
 * Mark one or more e-mails as (un)read
 */
export interface EMail_MarkEmailsAsReadRequest {
    /**
     * The e-mails to handle
     */
    Ids: number[];
    /**
     * If true mails are marked as read. If false mails are marked as unread.
     */
    Read: boolean;
}
/**
 * Delete specified mail items and optionally move to the specified folder
 */
export interface EMail_DeleteEmailsRequest {
    /**
     * The e-mails to handle
     */
    Ids: number[];
    /**
     * If set, move deleted items to this folder
     */
    MoveToFolder: string;
}
/**
 * Delete specified mail items and move to the Trash folder
 */
export interface EMail_MoveEmailsToTrashRequest {
    /**
     * The e-mails to handle
     */
    Ids: number[];
}
/**
 * Save the e-mail back to the database
 * Returns EMailEntity
 */
export interface EMail_SaveRequest {
    /**
     * The e-mail to save
     */
    Email: EMailEntity;
}
/**
 * Save the passed e-mail back to the mail server
 * Returns EMailEntity
 */
export interface EMail_SaveToMailServerRequest {
    /**
     * The e-mail to save
     */
    Email: EMailEntity;
}
/**
 * Send the provided e-mails
 * Returns EMailEntity[]
 */
export interface EMail_SendRequest {
    /**
     * The e-mails to send
     */
    Emails: EMailEntity[];
}
/**
 * Create forward email
 * Returns EMailEntity
 */
export interface EMail_CreateForwardEmailRequest {
    /**
     * The e-mail to forward
     */
    Email: EMailEntity;
}
/**
 *
 * Returns ContactOrPersonFromEmail[]
 */
export interface EMail_FindContactOrPersonByEmailNameRequest {
    /**
     * The sender name
     */
    Name: string;
    /**
     * The sender email address
     */
    EmailAddress: string;
}
/**
 *
 * Returns ContactOrPersonFromEmail[]
 */
export interface EMail_FindContactOrPersonByEmailNameWithLimitRequest {
    /**
     * The sender name
     */
    Name: string;
    /**
     * The sender email address
     */
    EmailAddress: string;
    /**
     * Maximum returned number of contacts
     */
    NumberOfContacts: number;
    /**
     * Maximum returned number of persons
     */
    NumberOfPersons: number;
}
/**
 * Get all emails in folder(s) from current associate
 * Returns string
 */
export interface EMail_RefreshFolderForAssociateRequest {
    /**
     * List of folder names to refresh
     */
    Folders: string[];
}
/**
 * Get new email in folder(s) for current associate
 * Returns EMailEnvelope[]
 */
export interface EMail_GetNewMailRequest {
    /**
     * List of folder ids to check for new email
     */
    Folders: number[];
}
/**
 * Fetch list of folders from email server for the current account, and cache in DB
 * Returns EMailFolder[]
 */
export interface EMail_CacheFolderListRequest {
}
/**
 * Move one or more emails to the specified folder in the DB, and on the server
 */
export interface EMail_MoveEmailsToFolderRequest {
    /**
     * The EmailFolderId of the folder to move to
     */
    FolderId: number;
    /**
     * The emails to move
     */
    EmailItemIds: number[];
}
/**
 * Get email from db based on Message Id
 * Returns EMailEntity
 */
export interface EMail_GetMailFromMessageIdRequest {
    /**
     * The message id
     */
    MessageId: string;
}
/**
 * Get email from db based on In-Reply-To Message Id
 * Returns EMailEntity
 */
export interface EMail_GetMailFromInReplyToRequest {
    /**
     * The message id
     */
    MessageId: string;
}
/**
 * Send the provided e-mail and create tmp document ready to archive
 * Returns string
 */
export interface EMail_SendAndSaveEmailToTmpDocumentRequest {
    /**
     * The e-mail to send
     */
    Email: EMailEntity;
    /**
     * If true, do not include attachments in tmp document
     */
    StripAttachments: boolean;
}
/**
 * Save the Email as a tmp document ready to archive
 * Returns string
 */
export interface EMail_SaveEmailToTmpDocumentRequest {
    /**
     * The e-mail to save
     */
    Email: EMailEntity;
    /**
     * The folder id where the email is
     */
    FolderId: number;
    /**
     * If true, do not include attachments in tmp document
     */
    StripAttachments: boolean;
}
/**
 * Save the Email entity to the drafts folder
 * Returns EMailEntity
 */
export interface EMail_SaveDraftRequest {
    /**
     * The entity to save
     */
    Entity: EMailEntity;
}
/**
 * Set the replied_at field based on the MessageID
 */
export interface EMail_SetRepliedAtRequest {
    /**
     * The MessageID
     */
    MessageId: string;
}
/**
 * Get an e-mail based on an archived document
 * Returns EMailEntity
 */
export interface EMail_GetEMailFromDocumentIdWithoutAttachmentStreamRequest {
    /**
     * Unique id of the document
     */
    DocumentId: number;
}
/**
 * Get an e-mail based on an archived document. The returned value is not sanitized.
 * Returns EMailEntity
 */
export interface EMail_GetUnsanitizedEMailFromDocumentIdWithoutAttachmentStreamRequest {
    /**
     * Unique id of the document
     */
    DocumentId: number;
}
/**
 * Retrieve an attachment from an e-mail
 * Returns EMailAttachment
 */
export interface EMail_GetAttachmentFromIdRequest {
    /**
     * Unique ID for the e-mail to retrieve the attachment from
     */
    MailItemId: number;
    /**
     * Id of the attachment in the e-mail
     */
    AttachmentId: string;
}
/**
 * Retrieve an attachment from an e-mail. The returned data is intended to be use for a preview.
 * Returns EMailAttachment
 */
export interface EMail_GetPreviewAttachmentFromIdRequest {
    /**
     * Unique ID for the e-mail to retrieve the attachment from
     */
    MailItemId: number;
    /**
     * Id of the attachment in the e-mail
     */
    AttachmentId: string;
    /**
     * Mimetype of the attachment. Must be set if attachmentId contains a chain.
     */
    AttachmentType: string;
    /**
     * Filename of the attachment. Must be set if attachmentId contains a chain.
     */
    AttachmentFilename: string;
}
/**
 * Retrieve an attachment from an e-mail. The returned data is intended to be use for a preview. The returned data is not sanitized.
 * Returns EMailAttachment
 */
export interface EMail_GetUnsanitizedPreviewAttachmentFromIdRequest {
    /**
     * Unique ID for the e-mail to retrieve the attachment from
     */
    MailItemId: number;
    /**
     * Id of the attachment in the e-mail
     */
    AttachmentId: string;
    /**
     * Mimetype of the attachment. Must be set if attachmentId contains a chain.
     */
    AttachmentType: string;
    /**
     * Filename of the attachment. Must be set if attachmentId contains a chain.
     */
    AttachmentFilename: string;
}
/**
 * Retrieve an attachment from an e-mail stored in the document archive. The returned data is intended to be use for a preview.
 * Returns EMailAttachment
 */
export interface EMail_GetPreviewAttachmentFromDocIdRequest {
    /**
     * Unique ID for the e-mail in the document archive to retrieve the attachment from
     */
    DocId: number;
    /**
     * Id of the attachment in the e-mail
     */
    AttachmentId: string;
}
/**
 * Retrieve an attachment from an e-mail stored in the document archive. The returned data is intended to be use for a preview. The returned data is not sanitized.
 * Returns EMailAttachment
 */
export interface EMail_GetUnsanitizedPreviewAttachmentFromDocIdRequest {
    /**
     * Unique ID for the e-mail in the document archive to retrieve the attachment from
     */
    DocId: number;
    /**
     * Id of the attachment in the e-mail
     */
    AttachmentId: string;
}
/**
 * Test if logged-in user has a working mail account
 * Returns boolean
 */
export interface EMail_TestAuthenticateRequest {
}
/**
 * Set subscription on or off on a set of folders
 */
export interface EMail_ToggleSubscriptionRequest {
    /**
     * The folder id to set subscription value on
     */
    FolderId: number;
    /**
     * The subscription status to set
     */
    SubscriptionStatus: boolean;
}
/**
 * Fast check for new mail in the database
 * Returns boolean
 */
export interface EMail_HasNewMailRequest {
    /**
     * The last known mailitemid
     */
    MailItemId: number;
    /**
     * The folderId for the folder to check for new mail
     */
    FolderId: number;
}
/**
 * Returns the latest id of the mail item by folder
 * Returns number
 */
export interface EMail_LatestItemIdByFolderRequest {
    /**
     * The folderId for the folder to check for the latest mail id
     */
    FolderId: number;
}
/**
 * Create Outlook style HTML header to use in for instance reply entities and when printing
 * Returns string
 */
export interface EMail_CreateInlineHtmlHeaderRequest {
    /**
     * The e-mail to generate header based on
     */
    Email: EMailEntity;
}
/**
 * Get appointment data contained in the emails iCal attachment
 * Returns EMailAppointment
 */
export interface EMail_GetEmailAppointmentRequest {
    /**
     * Id identifying the email
     */
    MailItemId: number;
}
/**
 * Get recurrence data contained in the email iCal attachment
 * Returns RecurrenceInfo
 */
export interface EMail_GetEmailAppointmentRecurrenceRequest {
    /**
     * Id identifying the email
     */
    MailItemId: number;
}
/**
 * Get participant data associated with the participant in the emails iCal attachment
 * Returns Person
 */
export interface EMail_GetParticipantInfoFromEmailAddressRequest {
    /**
     * Email address of participant
     */
    EmailAddress: string;
    /**
     * Appointment id of participant
     */
    AppointmentId: number;
}
/**
 * Gets a particular document, and tries to parse it, and returns it in MIME/RFC822 format.
 * Returns Blob
 */
export interface EMail_GetEmailDocumentAsMimeStreamRequest {
    /**
     * SuperOffice document ID
     */
    DocumentId: number;
}
/**
 * Limited information about one e-mail.
 */
export interface EMailEnvelope extends Carrier {
    /**
     * Unique id for the e-mail on the server
     */
    ServerId?: number;
    /**
     * Unique id of e-mails
     */
    MessageId?: string;
    /**
     * Subject of the e-mail
     */
    Subject?: string;
    /**
     * Who did the e-mail originate from
     */
    From?: EMailAddress;
    /**
     * To recipients of e-mail
     */
    To?: EMailAddress[];
    /**
     * When was the e-mail sent
     */
    Sent?: Date;
    /**
     * Importance of the e-mail
     */
    Priority?: enums.EMailPriority;
    /**
     * Flag status of this mail (unread, replied, deleted )
     */
    Flags?: enums.EMailFlags;
    /**
     * Total size of the e-mail
     */
    Size?: number;
    /**
     * Glue between SuperOffice data and an e-mail.
     */
    EMailSOInfo?: EMailSOInfo;
}
/**
 * Properties for a mail folder
 */
export interface EMailFolder extends Carrier {
    /**
     * Name of folder
     */
    Name?: string;
    /**
     * The character which is used to delimit folder levels on the server
     */
    Delimiter?: string;
    /**
     * Flags associated with the folder
     */
    Flags?: string;
    /**
     * Total number of messages in the folder
     */
    TotalItems?: number;
    /**
     * Number of unread messages in the folder
     */
    UnreadItems?: number;
    /**
     * Indicates if the folder is subscribed to
     */
    Subscribed?: boolean;
    /**
     * Primary key
     */
    EmailFolderId?: number;
}
/**
 * Glue between SuperOffice data and an e-mail.
 */
export interface EMailSOInfo extends Carrier {
    /**
     * Primary key
     */
    DocumentId?: number;
    /**
     * Primary key
     */
    AppointmentId?: number;
    /**
     * Primary key
     */
    ProjectId?: number;
    /**
     * Primary key
     */
    SaleId?: number;
    /**
     * Is this e-mail archived in SuperOffice
     */
    Archived?: boolean;
    /**
     * The datetime when this email was archived
     */
    ArchivedAt?: Date;
    /**
     * The associate who archived this email
     */
    ArchivedBy?: number;
    /**
     * The full name of the associate who archived this email
     */
    ArchivedDisplayName?: string;
}
/**
 * Details for syncing email user accounts
 */
export interface SyncUserAccount extends Carrier {
    /**
     * The account primary key
     */
    AccountId?: number;
    /**
     * The username of the associate owning the account
     */
    AssociateName?: string;
    /**
     * Id of the associate who owns this account
     */
    AssociateId?: number;
}
/**
 * Gets the list of SyncUserAccounts that should be synced.
 * Returns SyncUserAccount[]
 */
export interface EMail_GetReadySyncEmailAccountsRequest {
}
/**
 * Sync the given account
 */
export interface EMail_SyncEmailAccountRequest {
    /**
     * Account to sync
     */
    SyncUserAccount: SyncUserAccount;
}
/**
 * Start syncing of the given accounts
 */
export interface EMail_SyncEmailAccountsRequest {
    /**
     * Accounts to sync
     */
    SyncUserAccounts: SyncUserAccount[];
}
/**
 * Carrier for criteria information. It contains all the search criteria - that is, ArchiveRestrictionInfo - objects, including a  column specification. In addition, it contains the same criteria expressed as an archive, with an array of ArchiveColumnInfo specifications and a set of ArchiveRow rows. The rows of the archive form a subset of the restriction array.
 */
export interface CriteriaInformation extends Carrier {
    /**
     * Array of ArchiveRestrictionInfo restriction specifications (for the first restrictiongroup if there are more than one group
     */
    Restrictions?: ArchiveRestrictionInfo[];
    /**
     * Array of ColumnInfo column specifications
     */
    CriteriaArchiveColumns?: ArchiveColumnInfo[];
    /**
     * Array of archive list items, i.e., the service layer carrier for archive rows. These are the criteria, represented as archive rows.
     */
    CriteriaArchiveRows?: ArchiveListItem[];
    /**
     * Array of restrictiongroups, including the default first group of restrictions
     */
    RestrictionGroups?: ArchiveRestrictionGroup[];
}
/**
 * Get criteria information from a set of saved criteria. The result contains the restrictions in two forms: fully populated ArchiveRestrictionInfo objects, used to display details and for saving changes; and as a list suitable for an Archive control
 * Returns CriteriaInformation
 */
export interface Find_GetCriteriaInformationRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Optional array of restrictions that are to be EXCLUDED from the CriteriaArchiveRows part of the result. In the Find dialogs, that corresponds to the 'static' fields, to avoid duplicating them in the 'Match also' criteria list. This array can be null, indicating that all restrictions should be included in the criteria list.
     */
    StaticColumns: string[];
}
/**
 * Get criteria information from a set of saved criteria. The result contains the restrictions in two forms: fully populated ArchiveRestrictionInfo objects, used to display details and for saving changes; and as a list suitable for an Archive control
 * Returns CriteriaInformation
 */
export interface Find_GetCriteriaInformationWithContextRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Optional array of restrictions that are to be EXCLUDED from the CriteriaArchiveRows part of the result. In the Find dialogs, that corresponds to the 'static' fields, to avoid duplicating them in the 'Match also' criteria list. This array can be null, indicating that all restrictions should be included in the criteria list.
     */
    StaticColumns: string[];
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Save an array of restrictions for later use as search criteria (including as dynamic selection and Find).
 */
export interface Find_SaveRestrictionsRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * Array of restrictions. The ColumnInfo member and the DisplayValues members need NOT be populated; it is enough to provide a name, operator and any values the operator may need. The IsActive is also saved. Values should be encoded using the CultureDataFormatter to ensure compatibility across cultures.
     */
    Restrictions: ArchiveRestrictionInfo[];
}
/**
 * Save an array of restrictions for later use as search criteria (including as dynamic selection and Find).
 */
export interface Find_SaveRestrictionsWithContextRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * Array of restrictions. The ColumnInfo member and the DisplayValues members need NOT be populated; it is enough to provide a name, operator and any values the operator may need. The IsActive is also saved. Values should be encoded using the CultureDataFormatter to ensure compatibility across cultures.
     */
    Restrictions: ArchiveRestrictionInfo[];
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Save an array of restrictions as a restriction group for later use as search criteria (including as dynamic selection and Find).
 */
export interface Find_SaveRestrictionGroupRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * Information about a group of restrictions
     */
    RestrictionGroup: ArchiveRestrictionGroup;
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Save and rerank an array of restriction groups, returning the possibly modified array.
 * Returns ArchiveRestrictionGroup[]
 */
export interface Find_SaveRestrictionGroupsRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * Information about a group of restrictions
     */
    RestrictionGroups: ArchiveRestrictionGroup[];
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Return all the restriction groups.
 * Returns ArchiveRestrictionGroup[]
 */
export interface Find_GetRestrictionGroupsRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Return the restriction group with given rank or a blank carrier.
 * Returns ArchiveRestrictionGroup
 */
export interface Find_GetRestrictionGroupRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * Rank of the group to be deleted.
     */
    Rank: number;
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Create a restriction group, initialized with next rank etc.
 * Returns ArchiveRestrictionGroup
 */
export interface Find_CreateRestrictionGroupRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Create a restriction group, initialized with next rank etc.
 */
export interface Find_DeleteRestrictionGroupRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * Rank of the group to be deleted.
     */
    Rank: number;
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Save an array of restrictions for later use as search criteria (including as dynamic selection and Find). Then, return the same result as a call to GetCriteriaInformation would have done. The purpose is to encapsulate saving and updating of a GUI in one round trip.
 * Returns CriteriaInformation
 */
export interface Find_SaveRestrictionsAndGetCriteriaInformationRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * Array of restrictions. The ColumnInfo member and the DisplayValues members need NOT be populated; it is enough to provide a name, operator and any values the operator may need. The IsActive is also saved. Values should be encoded using the CultureDataFormatter to ensure compatibility across cultures.
     */
    Restrictions: ArchiveRestrictionInfo[];
    /**
     * Optional array of restrictions that are to be EXCLUDED from the CriteriaArchiveRows part of the result. In the Find dialogs, that corresponds to the 'static' fields, to avoid duplicating them in the 'Match also' criteria list. This array can be null, indicating that all restrictions should be included in the criteria list.
     */
    StaticColumns: string[];
}
/**
 * Execute a Find operation and return a page of results. The criteria for the Find are fetched from the restriction storage provider according to the given parameters. The columns of the result are calculated based on the restriction. The orderby columns are also calculated by the system.<para/>The other variants of the Find method allow you greater control over the individual aspects of the process.
 * Returns FindResults
 */
export interface Find_FindRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
}
/**
 * Execute a Find operation and return a page of results. The criteria for the Find are passed in directly, not fetched by a restriction storage provider. The columns of the result are calculated based on the restriction.
 * Returns FindResults
 */
export interface Find_FindFromRestrictionsRequest {
    /**
     * Array of restrictions specifying the search. Each restriction must match a column of the  given archive provider, and that column must have its CanRestrictBy property set to true.
     */
    Restrictions: ArchiveRestrictionInfo[];
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
}
/**
 * Execute a Find operation and return a page of results. <para/>The criteria for the Find are passed in directly, not fetched by a restriction storage provider. <para/>The desired columns of the result set are also passed in directly.<para/>The orderby information is calculated by the system.<para/>Use the GetCriteriaInformation and GetDefaultDesiredColumns service methods to let the system calculate these values, if you want to use or modify them.
 * Returns FindResults
 */
export interface Find_FindFromRestrictionsColumnsRequest {
    /**
     * Array of restrictions specifying the search. Each restriction must match a column of the  given archive provider, and that column must have its CanRestrictBy property set to true.
     */
    Restrictions: ArchiveRestrictionInfo[];
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Array of column names desired for the result. Each name must match a column offered by the given archive provider.
     */
    DesiredColumns: string[];
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
}
/**
 * Get a list of the column names corresponding to available restrictions for a certain archive provider and restriction storage provider. Such columns have CanRestrict set to true, and are supported by the given restriction storage provider.
 * Returns string[]
 */
export interface Find_GetAvailableRestrictionColumnsRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
}
/**
 * Get criteria information from a set of saved criteria, for a specific set of columns. The result contains the restrictions in two forms: fully populated ArchiveRestrictionInfo objects, used to display details and for saving changes; and as a list suitable for an Archive control. ALL columns specified in the call will be present in the results; those that do not have corresponding criteria set will have empty values and the default (first) operator, with the IsActive flag set to false.
 * Returns CriteriaInformation
 */
export interface Find_GetSpecifiedCriteriaInformationWithDefaultsRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Optional array of restrictions that are to be EXCLUDED from the CriteriaArchiveRows part of the result. In the Find dialogs, that corresponds to the 'static' fields, to avoid duplicating them in the 'Match also' criteria list. This array can be null, indicating that all restrictions should be included in the criteria list.
     */
    DesiredColumnNames: string[];
    /**
     * Optional array of restrictions that are to be EXCLUDED from the CriteriaArchiveRows part of the result. In the Find dialogs, that corresponds to the 'static' fields, to avoid duplicating them in the 'Match also' criteria list. This array can be null, indicating that all restrictions should be included in the criteria list.
     */
    StaticColumns: string[];
}
/**
 * Get criteria information from a set of saved criteria, for a specific set of columns. The result contains the restrictions in two forms: fully populated ArchiveRestrictionInfo objects, used to display details and for saving changes; and as a list suitable for an Archive control. ALL columns specified in the call will be present in the results; those that do not have corresponding criteria set will have empty values and the default (first) operator, with the IsActive flag set to false.
 * Returns CriteriaInformation
 */
export interface Find_GetSpecifiedCriteriaInformationWithDefaultsWithContextRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Optional array of restrictions that are to be EXCLUDED from the CriteriaArchiveRows part of the result. In the Find dialogs, that corresponds to the 'static' fields, to avoid duplicating them in the 'Match also' criteria list. This array can be null, indicating that all restrictions should be included in the criteria list.
     */
    DesiredColumnNames: string[];
    /**
     * Optional array of restrictions that are to be EXCLUDED from the CriteriaArchiveRows part of the result. In the Find dialogs, that corresponds to the 'static' fields, to avoid duplicating them in the 'Match also' criteria list. This array can be null, indicating that all restrictions should be included in the criteria list.
     */
    StaticColumns: string[];
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Execute a Find operation and return a page of results. <para/>The criteria for the Find are passed in directly, not fetched by a restriction storage provider. <para/>The desired columns of the result set are also passed in directly.<para/>The orderby information is also passed in directly.<para/>Use the GetCriteriaInformation, GetDefaultDesiredColumns and GetDefaultOrderBy service methods to let the system calculate these values, if you want to use or modify them.
 * Returns FindResults
 */
export interface Find_FindFromRestrictionsColumnsOrderByRequest {
    /**
     * Array of restrictions specifying the search. Each restriction must match a column of the  given archive provider, and that column must have its CanRestrictBy property set to true.
     */
    Restrictions: ArchiveRestrictionInfo[];
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Array of column names desired for the result. Each name must match a column offered by the given archive provider.
     */
    DesiredColumns: string[];
    /**
     * Array of order by specifications. If it is null or empty, the row order is unspecified, database dependent, and might not be the same from call to call, depending on query execution plans. The unspecified order willgenerally not vary within pages of the same query.
     */
    OrderBy: ArchiveOrderByInfo[];
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
}
/**
 * Calculate the default desired columns, i.e., the result columns for a given search. The search is defined by a storage type, provider name and storage key, which are used to fetch the corresponding restrictions from the database (in the same way as Find does). If you want to specify the restriction directly, use the GetDefaultDesiredColumnsFromRestrictions method instead. This is the algorithm that is used by the Find service method.
 * Returns ArchiveColumnInfo[]
 */
export interface Find_GetDefaultDesiredColumnsRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of the provider to calculate default desired columns for
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
}
/**
 * Calculate the default orderby columns for a given provider and a search. The search is specified by a storage type, provider name and storage key, and is fetched from the database. Default desired columns are then calculated for the search, and those columns are then used as the basis for calculating an order by. If you want to specify the desired columns directly, use the GetDefaultOrderByFromDesiredColumns method instead.  This is the same algorithm that is used by the Find service method.
 * Returns ArchiveOrderByInfo[]
 */
export interface Find_GetDefaultOrderByRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Provider name to calculate default orderby for
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
}
/**
 * Take an incoming set of minimally populated restrictions (name + operator is required), and populate all the other parts of the ArchiveRestrictionInfo structure. This includes column information, display values (including list value lookup), and calculated/default values where the value hints specify read-only (R).
 * Returns ArchiveRestrictionInfo[]
 */
export interface Find_PopulateRestrictionsRequest {
    /**
     * Provider name to use for populating column information
     */
    ProviderName: string;
    /**
     * Restrictions to populate. The Name and Operator fields have to have valid content, and Values should be set as appropriate. Other fields can be left blank or null. If a ColumnInfo is already set, it will not be overwritten.
     */
    Restrictions: ArchiveRestrictionInfo[];
}
/**
 * Take an incoming set of Restrictions (name + operator + any user-entered values), and populate/expand all values as specified by the operator's ValueHints, taking into account any values already there. Used for dynamic date periods; perhaps others in the future
 * Returns ArchiveRestrictionInfo[]
 */
export interface Find_PopulateRestrictionValuesRequest {
    /**
     * Restrictions to populate. The Name and Operator fields have to have valid content, and Values should be set as appropriate. Other fields can be left blank or null and will not be changed.
     */
    Restrictions: ArchiveRestrictionInfo[];
}
/**
 * Calculate the default desired columns, i.e., the result columns for a given search. The search is defined by a provider name and a set of restrictions. This is the algorithm that is used by the Find service method.
 * Returns ArchiveColumnInfo[]
 */
export interface Find_GetDefaultDesiredColumnsFromRestrictionsRequest {
    /**
     * Name of the provider to calculate default desired columns for
     */
    ProviderName: string;
    /**
     * Restriction to use in the calculation of default desired columns
     */
    Restrictions: ArchiveRestrictionInfo[];
}
/**
 * Calculate the default orderby columns for a given provider and a set of desired columns. This is the same algorithm that is used by the Find service method.
 * Returns ArchiveOrderByInfo[]
 */
export interface Find_GetDefaultOrderByFromDesiredColumnsRequest {
    /**
     * Provider name to calculate default orderby for
     */
    ProviderName: string;
    /**
     * Desired columns (return fields), used in the orderby calculation. You can generally only order by columns that have been set as 'desired'.
     */
    DesiredColumns: string[];
}
/**
 * Execute a Find operation and return a page of results. The criteria for the Find are fetched from the restriction storage provider according to the given parameters. The columns of the result are calculated based on the restriction. The orderby parameter is used for sorting the results.<para/>The other variants of the Find method allow you greater control over the individual aspects of the process.
 * Returns FindResults
 */
export interface Find_FindOrderByRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
    /**
     * Array of order by specifications. If it is null or empty, the row order is unspecified, database dependent, and might not be the same from call to call, depending on query execution plans. The unspecified order willgenerally not vary within pages of the same query.
     */
    OrderBy: ArchiveOrderByInfo[];
}
/**
 * Execute a Find operation and return a page of results. The criteria for the Find are fetched from the restriction storage provider according to the given parameters. In addition an extra set of restrictions can be added to the search. These restrictions will not be saved, they are only valid for the current search. Extra restrictions will override restrictions with the same key already stored on the storagekey.
 * Returns FindResults
 */
export interface Find_FindWithExtraRestrictionsRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Extra restrictions to append to the the search. These will override saved restrictions with the same key.
     */
    ExtraRestrictions: ArchiveRestrictionInfo[];
    /**
     * Array of order by specifications. If it is null or empty, the row order is unspecified, database dependent, and might not be the same from call to call, depending on query execution plans. The unspecified order willgenerally not vary within pages of the same query.
     */
    OrderBy: ArchiveOrderByInfo[];
    /**
     * Array of column names desired for the result. Each name must match a column offered by the given archive provider.
     */
    DesiredColumns: string[];
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
}
/**
 * Execute a Find operation and return a page of results. The criteria for the Find are fetched from the restriction storage provider according to the given parameters.
 * Returns FindResults
 */
export interface Find_FindWithColumnsRequest {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Array of column names desired for the result. Each name must match a column offered by the given archive provider.
     */
    DesiredColumns: string[];
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
    /**
     * Array of order by specifications. If it is null or empty, the row order is unspecified, database dependent, and might not be the same from call to call, depending on query execution plans. The unspecified order willgenerally not vary within pages of the same query.
     */
    OrderBy: ArchiveOrderByInfo[];
}
/**
 * Save an array of restrictions for later use as search criteria (including as dynamic selection and Find).
 */
export interface Find_SaveRestrictions2Request {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * String of restrictions. "name = 'SuperOffice'" The ColumnInfo member and the DisplayValues members need NOT be populated; it is enough to provide a name, operator and any values the operator may need. The IsActive is also saved. Values should be encoded using the CultureDataFormatter to ensure compatibility across cultures.
     */
    Restrictions: string;
}
/**
 * Save an array of restrictions for later use as search criteria (including as dynamic selection and Find).
 */
export interface Find_SaveRestrictionsWithContext2Request {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * String of restrictions. The ColumnInfo member and the DisplayValues members need NOT be populated; it is enough to provide a name, operator and any values the operator may need. The IsActive is also saved. Values should be encoded using the CultureDataFormatter to ensure compatibility across cultures.
     */
    Restrictions: string;
    /**
     * Optional context that can be used by FindProvider
     */
    Context: string;
}
/**
 * Save an array of restrictions for later use as search criteria (including as dynamic selection and Find). Then, return the same result as a call to GetCriteriaInformation would have done. The purpose is to encapsulate saving and updating of a GUI in one round trip.
 * Returns CriteriaInformation
 */
export interface Find_SaveRestrictionsAndGetCriteriaInformation2Request {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is the intended consumer of the restrictions
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it saves the restrictions as criteria
     */
    StorageKey: string;
    /**
     * String of restrictions. The ColumnInfo member and the DisplayValues members need NOT be populated; it is enough to provide a name, operator and any values the operator may need. The IsActive is also saved. Values should be encoded using the CultureDataFormatter to ensure compatibility across cultures.
     */
    Restrictions: string;
    /**
     * Optional string of comma-separated columns that are to be EXCLUDED from the CriteriaArchiveRows part of the result. In the Find dialogs, that corresponds to the 'static' fields, to avoid duplicating them in the 'Match also' criteria list. This array can be null, indicating that all restrictions should be included in the criteria list.
     */
    StaticColumns: string;
}
/**
 * Execute a Find operation and return a page of results. The criteria for the Find are passed in directly, not fetched by a restriction storage provider. The columns of the result are calculated based on the restriction.
 * Returns FindResults
 */
export interface Find_FindFromRestrictions2Request {
    /**
     * String of restrictions specifying the search. e.g. "name='SuperOffice'" Each restriction must match a column of the  given archive provider, and that column must have its CanRestrictBy property set to true.
     */
    Restrictions: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
}
/**
 * Execute a Find operation and return a page of results. <para/>The criteria for the Find are passed in directly, not fetched by a restriction storage provider. <para/>The desired columns of the result set are also passed in directly.<para/>The orderby information is calculated by the system.<para/>Use the GetCriteriaInformation and GetDefaultDesiredColumns service methods to let the system calculate these values, if you want to use or modify them.
 * Returns FindResults
 */
export interface Find_FindFromRestrictionsColumns2Request {
    /**
     * String of restrictions specifying the search. e.g.:"name begins 'Super'". Each restriction must match a column of the  given archive provider, and that column must have its CanRestrictBy property set to true.
     */
    Restrictions: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Array of column names desired for the result. Each name must match a column offered by the given archive provider.
     */
    DesiredColumns: string;
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
}
/**
 * Execute a Find operation and return a page of results. <para/>The criteria for the Find are passed in directly, not fetched by a restriction storage provider. <para/>The desired columns of the result set are also passed in directly.<para/>The orderby information is also passed in directly.<para/>Use the GetCriteriaInformation, GetDefaultDesiredColumns and GetDefaultOrderBy service methods to let the system calculate these values, if you want to use or modify them.
 * Returns FindResults
 */
export interface Find_FindFromRestrictionsColumnsOrderBy2Request {
    /**
     * String of restrictions specifying the search. Each restriction must match a column of the  given archive provider, and that column must have its CanRestrictBy property set to true.
     */
    Restrictions: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Comma separated list of column names desired for the result. Each name must match a column offered by the given archive provider.
     */
    DesiredColumns: string;
    /**
     * String of order by specifications. If it is null or empty, the row order is unspecified, database dependent, and might not be the same from call to call, depending on query execution plans. The unspecified order willgenerally not vary within pages of the same query.
     */
    OrderBy: string;
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
}
/**
 * Calculate the default desired columns, i.e., the result columns for a given search. The search is defined by a provider name and a set of restrictions. This is the algorithm that is used by the Find service method.
 * Returns ArchiveColumnInfo[]
 */
export interface Find_GetDefaultDesiredColumnsFromRestrictions2Request {
    /**
     * Name of the provider to calculate default desired columns for
     */
    ProviderName: string;
    /**
     * Restriction to use in the calculation of default desired columns
     */
    Restrictions: string;
}
/**
 * Execute a Find operation and return a page of results. The criteria for the Find are fetched from the restriction storage provider according to the given parameters. The columns of the result are calculated based on the restriction. The orderby parameter is used for sorting the results.<para/>The other variants of the Find method allow you greater control over the individual aspects of the process.
 * Returns FindResults
 */
export interface Find_FindOrderBy2Request {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
    /**
     * Comma separated list of order by specifications. "name asc, dept desc" If it is null or empty, the row order is unspecified, database dependent, and might not be the same from call to call, depending on query execution plans. The unspecified order willgenerally not vary within pages of the same query.
     */
    OrderBy: string;
}
/**
 * Execute a Find operation and return a page of results. The criteria for the Find are fetched from the restriction storage provider according to the given parameters. In addition an extra set of restrictions can be added to the search. These restrictions will not be saved, they are only valid for the current search. Extra restrictions will override restrictions with the same key already stored on the storagekey.
 * Returns FindResults
 */
export interface Find_FindWithExtraRestrictions2Request {
    /**
     * Restriction storage type specification, either 'Criteria' or 'Reporter' (or possible extensions)
     */
    StorageType: string;
    /**
     * Name of archive provider that is to execute the search and return the result columns/rows
     */
    ProviderName: string;
    /**
     * Storage key to be interpreted by the restriction storage provider, when it fetches criteria for the search
     */
    StorageKey: string;
    /**
     * Extra restrictions to append to the the search. These will override saved restrictions with the same key.
     */
    ExtraRestrictions: string;
    /**
     * Comma separated list of order by specifications. If it is null or empty, the row order is unspecified, database dependent, and might not be the same from call to call, depending on query execution plans. The unspecified order willgenerally not vary within pages of the same query.
     */
    OrderBy: string;
    /**
     * Comma separated list of column names desired for the result. Each name must match a column offered by the given archive provider.
     */
    DesiredColumns: string;
    /**
     * Size of result set pages
     */
    PageSize: number;
    /**
     * Result set page to return, 0 is the first page. When a call returns no rows, no further pages are available. Negative page numbers are interpreted as number of rows to skip.
     */
    PageNumber: number;
}
/**
 * Result carrier for the Find operation. It contains a set of column specifications, and a set of row, where each row contains the columns. The row set is the result of carrying out some search operation.
 */
export interface FindResults extends Carrier {
    /**
     * Array of ColumnInfo column specifications
     */
    ArchiveColumns?: ArchiveColumnInfo[];
    /**
     * Array of archive list items, i.e., the service layer carrier for archive rows. These are the find results, represented as archive rows
     */
    ArchiveRows?: ArchiveListItem[];
    /**
     * Count of rows, independent of paging. If you order up page 1 with page size 50, the row count may still be 279, that being the number of rows that would have been returned in a  paging-off situation
     */
    RowCount?: number;
}
/**
 * Webhook definitions. Webhooks broadcast events from NetServer to remote servers.
 */
export interface Webhook {
    /**
     * Primary Key. Unique id for this webhook.
     */
    WebhookId?: number;
    /**
     * Name to identify this webhook. Does not have to be unique.
     */
    Name?: string;
    /**
     * Array of event names that trigger this webhook: ['contact.created', 'sale.changed']
     */
    Events?: string[];
    /**
     * Destination to POST event info to. URL for webhooks. Id for CRM scripts
     */
    TargetUrl?: string;
    /**
     * Shared secret key used for generating SHA256 HMAC signature, so that receiver can verify that call came from this server
     */
    Secret?: string;
    /**
     * Webhook status - should we post events to the URL? 1=Active, 2=Stopped or 3=TooManyErrors
     */
    State?: enums.WebhookState;
    /**
     * Name of plugin that handles this webhook. 'webhook' for webhooks, which are handled by the system plugin.
     */
    Type?: string;
    /**
     * Custom HTTP Headers to add to webhook requests.
     */
    Headers?: StringDictionary;
    /**
     * Custom values to inject into JSON body of webhook call.
     */
    Properties?: StringObjectDictionary;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * The user that created the webhook.
     */
    RegisteredAssociate?: Associate;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * The user that last updated the webhook.
     */
    UpdatedAssociate?: Associate;
}
/**
 * Returns all webhooks, according to filter criteria
 * Returns Webhook[]
 */
export interface Webhook_GetAllWebhooksRequest {
    /**
     * Only return hooks with this name. Default NULL = no filter
     */
    NameFilter: string;
    /**
     * Only return hooks responding to this event name. Default NULL = no filter
     */
    EventFilter: string;
    /**
     * Only return hooks with this status. Default Unknown = no filter, returns all.
     */
    StatusFilter: enums.WebhookState;
}
/**
 * Pings a webhook with a 'test' event, returns SUCCESS(true) or FAILURE(false) + the response from the webhook target.
 * Returns WebhookResult
 */
export interface Webhook_TestWebhookRequest {
    /**
     * Webhook definition to ping. Must contain a valid TargetUrl.
     */
    Webhook: Webhook;
}
/**
 * Signal webhooks that an event has occurred. All webhooks listening for the event will be notified.
 */
export interface Webhook_SignalEventRequest {
    /**
     * Name of event to fire. 'entity.verb' For example: 'window.closed', 'button.clicked'.
     */
    EventName: string;
    /**
     * (Optional) Id of entity that is firing event. Can be 0 if not used.
     */
    PrimaryKey: number;
    /**
     * Event data. Not all the data values may be posted to the webhook, depending in webhook type: { 'windowName': 'foo', 'widgets': 123 }
     */
    Data: StringObjectDictionary;
}
/**
 * Return the most recent error message received when calling this webhook.
 * Returns string
 */
export interface Webhook_GetLastErrorRequest {
    /**
     * Webhook to get error message for.
     */
    WebhookId: number;
}
/**
 * Result of calling a webhook
 */
export interface WebhookResult extends Carrier {
    /**
     * Was call to webhook successful? (200 OK)
     */
    Success?: boolean;
    /**
     * Headers and body of response from webhook
     */
    Message?: string;
}
/**
 * This service provides sentry information such as TableRights.
 */
export interface Sentry extends Carrier {
}
/**
 * Returns a TableRight for a new row based on tableName parameter.
 * Returns TableRight
 */
export interface Sentry_GetNewTableRightRequest {
    /**
     * Name of the table to get the TableRights from
     */
    TableName: string;
}
/**
 * Return the TableRight from the relationship between the current user and the given user and group.
 * Returns TableRight
 */
export interface Sentry_GetTableRightByOwnershipRequest {
    /**
     * Name of the table to get the TableRights from.
     */
    TableName: string;
    /**
     * The user-group that the associate id is part of.
     */
    ContactGroupId: number;
    /**
     * The associate id of the owner of the record
     */
    ContactAssociateId: number;
}
/**
 * Get a string array of all functions rights for the role of the current associate.
 * Returns string[]
 */
export interface Sentry_GetFunctionRightsRequest {
}
/**
 * Get a boolean value indicating if the current user has the functional right.
 * Returns boolean
 */
export interface Sentry_HasFunctionRightRequest {
    /**
     * Function right to check.
     */
    FunctionRight: string;
}
/**
 * CanCreateAppointmentInAssociateDiaries will check if the current associate can create appointments in diaries belonging to the associates listed in associateIds. CanCreateAppointmentInAssociateDiaries will only check against associates that are diary owners. If none of the associates listed in the associateIds parameter is a diary owner, the method will return true.
 * Returns boolean
 */
export interface Sentry_CanCreateAppointmentInAssociateDiariesRequest {
    /**
     * Array of associate ids to check.
     */
    AssociateIds: number[];
}
/**
 * CanCreateAppointmentInAllDiaries will check if the current associate can create appointments in diaries belonging all other associates. CanCreateAppointmentInAssociateDiaries will only check against associates that are diary owners.
 * Returns boolean
 */
export interface Sentry_CanCreateAppointmentInAllDiariesRequest {
}
/**
 * Return the TableRight from the relationship between the current user and the given user and group.
 * Returns TableRight
 */
export interface Sentry_GetTableRightByContactOwnershipRequest {
    /**
     * Name of the table to get the TableRights from.
     */
    TableName: string;
    /**
     * The owner contact.
     */
    ContactId: number;
}
/**
 *
 */
export interface VisibleFor extends Carrier {
    /**
     *
     */
    VisibleId?: number;
    /**
     *
     */
    Visibility?: enums.Visibility;
    /**
     *
     */
    DisplayValue?: string;
}
/**
 * Abstract basic information about database fields. May be custom or user-defined fields. The information can be used to build a user interface.
 */
export interface FieldInfoBase {
    /**
     * What sort of data does this field contain. 1 = int, 2 = short text, ...
     */
    FieldType?: enums.CustomFieldType;
    /**
     * Database name or prog-id: 'x_foobar' or 'SuperOffice:2'.
     */
    FieldName?: string;
    /**
     * Label for field. May be multi-lang string encoded.
     */
    DisplayName?: string;
    /**
     * Optional tooltip text for this field
     */
    Description?: string;
    /**
     * Short name to be used in Archive headings and on page 1. If blank, the fieldLabel will be used everywhere.
     */
    ShortLabel?: string;
    /**
     * Hide the label if 1
     */
    HideLabel?: boolean;
    /**
     * Hide the field from the UI. Only allow API access.
     */
    HideField?: boolean;
    /**
     * Is this field indexed? 0 if no, index no. if yes
     */
    IsIndexed?: boolean;
    /**
     * 0 = no, 1 = yes (field must be filled out)
     */
    IsMandatory?: boolean;
    /**
     * 0 = read/write, 1 = readonly (don't combine with mandatory  8-) )
     */
    IsReadOnly?: boolean;
    /**
     * Should this field be shown to external users via customer center?
     */
    IsExternal?: boolean;
    /**
     * Tab order, ranking within the custom fields.
     */
    Rank?: number;
    /**
     * Template variable name: 'cs01', 'cl02' etc. Null for extra fields.
     */
    TemplateVariableName?: string;
}
/**
 * Return information about all the custom fields (user-defined + extra) on a particular table
 * Returns FieldInfoBase[]
 */
export interface UserDefinedFieldInfo_GetCustomFieldInfoListRequest {
    /**
     * The name of table that owns the custom fields. e.g. 'contact', 'person', 'project' etc.
     */
    TableName: string;
    /**
     * Include standard fields in result. Default false.
     */
    IncludeStandard: boolean;
}
/**
 * Return information about a particular custom field (user-defined + extra) on a particular table
 * Returns FieldInfoBase
 */
export interface UserDefinedFieldInfo_GetCustomFieldInfoRequest {
    /**
     * The name of table that owns the custom fields. e.g. 'contact', 'person', 'project' etc.
     */
    TableName: string;
    /**
     * The name of the field: prog:id or field name. e.g. 'SuperOffice:21' or 'x_foobar'
     */
    FieldName: string;
}
/**
 * Attachment custom database field.
 */
export interface FieldInfoAttachment extends FieldInfoBase {
    /**
     * Default attachment id value
     */
    DefaultValue?: number;
}
/**
 * Blob custom database field. Base64 encoded string value.
 */
export interface FieldInfoBlob extends FieldInfoBase {
}
/**
 * Boolean custom database field. Typically rendered as a checkbox.
 */
export interface FieldInfoBool extends FieldInfoBase {
    /**
     * Default boolean value
     */
    DefaultValue?: boolean;
}
/**
 * Date custom database field. Time component is ignored.
 */
export interface FieldInfoDate extends FieldInfoBase {
    /**
     * Default Date value
     */
    DefaultValue?: Date;
    /**
     * Should the current date be the default?
     */
    IsDefaultNow?: boolean;
}
/**
 * Date + time custom database field.
 */
export interface FieldInfoDateTime extends FieldInfoBase {
    /**
     * Default Date + time value
     */
    DefaultValue?: Date;
    /**
     * Should the current date + time be the default?
     */
    IsDefaultNow?: boolean;
}
/**
 * Decimal (double precision) custom database field.
 */
export interface FieldInfoDecimal extends FieldInfoBase {
    /**
     * Default decimal (double precision) value
     */
    DefaultValue?: number;
    /**
     * How many decimals to display
     */
    Precision?: number;
}
/**
 * Dynamic Link custom database field. Links are resolved indirectly via by CS.
 */
export interface FieldInfoDynamicLink extends FieldInfoBase {
    /**
     * Display text for link.
     */
    LinkName?: string;
    /**
     * URL link value. May contain CS tags to be replaced.
     */
    LinkValue?: string;
}
/**
 * Integer custom database field.
 */
export interface FieldInfoInt extends FieldInfoBase {
    /**
     * Default integer value
     */
    DefaultValue?: number;
}
/**
 * MDO List custom database field.
 */
export interface FieldInfoMdoList extends FieldInfoBase {
    /**
     * Default list item id
     */
    DefaultValue?: number;
    /**
     * MDO list name used to populate this list. (Read-only)
     */
    MdoListName?: string;
}
/**
 * Text string with a list of item choices - custom database field.
 */
export interface FieldInfoListText extends FieldInfoBase {
    /**
     * Default string value
     */
    DefaultValue?: string;
    /**
     * Length (in characters) of a text field, 0 for other types
     */
    TextLength?: number;
    /**
     * List of items to choose from.
     */
    Choices?: string[];
}
/**
 * Long Text custom database field.
 */
export interface FieldInfoLongText extends FieldInfoBase {
    /**
     * Default string value
     */
    DefaultValue?: string;
    /**
     * Do not escape HTML in field when displaying contents.
     */
    IsHtml?: boolean;
    /**
     * Use a multi-line text area?
     */
    UseTextArea?: boolean;
    /**
     * Number of lines of text to show. Text area height.
     */
    NumRows?: number;
}
/**
 * Relation to other table database field.
 */
export interface FieldInfoRelation extends FieldInfoBase {
    /**
     * Default record id.
     */
    DefaultValue?: number;
    /**
     * Name of target table: 'contact', 'y_equipment'
     */
    TargetTable?: string;
    /**
     * Display name on target entity.
     */
    TargetLabel?: string;
    /**
     * Show as dropdown list on target?
     */
    UseDropDown?: boolean;
    /**
     * MDO list name used to populate this list. (Read-only - derived from TargetTable)
     */
    MdoListName?: string;
}
/**
 * Short text string custom database field.
 */
export interface FieldInfoShortText extends FieldInfoBase {
    /**
     * Default string value
     */
    DefaultValue?: string;
    /**
     * Length (in characters) of a text field, 0 for other types
     */
    TextLength?: number;
    /**
     * Formatting mask, can be whatever the controls understand (currently nothing :-))
     */
    FormatMask?: string;
    /**
     * Do not escape HTML in field when displaying contents.
     */
    IsHtml?: boolean;
}
/**
 * Time custom database field. Date value is ignored.
 */
export interface FieldInfoTime extends FieldInfoBase {
    /**
     * Default Time value
     */
    DefaultValue?: Date;
    /**
     * Should the current date + time be the default?
     */
    IsDefaultNow?: boolean;
}
/**
 * Timespan custom database field. Number of minutes, represented as days/hours/minutes.
 */
export interface FieldInfoTimeSpan extends FieldInfoBase {
    /**
     * Default Timespan value - number of minutes.
     */
    DefaultValue?: number;
    /**
     * Should the time-span be counted in days?
     */
    UseDays?: boolean;
    /**
     * Should the time-span be counted in hours?
     */
    UseHours?: boolean;
    /**
     * Should the time-span be counted in minutes?
     */
    UseMinutes?: boolean;
    /**
     * Maximum number for the largest unit in the time-span
     */
    MaxNum?: number;
}
/**
 * Return information about the user defined fields. The information can be used to mirror the layout of the user-defined fields in the user interface.
 */
export interface UserDefinedFieldInfo extends Carrier {
    /**
     * Primary key
     */
    UDefFieldId?: number;
    /**
     * The ID of the database column this field corresponds to
     */
    ColumnId?: number;
    /**
     * Optional default value for String fields
     */
    FieldDefault?: string;
    /**
     * field height in pixels, 0 = 'enough' (from font)
     */
    FieldHeight?: number;
    /**
     * The label (lead text)
     */
    FieldLabel?: string;
    /**
     * X pixel coordinate of field
     */
    FieldLeft?: number;
    /**
     * Y pixel coordinate of field
     */
    FieldTop?: number;
    /**
     * Field type: 0 = leadtext only, 1 = Edit, 2 = CheckBox, 3 = dropdown, 4 = listbox
     */
    FieldType?: enums.UDefFieldType;
    /**
     * field width in pixels, 0 = 'enough' (from font)
     */
    FieldWidth?: number;
    /**
     * Formatting mask, can be whatever the controls understand (currently nothing :-))
     */
    FormatMask?: string;
    /**
     * Hide the label if 1
     */
    HideLabel?: boolean;
    /**
     * Is this field indexed? 0 if no, index no. if yes
     */
    IsIndexed?: boolean;
    /**
     * label height in pixels, 0 = 'enough' (from font)
     */
    LabelHeight?: number;
    /**
     * X pixel coordinate of label
     */
    LabelLeft?: number;
    /**
     * Y pixel coordinate of label
     */
    LabelTop?: number;
    /**
     * label width in pixels, 0 = 'enough' (from font)
     */
    LabelWidth?: number;
    /**
     * UDefFieldId this field had in the previous version, 0 = field is new in this version
     */
    LastVersionId?: number;
    /**
     * The table ID of the source table for lists: kTableAssoc, kTableContInt or whatever
     */
    ListTableId?: number;
    /**
     * 0 = no, 1 = yes (field must be filled out)
     */
    IsMandatory?: boolean;
    /**
     * ID of owning table (contact, person, project) - this is not the actual tableNumber, rather it's an enum
     */
    Type?: enums.UDefType;
    /**
     * Line no on View Page 1, used if MDO flags are OFF. 0 = this field is not visible on page 1
     */
    Page1LineNo?: number;
    /**
     * Programmatic ID, for use by software that needs to find a particular field. Carried over like udefIdentity across generations. Use a Company.Product.Field format to avoid naming conflicts; the Company name SuperOffice is reserved.
     */
    ProgId?: string;
    /**
     * 0 = read/write, 1 = readonly (don't combine with mandatory  8-) )
     */
    IsReadOnly?: boolean;
    /**
     * Short name to be used in Archive headings and on page 1. If blank, the fieldLabel will be used everywhere.
     */
    ShortLabel?: string;
    /**
     * Tab order value, sets the field processing sequence
     */
    TabOrder?: number;
    /**
     * Length (in characters) of a text field, 0 for other types
     */
    TextLength?: number;
    /**
     * Optional tooltip text for this field
     */
    Tooltip?: string;
    /**
     * Unique number used to track field identity across layout changes
     */
    UdefIdentity?: number;
    /**
     * List to use for populating dropdown or listbox
     */
    UDListDefinitionId?: number;
    /**
     * Justification - 0 = default, left, right, center
     */
    Justification?: enums.UdefJustification;
    /**
     * Definition version number; ALL fields get new version whenever layout is updated.
     */
    Version?: number;
    /**
     * Template variable name
     */
    TemplateVariableName?: string;
    /**
     * Has the udef field been published?
     */
    HasBeenPublished?: boolean;
    /**
     * MDO list name used to populate this list. Derived from UDListDefinitionId and ListTableId. (Read-only)
     */
    MdoListName?: string;
}
/**
 * Return information about all the user defined fields on a particular owner type (project, contact, person, etc). Note this may be different than the currently published fields.
 * Returns UserDefinedFieldInfo[]
 */
export interface UserDefinedFieldInfo_GetUserDefinedFieldListRequest {
    /**
     * The user-defined field owner-entity id.
     */
    OwnerType: enums.UDefType;
}
/**
 * Return information about all the user defined fields on a particular owner type (project, contact, person, etc).
 * Returns UserDefinedFieldInfo[]
 */
export interface UserDefinedFieldInfo_GetPublishedUserDefinedFieldListRequest {
    /**
     * The user-defined field owner-entity id.
     */
    OwnerType: enums.UDefType;
}
/**
 * Return information about the given user defined field identified by the owner and the field label. Note that field labels are fuzzy. Leading and trailing spaces and punctuation are ignored. Note this may be different than the currently published fields.
 * Returns UserDefinedFieldInfo
 */
export interface UserDefinedFieldInfo_GetUserDefinedFieldFromFieldLabelRequest {
    /**
     * The field label - the text label shown in the user interface. Trailing spaces and punctuation (":" and ".") are ignored when searching.
     */
    FieldLabel: string;
    /**
     * The user-defined field owner-entity id.
     */
    OwnerType: enums.UDefType;
}
/**
 * Return information about the given user defined field identified by the owner and the field label. Note that field labels are fuzzy. Leading and trailing spaces and punctuation are ignored.
 * Returns UserDefinedFieldInfo
 */
export interface UserDefinedFieldInfo_GetPublishedUserDefinedFieldFromFieldLabelRequest {
    /**
     * The field label - the text label shown in the user interface. Trailing spaces and punctuation (":" and ".") are ignored when searching.
     */
    FieldLabel: string;
    /**
     * The user-defined field owner-entity id.
     */
    OwnerType: enums.UDefType;
}
/**
 * Return information about the given user defined field identified by the owner and the prog-id. The prog-id is used as the key in the entity carriers. Note this may be different than the currently published fields.
 * Returns UserDefinedFieldInfo
 */
export interface UserDefinedFieldInfo_GetUserDefinedFieldFromProgIdRequest {
    /**
     * The prog.id is a hidden name that uniquely identifies the field.
     */
    ProgId: string;
    /**
     * The user-defined field owner-entity id.
     */
    OwnerType: enums.UDefType;
}
/**
 * Return information about the given user defined field identified by the owner and the prog-id. The prog-id is used as the key in the entity carriers.
 * Returns UserDefinedFieldInfo
 */
export interface UserDefinedFieldInfo_GetPublishedUserDefinedFieldFromProgIdRequest {
    /**
     * The prog.id is a hidden name that uniquely identifies the field.
     */
    ProgId: string;
    /**
     * The user-defined field owner-entity id.
     */
    OwnerType: enums.UDefType;
}
/**
 * Return an given array of user defined field identified by the ids.
 * Returns UserDefinedFieldInfo[]
 */
export interface UserDefinedFieldInfo_GetUserDefinedFieldFromIdsRequest {
    /**
     * Array of user defined field ids
     */
    Ids: number[];
}
/**
 * Return an given array user defined field identified by the owner and the prog-ids. The prog-id is used as the key in the entity carriers. Note this may be different than the currently published field layout.
 * Returns UserDefinedFieldInfo[]
 */
export interface UserDefinedFieldInfo_GetUserDefinedFieldFromProgIdsRequest {
    /**
     * The prog.id is a hidden name that uniquely identifies the field.
     */
    ProgIds: string[];
    /**
     * The user-defined field owner-entity id.
     */
    OwnerType: enums.UDefType;
}
/**
 * Create a UserDefinedFieldInfo based on a owner-entity id
 * Returns UserDefinedFieldInfo
 */
export interface UserDefinedFieldInfo_CreateUserDefinedFieldInfoRequest {
    /**
     * The user-defined field owner-entity id.
     */
    OwnerType: enums.UDefType;
    /**
     * The field type of the new field
     */
    FieldType: enums.UDefFieldType;
}
/**
 * Create a UserDefinedFieldInfo based on a owner-entity id
 * Returns UserDefinedFieldInfo
 */
export interface UserDefinedFieldInfo_ChangeFieldTypeRequest {
    /**
     * The user-defined field info carrier to want to modify
     */
    Info: UserDefinedFieldInfo;
    /**
     * The new field type you want
     */
    FieldType: enums.UDefFieldType;
    /**
     * The new indexed status you want
     */
    IsIndexed: boolean;
}
/**
 * Get a list of page one fields for given Udef type and current user group
 * Returns UserDefinedFieldInfo[]
 */
export interface UserDefinedFieldInfo_GetUserDefinedPageOneFieldsRequest {
    /**
     * The user-defined field owner-entity.
     */
    OwnerType: enums.UDefType;
    /**
     * Id of UserGroup
     */
    UserGroupId: number;
}
/**
 * Get a list of page one fields for given Udef type and current user group
 * Returns UserDefinedFieldInfo[]
 */
export interface UserDefinedFieldInfo_GetPublishedUserDefinedPageOneFieldsRequest {
    /**
     * The user-defined field owner-entity.
     */
    OwnerType: enums.UDefType;
    /**
     * Id of UserGroup
     */
    UserGroupId: number;
}
/**
 * Publish changed Udef fields for the given owner type
 * Returns number
 */
export interface UserDefinedFieldInfo_PublishRequest {
    /**
     * The owner type to publish for
     */
    OwnerType: enums.UDefType;
}
/**
 * Revert changed Udef fields for the given owner type - all unpublished changes will be lost
 */
export interface UserDefinedFieldInfo_RevertRequest {
    /**
     * The owner type to revert fields for
     */
    OwnerType: enums.UDefType;
}
/**
 * Save an array of user defined fields. This will update the unpublished layout.
 */
export interface UserDefinedFieldInfo_SaveUserDefinedFieldInfosRequest {
    /**
     * An array of user defined fields
     */
    Infos: UserDefinedFieldInfo[];
}
/**
 * Detect changes to the admin version (unpublished)
 * Returns boolean
 */
export interface UserDefinedFieldInfo_DetectUnpublishedChangesRequest {
    /**
     * The owner type
     */
    OwnerType: enums.UDefType;
}
/**
 * Detect columnid changes to the admin version (for determining publish warning)
 * Returns boolean
 */
export interface UserDefinedFieldInfo_DetectColumnIdChangesRequest {
    /**
     * The owner type
     */
    OwnerType: enums.UDefType;
}
/**
 * Sets a user defined fields as page one field.
 */
export interface UserDefinedFieldInfo_SetUserDefinedPageOneFieldRequest {
    /**
     * The user-defined field owner entity
     */
    OwnerType: enums.UDefType;
    /**
     * The id of the udeffield to set as page one field
     */
    UdefFieldId: number;
    /**
     * The usergroup id to associate the page one field with.
     */
    UserGroupId: number;
    /**
     * Page one line number
     */
    FieldLineNo: number;
}
/**
 * Check if the publish event is active for the given type
 * Returns boolean
 */
export interface UserDefinedFieldInfo_IsPublishEventActiveRequest {
    /**
     *
     */
    Type: enums.UDefType;
}
/**
 * Check if any publish events are active
 * Returns boolean
 */
export interface UserDefinedFieldInfo_IsAnyPublishEventActiveRequest {
}
/**
 * Gets which page one fields have changed from the current version
 * Returns boolean[]
 */
export interface UserDefinedFieldInfo_GetChangedPageOneFieldsRequest {
    /**
     * The user-defined field owner-entity.
     */
    OwnerType: enums.UDefType;
    /**
     * Id of UserGroup
     */
    UserGroupId: number;
}
/**
 * Sets the Page One Field grouping for a specific entity
 */
export interface UserDefinedFieldInfo_SetPageOneFieldGroupingRequest {
    /**
     * The user-defined field owner-entity.
     */
    OwnerType: enums.UDefType;
    /**
     * If true, use grouping
     */
    Active: boolean;
}
/**
 * Make stuff similar to what happens in the win client
 * Returns UserDefinedFieldInfo
 */
export interface UserDefinedFieldInfo_SetListTableIdAndUDListDefinitionIdFromSelectedListIdRequest {
    /**
     *
     */
    Info: UserDefinedFieldInfo;
    /**
     *
     */
    SelectedListId: number;
}
/**
 * Kind of the reverse of SetListTableIdAndUDListDefinitionIdFromSelectedListId
 * Returns number
 */
export interface UserDefinedFieldInfo_FigureOutListIdFromListTableIdAndUDListDefinitionIdRequest {
    /**
     *
     */
    Info: UserDefinedFieldInfo;
}
/**
 * Change rank of user defined fields
 */
export interface UserDefinedFieldInfo_SetRankOnFieldsRequest {
    /**
     * The user-defined field owner-entity.
     */
    OwnerType: enums.UDefType;
    /**
     * All IDs of this owner-entity in desired rank order
     */
    RankedFieldsIds: number[];
}
/**
 * Set the start flag for udef publishing. Must be called before PUBLISH, or PUBLISH will fail. Start flag is removed when publish process completes.
 */
export interface UserDefinedFieldInfo_SetPublishStartSystemEventRequest {
    /**
     * The user-defined field owner-entity.
     */
    OwnerType: enums.UDefType;
}
/**
 * Clear all relevant caches. This is normally done automatically but can be useful in certain circumstances.
 */
export interface UserDefinedFieldInfo_ClearCachesRequest {
}
/**
 *
 */
export interface ReportEntity extends Carrier {
    /**
     * The id of the report.
     */
    ReportId?: number;
    /**
     * The category of the report.
     */
    ReportCategory?: enums.ReportCategory;
    /**
     * The description of the report.
     */
    Description?: string;
    /**
     * The layout of the report.
     */
    ReportLayout?: enums.ReportLayout;
    /**
     * The name of the report
     */
    Name?: string;
    /**
     * The owner of the report.
     */
    AssociateId?: number;
    /**
     * The id of report template.
     */
    TemplateId?: number;
    /**
     * Is the report published?
     */
    Published?: boolean;
}
/**
 * Creates the report as favorite. The sourceId is the key to the report that the favorite is based on.
 * Returns ReportEntity
 */
export interface Report_CreateFavoriteRequest {
    /**
     * The primary key to the report to make the favorite from.
     */
    SourceId: number;
    /**
     * The name of the new favorite.
     */
    Name: string;
    /**
     * The description of the new favorite.
     */
    Description: string;
}
/**
 * Deletes the report favorite.
 */
export interface Report_DeleteFavoriteRequest {
    /**
     * The id of the report favorite to delete.
     */
    ReportEntityId: number;
}
/**
 * Updates the favorite.
 * Returns ReportEntity
 */
export interface Report_UpdateFavoriteRequest {
    /**
     * ReportEntity carrier containg updated data.
     */
    ReportEntity: ReportEntity;
}
/**
 * Generates the report in PDF format
 * Returns string
 */
export interface Report_GenerateReportRequest {
    /**
     * The id of the report.
     */
    ReportId: number;
    /**
     * The id of the labellayout. Use 0 if the report isn't of type label.
     */
    LabelLayoutId: number;
    /**
     * Filename of the report.
     */
    Filename: string;
    /**
     * Language to use when generating the report.
     */
    Language: string;
    /**
     *
     */
    FileType: string;
    /**
     * Use restrictions to provide additional restrictions when generating the report.
     */
    Restrictions: ArchiveRestrictionInfo[];
}
/**
 * Takes the input stream and create a report. This stream must be on a valid xml format
 * Returns number
 */
export interface Report_ImportReportRequest {
    /**
     * The report to import in a correct xml format
     */
    Report: string;
}
/**
 * Delete the report with the given id
 * Returns boolean
 */
export interface Report_DeleteReportRequest {
    /**
     * The id of the report to delete
     */
    ReportId: number;
}
/**
 *
 */
export interface ReportLabelLayoutEntity extends Carrier {
    /**
     * Primary key
     */
    ReportLabelLayoutId?: number;
    /**
     * Name of the label layout
     */
    Name?: string;
    /**
     * Description
     */
    Description?: string;
    /**
     * Paper orientation: 1=portrait, 2=landscape
     */
    Orientation?: enums.ReportPaperOrientation;
    /**
     * Paper width in twips
     */
    PaperWidth?: number;
    /**
     * Paper height in twips
     */
    PaperHeight?: number;
    /**
     * Left margin in twips
     */
    LeftMargin?: number;
    /**
     * Right margin in twips
     */
    RightMargin?: number;
    /**
     * Top margin in twips
     */
    TopMargin?: number;
    /**
     * Bottom margin in twips
     */
    BottomMargin?: number;
    /**
     * Number og columns
     */
    CountColumns?: number;
    /**
     * Number of rows
     */
    CountRows?: number;
}
/**
 * Definition of the three perionds for status monitors and some other settings per saint entity
 */
export interface SaintConfiguration extends Carrier {
    /**
     * The table that is the owning entity
     */
    OwnerTable?: number;
    /**
     * On/off switch for Saint functionality for this entity
     */
    Enabled?: boolean;
    /**
     * Length of the first counter period
     */
    Period1?: number;
    /**
     * Length of the second counter period
     */
    Period2?: number;
    /**
     * Length of the third counter period
     */
    Period3?: number;
    /**
     * When was the last regeneration started
     */
    GenerationStart?: Date;
    /**
     * When was the last regeneration finished
     */
    GenerationEnd?: Date;
    /**
     * Number of CounterValue rows generated for this entity
     */
    RowsGenerated?: number;
}
/**
 * Returns the StatusMonitorPeriods entity.
 * Returns SaintConfiguration[]
 */
export interface Saint_GetSaintConfigurationsRequest {
}
/**
 * Definition of all properties for a status monitor
 */
export interface StatusMonitor extends Carrier {
    /**
     * Id of table that owns the status monitor
     */
    OwnerTable?: number;
    /**
     * Priority rank, in case more than one status is signalled. Lowest wins
     */
    Rank?: number;
    /**
     * "Default task type for this status; the default task text is in the text table (since it can be long), and may contain template variables"
     */
    DefaultTask?: number;
    /**
     * Default task text for this status
     */
    DefaultTaskText?: string;
    /**
     * Should the status be visualized (active) in the client
     */
    IsVisual?: boolean;
    /**
     * When was this status last generated (i.e., statusValue rows created)
     */
    LastGenerated?: Date;
    /**
     * Description of the status monitor
     */
    Description?: string;
    /**
     * Name of status monitor
     */
    Name?: string;
    /**
     * Primary key
     */
    StatusMonitorId?: number;
    /**
     * Id of BinaryObject row that contains image for status monitor
     */
    PictureId?: number;
    /**
     * Is the definition dirty, ie., ALL values are invalid until a recalculation; this flag is set when the status DEFINITION is changed, as opposed to the flag on StatusValue
     */
    NeedsUpdate?: boolean;
    /**
     * Deleted flag, 1 if this record is deleted (never from the database)
     */
    Deleted?: boolean;
    /**
     * Number of targets that have this status, this should be the number of rows in StatusValue pointing to this definition, and that have isSignalled set to 1
     */
    NumMatches?: number;
    /**
     * Number of targets that had this status, but have their needsUpdate bit set due to some change
     */
    NumNeedUpdate?: number;
    /**
     * When was the last regeneration started
     */
    GenerationStart?: Date;
}
/**
 * Get all active status monitors for a specified target
 * Returns StatusMonitor[]
 */
export interface Saint_GetStatusMonitorsRequest {
    /**
     * Identity of target type(contact identity, project identity etc.)
     */
    Id: number;
    /**
     * Type to get status monitors for("contact", "project", etc.)
     */
    Type: string;
}
/**
 * Get a single status monitor based on its identity
 * Returns StatusMonitor
 */
export interface Saint_GetStatusMonitorRequest {
    /**
     * Identity of status monitor
     */
    Id: number;
}
/**
 * Regenerate status monitors
 * Returns BatchTaskInfo
 */
export interface Saint_RegenerateStatusMonitorsRequest {
    /**
     * If true, then execute the regeneration as a Batch Task; the service call will return immediately. Otherwise wait until the task completes, may cause a timeout if called as a Web Service
     */
    RunAsBatch: boolean;
}
/**
 * Set rank order on status monitors
 */
export interface Saint_SetRankOnStatusMonitorsRequest {
    /**
     * Type of status monitors to reorder ("contact", "project", etc.)
     */
    Type: string;
    /**
     * The ids of the items in the order you want
     */
    ItemsIds: number[];
}
/**
 * Regenerate the given status monitor
 */
export interface Saint_RegenerateStatusMonitorRequest {
    /**
     * The id of the statusmonitor to regenerate
     */
    StatusMonitorId: number;
}
/**
 * Regenerate the Saint counters - this can take several minutes
 * Returns BatchTaskInfo
 */
export interface Saint_RegenerateCountersRequest {
    /**
     * If true, then execute the regeneration as a Batch Task; the service call will return immediately. Otherwise wait until the task completes, may cause a timeout if called as a Web Service
     */
    RunAsBatch: boolean;
}
/**
 * Obsolete, use SaintConfiguration carrier and methods instead. Was:Definition of the three perionds for status monitors
 */
export interface StatusMonitorPeriods extends Carrier {
    /**
     * Days in the first period
     */
    Period1?: number;
    /**
     * Days in the second period
     */
    Period2?: number;
    /**
     * Days in the third period
     */
    Period3?: number;
}
/**
 * Returns the StatusMonitorPeriods entity.
 * Returns StatusMonitorPeriods
 */
export interface Saint_GetStatusMonitorPeriodsRequest {
}
/**
 * BatchTasks run in the background.
 */
export interface Batch extends Carrier {
}
/**
 * Get a single BatchTaskInfo based on Id.
 * Returns BatchTaskInfo
 */
export interface Batch_GetBatchTaskInfoRequest {
    /**
     * Id of the BatchTaskInfo to get.
     */
    Id: number;
}
/**
 * Get an array of BatchTaskInfo for the provided associate id's.
 * Returns BatchTaskInfo[]
 */
export interface Batch_GetBatchTaskInfosByAssociatesRequest {
    /**
     * Array of associate id's. empty array = all tasks, 0 = system tasks, -1 = all user tasks.
     */
    AssociateIds: number[];
}
/**
 * Start a batch job based on BatchTaskInfo.
 * Returns number
 */
export interface Batch_StartBatchJobRequest {
    /**
     * Use BatchTaskInfo to describe the new batch job.
     */
    BatchTaskInfo: BatchTaskInfo;
}
/**
 * Stop a batch job based on Id.
 * Returns boolean
 */
export interface Batch_StopBatchJobRequest {
    /**
     * Id of the batch job to stop.
     */
    Id: number;
}
/**
 * Gets an array of user BatchTaskInfo with state defined by a BatchTaskState.
 * Returns BatchTaskInfo[]
 */
export interface Batch_GetBatchTaskInfosByStateRequest {
    /**
     * The BatchTaskState to get batch tasks for.
     */
    State: enums.BatchTaskState;
}
/**
 * Update information about a BatchTask. Only the following properties can be updated: State, Description, Response and Request.
 * Returns BatchTaskInfo
 */
export interface Batch_UpdateBatchTaskRequest {
    /**
     * The updated information to save.
     */
    BatchTaskInfo: BatchTaskInfo;
}
/**
 * Gets an array of user BatchTaskInfo with state defined by a BatchTaskState and the batchtask definition name.
 * Returns BatchTaskInfo[]
 */
export interface Batch_GetBatchTaskInfosByNameAndStateRequest {
    /**
     * Batchtask definition name. Blank for all tasks.
     */
    Name: string;
    /**
     * The BatchTaskState to get batch tasks for.
     */
    State: enums.BatchTaskState;
}
/**
 * Get an array of BatchTaskInfo for the provided associate id's and batch task definition name.
 * Returns BatchTaskInfo[]
 */
export interface Batch_GetBatchTaskInfosByNameAndAssociatesRequest {
    /**
     * Batchtask definition name. Blank for all tasks.
     */
    Name: string;
    /**
     * Array of associate id's. Empty array for all. 0 for system tasks, -1 for all users, or specific user ids.
     */
    AssociateIds: number[];
}
/**
 * Get an array of BatchTaskInfo for the provided associate id's and batch task state.
 * Returns BatchTaskInfo[]
 */
export interface Batch_GetBatchTaskInfosByAssociatesAndStateRequest {
    /**
     * Array of associate id's. Empty array for all. 0 for system tasks, -1 for all users, or specific user ids.
     */
    AssociateIds: number[];
    /**
     * The BatchTaskState to get batch tasks for.
     */
    State: enums.BatchTaskState;
}
/**
 * Delete batch tasks from the database.
 */
export interface Batch_DeleteBatchTasksRequest {
    /**
     * Array of batchTask ids to delete.
     */
    BatchTaskIds: number[];
}
/**
 * Delete a batch task from the database.
 */
export interface Batch_DeleteBatchTaskRequest {
    /**
     * The batchTask id to delete.
     */
    BatchTaskId: number;
}
/**
 * Get an array of system and user BatchTaskInfo for the provided task name.
 * Returns BatchTaskInfo[]
 */
export interface Batch_GetAllBatchTaskInfosByNameRequest {
    /**
     * A task name, NULL or blank to get all tasks
     */
    TaskName: string;
}
/**
 * Get an array of system and user BatchTaskInfo for the provided task name and state.
 * Returns BatchTaskInfo[]
 */
export interface Batch_GetAllBatchTaskInfosByNameAndStateRequest {
    /**
     * A task name, NULL or blank to get all tasks
     */
    TaskName: string;
    /**
     * The BatchTaskState to get batch tasks for.
     */
    State: enums.BatchTaskState;
}
/**
 * Get an array of system BatchTaskInfo for the provided task name.
 * Returns BatchTaskInfo[]
 */
export interface Batch_GetSystemBatchTaskInfosByNameRequest {
    /**
     * A task name, NULL or blank to get all tasks
     */
    TaskName: string;
}
/**
 * Get an array of system BatchTaskInfo for the provided task name and state.
 * Returns BatchTaskInfo[]
 */
export interface Batch_GetSystemBatchTaskInfosByNameAndStateRequest {
    /**
     * A task name, NULL or blank to get all tasks
     */
    TaskName: string;
    /**
     * The BatchTaskState to get batch tasks for.
     */
    State: enums.BatchTaskState;
}
/**
 * BatchTaskInfo contains information about one batch task.
 */
export interface BatchTaskInfo extends Carrier {
    /**
     * Id of the task.
     */
    Id?: number;
    /**
     * Name of the task.
     */
    Name?: string;
    /**
     *  Task owner. If it is a System task, AssociateId = 0.
     */
    AssociateId?: number;
    /**
     * Id of table with more information about the task.
     */
    DetailsTable?: number;
    /**
     * Record Id of a row in the DetailsTable containing more info about the task.
     */
    DetailsRecord?: number;
    /**
     * If IsSystemTask is true, the task is not initiated by an associate.
     */
    IsSystemTask?: boolean;
    /**
     * If IsInternalTask is true, this task will not add a trace to the database.
     */
    IsInternalTask?: boolean;
    /**
     * ParameterObject will be serialized to a binary blob and saved in the BinaryObject table. The link to the BinaryObject will be set using DetailsTable and DetailsRecord.
     */
    ParameterObject?: StringDictionary;
    /**
     * When was the task last started.
     */
    LastStarted?: Date;
    /**
     * Task creation time.
     */
    Created?: Date;
    /**
     * Maps to the startcount field in the batchtask table.
     */
    StartCount?: number;
    /**
     * Serial number of the database the task is to run on.
     */
    DatabaseSerialNumber?: string;
    /**
     * Context for the executing task.
     */
    Context?: string;
    /**
     * Maps to the result field in the batchtask table.
     */
    Result?: string;
    /**
     * BatchTaskState of the task.
     */
    State?: enums.BatchTaskState;
    /**
     * Description of the task.
     */
    Description?: string;
    /**
     * Maps to the response field in the batchtask table.
     */
    Response?: string;
    /**
     * Maps to the request field in the batchtask table.
     */
    Request?: string;
    /**
     * Descriptive text for the current stage
     */
    ProgressDescription?: string;
    /**
     * Task progress, in percent of estimated total
     */
    ProgressPercent?: number;
    /**
     * The filename related to the batchtask.
     */
    FileName?: string;
    /**
     * Indicate if the task can be stopped.
     */
    CancellationBehaviour?: enums.BatchTaskCancellationBehaviour;
}
/**
 * Relationship between a (contact/person) and another (contact/person), as described by the RelationDefinition.
 */
export interface ContactRelationEntity extends Carrier {
    /**
     * Id of the source contact. The value is mandatory.
     */
    SourceContactId?: number;
    /**
     * Id of the source person. The value is not mandatory. The person must belong to the source contact.
     */
    SourcePersonId?: number;
    /**
     * Id of the destination contact. The value is mandatory.
     */
    DestinationContactId?: number;
    /**
     * Id of the destination person. The value is not mandatory. The person must belong to the destination contact.
     */
    DestinationPersonId?: number;
    /**
     * Primary key
     */
    RelationId?: number;
    /**
     * Comment for relation
     */
    Comment?: string;
    /**
     * Reference to definition
     */
    RelationDefinitionId?: number;
    /**
     * Is direction reversed relative to definition
     */
    Reversed?: number;
    /**
     * Last updated when
     */
    UpdatedDate?: Date;
    /**
     * Registered when
     */
    CreatedDate?: Date;
    /**
     *
     */
    CreatedBy?: Associate;
    /**
     *
     */
    UpdatedBy?: Associate;
    /**
     * Name of the source contact.
     */
    SourceContactName?: string;
    /**
     * Name of the source person.
     */
    SourcePersonName?: string;
    /**
     * Name of the destination contact.
     */
    DestinationContactName?: string;
    /**
     * Name of the destination person.
     */
    DestinationPersonName?: string;
    /**
     * Active text for the relation.
     */
    ActiveText?: string;
    /**
     * Passive text for the relation.
     */
    PassiveText?: string;
}
/**
 * Creates a new or updates an existing contact relation.
 * Returns ContactRelationEntity
 */
export interface Relation_SaveContactRelationRequest {
    /**
     * Relation to save
     */
    ContactRelationEntity: ContactRelationEntity;
}
/**
 * Deletes the spesified contact relation.
 */
export interface Relation_DeleteContactRelationRequest {
    /**
     * Relation to delete
     */
    ContactRelationEntityId: number;
}
/**
 * Activity list filter information.
 */
export interface ActivityFilter extends Carrier {
    /**
     * The filtering From date
     */
    FromDate?: Date;
    /**
     * The filtering To date
     */
    ToDate?: Date;
    /**
     * The list of associates to filter on
     */
    AssociateList?: SelectableMDOListItem[];
    /**
     * The list of groups to filter on
     */
    GroupList?: SelectableMDOListItem[];
    /**
     * The list of future date selections. This is a static MDO list with standard values.
     */
    FutureDateList?: MDOListItem[];
}
/**
 * Get activity filter for the specified list.
 * Returns ActivityFilter
 */
export interface Archive_GetActivityFilterRequest {
}
/**
 * Set activity filter for the specified list.
 */
export interface Archive_SetActivityFilterRequest {
    /**
     * New activity filter
     */
    ActivityFilter: ActivityFilter;
}
/**
 * Returns the  associate ids that belongs to the given groups
 * Returns number[]
 */
export interface Archive_GetGroupAssociateIdsRequest {
    /**
     * Array of group ids
     */
    GroupIds: number[];
}
/**
 * Data carrier class for an item (cell) in an archive. This class contains properties and members for three distinct values: The (visible) display value; the tooltip hint, and the link hint.
 */
export interface ArchiveColumnData {
    /**
     * The visible display value for an archive cell. It is always a string, and other data types are converted to string according to the invariant culture. "[I:123]" or "[D:2014-09-13]". Further conversion to the local culture is the responsibility of the client.
     */
    DisplayValue?: string;
    /**
     * The tooltip hint is either a text to be shown (after resource tag substitution), or a tooltip key to be given to the tooltip provider system in order to asynchronoously retrieve the actual tooltip.
     */
    TooltipHint?: string;
    /**
     * The link hint consists of information to construct an actual link; additional information (such as a view context) must be provided by the client, who is also responsible for building the link. The content of the link will generally be one or more ids, such as contact_id=123.
     */
    LinkHint?: string;
}
/**
 * This class carries information about the definition and properties of an archive display column. It is used by the archive MDO providers to construct column lists for the configuration dialogs, and by the archive control to know what type (and other properties) each column has. The class is serializable and used on both the application and Web server sides.
 */
export interface ArchiveColumnInfo {
    /**
     * The column name to show, can be a resource identifier string.
     */
    DisplayName?: string;
    /**
     * The column tooltip, used in the column list and in the column headings
     */
    DisplayTooltip?: string;
    /**
     * Type of column, so that the archive knows how to display it (actual display values are always strings, invariant-culture formatted). This name can contain resource tags.
     */
    DisplayType?: string;
    /**
     * Can this column be used for sorting?
     */
    CanOrderBy?: boolean;
    /**
     * Unique identity of this column (in this particular context); the name to be used when requesting the column from a provider, setting restrictions or order by criteria
     */
    Name?: string;
    /**
     * Can this column be used as a restriction
     */
    CanRestrictBy?: boolean;
    /**
     * The data type of the restriction; use this to retrieve the legal operators for the restriction.
     */
    RestrictionType?: string;
    /**
     * If the restriction data type is 'list', this property contains the name of the SoList so that choices can be shown
     */
    RestrictionListName?: string;
    /**
     * Is this column visible to the user in configuration dialogs etc
     */
    IsVisible?: boolean;
    /**
     * The width specification, if the column info has been extended with GUI-based information. It is either "n%" or "nc", where n is an integer. Percent-formatted fields grow and shrink; number-of-characters formatted fields have constant width when the whole archive width changes.
     */
    Width?: string;
    /**
     * Icon hint corresponding to the display name; this icon hint is used in the configuration dialog and other places where we 'talk about' the columns of the archive. The actual heading of the archive may also contain icons in lieu of textual names, the icon hint for that is specified in HeadingIconHint and is a different one.
     */
    IconHint?: string;
    /**
     * Icon hint for the archive heading only. If this is a nonempty string, the archive header should use this icon and ignore the DisplayName. Otherwise, the DisplayName should be used as the heading.
     */
    HeadingIconHint?: string;
    /**
     * Example: 'navigator' -> Should this column be mapped to a hyperlinked navigator text type?
     */
    ExtraInfo?: string;
}
/**
 * This service is used to store and fetch the configuration of an archive. The configuration consists of entities and columns; entities correspond to archive provider entities and the checkboxes you see in the bottom of standard archives. Column configuration includes both what columns should be visible, what order they are in (left to right), and whether the archive rows should be sorted by one or more columns.<para/>Note that desired columns can be set through the selectable mdo list called archiveColumns:&lt;perovider name&gt;, and entities can be set through the selectable mdo list archiveEntities:&lt;provider name&gt;. You can also use the SetChosenEntities and SetChosenColumns method of this service. The selectable mdo list implementation is suitable for data binding using mdo list controls.
 */
export interface ArchiveConfiguration extends Carrier {
    /**
     *
     */
    ArchiveColumnInfo?: ArchiveColumnInfo[];
    /**
     *
     */
    ArchiveEntityInfo?: SelectableMDOListItem[];
    /**
     *
     */
    ArchiveOrderByInfo?: ArchiveOrderByInfo[];
    /**
     * The actual ownership information for the configuration that was retrieved
     */
    OwnerKeys?: string;
}
/**
 * Get the configuration for one archive. The configuration is keyed by a combination of archive provider name and gui name. The archive provider name must match an archive provider plugin; the gui name is an arbitrary string used to distinguish multiple occurrences of the same underlying provider in a gui.
 * Returns ArchiveConfiguration
 */
export interface Archive_GetArchiveConfigurationRequest {
    /**
     * String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     */
    GuiName: string;
    /**
     * Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     */
    ProviderName: string;
}
/**
 * Get the configuration for one archive, with context parameter. The configuration is keyed by a combination of archive provider name and gui name. The archive provider name must match an archive provider plugin; the gui name is an arbitrary string used to distinguish multiple occurrences of the same underlying provider in a gui.
 * Returns ArchiveConfiguration
 */
export interface Archive_GetArchiveConfigurationWithContextRequest {
    /**
     * String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     */
    GuiName: string;
    /**
     * Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     */
    ProviderName: string;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
}
/**
 * Set the column widths for the given set of columns and GUI name.
 */
export interface Archive_SetColumnWidthsRequest {
    /**
     * String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     */
    GuiName: string;
    /**
     * Array of column widths. A column width is specified either as a fixed number of character (10c) or as a percentage (10%). Percentages will be recalculated so that they add up to exactly 100 when the configuration is fetched again.
     */
    ColumnWidths: string[];
}
/**
 * Set the currently chosen entities for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveEntities: plus the archive provider name and gui name as its additionalInfo.
 */
export interface Archive_SetChosenEntitiesRequest {
    /**
     * String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     */
    GuiName: string;
    /**
     * Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     */
    ProviderName: string;
    /**
     * Array of entity names
     */
    Entities: string[];
}
/**
 * Set the currently chosen columns for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveColumns: plus the archive provider name and gui name as its additionalInfo.
 */
export interface Archive_SetChosenColumnsRequest {
    /**
     * String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     */
    GuiName: string;
    /**
     * Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     */
    ProviderName: string;
    /**
     * Array of column names, where array order indicates left to right order in the archive.
     */
    ChosenColumns: string[];
}
/**
 * Get the configuration for one archive. The configuration is keyed by a combination of archive provider name (plus optional context), gui name, and optional table binding. The archive provider name must match an archive provider plugin; the gui name is an arbitrary string used to distinguish multiple occurrences of the same underlying provider in a gui.
 * Returns ArchiveConfiguration
 */
export interface Archive_GetArchiveConfigurationV2Request {
    /**
     * String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     */
    GuiName: string;
    /**
     * Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     */
    ProviderName: string;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor. Optional, but required for archives that depend on a context - for instance Quote archives that need to know their QuoteConnectionId to be meaningful
     */
    Context: string;
    /**
     * Name/value string containing ownership binding information. The first should resolve to a table/primarykey, such as selection=123. Future functionality may allow multiple/extended keys
     */
    OwnerKeys: string;
}
/**
 * Set the column widths for the given set of columns and GUI name.
 */
export interface Archive_SetColumnWidthsV2Request {
    /**
     * String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     */
    GuiName: string;
    /**
     * Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     */
    ProviderName: string;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor. Optional, but required for archives that depend on a context - for instance Quote archives that need to know their QuoteConnectionId to be meaningful
     */
    Context: string;
    /**
     * Name/value string containing ownership binding information. The first should resolve to a table/primarykey, such as selection=123. Future functionality may allow multiple/extended keys
     */
    OwnerKeys: string;
    /**
     * Array of column widths. A column width is specified either as a fixed number of character (10c) or as a percentage (10%). Percentages will be recalculated so that they add up to exactly 100 when the configuration is fetched again.
     */
    ColumnWidths: string[];
}
/**
 * Set the currently chosen entities for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveEntities: plus the archive provider name and gui name as its additionalInfo.
 */
export interface Archive_SetChosenEntitiesV2Request {
    /**
     * String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     */
    GuiName: string;
    /**
     * Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     */
    ProviderName: string;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor. Optional, but required for archives that depend on a context - for instance Quote archives that need to know their QuoteConnectionId to be meaningful
     */
    Context: string;
    /**
     * Name/value string containing ownership binding information. The first should resolve to a table/primarykey, such as selection=123. Future functionality may allow multiple/extended keys
     */
    OwnerKeys: string;
    /**
     * Array of entity names
     */
    Entities: string[];
}
/**
 * Set the currently chosen columns for the given gui name/provider name combination. This service corresponds to the SetSelected method of the SelectableMDOList service, for a list called archiveColumns: plus the archive provider name and gui name as its additionalInfo.
 */
export interface Archive_SetChosenColumnsV2Request {
    /**
     * String that identifies the archive in the GUI, must be the same when fetching and storing configurations, but does not otherwise have to match anything.
     */
    GuiName: string;
    /**
     * Name of archive provider, must match one of the plugins known to the ArchiveProviderFactory.
     */
    ProviderName: string;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor. Optional, but required for archives that depend on a context - for instance Quote archives that need to know their QuoteConnectionId to be meaningful
     */
    Context: string;
    /**
     * Name/value string containing ownership binding information. The first should resolve to a table/primarykey, such as selection=123. Future functionality may allow multiple/extended keys
     */
    OwnerKeys: string;
    /**
     * Array of column names, where array order indicates left to right order in the archive.
     */
    ChosenColumns: string[];
}
/**
 * Get a page of results for an archive list, explicitly specifying the restrictions, orderby and chosen columns.
 * Returns ArchiveListItem[]
 */
export interface Archive_GetArchiveListByColumnsRequest {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * An array of the names of the columns wanted.
     */
    Columns: string[];
    /**
     * Sort order for the archive. Can be null, which indicates 'no particular order'
     */
    SortOrder: ArchiveOrderByInfo[];
    /**
     * Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: ArchiveRestrictionInfo[];
    /**
     * Which entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string[];
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
}
/**
 * Get a page of results for an archive list with context parameter, explicitly specifying the restrictions, orderby and chosen columns.
 * Returns ArchiveListItem[]
 */
export interface Archive_GetArchiveListByColumnsWithContextRequest {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * An array of the names of the columns wanted.
     */
    Columns: string[];
    /**
     * Sort order for the archive. Can be null, which indicates 'no particular order'
     */
    SortOrder: ArchiveOrderByInfo[];
    /**
     * Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: ArchiveRestrictionInfo[];
    /**
     * Which entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string[];
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
}
/**
 * Get a page of data for an archive. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
 * Returns ArchiveListItem[]
 */
export interface Archive_GetArchiveListRequest {
    /**
     * The GUI name of the archive list, used to retrieve the currently configured set of columns (otherwise manipulated using the ArchiveConfiguration service)
     */
    GuiName: string;
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Sort order for the archive. Can be null, which indicates 'no particular order'
     */
    SortOrder: ArchiveOrderByInfo[];
    /**
     * Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: ArchiveRestrictionInfo[];
    /**
     * Which entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string[];
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
}
/**
 * Get a page of data for an archive, with context parameter. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
 * Returns ArchiveListItem[]
 */
export interface Archive_GetArchiveListWithContextRequest {
    /**
     * The GUI name of the archive list, used to retrieve the currently configured set of columns (otherwise manipulated using the ArchiveConfiguration service)
     */
    GuiName: string;
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Sort order for the archive. Can be null, which indicates 'no particular order'
     */
    SortOrder: ArchiveOrderByInfo[];
    /**
     * Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: ArchiveRestrictionInfo[];
    /**
     * Which entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string[];
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
}
/**
 * Get a page of results for an archive list, explicitly specifying the restrictions, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
 * Returns ArchiveListResult
 */
export interface Archive_GetArchiveListByColumnsWithHeaderRequest {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * An array of the names of the columns wanted.
     */
    Columns: string[];
    /**
     * Sort order for the archive. Can be null, which indicates 'no particular order'
     */
    SortOrder: ArchiveOrderByInfo[];
    /**
     * Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: ArchiveRestrictionInfo[];
    /**
     * Which entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string[];
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
    /**
     * name=value&amp;... formatted set of options. "rowcount=true" will cause the rowcount to be calculated and populated.
     */
    Options: string;
}
/**
 * Return list of all archive provider names
 * Returns string[]
 */
export interface Archive_GetProviderNamesRequest {
}
/**
 * Get a page of results for an archive list, with context parameter, explicitly specifying the restrictions, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
 * Returns ArchiveListResult
 */
export interface Archive_GetArchiveListByColumnsWithHeaderWithContextRequest {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * An array of the names of the columns wanted.
     */
    Columns: string[];
    /**
     * Sort order for the archive. Can be null, which indicates 'no particular order'
     */
    SortOrder: ArchiveOrderByInfo[];
    /**
     * Archive restrictions. Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: ArchiveRestrictionInfo[];
    /**
     * Which entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string[];
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
    /**
     * name=value&amp;... formatted set of options. "rowcount=true" will cause the rowcount to be calculated and populated.
     */
    Options: string;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
}
/**
 * Return list of all columns supported by an archive provider. See also GetArchiveConfiguration.
 * Returns ArchiveColumnInfo[]
 */
export interface Archive_GetAvailableColumnsRequest {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Optional context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
}
/**
 * Return list of all entities supported by an archive provider. See also GetArchiveConfiguration.
 * Returns MDOListItem[]
 */
export interface Archive_GetAvailableEntitiesRequest {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Optional context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
}
/**
 * Get a page of results for an archive list, explicitly specifying the restrictions as a string, orderby and chosen columns.
 * Returns ArchiveListItem[]
 */
export interface Archive_GetArchiveListByColumns2Request {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * An array of the names of the columns wanted.
     */
    Columns: string;
    /**
     * Sort order for the archive as string ('name asc, dept desc'). Can be null, which indicates 'no particular order'
     */
    SortOrder: string;
    /**
     * Archive restrictions as string ('category = 1 and business oneOf (1,2,3)'). Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restrictions: string;
    /**
     * Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string;
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
}
/**
 * Get a page of results for an archive list with context parameter, explicitly specifying the restrictions as a string, orderby and chosen columns.
 * Returns ArchiveListItem[]
 */
export interface Archive_GetArchiveListByColumnsWithContext2Request {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Comma separated names of the columns wanted.
     */
    Columns: string;
    /**
     * Comma separated list of columns to sort order for the archive. e.g.: "name asc, dept desc, registeredBy" Can be null, which indicates 'no particular order'
     */
    SortOrder: string;
    /**
     * Archive restrictions as string. e.g. "name startsWith 'foo' and (dept = 'bar' or dept = 'baz')" Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: string;
    /**
     * Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string;
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
}
/**
 * Get a page of data for an archive using a restriction string. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
 * Returns ArchiveListItem[]
 */
export interface Archive_GetArchiveList2Request {
    /**
     * The GUI name of the archive list, used to retrieve the currently configured set of columns (otherwise manipulated using the ArchiveConfiguration service)
     */
    GuiName: string;
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Sort order for the archive. Can be null, which indicates 'no particular order'
     */
    SortOrder: string;
    /**
     * Archive restrictions as string. e.g. "name = 'baz' or category oneOf (1,2,3)". Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: string;
    /**
     * Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string;
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
}
/**
 * Get a page of data for an archive using restrictions as strings, with context parameter. The columns returned will be those set as chosen columns, using either the SetChosenColumns service or the corresponding SelectableMDOList.SetSelected.
 * Returns ArchiveListItem[]
 */
export interface Archive_GetArchiveListWithContext2Request {
    /**
     * The GUI name of the archive list, used to retrieve the currently configured set of columns (otherwise manipulated using the ArchiveConfiguration service)
     */
    GuiName: string;
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Sort order for the archive. e.g. "name asc, dept desc" Can be null, which indicates 'no particular order'
     */
    SortOrder: string;
    /**
     * Archive restrictions as string. e.g. "name gt 'B' or dept = 'baz'" Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: string;
    /**
     * Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string;
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
}
/**
 * Get a page of results for an archive list, explicitly specifying the restrictions as strings, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
 * Returns ArchiveListResult
 */
export interface Archive_GetArchiveListByColumnsWithHeader2Request {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Comma separated string of the names of the columns wanted.
     */
    Columns: string;
    /**
     * Comma separated string of sort order for the archive. e.g. "name asc, dept desc" Can be null, which indicates 'no particular order'
     */
    SortOrder: string;
    /**
     * Archive restrictions. e.g. "category = 2 or business oneOf (2,3,4)" Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: string;
    /**
     * Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string;
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
    /**
     * name=value&amp;... formatted set of options. "rowcount=true" will cause the rowcount to be calculated and populated.
     */
    Options: string;
}
/**
 * Get a page of results for an archive list, with context parameter, explicitly specifying the restrictions as strings, orderby and chosen columns; as well as a name/value string formatted set of options. The return value includes a header that has various extra information, in addition to the actual rows.
 * Returns ArchiveListResult
 */
export interface Archive_GetArchiveListByColumnsWithHeaderWithContext2Request {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Comma separated list of the names of the columns wanted.
     */
    Columns: string;
    /**
     * Sort order for the archive. "name asc, dept desc" Can be null, which indicates 'no particular order'
     */
    SortOrder: string;
    /**
     * Archive restrictions as string. "updated > '2009.1.1' and registeredBy = 2" Archives will generally throw an exception if no restrictions are set. Pass in an empty array if you really do not want restrictions, but remember that you may end up fetching the first page of millions of rows.
     */
    Restriction: string;
    /**
     * Comma separated list of entities to include. Can be null, which indicates 'include all entities'
     */
    Entities: string;
    /**
     * Page number, page 0 is the first page. Negative page numbers are interpreted as number of rows to skip.
     */
    Page: number;
    /**
     * Page size, which should be kept reasonable (say, no more than 1000 rows at a time)
     */
    PageSize: number;
    /**
     * name=value&amp;... formatted set of options. "rowcount=true" will cause the rowcount to be calculated and populated.
     */
    Options: string;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
}
/**
 * Exports the target archive to a downloadable format.
 * Returns ExportArchiveResult
 */
export interface Archive_ExportArchiveRequest {
    /**
     * The name of the archive provider to use; it will be created via the ArchiveProviderFactory from a plugin
     */
    ProviderName: string;
    /**
     * Context parameter, url-encoded string context parameter for ArchiveProvider constructor
     */
    Context: string;
    /**
     * Comma separated list of the names of the desired entities.
     */
    DesiredEntities: string[];
    /**
     * Comma separated list of the names of the columns wanted; supports display names
     */
    Columns: string[];
    /**
     *
     */
    SortOrder: ArchiveOrderByInfo[];
    /**
     *
     */
    Restrictions: ArchiveRestrictionInfo[];
    /**
     * To what format the archive should be exported; Excel, etc.
     */
    ExportType: string;
    /**
     *
     */
    SelectedRowIds: string[];
    /**
     * The estimated amount of rows to be exported. Used to determine if the operation should be run as a batch task or immediately.
     */
    EstimatedRowCount: number;
}
/**
 *
 */
export interface ArchiveListItem extends Carrier {
    /**
     * The entity name of the ArchiveListItem. An ArchiveList may contain rows from different entities.
     */
    EntityName?: string;
    /**
     * The  primary key for the row
     */
    PrimaryKey?: number;
    /**
     * Dictionary of column name - column data items. Each column data item contains a display value, a tooltip hint, a link hint, and an orderby value. <para/>The display value is encoded by the CultureDataFormatter and can be decoded / localized by that class; all other values are optional. <para/>Tooltip hints can be passed to the TooltipProvider (Tooltip service) to be translated into an actual tootip.
     */
    ColumnData?: ColumnDataDictionary;
    /**
     * Link hint for the row, indicating things like navigation links that can be presented as clickable hyperlinks
     */
    LinkHint?: string;
    /**
     * Style hint for the row, for instance 'retired' for associates or 'private' for appointments. Presentation layers can interpret the style hints as they see fit.
     */
    StyleHint?: string;
}
/**
 * Header/Detail variant of archive result, with a Row Count plus the actual rows. Future extensions may include other header data on the same level as the RowCount
 */
export interface ArchiveListResult extends Carrier {
    /**
     * Count of rows, independent of paging. If you order up page 1 with page size 50, the row count may still be 279, that being the number of rows that would have been returned in a  paging-off situation
     */
    RowCount?: number;
    /**
     * The actual rows, according to the paging info, of the result. See RowCount for a paging-independent count estimate
     */
    Rows?: ArchiveListItem[];
}
/**
 * This class carries information about an ordering criterion for an archive.
 */
export interface ArchiveOrderByInfo {
    /**
     * Programmatic name of the column to order by, semantically the same as the ArchiveColumnInfo.Name.
     */
    Name?: string;
    /**
     * Direction to order.
     */
    Direction?: enums.OrderBySortType;
}
/**
 * Carrier for restriction group. It contains all the search restrictions for the group - that is, ArchiveRestrictionInfo - objects, including some info like rank and name
 */
export interface ArchiveRestrictionGroup {
    /**
     * The name of this criteria group
     */
    Name?: string;
    /**
     * Description of group
     */
    Description?: string;
    /**
     * Rank order within this CriteriaModel
     */
    Rank?: number;
    /**
     * Array of ArchiveRestrictionInfo restriction specifications
     */
    Restrictions?: ArchiveRestrictionInfo[];
}
/**
 * This class carries information about a restriction on the query of an archive provider
 */
export interface ArchiveRestrictionInfo {
    /**
     * The programmatic column name, including any required prefixes
     */
    Name?: string;
    /**
     * The operator, such as =, etc
     */
    Operator?: string;
    /**
     * Value(s) to test against
     */
    Values?: string[];
    /**
     * Display representation of value(s) - list ID's are decoded to display texts, other values are represented in a format suitable for decoding and display through the CultureDataFormatter.
     */
    DisplayValues?: string[];
    /**
     * Optional complete ArchiveColumnInfo for this restriction; in that case, ColumnInfo.Name == this.Name will always be true
     */
    ColumnInfo?: ArchiveColumnInfo;
    /**
     * Is this restriction active?  Inactive restrictions will not influence the generated query
     */
    IsActive?: boolean;
    /**
     * Optional collection of sub criteria, usually null but set for Saint counter fields
     */
    SubRestrictions?: ArchiveRestrictionInfo[];
    /**
     * Get or set the parenthesis (if any) associated with this restriction. Positive values indicate a number of opening parentheses (deepening nesting level), while negative numbers indicate closing parentheses. Zero means no change in nesting level (no parentheses).
     */
    InterParenthesis?: number;
    /**
     * Get or set the inter-restriction operator that describes how this restriction is related to the next one in an array. Default for new ArchiveRestrictionInfo objects is And
     */
    InterOperator?: enums.InterRestrictionOperator;
    /**
     *
     */
    UniqueHash?: number;
}
/**
 *
 */
export interface ExportArchiveResult extends Carrier {
    /**
     * Id of the BatchTask created. <=0 if no BatchTask was created.
     */
    BatchTaskId?: number;
    /**
     * The path to the output file created, if it exists. Will be an empty string if no file was created.
     */
    FileName?: string;
    /**
     * Descriptive messages; errors, etc.
     */
    Message?: string;
}
/**
 * Display data items for one or more related-table fields, specified using a root entity and dot-syntax
 */
export interface RelatedData {
    /**
     * The name of a 'related field'. This must be a valid column name in the DotSyntax/Dynamic system, implicitly starting with the given root table
     */
    Field?: string;
    /**
     * The value for the Field, expressed as an archive column data cell
     */
    FieldValue?: ArchiveColumnData;
}
/**
 * Get data for fields related to a table record. While this method /can/ be used to fetch plain fields, that is not the intended usage and it does not replace the Entity.Get methods available for that purpose. Nor does it replace the generic DotSyntax/Dynamic archive provider.
 * Returns RelatedData[]
 */
export interface Archive_GetRelatedDataRequest {
    /**
     * The root table to get related data for, such as 'ticket' or 'y_car'
     */
    Table: string;
    /**
     * The primary key of the root table to get related data for
     */
    RecordId: number;
    /**
     * Names of fields - these need to be valid in the DotSyntax for this table, and can be arbitrarily deep. Examples: 'title', 'created_by.associate_id.person.fullName', 'x_comment'. Do not start with the root table name.
     */
    Fields: string[];
}
/**
 * Get data for fields related to a table record. While this method /can/ be used to fetch plain fields, that is not the intended usage and it does not replace the Entity.Get methods available for that purpose. Nor does it replace the generic DotSyntax/Dynamic archive provider.
 * Returns RelatedData[]
 */
export interface Archive_GetRelatedData2Request {
    /**
     * The root table to get related data for, such as 'ticket' or 'y_car'
     */
    Table: string;
    /**
     * The primary key of the root table to get related data for
     */
    RecordId: number;
    /**
     * Names of fields as a comma-separated list - these need to be valid in the DotSyntax for this table, and can be arbitrarily deep. Example: 'title,created_by.associate_id.person.fullName, x_comment'. Do not start with the root table name.
     */
    Fields: string;
}
/**
 * An Audience configuration parameter, used for handling Audience application or Web part settings.
 */
export interface AudienceConfigParameter extends Carrier {
    /**
     * The id of the Audience layout this configuration setting belongs to
     */
    AudienceLayoutId?: number;
    /**
     * The name of the configuration parameter
     */
    Name?: string;
    /**
     * The value of the configuration parameter
     */
    Value?: string;
    /**
     * The date and time the configuration parameter was created
     */
    CreatedDate?: Date;
    /**
     * The date and time the configuration parameter was last updated
     */
    UpdatedDate?: Date;
    /**
     * Name of the person that created the configuration parameter
     */
    CreatedBy?: string;
    /**
     * Name of the person that last updated the configuration parameter
     */
    UpdatedBy?: string;
}
/**
 * Saves an Audience configuration parameter belonging to a Audience layout
 * Returns AudienceConfigParameter
 */
export interface Audience_SaveConfigParameterRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
    /**
     * The Audience configuration parameter to save.
     */
    ConfigParameter: AudienceConfigParameter;
}
/**
 * Gets the string value of an Audience configuration parameter belonging to a given Audience layout with the specified configuration parameter name
 * Returns string
 */
export interface Audience_GetConfigParameterValueRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
    /**
     * The name of the Audience configuration parameter
     */
    ParameterName: string;
}
/**
 * Gets an Audience configuration parameter belonging to a given Audience layout with the specified configuration parameter name
 * Returns AudienceConfigParameter
 */
export interface Audience_GetConfigParameterRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
    /**
     * The name of the Audience configuration parameter
     */
    ParameterName: string;
}
/**
 * Deletes an Audience configuration parameter belonging to a Audience layout
 */
export interface Audience_DeleteConfigParameterRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
    /**
     * The name of the Audience configuration parameter
     */
    ParameterName: string;
}
/**
 * Gets an Audience configuration parameter belonging to the currently logged on user with the specified configuration parameter name.
 * Returns AudienceConfigParameter
 */
export interface Audience_GetMyConfigParameterRequest {
    /**
     * The name of the Audience configuration parameter
     */
    ParameterName: string;
}
/**
 * Gets the string value of an Audience configuration parameter belonging to the currently logged on user with the specified configuration parameter name.
 * Returns string
 */
export interface Audience_GetMyConfigParameterValueRequest {
    /**
     * The name of the Audience configuration parameter
     */
    ParameterName: string;
}
/**
 * Gets the string value of an Audience configuration parameter with the specified configuration parameter name on the person specified
 * Returns string
 */
export interface Audience_GetConfigParameterValueOnPersonRequest {
    /**
     * The name of the Audience configuration parameter
     */
    ParameterName: string;
    /**
     * Id of the person the parameter belongs to
     */
    PersonId: number;
}
/**
 * Gets an Audience configuration parameter with the specified configuration parameter name on the person specified
 * Returns AudienceConfigParameter
 */
export interface Audience_GetConfigParameterOnPersonRequest {
    /**
     * The name of the Audience configuration parameter
     */
    ParameterName: string;
    /**
     * Id of the person the parameter belongs to
     */
    PersonId: number;
}
/**
 * Gets the Audience configuration parameters belonging to a given Audience layout.
 * Returns AudienceConfigParameter[]
 */
export interface Audience_GetConfigParametersByLayoutNameRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
}
/**
 * Gets the Audience configuration parameters belonging to the currently logged on user.
 * Returns AudienceConfigParameter[]
 */
export interface Audience_GetMyConfigParametersRequest {
}
/**
 * Gets the Audience configuration parameters belonging to the person specified
 * Returns AudienceConfigParameter[]
 */
export interface Audience_GetConfigParametersOnPersonRequest {
    /**
     * Id of the person the parameter belongs to
     */
    PersonId: number;
}
/**
 * Audience layout. Each instance of Audience has at least one layout. The layout is connected to the instance by it's instance name or is linked to the currently logged on user. The web part layout and the Audience configuration parameters belongs to an Audience layout
 */
export interface AudienceLayoutEntity extends Carrier {
    /**
     * The Id of the Audience layout
     */
    AudienceLayoutId?: number;
    /**
     * The web part layout as a serialized string
     */
    InstanceLayout?: string;
    /**
     * Name of the layout instance
     */
    InstanceName?: string;
    /**
     * The date and time the Audience layout was created
     */
    CreatedDate?: Date;
    /**
     * The date and time the Audience layout was last updated
     */
    UpdatedDate?: Date;
    /**
     * Name of the person that created the Audience layout
     */
    CreatedBy?: Associate;
    /**
     * Name of the person that last updated the Audience layout
     */
    UpdatedBy?: Associate;
}
/**
 * Gets an Audience layout by it's instance name
 * Returns AudienceLayoutEntity
 */
export interface Audience_GetAudienceLayoutByNameRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
}
/**
 * Gets the Audience layout belonging to the currently logged on user.
 * Returns AudienceLayoutEntity
 */
export interface Audience_GetMyAudienceLayoutRequest {
}
/**
 * Gets the Audience layout belonging to the person specified.
 * Returns AudienceLayoutEntity
 */
export interface Audience_GetAudienceLayoutOnPersonRequest {
    /**
     * The person id
     */
    PersonId: number;
}
/**
 * Returns the default project or event image that is displayed in Audience when no project/event image is found. The image belongs to a specific Audience layout instance.
 * Returns Blob
 */
export interface Audience_GetDefaultProjectImageRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
}
/**
 * Stores the default project or event image that is displayed in Audience when no project/event image is found. The image is set on a specific Audience layout instance.
 */
export interface Audience_SetDefaultProjectImageRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
    /**
     * The default project/event image to be stored for this Audience layout instance (System.Drawing.Image)
     */
    Image: ArrayBuffer | string;
}
/**
 * Stores the default person (sales rep) image that is displayed in Audience when no person image is found. The image is set on a specific Audience layout instance.
 */
export interface Audience_SetDefaultPersonImageRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
    /**
     * The default project/event image to be stored for this Audience layout instance (System.Drawing.Image)
     */
    Image: ArrayBuffer | string;
}
/**
 * Returns the default person (sales rep) image that is displayed in Audience when no person image is found. The image belongs to a specific Audience layout instance.
 * Returns Blob
 */
export interface Audience_GetDefaultPersonImageRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
}
/**
 * Stores the default country flag image that is displayed in Audience when no person image is found. The image is set on a specific Audience layout instance.
 */
export interface Audience_SetDefaultCountryFlagRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
    /**
     * The default country image to be stored for this Audience layout instance (System.Drawing.Image)
     */
    Image: ArrayBuffer | string;
}
/**
 * Returns the default country flag image that is displayed in Audience when no person image is found. The image belongs to a specific Audience layout instance.
 * Returns Blob
 */
export interface Audience_GetDefaultCountryFlagRequest {
    /**
     * Name of the Audience layout instance
     */
    LayoutName: string;
}
/**
 *
 * Returns Blob
 */
export interface Audience_GetLogoImageRequest {
    /**
     *
     */
    LayoutName: string;
}
/**
 *
 */
export interface Audience_SetLogoImageRequest {
    /**
     *
     */
    LayoutName: string;
    /**
     *
     */
    Image: ArrayBuffer | string;
}
/**
 * One preference item, which contains a specification (section/key), the raw string value, and the level at which this value was found.
 */
export interface Preference extends Carrier {
    /**
     * Preference level, using the standard enumerated type. Undefined is returned for preferences that do not have a current setting.
     */
    Level?: enums.PreferenceLevel;
    /**
     * Preference value
     */
    RawValue?: string;
    /**
     * Preference specification, consisting of the section name and key name
     */
    Specification?: PreferenceSpec;
    /**
     * Display value, populated when asked for. Suitable for binding display-datasource in lists, etc. Formatted using CultureDataFormatter.
     */
    DisplayValue?: string;
    /**
     * Display tooltip, populated when asked for. Suitable for binding display-datasource in lists, etc. Formatted using CultureDataFormatter.
     */
    DisplayTooltip?: string;
    /**
     * Display type, populated when asked for.
     */
    DisplayType?: enums.PrefDescValueType;
    /**
     *
     */
    TabOrder?: TabOrder;
    /**
     * The id of the target row. The table it points at is specified by the preference type.
     */
    TargetId?: number;
    /**
     * The id of the prefdesc this preference is connected to
     */
    PrefDescId?: number;
    /**
     * For DisplayType=PrefDescValueType.ListTableRef, TableName will contain the name of the table which the value reference to.
     */
    TableName?: string;
    /**
     * The id of the user preference
     */
    UserPreferenceId?: number;
}
/**
 * Save this preference
 */
export interface Preference_SavePreferenceRequest {
    /**
     * Preference to be saved. All fields must be filled in, and the preference will be saved on the Associate level only. Setting for other levels is an administrative task and not available through this service.
     */
    Preference: Preference;
}
/**
 * Saves the tab order. The order is saved pr. user.
 */
export interface Preference_SaveTabOrderRequest {
    /**
     * Name of the tab control
     */
    TabOrder: TabOrder;
}
/**
 * Gets the tab order.
 * Returns TabOrder
 */
export interface Preference_GetTabOrderRequest {
    /**
     * Name of the tab control
     */
    TabName: string;
}
/**
 * Get a preference by id
 * Returns Preference
 */
export interface Preference_GetPreferenceRequest {
    /**
     * The id of the preference to load
     */
    Id: number;
}
/**
 * Saves a complete preference object, on any level and any target. Preference administrator rights are required to use this
 * Returns Preference
 */
export interface Preference_SavePreferenceEntityRequest {
    /**
     * The preference object to be saved
     */
    Preference: Preference;
    /**
     * If this is true, all user preferences on lower levels will be deleted
     */
    RemoveLowerLevels: boolean;
}
/**
 * Delete a preference by id
 */
export interface Preference_DeletePreferenceRequest {
    /**
     * The id of the preference to delete
     */
    Id: number;
}
/**
 * Delete some preferences by id
 */
export interface Preference_DeletePreferencesRequest {
    /**
     * The ids of the preference to delete
     */
    Ids: number[];
}
/**
 * Get a preference by name
 * Returns Preference
 */
export interface Preference_GetPreferenceByNameRequest {
    /**
     * The preference section name. e.g. 'Functions'. See SuperOffice.CRM.UserPreferenceStrings for constants.
     */
    PrefSection: string;
    /**
     * The preference key name. e.g. 'ShowTipsAtStart'. See SuperOffice.CRM.UserPreferenceStrings for constants.
     */
    PrefKey: string;
    /**
     * The preference level to read. Undefined (0) means to return the preference defined closest to the user.
     */
    PrefLevel: enums.PreferenceLevel;
}
/**
 * Get a preference by name and owner id.
 * Returns Preference
 */
export interface Preference_GetPreferenceByNameAndIdRequest {
    /**
     * The preference section name. e.g. 'Functions'. See SuperOffice.CRM.UserPreferenceStrings for constants.
     */
    PrefSection: string;
    /**
     * The preference key name. e.g. 'ShowTipsAtStart'. See SuperOffice.CRM.UserPreferenceStrings for constants.
     */
    PrefKey: string;
    /**
     * The preference level to read. Undefined (0) means to return the preference defined closest to the user.
     */
    PrefLevel: enums.PreferenceLevel;
    /**
     * The preference owner id, individual or group.
     */
    OwnerId: number;
}
/**
 * Returns URL to status service. e.g. 'https://help.superoffice.com/sodispatcher/v1/status' Returns NULL if status does not need to be checked yet.
 * Returns string
 */
export interface Preference_GetNetServicesStatusUrlRequest {
}
/**
 * Update the NetServices preferences with values contained in the content from the Status URL
 */
export interface Preference_UpdateNetServicesStatusRequest {
    /**
     * The text that was returned by getting the Status URL
     */
    XmlOrJson: string;
}
/**
 * Returns paths that XSRF cookies should be set on
 * Returns string[]
 */
export interface Preference_GetXsrfPathsRequest {
    /**
     * The hostname that we are storing paths for.
     */
    Hostname: string;
}
/**
 * Update the paths that need XSRF cookies
 */
export interface Preference_SetXsrfPathsRequest {
    /**
     * The hostname that we are storing paths for.
     */
    Hostname: string;
    /**
     * Paths that XSRF cookies should be set for: ['/cs', '/crm']
     */
    Paths: string[];
}
/**
 * Preference description, drives the Preference GUI. Maintenance client - controls all preferences in SuperOffice.
 */
export interface PreferenceDescription extends Carrier {
    /**
     * Primary key
     */
    PrefDescId?: number;
    /**
     * Preference section name
     */
    Section?: string;
    /**
     * Preference key name
     */
    Key?: string;
    /**
     * Multi-language name
     */
    Name?: string;
    /**
     * 1=number, 2=text, 3=bool, 4=list of values; 5=list table ref; 6=contact ID, 7=Person ID, 8=Project ID, 9=Selection ID
     */
    ValueType?: enums.PrefDescValueType;
    /**
     * Lowest allowed setting level, set by user, but not lower than sysMaxLevel
     */
    MaxLevel?: enums.PreferenceLevel;
    /**
     * Lowest allowed setting level, set by SuperOffice
     */
    SysMaxLevel?: enums.PreferenceLevel;
    /**
     * 1=wizard mode, 2=level 0, 4=admin gui, 8=crm gui
     */
    AccessFlags?: enums.PrefDescAccessFlags;
    /**
     * Description of preference, multi-language parsed
     */
    Description?: string;
    /**
     * 1 = This row populated and maintained by SuperOffice
     */
    IsBuiltin?: boolean;
    /**
     * If valueType = 5, then TableName contains the table referenced by the preference
     */
    TableName?: string;
    /**
     * Read-only field, If valueType = 5, and TableName is UDList, then UserdefinedLIstId contains the id of the list referenced by the preference
     */
    UserDefinedListId?: number;
    /**
     * Rank field for ordering sections, and keys within sections
     */
    Rank?: number;
    /**
     * Keys that share a value (including NULL) in this field are shown together; a visual spacer is shown between groups
     */
    SubGroup?: string;
    /**
     * The minimum (furthest away from User) level this preference can be set for
     */
    MinLevel?: number;
    /**
     * Max value (if type 1); list table ID (if type 5)
     */
    MaxValue?: number;
    /**
     * Min value (if type 1); list extra id (if type 5)
     */
    MinValue?: number;
    /**
     * Licenses the user/installation must have if this reference is to be shown. Comma-separated list of owner.module pairs
     */
    RequiredLicense?: string;
}
/**
 * Gets a PreferenceDescription based on the section and key
 * Returns PreferenceDescription
 */
export interface Preference_GetFromSectionAndKeyRequest {
    /**
     * The PreferenceDescription-section
     */
    Section: string;
    /**
     * The PreferenceDescription-key
     */
    Key: string;
}
/**
 * Gets a list of all PreferenceDescriptions in the system.
 * Returns PreferenceDescription[]
 */
export interface Preference_GetAllRequest {
}
/**
 * Gets all PreferenceDescription-items in the specified section
 * Returns PreferenceDescription[]
 */
export interface Preference_GetAllFromSectionRequest {
    /**
     * The PreferenceDescription-section
     */
    Section: string;
}
/**
 * Update a PreferenceDescription based on the section and key
 * Returns PreferenceDescription
 */
export interface Preference_SaveFromSectionAndKeyRequest {
    /**
     * The PreferenceDescription-section
     */
    Section: string;
    /**
     * The PreferenceDescription-key
     */
    Key: string;
    /**
     * The PreferenceDescription to save.
     */
    PreferenceDescription: PreferenceDescription;
}
/**
 * Gets a PreferenceDescription based on the section and key
 */
export interface Preference_DeleteFromSectionAndKeyRequest {
    /**
     * The PreferenceDescription-section
     */
    Section: string;
    /**
     * The PreferenceDescription-key
     */
    Key: string;
}
/**
 * Preference description line, contains information about a single item in a preference description list.
 */
export interface PreferenceDescriptionLine extends Carrier {
    /**
     * Primary key
     */
    PrefDescLineId?: number;
    /**
     * Preference description (parent)
     */
    PrefDescId?: number;
    /**
     * Possible value
     */
    PrefValue?: string;
    /**
     * Descriptive value, multilang-parsed, to put in list
     */
    PrefShowValue?: string;
    /**
     * Description of preference value, multi-language parsed
     */
    Description?: string;
    /**
     * 1 = This row populated and maintained by SuperOffice
     */
    IsBuiltin?: boolean;
}
/**
 * Get a preference description line from a prefDesc_id and a prefValue
 * Returns PreferenceDescriptionLine
 */
export interface Preference_GetPreferenceDescriptionLineFromIdAndValueRequest {
    /**
     * The id of the preference description this line is connected to
     */
    PrefDescId: number;
    /**
     * The value of the description line to return
     */
    PrefValue: string;
}
/**
 * Get all preference description lines from a prefDesc_id
 * Returns PreferenceDescriptionLine[]
 */
export interface Preference_GetPreferenceDescriptionLinesByPrefDescIdRequest {
    /**
     * The id of the preference description this line is connected to
     */
    PrefDescId: number;
}
/**
 * Saves the PreferenceDescriptionLine array in the SuperOffice database
 * Returns PreferenceDescriptionLine[]
 */
export interface Preference_SavePreferenceDescriptionLinesRequest {
    /**
     * The PreferenceDescriptionLine array to save.
     */
    PreferenceDescriptionLines: PreferenceDescriptionLine[];
}
/**
 * Delete the PrefDescLines in the SuperOffice database
 */
export interface Preference_DeletePreferenceDescriptionLinesRequest {
    /**
     * Primary keys of the PrefDescLines to delete
     */
    PrefDescLineIds: number[];
}
/**
 * Delete the PrefDescLines associated with Preference Description Id in the SuperOffice database
 */
export interface Preference_DeletePrefDescLinesByPrefDescIdRequest {
    /**
     * Primary key of the Preference Description that contains PrefDescLines to delete
     */
    PrefDescId: number;
}
/**
 * Delete the PrefDescLines associated with Preference Description Ids in the SuperOffice database
 */
export interface Preference_DeletePrefDescLinesByPrefDescIdsRequest {
    /**
     * Primary keys of the Preference Descriptions that contains PrefDescLines to delete
     */
    PrefDescIds: number[];
}
/**
 * Get one or more preferences based on a set of specifications.<br/>The prefDisplayvalue and prefDisplaytooltip are blank (faster processing relative to GetPreferencesWithDisplayValues)
 * Returns Preference[]
 */
export interface Preference_GetPreferencesRequest {
    /**
     * Array of preference specifications. The key value may be * (asterisk), which means 'all keys within section'. Note that the semantics of this are more strictly 'all keys actually set at any accessible level for this associate'; you will NOT get entries for preferences that might exist, but have no set value anywhere. You can also have askerisk as the section name. In that case the specification array must contain exactly one entry and the key must also be asterisk. This will return all known preferences in all sections for your associate. It might be a lot, tests have shown that a heavily used database can accumulate up to 500 preferences on a single associate. If the Sentry table/field right preferences have been used, the number could be a lot greater!
     */
    Specifications: PreferenceSpec[];
}
/**
 * Save this set of preferences. Note this method DOES NOT look at level/targetId - it only saves on behalf of the CURRENT USER.
 */
export interface Preference_SavePreferencesRequest {
    /**
     * Preferences to be saved. Note that all fields must be filled in, and the preference will be saved on the Associate level only! Setting for other levels is an administrative task and not available through this service.
     */
    Preferences: Preference[];
}
/**
 * Get one or more preferences based on a set of specifications<br/>The PrefDisplayValue and PrefDisplaytooltip are populated, at some additional processing cost.
 * Returns Preference[]
 */
export interface Preference_GetPreferencesWithDisplayValuesRequest {
    /**
     * Array of preference specifications. The key value may be * (asterisk), which means 'all keys within section'. Note that the semantics of this are more strictly 'all keys actually set at any accessible level for this associate'; you will NOT get entries for preferences that might exist, but have no set value anywhere. You can also have askerisk as the section name. In that case the specification array must contain exactly one entry and the key must also be asterisk. This will return all known preferences in all sections for your associate. It might be a lot, tests have shown that a heavily used database can accumulate up to 500 preferences on a single associate. If the Sentry table/field right preferences have been used, the number could be a lot greater!
     */
    Specifications: PreferenceSpec[];
}
/**
 *
 * Returns TabOrder[]
 */
export interface Preference_GetTabOrdersRequest {
}
/**
 *
 */
export interface Preference_SaveTabOrdersRequest {
    /**
     *
     */
    TabOrders: TabOrder[];
}
/**
 * Save this set of preferences.
 */
export interface Preference_SavePreferenceEntitiesRequest {
    /**
     * Preferences to be saved. Note that all fields must be filled in.
     */
    Preferences: Preference[];
    /**
     * If this is true, all user preferences on lower levels will be deleted
     */
    RemoveLowerLevels: boolean;
}
/**
 * Preference specification, consisting of the section name and key name
 */
export interface PreferenceSpec extends Carrier {
    /**
     * Preference section name
     */
    Section?: string;
    /**
     * Preference key name
     */
    Key?: string;
}
/**
 *
 */
export interface TabOrder extends Carrier {
    /**
     * Primary key
     */
    TabOrderId?: number;
    /**
     * Name of tab control
     */
    TabName?: string;
    /**
     * The actual tab order
     */
    Order?: string;
    /**
     * Associate who owns this tab order
     */
    AssociateId?: number;
}
/**
 * Result of CheckLicenseStatus
 */
export interface CheckLicenseStatusResult {
    /**
     * Result of CheckLicenseStatus
     */
    LicenseStatus?: enums.LicenseStatus;
    /**
     * Message to display in SOADMIN if LinkType=90.
     */
    Message?: string;
    /**
     * Url to show to the user.  This is relevant when LinkType is 60.
     */
    Url?: string;
}
/**
 *
 */
export interface ExtendedLicenseInfo {
    /**
     *
     */
    Reason?: string;
    /**
     *
     */
    CanBeActivated?: boolean;
    /**
     *
     */
    New?: LicenseInfo;
    /**
     *
     */
    Current?: LicenseInfo;
    /**
     *
     */
    ExtendedModuleLicenses?: ExtendedModuleLicense[];
    /**
     *
     */
    AccumulatedNextCheckDate?: Date;
}
/**
 *
 */
export interface ExtendedModuleLicense {
    /**
     *
     */
    New?: ModuleLicense;
    /**
     *
     */
    Current?: ModuleLicense;
    /**
     *
     */
    NumberOfLicensesInUse?: number;
    /**
     *
     */
    NumberOfLicensesFree?: number;
    /**
     *
     */
    NumberOfLicensesAdded?: number;
    /**
     *
     */
    NumberOfLicensesNewTotal?: number;
    /**
     *
     */
    NumberOfLicensesNewFree?: number;
    /**
     *
     */
    NumberOfLicensesTotal?: number;
}
/**
 * License information, hashed and signed with public keys to prevent tampering. Counts License usage and assignments.
 */
export interface License extends Carrier {
}
/**
 * Get all licenses, with usage, from all module owners as they are stored in the database
 * Returns ExtendedLicenseInfo[]
 */
export interface License_GetLicenseForAllOwnersFromDBRequest {
}
/**
 *
 * Returns ExtendedLicenseInfo
 */
export interface License_GetLicenseFromLicenseServerRequest {
    /**
     *
     */
    OwnerName: string;
}
/**
 * Get details about a license from the license server.
 * Returns string
 */
export interface License_GetModuleLicenseHistoryFromLicenseServerRequest {
    /**
     * Description of the license
     */
    LicenseInfo: ExtendedLicenseInfo;
    /**
     * Information about a particular module to get information for.
     */
    ModuleLicense: ExtendedModuleLicense;
}
/**
 * Validate that a license is consistant.
 * Returns LicenseResult
 */
export interface License_ValidateLicenseInfoRequest {
    /**
     * License to validate consistancy for
     */
    LicenseInfo: ExtendedLicenseInfo;
}
/**
 * Save a new license to the database.
 * Returns LicenseResult
 */
export interface License_ActivateLicenseInfoRequest {
    /**
     * New license to save to the database.
     */
    NewLicense: ExtendedLicenseInfo;
}
/**
 * Get License from the license server for a particular module owner.
 * Returns CheckLicenseStatusResult
 */
export interface License_GetLicenseStatusFromLicenseServerRequest {
    /**
     * Name of the module owner to get license from.
     */
    OwnerName: string;
}
/**
 * Get license, with usage, as it is stored in the database for one particular module owner.
 * Returns ExtendedLicenseInfo
 */
export interface License_GetLicenseFromDBRequest {
    /**
     * Name of the module owner.
     */
    OwnerName: string;
}
/**
 * Change the new serial number for the installation. Requests a new license from SuperLicense, checks if change is authorized.
 * Returns LicenseResult
 */
export interface License_ChangeSerialNumberRequest {
    /**
     * The new company name
     */
    NewCompanyName: string;
    /**
     * New serial number to change to.
     */
    NewSerialNumber: string;
}
/**
 * Obtain information about associate module licenses
 * Returns LicenseOwner[]
 */
export interface License_GetUserLicensesRequest {
    /**
     * Associate id to check for associate module licenses
     */
    AssociateId: number;
}
/**
 * Obtain information about satellite module licenses
 * Returns LicenseOwner[]
 */
export interface License_GetSatelliteLicensesRequest {
    /**
     * Satellite id to check for satellite module licenses
     */
    SatelliteId: number;
}
/**
 * Remove the license from a particular module owner from the database.  It is not permitted to remove licenses from SuperOffice
 * Returns LicenseResult
 */
export interface License_RemoveLicenseFromDBRequest {
    /**
     * Name of the module owner to remove license from.
     */
    ModuleOwner: string;
}
/**
 * Load a new license from file
 * Returns ExtendedLicenseInfo
 */
export interface License_GetLicenseFromFileRequest {
    /**
     * Content of the license file as read.
     */
    FileContent: string;
}
/**
 * Get the shop URL for the specified module owner. This can be used to redirect user to the web shop.
 * Returns string
 */
export interface License_GetShopUrlRequest {
    /**
     * Name of the module owner.
     */
    OwnerName: string;
}
/**
 * Get all licenses in a MDOListItem structure.
 * Returns SelectableMDOListItem[]
 */
export interface License_GetUserLicensesMDOListRequest {
}
/**
 * Get license information for one particular license module.
 * Returns ModuleLicense
 */
export interface License_GetModuleLicenseFromDBRequest {
    /**
     * Name of the module owner.
     */
    OwnerName: string;
    /**
     * Name of the license module.
     */
    ModuleName: string;
}
/**
 * Load and activate a new license from file/string if the new license is valid.
 * Returns ExtendedLicenseInfo
 */
export interface License_AddLicenseFromFileRequest {
    /**
     * Content of the license file as XML.
     */
    FileContent: string;
}
/**
 * Get license assignments for an associate for licenses belonging to an other module owner than SuperOffice
 * Returns ModuleLicenseLink[]
 */
export interface License_GetThirdPartyLicenseAssignmentsRequest {
    /**
     * User to get third party license assignments for
     */
    AssociateId: number;
    /**
     * Name of the module owner to get license assignments for
     */
    ModuleOwner: string;
}
/**
 * Assign third party licenses
 * Returns ModuleLicenseLink[]
 */
export interface License_AssignThirdPartyLicensesRequest {
    /**
     * User to assign third party licenses for
     */
    AssociateId: number;
    /**
     * Name of the module owner to assign license for
     */
    ModuleOwner: string;
    /**
     * Name of module licenses to assign
     */
    ModuleLicenseNames: string[];
}
/**
 * Unassign (remove) third party licenses
 * Returns ModuleLicenseLink[]
 */
export interface License_UnassignThirdPartyLicensesRequest {
    /**
     * User to unassign third party licenses for
     */
    AssociateId: number;
    /**
     * Name of the module owner to unassign license for
     */
    ModuleOwner: string;
    /**
     * Name of module licenses to unassign (remove)
     */
    ModuleLicenseNames: string[];
}
/**
 * Represents all licenses for this owner at this site.
 */
export interface LicenseInfo {
    /**
     * Name of the database owner company.
     */
    CompanyName?: string;
    /**
     * Serial number. e.g.: 1010000014.
     */
    SerialNr?: string;
    /**
     * The name of the module owner, not visible in GUI but used in the code. OwnerName SUPEROFFICE is reserved and may NEVER be used by partners. This must be in UPPER CASE and only contain A-Z and 0-9. NO EXTENDED CHARACTERS please.
     */
    OwnerName?: string;
    /**
     * Human-readable description of owner, shown in GUI, default language. Additional languages can be added to LocaleText, resource type 26
     */
    OwnerDescription?: string;
    /**
     * When should the system next check with the license issuer
     */
    NextCheckDate?: Date;
    /**
     * Expiration date for maintenance. After this date, upgrades should refuse to install.
     */
    MaintenanceDate?: Date;
    /**
     * When should nagging begin (for instance, during login to SoAdmin)
     */
    AdminWarningDate?: Date;
    /**
     * Expiration date, 0 = forever
     */
    ExpiryDate?: Date;
    /**
     * Real expiration date, when the given module actually stops working. Modules that normally update data should switch to read-only mode. Modules that only read anyway, should disable themselves in some other way
     */
    GraceDate?: Date;
    /**
     * Unspecified extra flags of license, part of checksum
     */
    ExtraFlags?: number;
    /**
     * The url that will provide keycodes for all modules owned by this owner
     */
    LicenseUrl?: string;
    /**
     * The url that will provide keycodes for all modules owned by this owner
     */
    LicenseVersion?: string;
    /**
     * Type of deployment
     */
    DeploymentType?: number;
    /**
     * Type of product
     */
    ProductType?: string;
    /**
     * Description of type of product
     */
    ProductDescription?: string;
    /**
     * The module licenses.
     */
    ModuleLicenses?: ModuleLicense[];
    /**
     * The public key used to verify licenses owned by this owner.
     */
    PublicKey?: SignedPublicKey;
    /**
     * Signature of all non-zero-amount moduleLicense rows referring to this owner
     */
    Signature?: string;
}
/**
 *
 */
export interface LicenseOwner extends Carrier {
    /**
     * The name of the license owner
     */
    Name?: string;
    /**
     *
     */
    Description?: string;
    /**
     *
     */
    RestrictedModuleLicenses?: ModuleLicenseLink[];
    /**
     * The unrestricted module licenses that this license owner
     */
    UnrestrictedModuleLicenses?: ModuleLicenseLink[];
}
/**
 *
 */
export interface LicenseResult extends Carrier {
    /**
     *
     */
    Succeeded?: boolean;
    /**
     *
     */
    Reason?: string;
}
/**
 * Represents a single module license info.
 */
export interface ModuleLicense {
    /**
     * The name of the module owner, not visible in GUI but used in the code. OwnerName SUPEROFFICE is reserved and may NEVER be used by partners. This must be in UPPER CASE and only contain A-Z and 0-9. NO EXTENDED CHARACTERS please.
     */
    OwnerName?: string;
    /**
     * The name of the module, not visible in GUI but used in the code. This must be in UPPER CASE and only contain A-Z and 0-9. NO EXTENDED CHARACTERS please.
     */
    ModuleName?: string;
    /**
     * Human-readable description of module, shown in GUI, default language. Additional languages can be added to LocaleText, resource type 25
     */
    ModuleDescription?: string;
    /**
     * Tooltip text, anything you want; shown when the cursor hovers over the line in the GUI. Default language. Additional languages can be added to LocaleText, resource type 27
     */
    ModuleTooltip?: string;
    /**
     * Version string for this module
     */
    ModuleVersion?: string;
    /**
     * Entire system, per database, or per associate
     */
    LicenseType?: enums.LicenseType;
    /**
     * If true, then there is no licenseNumber limit on how many of these modules may be assigned
     */
    Unrestricted?: boolean;
    /**
     * Allowed associate type for user licenses: internal(0), external(4).
     */
    AllowedUserType?: enums.UserType;
    /**
     * Number of licenses purchased.
     */
    NumberOfLicenses?: number;
    /**
     * Unspecified extra flags of license, part of checksum. Value=1 means this a 'user plan'; such licenses cause the admin gui to switch to radiobutton view
     */
    ExtraFlags?: number;
    /**
     * Free field, can be used by the module owner (example: host domain, for eJournal). NOTE: For rows with extraFlags=1 this field contains the list of modules that this plan comprises
     */
    ExtraInfo?: string;
    /**
     * Ordering value - generated by SuperLicense and transferred here. Must be followed for signatures to be correct
     */
    SortOrder?: number;
    /**
     * If true, then this module should not appear in GUI and is not assignable by users
     */
    IsHidden?: boolean;
    /**
     * If set, specifies a module license needed before this license can be granted
     */
    PrerequisiteModuleName?: string;
    /**
     * Signature that verifies that this row is correctly transferred from SuperLicense
     */
    Signature?: string;
}
/**
 * License assignments carrier
 */
export interface ModuleLicenseLink extends Carrier {
    /**
     * Is this module license restricted or unrestricted
     */
    Unrestricted?: boolean;
    /**
     * The total number of module licenses. In other words the number of free license added to the number of licenses in use equals the total number of licenses
     */
    Total?: number;
    /**
     * The tooltip to be shown in some gui with details on the module license
     */
    Tooltip?: string;
    /**
     * Can a specific user assign this module license
     */
    CanAssign?: boolean;
    /**
     * The number of licenses that are free to be assigned
     */
    Free?: number;
    /**
     * The total number of licenses (of a given license module) that are occupied
     */
    InUse?: number;
    /**
     * Is hidden from UI
     */
    IsHidden?: boolean;
    /**
     * Is the module license assigned to a given user?
     */
    Assigned?: boolean;
    /**
     * The identifier of the module license
     */
    ModuleLicenseId?: number;
    /**
     * The name of the module license
     */
    Name?: string;
    /**
     * The description of the module license
     */
    Description?: string;
    /**
     * Name of module that must be active for this license to be used.
     */
    PrerequisiteModuleName?: string;
    /**
     * Sort order of licenses.
     */
    SortOrder?: number;
    /**
     * License flags. 1 = user plan
     */
    ExtraFlags?: number;
}
/**
 * Represents all licenses for this owner at this site.
 */
export interface SignedPublicKey {
    /**
     * The name of the module owner, not visible in GUI but used in the code. OwnerName SUPEROFFICE is reserved and may NEVER be used by partners. This must be in UPPER CASE and only contain A-Z and 0-9. NO EXTENDED CHARACTERS please.
     */
    OwnerName?: string;
    /**
     * Date when the the public key was signed. No Timezone.
     */
    SignDate?: Date;
    /**
     * Date when the signature expires. No Timezone.
     */
    ExpiryDate?: Date;
    /**
     * Public key held by module owner.
     */
    Key?: DSAParameters;
    /**
     * Signature - Base64 encoded value
     */
    Signature?: string;
}
/**
 * Access gateway related data and operations
 */
export interface AccessGatewayInfo extends Carrier {
    /**
     * This is the registered client_id for AccessGateway OIDC
     */
    ClientId?: string;
    /**
     * This is the registered redirect_uri for AccessGateway OIDC.
     */
    RedirectUri?: string;
}
/**
 * Returns accessgateway registration info
 * Returns AccessGatewayInfo
 */
export interface User_GetAccessGatewayInfoRequest {
}
/**
 * Returns accessgateway registration info and registers a new or adds the url if necessary
 * Returns AccessGatewayInfo
 */
export interface User_GetOrRegisterAccessGatewayInfoRequest {
    /**
     * This is the registered redirect_uri for AccessGateway OIDC.
     */
    RedirectUri: string;
}
/**
 * Registers with access gateway if not already done, otherwise will attempt to update
 * Returns AccessGatewayInfo
 */
export interface User_RegisterWithAccessGatewayRequest {
    /**
     * This is the registered redirect_uri for AccessGateway OIDC.
     */
    RedirectUri: string;
}
/**
 * Checks if AccessGatewayRegistration is valid
 * Returns boolean
 */
export interface User_CheckAccessGatewayRegistrationRequest {
}
/**
 * Credentials supported for authentication
 */
export interface Credential extends Carrier {
    /**
     * Description of credential type
     */
    Type?: CredentialType;
    /**
     * This is the actuall value of the credentials.  This will typically be the password or teh users SID in active directory
     */
    Value?: string;
    /**
     * The value displayed to the user. this will typically be the users login name in active directory.
     */
    DisplayValue?: string;
}
/**
 * Save (adds/replaces) current credential of the same type for the user.
 * Returns boolean
 */
export interface User_SaveCredentialRequest {
    /**
     * Primary key of the user (i.e. associate)
     */
    UserId: number;
    /**
     * Credentials supported for authentication
     */
    Credential: Credential;
}
/**
 * Remove credential of a specific type for a user
 * Returns boolean
 */
export interface User_DeleteCredentialRequest {
    /**
     * Primary key of the user (i.e. associate)
     */
    UserId: number;
    /**
     * Type of credentials, corresponding to name of plugin and type in the credentials table
     */
    CredentialType: string;
}
/**
 * Get user groups holding users filtered by the searchString.  This method is only relevant if the CredentialType control is of type link.  There will allways be at least one groups even if the underlying provider does not support groups.
 * Returns CredentialsGroup[]
 */
export interface User_FindCredentialsGroupsRequest {
    /**
     * Type of credentials, corresponding to name of plugin and type in the credentials table.
     */
    Type: string;
    /**
     * Partly name of domain group.
     */
    SearchString: string;
}
/**
 * Find users matching the partial name.
 * Returns CredentialsGroupUsers
 */
export interface User_FindCredentialUsersRequest {
    /**
     * Type of credentials, corresponding to name of plugin and type in the credentials table.
     */
    Type: string;
    /**
     * Partly name of the user group
     */
    SearchString: string;
}
/**
 * Get credential users within a user group
 * Returns CredentialsGroupUsers
 */
export interface User_GetCredentialUsersInGroupRequest {
    /**
     * Type of credentials, corresponding to name of plugin and type in the credentials table.
     */
    Type: string;
    /**
     * Name of user group needed to discover the users.
     */
    GroupName: string;
}
/**
 * When the CredentialType's control is of type link, the user is selected from a source like active directory.  This will then be the organisational unit (e.g. user security group) in active directory.  Only one group is listed if the system does not support groups.
 */
export interface CredentialsGroup extends Carrier {
    /**
     * This is the full name of the group as needed to discover the users within the group.  this value should not be displayed to the end user.
     */
    Name?: string;
    /**
     * The display name of the group to display to the user.
     */
    DisplayName?: string;
}
/**
 * This is the users within a user group.
 */
export interface CredentialsGroupUsers extends Carrier {
    /**
     * Headings in which to list the different users.
     */
    Headings?: string[];
    /**
     * The list of actual users that can be selected
     */
    Users?: CredentialUser[];
}
/**
 * Description of credential type
 */
export interface CredentialType extends Carrier {
    /**
     * The name of the credentials to be displayed in the user interface.  This will typically be Password for user-name/password scenarios and Active Directoru User for AD integration.
     */
    DisplayType?: string;
    /**
     * Type of credentials, corresponding to name of plugin and type in the credentials table
     */
    Type?: string;
    /**
     * Description of the authentication type.  This value is used in a list of authentication providers that can be choosen by an end user and should be a fairly describtive text.  This will typically be SuperOffice is responsible for username and password for a password scenario.
     */
    Description?: string;
    /**
     * Type of control used to display the value.
     */
    ValueControl?: enums.CredentialControlType;
    /**
     *
     */
    CanCreatePerson?: boolean;
    /**
     *
     */
    IsUserNameSupported?: boolean;
}
/**
 * Information about a users credentials in a foregin system that can be bound to a SuperOffice user (i.e. associate)
 */
export interface CredentialUser extends Carrier {
    /**
     * Identification of user in the foreign system.  This value needs to be applied to the Credential.Value field
     */
    Value?: string;
    /**
     * Display value of the user.  This value needs to be applied to the Credential.DisplayValue field.
     */
    DisplayValue?: string;
    /**
     * Columns, matching CredentialUsers.Headings
     */
    Columns?: string[];
    /**
     *
     */
    CanCreatePerson?: boolean;
}
/**
 *
 */
export interface DataRight extends Carrier {
    /**
     *
     */
    Value?: string;
    /**
     *
     */
    Description?: string;
}
/**
 *
 */
export interface DataRights extends Carrier {
    /**
     *
     */
    ColumnsInfo?: RelationToOwner[];
    /**
     *
     */
    RowsInfo?: EntityName[];
    /**
     *
     */
    Rights?: DataRight[][];
}
/**
 *
 */
export interface EntityName extends Carrier {
    /**
     * The name of the table in the database
     */
    TableName?: string;
    /**
     * Name to be used in GUI, preferable a resource string
     */
    TableDescription?: string;
}
/**
 *
 */
export interface RelationToOwner extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 * The User Service. The service implements all services working with the User object.
 */
export interface ResolvedUser extends Carrier {
    /**
     * The resolved User instance.
     */
    User?: User;
    /**
     * Indicates if the resolved person was created or not.
     */
    PersonCreated?: boolean;
}
/**
 * Users role for role-based security
 */
export interface Role extends Carrier {
    /**
     * The list item Id
     */
    Id: number;
    /**
     * The list item Value
     */
    Value?: string;
    /**
     * The list item Tooltip
     */
    Tooltip?: string;
}
/**
 *
 */
export interface RoleEntity extends Carrier {
    /**
     * Primary key
     */
    RoleId?: number;
    /**
     * Visible role name
     */
    Name?: string;
    /**
     * Description of the role.
     */
    Tooltip?: string;
    /**
     * The role type. Note that changing this field has no effect, so treat this as a read-only field.
     */
    RoleType?: enums.RoleType;
    /**
     * 1 if role has been deleted (we do not actually delete)
     */
    Deleted?: number;
    /**
     * Sorting rank of this role in lists
     */
    Rank?: number;
    /**
     * Registered when
     */
    Created?: Date;
    /**
     * Apply role category membership to users
     */
    UseCategories?: number;
    /**
     * Created by user
     */
    CreatedBy?: Associate;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Last updated by user
     */
    UpdatedBy?: Associate;
    /**
     * Data rights matrix - defines role's access to data owned by current user, users in same group, and other users.
     */
    DataRights?: DataRights;
}
/**
 * Delete the specified role and move all users associated with the role to the replacingRoleId
 */
export interface User_DeleteRoleRequest {
    /**
     * The roleId to delete
     */
    RoleIdToDelete: number;
    /**
     * The roleId which all associated users will be moved to.
     */
    ReplacingRoleId: number;
}
/**
 * Get a list of all roles for the given type of role. MDO List name = 'Roles', extra='0' (roleType)
 * Returns SelectableMDOListItem[]
 */
export interface User_GetAllRolesRequest {
    /**
     * Type of role (Employee/External/Anonymous/System)
     */
    RoleType: enums.RoleType;
}
/**
 * Get a list of all functional rights for the given type of role. MDO List name = 'FunctionRights', extra='roleType=0'
 * Returns SelectableMDOListItem[]
 */
export interface User_GetAllFunctionalRightsRequest {
    /**
     * Type of role (Employee/External/Anonymous/System)
     */
    RoleType: enums.RoleType;
}
/**
 * Get all functional rights for the given role. Functional rights not set on the role are not included. MDO List name = 'FunctionRights', extra='role=123'
 * Returns SelectableMDOListItem[]
 */
export interface User_GetFunctionalRightsRequest {
    /**
     * The role id to get the functional rights for.
     */
    RoleId: number;
}
/**
 * Set all functional rights for the given role. Functional rights not specified here will be removed from the role.
 */
export interface User_SetFunctionalRightsRequest {
    /**
     * The role id to set the functional rights for
     */
    RoleId: number;
    /**
     * An array of functional rights ids to set for this role. Rights not included here are removed from the role.
     */
    FunctionalRightIds: number[];
}
/**
 * Set one specific data right at the given position. An exception will be thrown if non existing position is specified.
 */
export interface User_SetDataRightRequest {
    /**
     * The role id to set the data right for
     */
    RoleId: number;
    /**
     * The name of the entity/table
     */
    TableName: string;
    /**
     * The id of the relation to owner
     */
    RelationToOwner: enums.RoleRelationToOwner;
    /**
     * The data right value to set at the specified position (CRUD)
     */
    DataRightValue: string;
}
/**
 * Read one specific data right at the given position. An exception will be thrown if non existing position is specified.
 * Returns string
 */
export interface User_GetDataRightRequest {
    /**
     * The role id to set the data right for
     */
    RoleId: number;
    /**
     * The name of the entity/table
     */
    TableName: string;
    /**
     * The id of the relation to owner
     */
    RelationToOwner: enums.RoleRelationToOwner;
}
/**
 * Read specific a set of data rights at the given row in the rights matrix. An exception will be thrown if non existing position is specified.
 * Returns StringDictionary
 */
export interface User_GetDataRightsRequest {
    /**
     * The role id to set the data right for
     */
    RoleId: number;
    /**
     * The name of the entity/table
     */
    TableName: string;
}
/**
 * Create a new role entity of the specified role type. The role type cannot be changed after the entity is created.
 * Returns RoleEntity
 */
export interface User_CreateDefaultRoleEntityFromTypeRequest {
    /**
     * Type of role (Employee/External/Anonymous/System)
     */
    Type: enums.RoleType;
}
/**
 * Find all roles with a given functional right. The roles matched must contain the specified functional right.
 * Returns MDOListItem[]
 */
export interface User_FindRolesWithFunctionalRightRequest {
    /**
     * Functional right name to search for
     */
    FunctionalRightName: string;
}
/**
 * Find all roles with a given set of functional rights. The roles matched must contain one or more of the specified functional rights.
 * Returns number[]
 */
export interface User_FindRolesWithFunctionalRightsRequest {
    /**
     * An array of functional rights names to search for
     */
    FunctionalRightNames: string[];
}
/**
 * Find all roles without a given set of functional rights. The roles matched must not contain any of the specified functional rights.
 * Returns number[]
 */
export interface User_FindRolesWithoutFunctionalRightsRequest {
    /**
     * An array of functional rights names to search for
     */
    FunctionalRightNames: string[];
}
/**
 * Properties for service authentication
 */
export interface ServiceAuth extends Carrier {
    /**
     * The primary key
     */
    ServiceAuthId?: number;
    /**
     * The mail server
     */
    Server?: string;
    /**
     * The server port
     */
    Port?: number;
    /**
     * The type of authentication, plain-text, OAuth...
     */
    AuthType?: string;
    /**
     * The username
     */
    Username?: string;
    /**
     * The (decrypted) password or token
     */
    Password?: string;
}
/**
 * Token information
 */
export interface TokenManagementInfo extends Carrier {
    /**
     * The provider these tokens belong to
     */
    Provider?: string;
    /**
     * Access token
     */
    AccessToken?: string;
    /**
     * Refresh token
     */
    RefreshToken?: string;
}
/**
 * Saves the external tokens to the DB and returns a key that can be used to retrieve them
 * Returns string
 */
export interface User_SaveExternalTokensRequest {
    /**
     * Token information.
     */
    TokenManagementInfo: TokenManagementInfo;
}
/**
 * First asks AccessGateway to decrypt the tokens, then saves the external tokens to the DB and returns a key that can be used to retrieve them
 * Returns string
 */
export interface User_DecryptAndSaveExternalTokensRequest {
    /**
     * Token information.
     */
    TokenManagementInfo: TokenManagementInfo;
}
/**
 * Retrieve the tokens from the DB based on the given key
 * Returns TokenManagementInfo
 */
export interface User_GetExternalTokensRequest {
    /**
     * Token retrievel key
     */
    Key: string;
}
/**
 * Credentials for external authentication.
 */
export interface UntrustedCredentials extends Carrier {
    /**
     * Credentials are valid from this date.
     */
    ValidFrom?: Date;
    /**
     * Credentials are valid to this date.
     */
    ValidTo?: Date;
    /**
     * Description of credentials. Max 255 characters.
     */
    Comment?: string;
    /**
     * Data stored encrypted in the db. Typically a password. Max 70 characters.
     */
    SecretValue?: string;
    /**
     * Data stored unencrypted in the db.  Typically server and or username. Max 238 characters.
     */
    PublicValue?: string;
    /**
     * Is this credentials currently active.
     */
    IsActive?: boolean;
}
/**
 * SuperOffice User, with login credentials and an associated person.
 */
export interface User extends Carrier {
    /**
     * Primary key
     */
    AssociateId?: number;
    /**
     * Initials, UserId - also used as login name for on-site installations. Identifies user in archives.
     */
    Name?: string;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * The restricted and unrestricted module licenses grouped by license owner. These module licenses are either assigned or unassigned to this user
     */
    LicenseOwners?: LicenseOwner[];
    /**
     * Users role for role-based security. Determines permissions and access rights for the user.
     */
    Role?: Role;
    /**
     * The main user group that this user belongs to.
     * Use MDO List name "usergroup" to get list items.
     */
    UserGroup?: UserGroup;
    /**
     * The other groups this user is a member of, apart from the main user group.
     * Use MDO List name "usergroup" to get list items.
     */
    OtherGroups?: UserGroup[];
    /**
     * The person associated with this user. Detailed information about the user
     * Use MDO List name "person_new" to get list items.
     */
    Person?: Person;
    /**
     * If true, the user is retired and should have no rights, not appear in lists, etc.
     */
    Deleted?: boolean;
    /**
     * Last login date
     */
    Lastlogin?: Date;
    /**
     * Last logout date
     */
    Lastlogout?: Date;
    /**
     * ID of the ej user record corresponding to this associate; 0 for associates that are not ej users
     */
    EjUserId?: number;
    /**
     * ej users request signature
     */
    RequestSignature?: string;
    /**
     * User type: 1=InternalAssociate, 2=ResourceAssociate, 3=ExternalAssociate, 4=AnonymousAssociate, 5=SystemAssociate
     */
    Type?: enums.UserType;
    /**
     * True if the user is retired and should have no rights, not appear in lists, etc.
     */
    IsPersonRetired?: boolean;
    /**
     * True if the user is on travel.
     */
    IsOnTravel?: boolean;
    /**
     * List of credentials registered for this user. i.e. valid authentication methods.
     */
    Credentials?: Credential[];
    /**
     * User name, a.k.a. Login name. This might be an e-mail address.
     */
    UserName?: string;
    /**
     * Request Ticket Categories assigned to the user.
     * Use MDO List name "ejCategory" to get list items.
     */
    TicketCategories?: MDOListItem[];
    /**
     * The unique nick name for this user. Used in Service as an alias, similar to Name/Initials.
     */
    NickName?: string;
    /**
     * The user is waiting for an administrator to approve/grant her/him access.
     */
    WaitingForApproval?: boolean;
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
    /**
     * Post custom commands the client should execute after save has completed.
     */
    PostSaveCommands?: CustomCommand[];
}
/***
 * Get registered custom commands for a User entity.
 */
export interface GetUserCommandsRequest {
    /**
     * The User to get custom commands for.
     */
    User: User;
}
/**
  * Executes the custom command for User: Command name, Action result, User entity.
  */
export interface ExecuteUserCommandRequest {
    /**
     * The name of the command to execute.
     */
    CommandName: string;
    /**
     * Result of an UI operation (Implicit,Yes,Ok,No,Cancel). Input to the command.
     */
    ActionResult?: enums.CommandActionResult;
    /**
     * The User to execute the command on.
     */
    User?: User;
}
/**
 * Get a user, with lookup based on user name.
 * Returns User
 */
export interface User_GetUserFromNameRequest {
    /**
     * User name of the user to get.
     */
    UserName: string;
}
/**
 * Save a user, with lookup based on the user name.
 * Returns User
 */
export interface User_SaveUserFromNameRequest {
    /**
     * User name of the user to get.
     */
    UserName: string;
    /**
     * User object to save.
     */
    User: User;
}
/**
 * Delete a user, with lookup based on the user name.
 */
export interface User_DeleteUserFromNameRequest {
    /**
     * User name of the user to delete.
     */
    UserName: string;
}
/**
 * Get available credential types that can be used for authentication
 * Returns CredentialType[]
 */
export interface User_GetCredentialTypesRequest {
}
/**
 * Get available credential types that can be used for the specified user type.
 * Returns CredentialType[]
 */
export interface User_GetCredentialTypesForUserTypeRequest {
    /**
     * The user type to retrieve credential types for
     */
    UserType: enums.UserType;
}
/**
 * Save credentials for authenticated user.
 */
export interface User_SaveUntrustedCredentialsRequest {
    /**
     * Type of credential(Ex: "imap", "smtp")
     */
    Type: string;
    /**
     * Credentials to save.
     */
    Credentials: UntrustedCredentials;
}
/**
 * Get a set of credentials of a specified type for authenticated user.
 * Returns UntrustedCredentials[]
 */
export interface User_GetUntrustedCredentialsRequest {
    /**
     * Type of credential(Ex: "imap", "smtp").
     */
    Type: string;
}
/**
 * Get a set of credentials of a specified type for a specified user. SecretValue is only populated for authenticated user, and system users.
 * Returns UntrustedCredentials[]
 */
export interface User_GetUntrustedCredentialsForAssociateRequest {
    /**
     * Id of user to retrieve credentials for.
     */
    AssociateId: number;
    /**
     * Type of credential(Ex: "imap", "smtp").
     */
    Type: string;
}
/**
 * Save credentials for a specified user.
 */
export interface User_SaveUntrustedCredentialsForAssociateRequest {
    /**
     * Id of user to save credentials for.
     */
    AssociateId: number;
    /**
     * Type of credential(Ex: "imap", "smtp")
     */
    Type: string;
    /**
     * Credentials to save.
     */
    Credentials: UntrustedCredentials;
}
/**
 * Remove a credentials entry for authenticated user.
 */
export interface User_RemoveUntrustedCredentialsRequest {
    /**
     * Type of credential(Ex: "imap", "smtp")
     */
    Type: string;
    /**
     * PublicValue field of credentials to remove.
     */
    PublicValue: string;
}
/**
 * Remove a credentials entry for a specified user.
 */
export interface User_RemoveUntrustedCredentialsForAssociateRequest {
    /**
     * Id of user to remove credentials for.
     */
    AssociateId: number;
    /**
     * Type of credential(Ex: "imap", "smtp")
     */
    Type: string;
    /**
     * PublicValue field of credentials to remove.
     */
    PublicValue: string;
}
/**
 * Creates an associate of type external user.
 * Returns number
 */
export interface User_CreateExternalUserRequest {
    /**
     * The personId to create an external user for.
     */
    PersonId: number;
    /**
     * Login username.
     */
    UserName: string;
    /**
     * Login password.
     */
    Password: string;
    /**
     * Id of role for the external user. The role must be a role of type external users.
     */
    RoleId: number;
    /**
     * Set isActive to true to enable the external user to log in.
     */
    IsActive: boolean;
}
/**
 * Deletes an associate of type external user.
 */
export interface User_DeleteExternalUserRequest {
    /**
     * The associateId to delete the associate entry for.
     */
    AssociateId: number;
}
/**
 * Modifies an external user. Changes external users information according to the flags set in  externalUserInfoModification.
 */
export interface User_SetExternalUserInfoRequest {
    /**
     * The associateId to alter.
     */
    AssociateId: number;
    /**
     * Login username.
     */
    UserName: string;
    /**
     * Login password.
     */
    Password: string;
    /**
     * Set isActive to true to enable the external user to log in.
     */
    IsActive: boolean;
    /**
     * Id of role for the external user. The role must be a role of type external users.
     */
    RoleId: number;
    /**
     * externalUserInfoModification is a flag describing what to change. <see cref="SuperOffice.CRM.Services.Util.ExternalUserInfoModification"/>.
     */
    ExternalUserInfoModification: enums.ExternalUserInfoModification;
}
/**
 * Generates a new password for an external user.
 * Returns string
 */
export interface User_GenerateNewPasswordForExternalUserRequest {
    /**
     * The name of the associate to change the password for.
     */
    AssociateName: string;
}
/**
 * Check if the current assoicate can change the password for an associate
 * Returns boolean
 */
export interface User_CanChangePasswordRequest {
    /**
     * AssociateId of the user to check if password can be changed
     */
    AssociateId: number;
}
/**
 * Get the different methods the user can use to change password
 * Returns ChangePasswordType[]
 */
export interface User_GetSupportedChangePasswordTypesRequest {
    /**
     * AssociateId of the user to check if password can be changed
     */
    AssociateId: number;
}
/**
 * Change password for a user.
 * Returns boolean
 */
export interface User_ChangePasswordRequest {
    /**
     * AssociateId of the user to change password for.
     */
    AssociateId: number;
    /**
     * The current password of the user.  Administrators can leave this blank to force a new password upon a user.
     */
    OldPassword: string;
    /**
     * The new password for the user
     */
    NewPassword: string;
}
/**
 * Send a change password email to this users registered address.
 * Returns OperationResult
 */
export interface User_SendChangePasswordEMailRequest {
    /**
     * AssociateId of the user to change password for.
     */
    AssociateId: number;
}
/**
 * Returns the user associated with the supplied person id
 * Returns User[]
 */
export interface User_GetUserFromPersonIdRequest {
    /**
     *
     */
    PersonId: number;
}
/**
 * Create default User providing the associate type and person id.  System and Anonymous users can be created without an exsisting person and permits person id to be 0.
 * Returns User
 */
export interface User_CreateDefaultUserFromUserTypeAndPersonIdRequest {
    /**
     * Type of associate for the user
     */
    UserType: enums.UserType;
    /**
     * Primary key of the person to become a user.
     */
    PersonId: number;
}
/**
 * Create default User providing the user type.  Only System and Anonymous users can be created without an exsisting person.  Use CreateDefaultUserFromUserTypeAndPersonId to create internal (i.e. Employee) or external users.
 * Returns User
 */
export interface User_CreateDefaultUserFromUserTypeRequest {
    /**
     * Type of associate for the user.  This can only be System or Anonymous. Use CreateDefaultUserFromUserTypeAndPersonId to create internal (i.e. Employee) or external users.
     */
    UserType: enums.UserType;
}
/**
 * Get user from ejUserId - used for eJournal Legacy Support.
 * Returns User[]
 */
export interface User_GetUserFromEjUserIdRequest {
    /**
     * ejUserId -
     */
    EjUserId: number;
}
/**
 * Change password for a user.
 * Returns boolean
 */
export interface User_SetPasswordFromNameRequest {
    /**
     * Username to set password for
     */
    AssociateName: string;
    /**
     * New password
     */
    Password: string;
}
/**
 * Change password for a user.
 * Returns boolean
 */
export interface User_SetPasswordRequest {
    /**
     * Id of User to set password for
     */
    AssociateId: number;
    /**
     * New password
     */
    Password: string;
}
/**
 * Change password for a user.
 * Returns boolean
 */
export interface User_ChangeOwnPasswordRequest {
    /**
     * The current password of the user.  Administrators can leave this blank to force a new password upon a user.
     */
    OldPassword: string;
    /**
     * The new password for the user
     */
    NewPassword: string;
}
/**
 * Change password for a user.
 * Returns boolean
 */
export interface User_ChangePasswordFromNameRequest {
    /**
     * Username of the user to change password for.
     */
    AssociateName: string;
    /**
     * The current password of the user.  Administrators can leave this blank to force a new password upon a user.
     */
    OldPassword: string;
    /**
     * The new password for the user
     */
    NewPassword: string;
}
/**
 *
 * Returns boolean
 */
export interface User_IsUserNameValidRequest {
    /**
     *
     */
    AssociateId: number;
    /**
     *
     */
    Type: enums.UserType;
    /**
     *
     */
    PersonId: number;
    /**
     *
     */
    UserName: string;
}
/**
 *
 * Returns boolean
 */
export interface User_IsPasswordValidRequest {
    /**
     *
     */
    AssociateId: number;
    /**
     *
     */
    Type: enums.UserType;
    /**
     *
     */
    PersonId: number;
    /**
     *
     */
    Password: string;
}
/**
 *
 * Returns string
 */
export interface User_SetGeneratedPasswordRequest {
    /**
     *
     */
    AssociateId: number;
}
/**
 *
 * Returns string
 */
export interface User_SetGeneratedPasswordFromNameRequest {
    /**
     *
     */
    AssociateName: string;
}
/**
 *
 * Returns UserValidationResult
 */
export interface User_IsPasswordValidWithReasonRequest {
    /**
     *
     */
    AssociateId: number;
    /**
     *
     */
    Type: enums.UserType;
    /**
     *
     */
    PersonId: number;
    /**
     *
     */
    Password: string;
}
/**
 *
 * Returns UserValidationResult
 */
export interface User_IsUserNameValidWithReasonRequest {
    /**
     *
     */
    AssociateId: number;
    /**
     *
     */
    Type: enums.UserType;
    /**
     *
     */
    PersonId: number;
    /**
     *
     */
    UserName: string;
}
/**
 * Get a user from the user name.
 * Returns User
 */
export interface User_ChangeUserTypeRequest {
    /**
     * User name of the user to get.
     */
    User: User;
    /**
     *
     */
    UserType: enums.UserType;
}
/**
 * Creates a PersonEntity with default values based on the contactId and credentials.
 * Returns User
 */
export interface User_CreateDefaultUserFromUserTypeAndCredentialRequest {
    /**
     * Type of associate for the user
     */
    UserType: enums.UserType;
    /**
     * Contact id of the person
     */
    ContactId: number;
    /**
     * Type of credentials, corresponding to name of plugin and type in the credentials table.
     */
    CredentialType: string;
    /**
     * This is the actuall value of the credentials.  This will typically be the password or teh users SID in active directory
     */
    CredentialValue: string;
    /**
     * The value displayed to the user. this will typically be the users login name in active directory.
     */
    CredentialDisplayValue: string;
}
/**
 *
 * Returns string
 */
export interface User_GetValidUserNameRequest {
    /**
     *
     */
    AssociateId: number;
    /**
     *
     */
    Type: enums.UserType;
    /**
     *
     */
    PersonId: number;
    /**
     *
     */
    UserName: string;
}
/**
 * Remove all user licenses.
 */
export interface User_RemoveLicensesRequest {
    /**
     *
     */
    AssociateId: number;
}
/**
 * Retiring a user means to remove all licenses, setting person.retired=1 and associate.deleted=1. Unretiering a user means setting  person.retired=0 and associate.deleted=0
 */
export interface User_MakeRetiredRequest {
    /**
     *
     */
    AssociateId: number;
    /**
     *
     */
    Retired: boolean;
}
/**
 *
 */
export interface User_AddOwnerContactRequest {
    /**
     * Id of the contact to add as a owner contact
     */
    ContactId: number;
}
/**
 * Remove a contact from the ownercontactlink table
 */
export interface User_RemoveOwnerContactRequest {
    /**
     * The id of the contact to remove
     */
    ContactId: number;
}
/**
 * Get a user from the provided information. If the user or associated person does not exist, it will be created on demand.
 * Returns ResolvedUser
 */
export interface User_ResolveUserFromInfoRequest {
    /**
     * The contact Id of the contact which the person belongs to. Cannot be 0.
     */
    ContactId: number;
    /**
     * The full name of the person to be resolved. Optional.
     */
    PersonName: string;
    /**
     * Phone numbers registered on the person. Optional.
     */
    PhoneNumbers: string[];
    /**
     * Email-addresses registered on the person. Optional.
     */
    Emails: string[];
    /**
     * The type of user to look up or create.
     */
    UserType: enums.UserType;
    /**
     * The credentials to be used for the user. Required.
     */
    Credential: Credential;
}
/**
 * Get an access token based on the current user's session.
 * Returns string
 */
export interface User_GetAccessTokenRequest {
    /**
     * Application token to get access on behalf of. Optional.
     */
    AppToken: string;
    /**
     * Initialize CS session for this access token?.
     */
    IncludeCsSession: boolean;
}
/**
 * Generates a valid username for an unsaved user
 * Returns string
 */
export interface User_GetValidUserNameForNewUserRequest {
    /**
     *
     */
    User: User;
}
/**
 * Get the default username for a person
 * Returns string
 */
export interface User_GetDefaultAssociateUserNameRequest {
    /**
     *
     */
    User: User;
}
/**
 *
 * Returns boolean
 */
export interface User_IsNickNameUniqueRequest {
    /**
     *
     */
    AssociateId: number;
    /**
     *
     */
    NickName: string;
}
/**
 * Check that entity is ready for saving, return error messages by field.
 * Returns StringDictionary
 */
export interface User_ValidateUserRequest {
    /**
     * Entity to be checked for errors.
     */
    User: User;
}
/**
 * Get user presence status
 * Returns UserPresenceStatus
 */
export interface User_GetUserPresenceStatusRequest {
    /**
     * AssociateId of user to retrieve status for.
     */
    AssociateId: number;
}
/**
 * Set user presence status
 * Returns UserPresenceStatus
 */
export interface User_SetUserPresenceStatusRequest {
    /**
     * AssociateId of user to set status for.
     */
    AssociateId: number;
    /**
     * User presence status to set
     */
    UserPresenceStatus: UserPresenceStatus;
}
/**
 * The main user group that this user belongs to
 */
export interface UserGroup extends Carrier {
    /**
     * UserGroup name
     */
    Value?: string;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * Primary key
     */
    Id?: number;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Deleted equal to true means that this is a user group that no longer can be selected by the user.  It is not permitted to delete a UserGroup.
     */
    Deleted?: boolean;
}
/**
 * Save a user group.  Set UserGroup.Deleted to mark a user group as deleted and invisible in the user interface.
 * Returns UserGroup
 */
export interface User_SaveUserGroupRequest {
    /**
     * UserGroup to save
     */
    UserGroup: UserGroup;
}
/**
 * Get all user groups
 * Returns UserGroup[]
 */
export interface User_GetAllUserGroupsRequest {
    /**
     * Include user groups with Deleted set to true
     */
    IncludeDeleted: boolean;
}
/**
 * Create UserGroup (Rank is assigned to the highest rank)
 * Returns UserGroup
 */
export interface User_CreateUserGroupRequest {
}
/**
 * Delete a usergroup and move its members to another usergroup
 */
export interface User_DeleteUserGroupRequest {
    /**
     * The id of the userGroup to delete
     */
    UserGroupToDelete: number;
    /**
     * The id of the userGroup to move the members to
     */
    UserGroupToMoveTo: number;
}
/**
 *
 */
export interface UserInfo extends Carrier {
    /**
     * If true, the user is retired and should have no rights, not appear in lists, etc.
     */
    Deleted?: boolean;
    /**
     * Primary key
     */
    UserInfoId?: number;
    /**
     * Initials, also login name, possibly database user name
     */
    UserName?: string;
    /**
     * Owning person record
     */
    PersonId?: number;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Tooltip or other description
     */
    Tooltip?: string;
    /**
     * Primary group membership, see UserGroupLink for secondary memberships
     */
    UserGroupId?: number;
    /**
     * ID of the ej user record corresponding to this associate; 0 for associates that are not ej users
     */
    EjUserId?: number;
    /**
     *
     */
    UserType?: enums.UserType;
    /**
     *
     */
    GrantedLicenses?: string[];
    /**
     *
     */
    CanLogon?: boolean;
    /**
     *
     */
    RoleName?: string;
    /**
     *
     */
    RoleTooltip?: string;
    /**
     *
     */
    UserGroupName?: string;
    /**
     *
     */
    UserGroupTooltip?: string;
}
/**
 * Manage present/absent status for a Service user account (influences ticket assignments).
 */
export interface UserPresenceStatus {
    /**
     * The status (enum) for this user.
     */
    Status?: enums.EjUserStatus;
    /**
     * Comment to add for user when status is not present.
     */
    Message?: string;
}
/**
 *
 */
export interface UserValidationResult extends Carrier {
    /**
     *
     */
    Reason?: string;
    /**
     *
     */
    Result?: boolean;
}
/**
 *
 */
export interface Area extends Carrier {
    /**
     * Primary key
     */
    AreaId?: number;
    /**
     * Area name
     */
    Name?: string;
    /**
     * Max age of data when generating db's based on this area
     */
    MaxDataAge?: number;
    /**
     *
     */
    NumberOfUsers?: number;
    /**
     *
     */
    NumberOfLogins?: number;
    /**
     *
     */
    FreetextEnabeled?: boolean;
}
/**
 * Enable freetext search on this area
 */
export interface Replication_SetFreetextSearchEnabledOnAreaRequest {
    /**
     * The id of the area
     */
    AreaId: number;
    /**
     * True if freetextSearch on this area shall be enabled
     */
    FreetextEnabled: boolean;
}
/**
 *
 */
export interface Satellite extends Carrier {
    /**
     * Primary key
     */
    SatelliteId?: number;
    /**
     * Registered when
     */
    Created?: Date;
    /**
     *
     */
    CreatedBy?: Associate;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     *
     */
    UpdatedBy?: Associate;
    /**
     *
     */
    Contact?: Contact;
    /**
     *
     */
    Area?: Area;
    /**
     * The restricted and unrestricted module licenses grouped by license owner. These module licenses are either assigned or unassigned to this user
     */
    LicenseOwners?: LicenseOwner[];
}
/**
 *
 * Returns LicenseOwner[]
 */
export interface Replication_GetCentralLicenseRequest {
}
/**
 *
 * Returns LicenseOwner[]
 */
export interface Replication_SaveCentralLicenseRequest {
    /**
     *
     */
    License: LicenseOwner[];
}
/**
 * This service support fetching of client interface configuration data. <para/> Client configuration data include Application configuration, which defines how an application is composed out of pages; and page configuration that defines how a page is built out of panels, cards, views and controls. <para/> Separate access points also exist for fetching object mappings and filter lists.
 */
export interface PreferredTimeZone {
    /**
     * Primary key of userpreference row that specifies the TZLocationId, if set; 0 if the data are from a fallback (but still valid)
     */
    PreferenceId?: number;
    /**
     * Primary key
     */
    TZLocationId?: number;
    /**
     * Code, such as CA-NT, identifying the timezone location in the imported data. Unique, NOT equal to the culture codes of Windows
     */
    LocationCode?: string;
    /**
     * Description of the time zone
     */
    Description?: string;
    /**
     * Name of the country of the time zone
     */
    Country?: string;
    /**
     * number of minutes bias relative to UTC time
     */
    Bias?: number;
}
/**
 * Get information about the current, preferred timezone for the current user. If no such preference has been set, returns the correct fallback (and UserPreferenceId is 0)
 * Returns PreferredTimeZone
 */
export interface TimeZone_GetDefaultTimeZoneInformationRequest {
}
/**
 * This service support fetching of client interface configuration data. <para/> Client configuration data include Application configuration, which defines how an application is composed out of pages; and page configuration that defines how a page is built out of panels, cards, views and controls. <para/> Separate access points also exist for fetching object mappings and filter lists.
 */
export interface RemoteTimeZoneMethods extends Carrier {
}
/**
 * Initalizes the TimeZoneData
 * Returns TimeZoneData[]
 */
export interface TimeZone_InitializeTimeZoneDataRequest {
}
/**
 * Get the base timezone id.
 * Returns number
 */
export interface TimeZone_GetBaseTimeZoneIdRequest {
}
/**
 * Retrieve time zone data from the SuperOffice server and update TimeZone data in the database
 * Returns boolean
 */
export interface TimeZone_UpdateTimeZoneDataRequest {
}
/**
 * Check to see if new timezone data is available
 * Returns boolean
 */
export interface TimeZone_CheckNewTimeZoneDataAvailableRequest {
}
/**
 * Toggles active state of a single row in the TZLocation table
 */
export interface TimeZone_ToggleActiveTimeZoneRowRequest {
    /**
     * Id of row to toggle active state on
     */
    Id: number;
}
/**
 * Toggles active state of a single row in the TZLocation table
 */
export interface TimeZone_SetActiveTimeZonesByFilterRequest {
    /**
     * Filter timezones
     */
    Filter: string;
    /**
     * Set active to true or false
     */
    Active: boolean;
}
/**
 * Get the time time zone data was last updated
 * Returns Date
 */
export interface TimeZone_TimeOfLastTimeZoneUpdateRequest {
}
/**
 * Set the base timezone id.
 * Returns boolean
 */
export interface TimeZone_SetBaseTimeZoneIdRequest {
    /**
     * The timezone id to save
     */
    TimezoneId: number;
}
/**
 * Returns the id of the default timezone preference with deflevel system wide
 * Returns number
 */
export interface TimeZone_GetDefaultTimeZonePreferenceRequest {
}
/**
 * Deletes all time zone data (locations and rules) from the database
 */
export interface TimeZone_DeleteTimeZonesRequest {
}
/**
 * Set active state of singe row in the TZLocation table
 */
export interface TimeZone_SetActiveTimeZoneRowRequest {
    /**
     * Id of row to set active state on
     */
    Id: number;
    /**
     * Set active to true or false
     */
    Active: boolean;
}
/**
 * Information about a TimeZone
 */
export interface TimeZoneData {
    /**
     * Timezone location ID
     */
    TZLocationID?: number;
    /**
     * Name associated with the location
     */
    Name?: string;
    /**
     * Code associated with location
     */
    TZLocationCode?: string;
    /**
     * Cities associated with location
     */
    TZLocationCities?: string;
    /**
     *
     */
    IsoNumber?: number;
    /**
     * Rules for standard time
     */
    TimeZoneSTDRules?: TimeZoneRuleDictionary;
    /**
     * Rules for daylight savings time
     */
    TimeZoneDSTRules?: TimeZoneRuleDictionary;
}
/**
 * Information about a rule for a TimeZone
 */
export interface TimeZoneRule {
    /**
     * Number of minutes bias relative to UTC time
     */
    TZOffset?: number;
    /**
     * DST start rule, such as 0200 1ST-SUN-APR; limited to rules that we have parse code for; use dayOfMonth etc for custom rules
     */
    StartRulePattern?: string;
    /**
     * DST end rule, such as 2300 LST-SAT-OCT; limited to rules that we have parse code for; use dayOfMonth etc for custom rules
     */
    EndRulePattern?: string;
    /**
     * Custom DST start day, if 0 then parse startRule
     */
    StartDay?: number;
    /**
     * Custom DST start month, if 0 then parse startRule
     */
    StartMonth?: number;
    /**
     * Custom DST end day, if 0 then parse startRule
     */
    EndDay?: number;
    /**
     * Custom DST end month, if 0 then parse startRule
     */
    EndMonth?: number;
}
/**
 * Serializable dictionary.
 */
export interface TimeZoneRuleDictionary {
    [index: string]: TimeZoneRule;
}
/**
 * Details about a message to be sent
 */
export interface IncomingMessage extends Carrier {
    /**
     * Address of the recipient. This can be in the form of phone number or email.
     */
    To?: string;
    /**
     * Who the message is from.  This can vary from provider to provider and can for SMS typically be a phone number or a string.  This is mail address on the form of an e-mail.
     */
    From?: string;
    /**
     * Content, or body, of the message.
     */
    Content?: string;
    /**
     * Format of the content
     */
    Format?: string;
    /**
     * Session key used for threading.
     */
    SessionKey?: string;
    /**
     * Name of plugin
     */
    Plugin?: string;
}
/**
 * Create a new message and insert it in the message queue. (inbox)
 */
export interface Messaging_CreateMessageRequest {
    /**
     *
     */
    IncomingMessage: IncomingMessage;
}
/**
 * Class used to describe the message status.
 */
export interface MessageDeliveryStatus extends Carrier {
    /**
     * Current message status
     */
    Status?: number;
    /**
     * String describing the current message status.
     */
    StatusDescription?: string;
    /**
     * Id to the outgoing message table
     */
    MessagingId?: number;
}
/**
 * Get delivery status
 * Returns MessageDeliveryStatus[]
 */
export interface Messaging_GetDeliveryStatusRequest {
    /**
     * Array of messaging ids.
     */
    MessagingIds: number[];
}
/**
 * Set or change the delivery status on an outgoing messsage.
 */
export interface Messaging_SetDeliveryStatusRequest {
    /**
     * Name of plugin
     */
    Plugin: string;
    /**
     * External message id known to plugin.
     */
    ExternalMessageId: string;
    /**
     * Delivery status
     */
    Status: number;
    /**
     * String describing delivery status.
     */
    StatusDescription: string;
}
/**
 * Details about a message to be sent
 */
export interface OutgoingMessage extends Carrier {
    /**
     * Who the message is from.  This can vary from provider to provider and can for SMS typically be a phone number or a string.  This is mail address on the form of an e-mail.
     */
    From?: string;
    /**
     * Address of the recipient. This can be in the form of phone number or email.
     */
    To?: string;
    /**
     * Content, or body, of the message.
     */
    Content?: string;
    /**
     * Format of content
     */
    Format?: string;
    /**
     * Id to the previous outgoing message related to this one. Used from message threading.
     */
    ParentMessagingId?: number;
    /**
     *
     */
    SuggestedSessionKey?: string;
}
/**
 * Send an array of messages
 * Returns MessageDeliveryStatus[]
 */
export interface Messaging_SendMessagesRequest {
    /**
     * Name of plugin to use.
     */
    Plugin: string;
    /**
     * Array of outgoing messages you want to send.
     */
    OutgoingMessages: OutgoingMessage[];
}
/**
 * Send an array of messages using given config
 * Returns MessageDeliveryStatus[]
 */
export interface Messaging_SendMessagesWithConfigRequest {
    /**
     * Name of plugin to use.
     */
    Plugin: string;
    /**
     * Array of outgoing messages you want to send.
     */
    OutgoingMessages: OutgoingMessage[];
    /**
     * Config values used by the plugin.
     */
    Config: StringDictionary;
}
/**
 * Information about a provider plugin
 */
export interface ProviderInfo extends Carrier {
    /**
     * Unique name of the provider plugin
     */
    Name?: string;
    /**
     * This value can typically be "sms/160", "sms/mms", "smtp/rfc822"
     */
    SupportedMessagingFormats?: string[];
    /**
     * True if it supports the config parameters to the sending methods
     */
    SupportsConfig?: boolean;
}
/**
 *
 * Returns ProviderInfo[]
 */
export interface Messaging_GetPluginsRequest {
}
/**
 * Used to import data into the system. Representing one entity that will be imported.
 */
export interface ImportLine extends Carrier {
    /**
     * An array of the values that will be imported on the entity
     */
    Values?: string[];
    /**
     * True if the entity shall be imported, false if the entity shall be ignored
     */
    Selected?: boolean;
    /**
     * Which operation will be used? This is a read-only property
     */
    Operation?: enums.ImportAction;
    /**
     * Which entity type will be created? This is a read-only property
     */
    Type?: enums.ImportEntityType;
    /**
     * Optional external primary key for the row
     */
    ExternalKey?: string;
}
/**
 * Preview the import
 * Returns ImportLine[]
 */
export interface Import_PreviewImportRequest {
    /**
     * The rows that will be manipulated and according to Import rules
     */
    ImportLines: ImportLine[];
    /**
     * An array of the columndefinitions, like firstname, lastname, ...
     */
    ColumnDefinition: string[];
    /**
     * The current culture used in the import. Used to match language specific strings
     */
    Culture: string;
    /**
     * Optional context for the import.
     */
    Context: string;
}
/**
 * Do the actual import
 * Returns number[]
 */
export interface Import_SaveImportRequest {
    /**
     * The rows that will be imported
     */
    ImportLines: ImportLine[];
    /**
     * An array of the columndefinitions, like firstname, lastname, ...
     */
    ColumnDefinition: string[];
    /**
     * true if a selection of the imported entities shall be made
     */
    CreateSelection: boolean;
    /**
     * The current culture used in the import. Used to match language specific strings
     */
    Culture: string;
    /**
     * Optional context for the import.
     */
    Context: string;
}
/**
 * Create a new empty import row with x count of values
 * Returns ImportLine
 */
export interface Import_CreateDefaultImportLineRequest {
    /**
     * The count of values that will can be filled out
     */
    CountColumns: number;
}
/**
 * Column info for importlines.
 */
export interface ImportColumnInfo extends Carrier {
    /**
     * Name of the column
     */
    Name?: string;
    /**
     * Display name of the column
     */
    DisplayName?: string;
    /**
     * If true disable the option of choose column
     */
    Locked?: boolean;
}
/**
 * Used to import data into the system. Representing one entity that will be imported.
 */
export interface ImportErpData extends Carrier {
    /**
     * An array of Import lines
     */
    ImportLines?: ImportLine[];
    /**
     * Array of column definitions
     */
    ColumnInfos?: ImportColumnInfo[];
}
/**
 * Populates the ImportLines and columnDefs basedfrom erp system
 * Returns ImportErpData
 */
export interface Import_CreateErpImportDataRequest {
    /**
     * Archive restrictions.
     */
    Restriction: ArchiveRestrictionInfo[];
    /**
     * Columns.
     */
    Columns: string[];
    /**
     * Connection id for Erp system
     */
    ConnectionId: number;
    /**
     * Erp Actor type
     */
    ErpActorType: enums.ErpActorType;
}
/**
 * Used to manage freetext search.
 */
export interface FreeText extends Carrier {
    /**
     * True if freetext search enabled
     */
    FreeTextEnabled?: boolean;
    /**
     * Starts with, contains or exact match
     */
    SingleWordOperator?: enums.FreeTextOperator;
    /**
     * Starts with, contains or exact match
     */
    MultiWordOperator?: enums.FreeTextOperator;
    /**
     * Count of unique search words
     */
    CountWords?: number;
    /**
     * Total count of search words
     */
    Occurrences?: number;
    /**
     * Last time search has been generated
     */
    LastGenerated?: Date;
    /**
     * Automatically enable freetext search for new travel areas
     */
    AutoEnableTravelAreas?: boolean;
}
/**
 * Returns status for the freetext search words
 * Returns FreeText
 */
export interface FreeText_GetStatusRequest {
}
/**
 * Sets freetext search to enabled (true) or disabled (false)
 */
export interface FreeText_SetEnabledRequest {
    /**
     * If enabled true, else false
     */
    Enabled: boolean;
}
/**
 * Automatically enable freetext search for new travel areas? true or false
 */
export interface FreeText_SetAutoEnableTravelAreasRequest {
    /**
     * If true, auto enable
     */
    AutoEnable: boolean;
}
/**
 * Sets the operator used when matching single words
 */
export interface FreeText_SetSingleWordOperatorRequest {
    /**
     * The operator
     */
    FreeTextOperator: enums.FreeTextOperator;
}
/**
 * Sets the operator used when matching multiple words
 */
export interface FreeText_SetMultiWordOperatorRequest {
    /**
     * The operator
     */
    FreeTextOperator: enums.FreeTextOperator;
}
/**
 * Returns the list of stop words
 * Returns string[]
 */
export interface FreeText_GetStopWordListRequest {
}
/**
 * Adds the words in the string to the stop word list
 */
export interface FreeText_AddWordsRequest {
    /**
     * The stop words to add
     */
    StopWords: string;
}
/**
 * Delete the stop words with these ids
 */
export interface FreeText_DeleteStopWordsByIdRequest {
    /**
     * The ids of the stopwords to delete
     */
    StopWordIds: number[];
}
/**
 * Returns the top used words in the freetext index table, sorted as most used first
 * Returns MDOListItem[]
 */
export interface FreeText_GetSuggestedStopWordsRequest {
    /**
     * The count of words that will be returned
     */
    CountWords: number;
}
/**
 * Wipe and regenerate the freetext index by scanning the database (freetext search will be unavailable while this operation runs
 * Returns BatchTaskInfo
 */
export interface FreeText_RegenerateIndexRequest {
    /**
     * If true, then execute the regeneration as a Batch Task; the service call will return immediately. Otherwise wait until the task completes, may cause a timeout if called as a Web Service
     */
    RunAsBatch: boolean;
}
/**
 * Update the freetext index for one or more rows from the same table
 */
export interface FreeText_FreetextIndexRowsRequest {
    /**
     * The name of the table the rows come from; this table should have at least one freetext-indexable field
     */
    TableName: string;
    /**
     * One or more primary keys, identifying records to be (re)indexed. It doesn't matter if they have been indexed before or not
     */
    IDs: number[];
}
/**
 * A refcount entity for a number allocation
 */
export interface RefCountEntity extends Carrier {
    /**
     * Primary key
     */
    RefCountsId?: number;
    /**
     * Field identifier in string format table.field
     */
    Field?: string;
    /**
     * Record id in target table, used when there are separate counters for each target record
     */
    RecordId?: number;
    /**
     * List of valid entities, the associated record is selected in the list, used records are filtered out
     */
    SuggestedRecords?: MDOListItem[];
    /**
     * Current value of counter
     */
    CurrentValue?: number;
    /**
     * size of prefix for Travel use of ths counter
     */
    TravelPrefix?: number;
    /**
     * size of prefix for Satellite use of this counter
     */
    SatPrefix?: number;
    /**
     * Allocate numbers automatically
     */
    Allocate?: boolean;
    /**
     * Check that entered value is unique
     */
    Unique?: boolean;
    /**
     * Target field is read only in GUI
     */
    ReadOnly?: boolean;
    /**
     * Allow blank  as a valid value
     */
    AllowBlank?: boolean;
}
/**
 * Saves default numbering values in preferences
 */
export interface NumberAllocation_SaveDefaultNumberingRequest {
    /**
     * The refCountEntity that holds the values that will be saved
     */
    RefCountEntity: RefCountEntity;
}
/**
 * Returns true or false if Automatically create new counters for new document templates
 * Returns boolean
 */
export interface NumberAllocation_GetNumberEachTemplateRequest {
}
/**
 * Saves true or false if Automatically create new counters for new document templates
 */
export interface NumberAllocation_SetNumberEachTemplateRequest {
    /**
     * true or false if Automatically create new counters for new document templates
     */
    SetValue: boolean;
}
/**
 * Use the ChatSessionEntity on the Chat agent instead. Chat sessions belong to a chat topic, and contain messages to/from users
 */
export interface ChatSession extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    ChatSessionId?: number;
}
/**
 * Deletes the specified chat sessions.
 */
export interface CustomerService_DeleteChatSessionsRequest {
    /**
     * The ids of the chat sessions to delete
     */
    Ids: number[];
}
/**
 * Get all chat TOPICS which this user is a member of. Members means that you have at least one of: Can Respond, Notifications, Listen or Manager
 * Returns ChatSession[]
 */
export interface CustomerService_ChatSessionsForUserRequest {
}
/**
 *
 */
export interface CsFeatureToggle extends Carrier {
    /**
     * Name of the feature toggle
     */
    Name?: string;
    /**
     * Describes if the feature toggle is turned on or off
     */
    State?: boolean;
}
/**
 * Update the cached FeatureToggles for CS
 */
export interface CustomerService_UpdateFeatureTogglesRequest {
    /**
     * Feature toggle name / state
     */
    FeatureToggles: CsFeatureToggle[];
}
/**
 * Check if an eventhandler exists for a given enum
 * Returns boolean
 */
export interface CustomerService_EventHandlerExistsRequest {
    /**
     * The EventHandlerType we are checking
     */
    EventHandlerType: enums.EventHandlerType;
}
/**
 *
 */
export interface CsSessionKey extends Carrier {
    /**
     * The session key created in the login table
     */
    Key?: string;
    /**
     * The id of the login row
     */
    LoginId?: number;
    /**
     * The ejuser id owning this session key
     */
    UserId?: number;
}
/**
 * Creates a login session for a CS user
 * Returns CsSessionKey
 */
export interface CustomerService_CreateSessionRequest {
    /**
     * The ip of the client creating the session
     */
    RemoteIp: string;
}
/**
 * Remove a login session for a CS user
 */
export interface CustomerService_RemoveSessionRequest {
    /**
     * The login id to remove
     */
    LoginId: number;
}
/**
 * Check if a CS session is valid
 * Returns boolean
 */
export interface CustomerService_SessionIsValidRequest {
    /**
     * The CS session key to check
     */
    CsSessionKey: string;
}
/**
 * Check if user has any chat notification
 * Returns boolean
 */
export interface CustomerService_HasChatNotifyRequest {
}
/**
 * Do a test to check that we are using the same encryption keys
 * Returns string
 */
export interface CustomerService_CheckSymmetricEncryptionRequest {
    /**
     * An encrypted version of the string
     */
    EncryptedString: string;
}
/**
 * Report a session as being 'active'; will update the corresponding row in login table, but not more than once per minute/session
 * Returns number
 */
export interface CustomerService_ReportSessionActiveRequest {
    /**
     * CS session key, matching the 'login' table
     */
    SessionKey: string;
}
/**
 * Contains configuration when displaying the Customer Center
 */
export interface CustomerCenterConfig extends Carrier {
    /**
     * Primary key
     */
    CustConfigId?: number;
    /**
     * What kind of data is in this row
     */
    Type?: enums.ConfigType;
    /**
     * A JSON-formatted config
     */
    Config?: string;
    /**
     * The customer language which this config belongs to. 0 indicates that the config is global
     */
    CustLangId?: number;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Registered by whom
     */
    RegisteredAssociateId?: number;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Last updated by whom
     */
    UpdatedAssociateId?: number;
}
/**
 * Get all rows from cust_config as an array of CustomerCenterConfig entities
 * Returns CustomerCenterConfig[]
 */
export interface CustomerService_GetAllCustomerCenterConfigsRequest {
}
/**
 * Save an array of CustomerCenterConfig entities to the database
 */
export interface CustomerService_SaveAllCustomerCenterConfigsRequest {
    /**
     * The CustomerCenterConfig entities to be saved. If the id does not exists, a new one will be created. Unknown ids will be skipped
     */
    CustConfigs: CustomerCenterConfig[];
}
/**
 * Checks whether the core html templates are customized
 * Returns boolean
 */
export interface CustomerService_CheckIfCustomizedTemplatesRequest {
}
/**
 * This contains different configuration methods regarding Service
 */
export interface CustomerServiceConfig extends Carrier {
}
/**
 * This method will convert a module name into a Service URL.
 * Returns string
 */
export interface CustomerService_GetProgramUrlRequest {
    /**
     * In this parameter you must specify which CS program you want to create an URL for. Valid examples are "ticket", "rms", "spm" etc.
     */
    ProgramName: string;
    /**
     * If set to true, this will generate URLs that are accesible from the outside (for example Internet)
     */
    External: boolean;
}
/**
 * Get a FAQ entry, ment to be displayed for a customer. This can either be a link to the FAQ entry on Custom Center, or it can be the answer and question. This is dependent on Registry setting with reg_id=157
 * Returns string
 */
export interface CustomerService_GetFaqForCustomerRequest {
    /**
     * The id of the FAQ entry to get. Only FAQ entries with access level public (both for unauthenticated and autenticated customer) will be returned
     */
    FaqEntryId: number;
}
/**
 * This carrier contains various data needed by Service for startup. Do not use this API, as it is for internal use and might change without notice
 */
export interface CustomerServiceStartup extends Carrier {
    /**
     * Is timezone enabled
     */
    TimezoneEnabled?: boolean;
    /**
     * The offset in minutes compared with UTC, calculated for DateTime.Now
     */
    TZOffset?: number;
    /**
     * A global recaptcha site key, used with the google recaptcha component. This value is taken from the web.config file
     */
    RecaptchaSiteKey?: string;
}
/**
 * Get the carrier with data that Service needs when starting up
 * Returns CustomerServiceStartup
 */
export interface CustomerService_GetCustomerServiceStartupRequest {
}
/**
 * EventData containing data related to event handlers
 */
export interface EventData extends Carrier {
    /**
     * The type of event we are triggered by
     */
    Type?: enums.EventHandlerType;
    /**
     * Environment values sent to the event handler
     */
    InputValues?: StringDictionary;
    /**
     * Whether the context should stop what it is doing, e.g. saving a sale
     */
    BlockExecution?: boolean;
    /**
     * Where the context should naviate afterwards
     */
    NavigateTo?: string;
    /**
     * A message to be presented to the user
     */
    Message?: string;
    /**
     * JSON structure of dialog to show
     */
    ShowDialog?: string;
    /**
     * Values sent back to the environment from the event handler
     */
    OutputValues?: StringDictionary;
    /**
     * Values kept between event handlers
     */
    StateValues?: StringDictionary;
    /**
     * String containing error message from handler system if it failed
     */
    Exception?: string;
}
/**
 * This method will execute event handlers in CRMScript for a given event.
 * Returns EventData
 */
export interface CustomerService_ExecuteEventHandlersRequest {
    /**
     * The EventData instance sent to the event handler
     */
    EventData: EventData;
}
/**
 * Knowledge base category. Groups knowledge base articles into hierarchy.
 */
export interface KbCategory {
    /**
     * The primary key (auto-incremented)
     */
    KbCategoryId?: number;
    /**
     * The name of this category.
     */
    Name?: string;
    /**
     * The description of this category.
     */
    Description?: string;
    /**
     * The full name of this category, i.e. Foo/bar/test.
     */
    Fullname?: string;
    /**
     * This entry contains a reference to the parent category. NULL or -1 if this is a toplevel category.
     */
    ParentId?: number;
    /**
     * A strictly ascending number used for sorting categories when they are listed.
     */
    SortOrder?: number;
}
/**
 * Carrier containing information about a Service mailbox
 */
export interface Mailbox extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    MailInFilterId?: number;
    /**
     * The address associated with this mailbox (used as FROM: address when sending emails).
     */
    Address?: string;
    /**
     * The name of the category that the mailbox is connected to
     */
    CategoryName?: string;
    /**
     * The name of the priority that the mailbox is connected to
     */
    PriorityName?: string;
}
/**
 * This method will get all registered mailboxes in Service
 * Returns Mailbox[]
 */
export interface CustomerService_GetMailboxesRequest {
}
/**
 * This entity represent a mailbox used for importing emails in Service
 */
export interface MailboxEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    MailInFilterId?: number;
    /**
     * Enum indicating the protocol to use (POP/IMAP).
     */
    ServerType?: enums.MailboxType;
    /**
     * The address associated with this mailbox (used as FROM: address when sending emails).
     */
    Address?: string;
    /**
     * The username used to log onto the mail account
     */
    Username?: string;
    /**
     * The password used to log into the mail account. This is hidden when reading
     */
    Password?: string;
    /**
     * The email server to connect to
     */
    Server?: string;
    /**
     * The port used to connect to the server
     */
    Port?: number;
}
/**
 * A faq entry with information suitable for preview.
 */
export interface PreviewFaqEntry extends Carrier {
    /**
     * The title of this entry.
     */
    Title?: string;
    /**
     * Full name of associate that created this faq entry
     */
    RegisteredByFullName?: string;
    /**
     * Date/time this faq entry was last updated.
     */
    Updated?: Date;
    /**
     * The question for this entry.
     */
    Question?: string;
    /**
     * The answer for this entry.
     */
    Answer?: string;
}
/**
 * Get a faq entry from its faq entry id
 * Returns PreviewFaqEntry
 */
export interface CustomerService_GetPreviewFaqEntryRequest {
    /**
     * FAQ entry ID
     */
    KbEntryId: number;
}
/**
 * A quick reply with information suitable for preview.
 */
export interface PreviewQuickReply extends Carrier {
    /**
     * The short name of the quick reply
     */
    Name?: string;
    /**
     * Full name of associate last updating this quick reply
     */
    UpdatedByFullName?: string;
    /**
     * Date/time this quick reply was last updated.
     */
    Updated?: Date;
    /**
     * Quick reply body in HTML format.
     */
    HtmlBody?: string;
}
/**
 * Get a quick reply from its quick reply id
 * Returns PreviewQuickReply
 */
export interface CustomerService_GetPreviewQuickReplyRequest {
    /**
     * Quick reply ID
     */
    QuickReplyId: number;
}
/**
 * A reply template with information suitable for preview.
 */
export interface PreviewReplyTemplate extends Carrier {
    /**
     * The name for this reply template.
     */
    Name?: string;
    /**
     * The description for this reply template.
     */
    Description?: string;
    /**
     * Full name of the associate that owns this reply template
     */
    OwnedByFullName?: string;
    /**
     * Date/time this reply template was last updated.
     */
    Updated?: Date;
    /**
     * Reply template body in the best available format.
     */
    Body?: string;
    /**
     * If true, body is HTML.
     */
    IsHtml?: boolean;
}
/**
 * Get a reply template from its reply template id
 * Returns PreviewReplyTemplate
 */
export interface CustomerService_GetPreviewReplyTemplateRequest {
    /**
     * Reply template ID
     */
    ReplyTemplateId: number;
}
/**
 * Reply template item
 */
export interface ReplyTemplate {
    /**
     * The primary key (auto-incremented)
     */
    ReplyTemplateId?: number;
    /**
     * The name for this reply template.
     */
    Name?: string;
    /**
     * The description for this reply template.
     */
    Description?: string;
    /**
     * The id of the folder in which this reply template is located. NULL or -1 if this is a toplevel reply template.
     */
    FolderId?: number;
}
/**
 * Reply template with parsed text. Represent one language version of reply template
 */
export interface ReplyTemplateParsed extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    ReplyTemplateId?: number;
    /**
     * The plain text version of the reply template, and if applicable parsed with customer and ticket data
     */
    PlainParsed?: string;
    /**
     * The HTML version of the reply template, and if applicable parsed with customer and ticket data
     */
    HtmlParsed?: string;
    /**
     * Meta data for the connected attachments
     */
    Attachments?: AttachmentEntity[];
    /**
     * The subject for this reply template
     */
    Subject?: string;
}
/**
 * Get a specific langauge version of the reply template, and run this trough the parser
 * Returns ReplyTemplateParsed
 */
export interface CustomerService_GetParsedTemplateRequest {
    /**
     * The id of the reply template
     */
    ReplyTemplateId: number;
    /**
     * The language id (prefered language). If 0 is given, the language of the person will be used
     */
    LanguageId: number;
    /**
     * The id of the person that will be populated into the parser
     */
    PersonId: number;
    /**
     * The id of the ticket that will be populated into the parser
     */
    TicketId: number;
}
/**
 * Get a specific langauge version of the reply template. No parsing is performed.
 * Returns ReplyTemplateParsed
 */
export interface CustomerService_GetUnparsedTemplateRequest {
    /**
     * The id of the reply template
     */
    ReplyTemplateId: number;
    /**
     * The language id (prefered language). If 0 is given, the language of the person will be used
     */
    LanguageId: number;
}
/**
 * Sms settings for Customer Service sms providers.
 */
export interface SmsConfig extends Carrier {
    /**
     * Phone prefix, will default to the current users HomeCountryId.
     */
    DefaultSmsCountry?: string;
    /**
     * Name of the selected provider, i.e. CM, Compaya SMS (cpsms.dk), Intelecom SMS, PSWinCom SMS, SMS Teknik or TXTLocal.
     */
    NetServerSmsProvider?: string;
    /**
     * The sender of the SMS messages. This text will appear on the recipient's mobile phone.
     */
    NsPluginSender?: string;
    /**
     * Configuration settings provided by the SMS provider. Typically contains newline-delimited settings such as username and password.
     */
    NsPluginConfig?: StringDictionary;
}
/**
 * Get the SmsConfig settings for Customer Service sms providers.
 * Returns SmsConfig
 */
export interface CustomerService_GetSmsConfigRequest {
}
/**
 * Carrier containing information about the result of a SMTP test
 */
export interface SmtpTestResult extends Carrier {
    /**
     * True if the test went ok. False if it failed. See the error message for details
     */
    Success?: boolean;
    /**
     * If an error occured, this member will contain a description of the error
     */
    ErrorMessage?: string;
}
/**
 * This method will do a test of a SMTP account, by sending an email to a special @superoffice.com account
 * Returns SmtpTestResult
 */
export interface CustomerService_TestSmtpServerRequest {
    /**
     * An URI containing information to connect to the SMTP server, eg. smtps://myuser:mypassword@smtp.myserver.com:465. Note that username and password must be url encoded
     */
    SmtpUri: string;
    /**
     * The from-address used in the test
     */
    From: string;
    /**
     * Use database persisted password
     */
    UseStoredPassword: boolean;
}
/**
 *
 */
export interface StatisticsDataSet extends Carrier {
    /**
     * The label for the data set
     */
    Label?: string;
    /**
     * Values in this set
     */
    Values?: StatisticsDataValue[];
    /**
     * Tooltip for data value
     */
    Description?: string;
}
/**
 * Returns the calculated results for the required statistics for the Customer Service Status Page
 * Returns StatisticsDataSet[]
 */
export interface CustomerService_GetStatisticsRequest {
    /**
     * List of functions to calculate and return
     */
    Functions: enums.StatusScreenPanelType[];
}
/**
 * This class contains a single data value in a data set, used by CS for Status Screen reports
 */
export interface StatisticsDataValue extends Carrier {
    /**
     * The label for the data value
     */
    Label?: string;
    /**
     * The value for the data value
     */
    Value?: number;
    /**
     * Tooltip for data value
     */
    Description?: string;
}
/**
 * System template settings item
 */
export interface SystemTemplateSettings extends Carrier {
    /**
     * Template for new contacts
     */
    CustomerNewCustomerTemplateId?: number;
    /**
     * Template for auto-reply
     */
    CustomerCustomerReplyTemplateId?: number;
    /**
     * Template for sending password to contacts
     */
    CustomerPasswordTemplateId?: number;
    /**
     * Template for sending confirmation e-mail to contacts
     */
    CustomerConfirmEmailTemplateId?: number;
    /**
     * Template for customer chat log
     */
    CustomerChatLogTemplateId?: number;
    /**
     * Template for new link
     */
    NewLinkTemplateId?: number;
    /**
     * Template for notification of a new message in the favourites list
     */
    HotlistNewMessageTemplateId?: number;
    /**
     * Template for notification of a activated ticket in the favourites list
     */
    HotlistTicketActivatedTemplateId?: number;
    /**
     * Template for notification of escalated request
     */
    UserTicketAlarmTemplateId?: number;
    /**
     * Template for notification of reassignment of a request in the favourites list
     */
    HotlistTicketTakenOverTemplateId?: number;
    /**
     * Template for notification of open requests
     */
    UserActiveTicketsTemplateId?: number;
    /**
     * Template for notification of new message
     */
    UserNewMessageTemplateId?: number;
    /**
     * Template for notification of activated request
     */
    UserTicketActivatedTemplateId?: number;
    /**
     * Template for new ticket notification
     */
    UserNewTicketTemplateId?: number;
    /**
     * Template for formatting FAQ questions
     */
    PublishKbQuestionTemplateId?: number;
    /**
     * Template for formatting FAQ answers
     */
    PublishKbAnswerTemplateId?: number;
    /**
     * Template for ticket reassignment
     */
    UserTicketTakenOverTemplateId?: number;
    /**
     * Template for printing a ticket
     */
    PrintTicketTemplateId?: number;
    /**
     * Template for weekly statistics
     */
    WeekStatTemplateId?: number;
    /**
     * Template for notification of an escalated request in the favourites list
     */
    TicketAlarmHotlistTemplateId?: number;
    /**
     * One or more e-mail addresses (comma-separated)
     */
    EmailAddresses?: string;
}
/**
 * Returns system template settings
 * Returns SystemTemplateSettings
 */
export interface CustomerService_GetSystemTemplateSettingsRequest {
}
/**
 * Saves and validates updated system templates. Throws exception if validation fails
 * Returns SystemTemplateSettings
 */
export interface CustomerService_SaveSystemTemplateSettingsRequest {
    /**
     * System template settings item with updated values
     */
    SystemTemplateSettings: SystemTemplateSettings;
}
/**
 * A small carrier that contains information about a ticket
 */
export interface TicketInfo extends Carrier {
    /**
     * The id of the created ticket
     */
    TicketId?: number;
    /**
     * The title/subject of the created ticket
     */
    Title?: string;
    /**
     * The name of the owner which the request was assigned to
     */
    OwnerName?: string;
    /**
     * The name of the category for the request
     */
    CategoryName?: string;
    /**
     * The name of the priority for the request
     */
    PriorityName?: string;
    /**
     * A URL leading directly to the created request. This is a URL ment to be used by a Service user
     */
    TicketUrl?: string;
    /**
     * The name of the person/customer connected to the ticket
     */
    PersonName?: string;
    /**
     * The name of the contact/company connected to the ticket
     */
    ContactName?: string;
}
/**
 * This method create a new ticket in the same way as importMail would import an email. It accepts RFC822 formatted data
 * Returns TicketInfo
 */
export interface CustomerService_CreateTicketFromMailDataRequest {
    /**
     * The id of the Service mailbox
     */
    MailboxId: number;
    /**
     * RFC822 formatted data to import as a ticket
     */
    Data: string;
}
/**
 * This method will add a message to an existing request in the sam way as importMail would do it from an email. It accepts RFC822 formatted data
 * Returns TicketInfo
 */
export interface CustomerService_AddMessageFromMailDataRequest {
    /**
     * The id of the ticket to add a message
     */
    TicketId: number;
    /**
     * RFC822 formatted data to import as a message
     */
    Data: string;
}
/**
 * This method wil search for tickets matching title or id
 * Returns TicketInfo[]
 */
export interface CustomerService_FindTicketsByTitleOrIdRequest {
    /**
     * The search string. If this is a number, it will also search for a matching ticket id
     */
    TitleOrId: string;
    /**
     * The maximum number of rows to be returned
     */
    MaxRows: number;
}
/**
 * Describes a caller ID for Mobile to lookup phone calls. Can be for a person, or for a company, in which case the personId field will be 0
 */
export interface CallerID {
    /**
     * Phone number, as a long instead of a string, to avoid parsing all the phonenumbers in Mobile CRM
     */
    PhoneNumber?: number;
    /**
     * Prefix for dialing into the country from outside (country code), empty if PhoneNumber already contains the country code
     */
    DialInPrefix?: number;
    /**
     * Primary key
     */
    PersonId?: number;
    /**
     * Full name of the person
     */
    PersonName?: string;
    /**
     * e.g. Mrs   sex_title
     */
    Mrmrs?: string;
    /**
     * Primary key
     */
    ContactId?: number;
    /**
     * Contact name
     */
    ContactName?: string;
}
/**
 * Get caller ids that the current principal might be interested in (phone numbers of related persons in sales and appointments created/owned/touched by ourselves or colleagues in our primary group
 * Returns CallerIDCollection
 */
export interface Pocket_GetMyCallerIDsRequest {
    /**
     * Hash for the previous call, used for checking if the same set of caller ids was sent in a previous call, and returning null in that case
     */
    LastHash: string;
    /**
     * Only check activities after this date
     */
    MinDate: Date;
    /**
     * Only check activities before this date
     */
    MaxDate: Date;
}
/**
 * Get caller ids from a selection. Queries the shadow selection of persons and companies, so selections of any kind can be used
 * Returns CallerIDCollection
 */
export interface Pocket_GetCallerIDsFromSelectionRequest {
    /**
     * Id of selection to get caller ids from
     */
    SelectionId: number;
    /**
     * Hash for the previous call, used for checking if the same set of caller ids was sent in an earlier call, and returning null in that case
     */
    LastHash: string;
}
/**
 * Collection of caller ids with their corresponding hash
 */
export interface CallerIDCollection {
    /**
     * Hash of the caller ids, used for checking if the same set of caller ids was sent earlier
     */
    CallerIDHash?: string;
    /**
     * Array of caller ids, sorted numerically on the phone number
     */
    CallerIDs?: CallerID[];
}
/**
 * Carrier for a notification event for a given notification type and entity id
 */
export interface NotificationEvent {
    /**
     * Type of notification event
     */
    Type?: enums.NotificationEventType;
    /**
     * Id of entity this notification event is about
     */
    Id?: number;
}
/**
 * Describes behaviour and content for a push notification message
 */
export interface PocketNotificationMessage {
    /**
     * Title for the notification
     */
    Title?: string;
    /**
     * The notification message body
     */
    Message?: string;
    /**
     * An url associated with the notification that will be handled by Pocket
     */
    Url?: string;
    /**
     * Indicates wether or not the message will vibrate/play a sound when delivered
     */
    Silent?: boolean;
    /**
     * The type of notification this is
     */
    Type?: enums.NotificationMessageType;
    /**
     * Specifies how many minutes the message should be valid
     */
    TimeToLive?: number;
    /**
     * If the message is about some specific database record, this could be its primary key
     */
    RecordId?: number;
    /**
     * If the message is about some event happening at a specific date and time
     */
    Date?: Date;
    /**
     * Specify duration of the event
     */
    Duration?: moment.Duration;
    /**
     * Additional key/value properties to include in the message
     */
    ExtraValues?: StringDictionary;
}
/**
 * Describes a device running Pocket CRM
 */
export interface PocketDeviceInfo {
    /**
     * A friendly display name for the device. Ex: 'Bobbys iPhone 5S'
     */
    DeviceName?: string;
    /**
     * A unique identifier of this device. This value should always be the same for the same device
     */
    DeviceIdentifier?: string;
    /**
     * What version of Pocket CRM this device is running. Ex: '8.0.37'
     */
    PocketVersion?: string;
    /**
     * The language which this device will receive notifications translated in
     */
    Language?: string;
    /**
     * The identifier associated with the device that will be used when talking with vendors push services
     */
    PNSHandle?: string;
    /**
     * What platform does this device belong to
     */
    Platform?: enums.NotificationPlatform;
    /**
     * The operating system version. Ex: 'iOS v10.2'
     */
    OSVersion?: string;
    /**
     * The timezone to show for dates in messages
     */
    TimeZoneId?: number;
}
/**
 * The Pocket Service. The service implements pocket specific stuff, like consolidated post-login stuff.
 */
export interface PocketStartupData extends Carrier {
    /**
     * List of tablerights for logged in user, in the same order as the Tables array parameter
     */
    TableRights?: enums.ETableRight[];
    /**
     *
     */
    PhoneLocaleTimeZoneData?: TimeZoneData;
    /**
     *
     */
    BaseLocaleTimeZoneData?: TimeZoneData;
    /**
     * Number of overdued sales for current user
     */
    OverdueSalesCount?: number;
    /**
     * Number of new invitations
     */
    NotificationsCount?: number;
    /**
     * Web panels defined in Admin client, set to be shown in Pocket client
     */
    SystemWebPanels?: WebPanelEntity[];
    /**
     * All Pocket specific preferences, including WebPanels defined by the user in Pocket
     */
    PocketPreferences?: Preference[];
    /**
     * Is push notification configured and enabled in Netserver
     */
    IsPushNotificationEnabled?: boolean;
    /**
     * Custom data for Pocket, in JSON format
     */
    CustomData?: string;
}
/**
 *
 * Returns PocketStartupData
 */
export interface Pocket_GetPocketStartupDataRequest {
    /**
     * Tables to check for license
     */
    Tables: string[];
    /**
     * Current time on the client, used for overdue sale lookup having correct timezone relative to client
     */
    CurrentClientTime: Date;
}
/**
 * Register a device that should receive push notifications when notable events occour
 */
export interface Pocket_RegisterDeviceForPushNotificationRequest {
    /**
     * Properties for the device to register
     */
    DeviceInfo: PocketDeviceInfo;
}
/**
 * Retrieve all registered devices for an associate
 * Returns PocketDeviceInfo[]
 */
export interface Pocket_GetRegisteredDevicesRequest {
    /**
     * The user to get devices for
     */
    AssociateId: number;
}
/**
 * Specify what kind of notification events a device should receive push notifications for
 */
export interface Pocket_SetPushNotificationTagsForDeviceRequest {
    /**
     * The unique identifier for a device
     */
    DeviceIdentifier: string;
    /**
     * A comma separated list of events this device should receive push events for
     */
    Tags: string;
}
/**
 * Specify what kind of notification events a user should receive push notifications for.  This will update all registerred devices for this user.
 */
export interface Pocket_SetPushNotificationTagsForUserRequest {
    /**
     * The associate to set tags for
     */
    AssociateId: number;
    /**
     * A comma separated list of events the associate should receive push events for
     */
    Tags: string;
}
/**
 * Retrieve current tag value for a device
 * Returns string
 */
export interface Pocket_GetPushNotificationTagsForDeviceRequest {
    /**
     * The unique identifier of this device
     */
    DeviceIdentifier: string;
}
/**
 * Send a push notification to one or more associates
 */
export interface Pocket_SendPushNotificationRequest {
    /**
     * The associates to send the push notification message to
     */
    AssociateIds: number[];
    /**
     * The message to send
     */
    Message: PocketNotificationMessage;
}
/**
 * Execute the AppointmentAlarmBroker once
 */
export interface Pocket_RunAppointmentAlarmBrokerRequest {
}
/**
 * Notify users about a new or changed entity
 */
export interface Pocket_NotifyUsersRequest {
    /**
     * Type of notification
     */
    NotificationEventType: enums.NotificationEventType;
    /**
     * Id of entity to notify about
     */
    Id: number;
}
/**
 * Mark a notification as handled, so it can be cleaned up on other clients that have received the notification
 */
export interface Pocket_NotificationHandledRequest {
    /**
     * Type of notification
     */
    NotificationEventType: enums.NotificationEventType;
    /**
     * Id of entity to notify about
     */
    Id: number;
}
/**
 * Mark a set of notifications as handled, so they can be cleaned up on other clients that have received the notification
 */
export interface Pocket_NotificationsHandledRequest {
    /**
     * List of notifications to mark as handled
     */
    NotificationEvents: NotificationEvent[];
}
/**
 * Dashboard configuration
 */
export interface Dashboard extends Carrier {
    /**
     * The dashboard id
     */
    DashboardId?: number;
    /**
     * Id of the associate who owns this dashboard
     */
    AssociateId?: number;
    /**
     * The caption for this dashboard
     */
    Caption?: string;
    /**
     * The dashboard layout, how the tiles are organized on the screen
     */
    Layout?: enums.DashboardLayout;
    /**
     * The tiles associated with this dashboard
     */
    Tiles?: DashboardTile[];
}
/**
 * Gets all dashboards for an associate
 * Returns Dashboard[]
 */
export interface Dashboard_GetDashboardsRequest {
    /**
     * Associate Id
     */
    AssociateId: number;
}
/**
 * Sets tile in the given dashboard position
 * Returns Dashboard
 */
export interface Dashboard_SetTileRequest {
    /**
     * Dashboard Id
     */
    DashboardId: number;
    /**
     * Tile Id
     */
    TileId: number;
    /**
     * Tile position in the dashboard
     */
    Position: number;
}
/**
 * Dashboard Tile configuration
 */
export interface DashboardTile extends Carrier {
    /**
     * The tile id
     */
    DashboardTileId?: number;
    /**
     * The tile caption
     */
    Caption?: string;
    /**
     * The tile description
     */
    Description?: string;
    /**
     * The original chart name
     */
    ChartName?: string;
    /**
     * The original chart Id
     */
    ChartId?: string;
    /**
     * True if this is one of the default tiles
     */
    IsDefault?: boolean;
    /**
     * Id of the associate who owns this tile
     */
    AssociateId?: number;
    /**
     * Id of the associates primary group at storage time
     */
    GroupId?: number;
    /**
     * The selection that defines the data filter/restrictions
     */
    SelectionId?: number;
    /**
     * The tile config
     */
    Config?: string;
    /**
     * The tile type, what kind of tile this is
     */
    Type?: enums.DashboardTileType;
    /**
     * The tile entity type
     */
    EntityType?: enums.DashboardTileEntityType;
    /**
     * The tile options
     */
    Options?: DashboardTileOption[];
    /**
     * The set of users or groups the record is visible for
     */
    VisibleFor?: VisibleFor[];
}
/**
 * Gets an array of dashboard tiles for the provided ids
 * Returns DashboardTile[]
 */
export interface Dashboard_GetDashboardTilesRequest {
    /**
     * The ids of the tiles to get
     */
    DashboardTileIds: number[];
}
/**
 * Gets the standard tile (not personal tile) corresponding to the given chart id
 * Returns DashboardTile
 */
export interface Dashboard_GetStandardDashboardTileFromChartIdRequest {
    /**
     * The ChartId of the wanted chart/tile
     */
    ChartId: string;
}
/**
 * Get data for this tile
 * Returns TileData[]
 */
export interface Dashboard_GetDataRequest {
    /**
     * Tile Id
     */
    DashboardTileId: number;
    /**
     * Replacement restrictions
     */
    Restrictions: string;
}
/**
 * Create new tile from another tile used as template
 * Returns DashboardTile
 */
export interface Dashboard_CreateNewFromTemplateRequest {
    /**
     * Tile template Id
     */
    DashboardTileId: number;
    /**
     * Caption of new tile
     */
    Caption: string;
    /**
     * Description of new tile
     */
    Description: string;
    /**
     * Selection id of new tile
     */
    SelectionId: number;
    /**
     * Who the tile should be visible for
     */
    VisibleFor: VisibleFor[];
}
/**
 * Get data for this tile
 * Returns TileData[]
 */
export interface Dashboard_GetDataWithSelectionRequest {
    /**
     * Tile Id
     */
    DashboardTileId: number;
    /**
     * Selection Id
     */
    SelectionId: number;
    /**
     * Replacement restrictions
     */
    Restrictions: string;
}
/**
 * Dashboard Tile option
 */
export interface DashboardTileOption extends Carrier {
    /**
     * Name of option, usually not visible to users
     */
    Name?: string;
    /**
     * Option description, visible to users
     */
    Description?: string;
    /**
     * The type of option - integer, list, boolean (checkbox) etc.
     */
    Type?: enums.DashboardTileOptionType;
    /**
     * An MDO list name, used if the type is list and no ListOptions are given
     */
    ListName?: string;
    /**
     * List options given directly, not via MDO list name
     */
    ListItems?: MDOListItem[];
    /**
     * The value, encoded as string, Id:Name of list item if type is list
     */
    Value?: string;
    /**
     * True if this option only applies to the default data source, not selections
     */
    DefaultDataOption?: boolean;
}
/**
 * Class representing data to be visualized in a dashboard tile.
 */
export interface TileData {
    /**
     * Column information
     */
    Columns?: ArchiveColumnInfo[];
    /**
     * The result set
     */
    Result?: ArchiveListResult;
}
/**
 * Dashboard configuration
 */
export interface Dash extends Carrier {
    /**
     * Primary key
     */
    DashboardId?: number;
    /**
     * GUID identifying a default dashboard from SuperOffice
     */
    UniqueId?: string;
    /**
     * The name of this dashboard
     */
    Name?: string;
    /**
     * Detailed description
     */
    Description?: string;
    /**
     * Associate who owns this dashboard
     */
    AssociateId?: number;
    /**
     * How many columns there will be in the dashboard.
     */
    Columns?: number;
    /**
     * The theme for this dashboard
     */
    Theme?: DashTheme;
    /**
     * True if visible for all
     */
    VisibleForAll?: number;
    /**
     * Array of references to the visible for associates
     */
    VisibleForAssociates?: number[];
    /**
     * Array of references to the visible for groups
     */
    VisibleForGroups?: number[];
    /**
     * True if pinned for all
     */
    PinForAll?: number;
    /**
     * Array of references to the pinned associates
     */
    PinForAssociates?: number[];
    /**
     * Array of references to the pinned groups
     */
    PinForGroups?: number[];
}
/**
 * Add a tile to a dashboard with next rank
 * Returns DashTile
 */
export interface Dash_AddTileToDashboardRequest {
    /**
     * The id of the dashboard to add the tile to
     */
    DashboardId: number;
    /**
     * The id of the dashboard tile definition
     */
    DashTileDefinitionId: number;
}
/**
 * Add a new tile to a dashboard with next rank
 * Returns DashTile
 */
export interface Dash_AddNewTileToDashboardRequest {
    /**
     * The id of the dashboard to add the tile to
     */
    DashboardId: number;
    /**
     * The tile definition data to add to the dashboard
     */
    DashTileDefinition: DashTileDefinition;
}
/**
 * Duplicate for the dashboard and all the sub elements
 * Returns Dash
 */
export interface Dash_DuplicateDashboardRequest {
    /**
     * The id of the dashboard to add the tile to
     */
    DashboardId: number;
    /**
     * The name of the new dashboard
     */
    Name: string;
}
/**
 * Gets the ordered list of dashboards
 * Returns Dash[]
 */
export interface Dash_GetDashListRequest {
    /**
     * List of dashboardIds
     */
    Dashboards: number[];
}
/**
 * Collection of dashboards for an associate
 */
export interface DashCollection extends Carrier {
    /**
     * Dashboards pinned to the associate
     */
    Pinned?: Dash[];
    /**
     * The assocates favourite dashboards
     */
    Favourites?: Dash[];
    /**
     * Other dashboards
     */
    Other?: Dash[];
}
/**
 * Gets a collection of dashboards for the current associate
 * Returns DashCollection
 */
export interface Dash_GetDashCollectionRequest {
}
/**
 * Dashboard theme configuration
 */
export interface DashTheme extends Carrier {
    /**
     * Primary key
     */
    DashboardThemeId?: number;
    /**
     * The name of this theme
     */
    Name?: string;
    /**
     * The JSON clob-formatted config
     */
    Config?: string;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * Name of client(s) this theme is available to
     */
    Client?: string;
    /**
     * Style value - for example 'light' or 'dark'
     */
    Style?: string;
}
/**
 * Dashboard Tile configuration
 */
export interface DashTile extends Carrier {
    /**
     * Primary key
     */
    DashboardTileId?: number;
    /**
     * The associated dashboard
     */
    DashboardId?: number;
    /**
     * Height used by this tile in the dashboard
     */
    Height?: number;
    /**
     * Width used by this tile in the dashboard
     */
    Width?: number;
    /**
     * Rank order
     */
    Rank?: number;
    /**
     * The tile definition entity
     */
    DashTileDefinition?: DashTileDefinition;
}
/**
 * Gets the ordered list of tiles for a dashboard
 * Returns DashTile[]
 */
export interface Dash_GetDashTilesRequest {
    /**
     * The id of the dashboard
     */
    DashboardId: number;
}
/**
 * Saves the ordered list of tiles for a dashboard
 */
export interface Dash_SaveDashTilesRequest {
    /**
     * The id of the dashboard
     */
    DashboardId: number;
    /**
     * The tiles in order
     */
    DashTiles: DashTile[];
}
/**
 * Returns the id to a dashboard tile selection
 * Returns number
 */
export interface Dash_CreateDashTileSelectionFromEntityRequest {
    /**
     * The name of the entity to create a default selection for
     */
    EntityName: string;
}
/**
 * Copy Tile Selection for the dashboard
 * Returns number
 */
export interface Dash_CopyTileSelectionRequest {
    /**
     * The id of the selection to copy from
     */
    SelectionId: number;
}
/**
 * Copy selection to temporary personal tile selection
 * Returns number
 */
export interface Dash_GetTempTileSelectionRequest {
    /**
     * The id of the selection to copy from
     */
    SelectionId: number;
}
/**
 * Copy selection to secondary temporary personal tile selection
 * Returns number
 */
export interface Dash_GetSecondaryTempTileSelectionRequest {
    /**
     * The id of the selection to copy from
     */
    SelectionId: number;
}
/**
 * Set Measure to CountAll and MeasureField to primary key field
 * Returns DashTile
 */
export interface Dash_CreateDefaultTileForEntityRequest {
    /**
     * Name of entity to use for primary key
     */
    EntityName: string;
}
/**
 * Duplicate for the tile and all the sub elements
 * Returns DashTile
 */
export interface Dash_DuplicateTileRequest {
    /**
     * The id of the tile to copy
     */
    DashTileId: number;
    /**
     * The name of the new tile
     */
    Name: string;
}
/**
 * Dashboard Tile definition
 */
export interface DashTileDefinition extends Carrier {
    /**
     * Primary key
     */
    DashboardTileDefinitionId?: number;
    /**
     * The name of the tile
     */
    Name?: string;
    /**
     * Detailed description
     */
    Description?: string;
    /**
     * Default height when added to a dashboard
     */
    DefaultHeight?: number;
    /**
     * Default width when added to a dashboard
     */
    DefaultWidth?: number;
    /**
     * Dashboard tile type
     */
    TileType?: enums.DashTileType;
    /**
     * Dashboard entity type
     */
    EntityType?: enums.DashTileEntityType;
    /**
     * The entity measured by this tile, defines what provider to use
     */
    EntityName?: string;
    /**
     * Selection holding the criterias for the tile definition
     */
    SelectionId?: number;
    /**
     * Dashboard currency mode
     */
    CurrencyMode?: enums.DashTileCurrencyMode;
    /**
     * Currency code
     */
    CurrencyCode?: string;
    /**
     * Dashboard measure type (Count, Sum, Avg, etc.)
     */
    Measure?: enums.DashTileMeasure;
    /**
     * Field to be measured
     */
    MeasureField?: string;
    /**
     * Sort by field
     */
    SortBy?: string;
    /**
     * The JSON formatted layout config
     */
    LayoutConfig?: string;
    /**
     * Selection holding the replaced or changed criterias (period comparisons etc)
     */
    SecondarySelectionId?: number;
    /**
     * Field to group by
     */
    MeasureByField?: string;
    /**
     * Where this tile can be used
     */
    Usage?: enums.DashTileUsage;
    /**
     * Name of provider to use with this entity type - read only property
     */
    ProviderName?: string;
}
/**
 * Set Measure to CountAll and MeasureField to primary key field
 * Returns DashTileDefinition
 */
export interface Dash_CreateDefaultTileDefinitionForEntityRequest {
    /**
     * Name of entity to use for primary key
     */
    EntityName: string;
}
/**
 * HTML data for dash tiles with TileType = HTML
 */
export interface DashTileHtml extends Carrier {
    /**
     * Content language
     */
    LanguageCode?: string;
    /**
     * HTML data
     */
    Html?: string;
}
/**
 * Get HTML for a dashboard tile definition with TileType = HTML
 * Returns DashTileHtml
 */
export interface Dash_GetDashTileHtmlRequest {
    /**
     * The id of the dashboard tile definition
     */
    DashboardTileDefinitionId: number;
    /**
     * Preferred language code.
     */
    LanguageCode: string;
}
/**
 * Get HTML for a dashboard tile definition with TileType = HTML. Retrieve a list with all registered languages.
 * Returns DashTileHtml[]
 */
export interface Dash_GetDashTileHtmlListRequest {
    /**
     * The id of the dashboard tile definition
     */
    DashboardTileDefinitionId: number;
}
/**
 * Set the HTML data for a tile with TileType = HTML.
 * Returns DashTileHtml[]
 */
export interface Dash_SaveDashTileHtmlListRequest {
    /**
     * The id of the dashboard tile definition
     */
    DashboardTileDefinitionId: number;
    /**
     * List of HTML content per language
     */
    Languages: DashTileHtml[];
}
/**
 * Dashboard preview
 */
export interface PreviewDash extends Carrier {
    /**
     * The name of this dashboard
     */
    Name?: string;
    /**
     * Detailed description
     */
    Description?: string;
    /**
     * Full name of dashboard owner
     */
    OwnedByFullName?: string;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Dashboard tiles
     */
    Tiles?: PreviewDashTile[];
}
/**
 * Get a dashboard from its id
 * Returns PreviewDash
 */
export interface Dash_GetPreviewDashRequest {
    /**
     * Dashboard ID
     */
    DashboardId: number;
}
/**
 * Dashboard tile preview
 */
export interface PreviewDashTile extends Carrier {
    /**
     * The name of the tile
     */
    Name?: string;
    /**
     * Dashboard tile type
     */
    TileType?: enums.DashTileType;
}
/**
 * Target Period Assignment carrier
 */
export interface TargetAssignment extends Carrier {
    /**
     * Primary key
     */
    TargetAssignmentInfoId?: number;
    /**
     * Values of the target; all periods; in ascending order.
     */
    Values?: number[];
    /**
     * Locked, should not be editable
     */
    Locked?: boolean;
    /**
     * The associate this target is set for. Only one of TargetAssociate, TargetContact and TargetUserGroup will be set for a target.
     */
    TargetAssociate?: Associate;
    /**
     * The contact this target is set for. Only one of TargetAssociate, TargetContact and TargetUserGroup will be set for a target.
     */
    TargetContact?: Contact;
    /**
     * The usergroup this target is set for. Only one of TargetAssociate, TargetContact and TargetUserGroup will be set for a target.
     */
    TargetUserGroup?: UserGroup;
    /**
     * The currency of the target.
     * Use MDO List name "currency" to get list items.
     */
    Currency?: Currency;
    /**
     * Id of the dimension list item this assignement is for
     */
    DimensionListItem?: number;
    /**
     * Display name of the dimension list item this assignement is for.
     */
    DimensionListItemDisplayName?: string;
}
/**
 * Returns a default target assignment for the owner company.
 * Returns TargetAssignment
 */
export interface Targets_CreateDefaultTargetAssignmentForCompanyRequest {
}
/**
 * Returns a default target assignment for the specified usergroup.
 * Returns TargetAssignment[]
 */
export interface Targets_CreateDefaultTargetAssignmentForUserGroupRequest {
    /**
     * The id of the UserGroup
     */
    UserGroupId: number;
}
/**
 * Returns the target assignment for the specified year and entity type.
 * Returns TargetAssignment
 */
export interface Targets_GetTargetAssignmentForYearRequest {
    /**
     * Targeted year
     */
    TargetYear: number;
    /**
     * Targeted entity type
     */
    EntityType: enums.TargetEntityType;
    /**
     * The level of target the id is referring to.
     */
    TargetLevel: enums.TargetLevel;
    /**
     * Contact, UserGroup or Associate id.
     */
    Id: number;
}
/**
 * Returns a default target assignment for the owner company, for the specified dimension.
 * Returns TargetAssignment[]
 */
export interface Targets_CreateDefaultTargetAssignmentForCompanyWithDimensionRequest {
    /**
     * The dimension id to use.
     */
    TargetDimensionId: number;
}
/**
 * Returns a default target assignment for the specified usergroup, for the specified dimension.
 * Returns TargetAssignment[]
 */
export interface Targets_CreateDefaultTargetAssignmentForUserGroupWithDimensionRequest {
    /**
     * The id of the UserGroup
     */
    UserGroupId: number;
    /**
     * The dimension id to use.
     */
    TargetDimensionId: number;
}
/**
 * Returns the target assignment for the specified year, entity type and dimension.
 * Returns TargetAssignment
 */
export interface Targets_GetTargetAssignmentForYearAndDimensionRequest {
    /**
     * Targeted year
     */
    TargetYear: number;
    /**
     * Targeted entity type
     */
    EntityType: enums.TargetEntityType;
    /**
     * The level of target the id is referring to.
     */
    TargetLevel: enums.TargetLevel;
    /**
     * Contact, UserGroup or Associate id.
     */
    Id: number;
    /**
     * Id of dimension.
     */
    DimensionId: number;
}
/**
 * Returns a default target assignment for the owner company, for the specified year and dimension.
 * Returns TargetAssignment[]
 */
export interface Targets_CreateDefaultTargetAssignmentForCompanyWithYearAndDimensionRequest {
    /**
     * The year from which to retrieve dimension data.
     */
    Year: number;
    /**
     * The dimension id to use.
     */
    TargetDimensionId: number;
}
/**
 * Returns a default target assignment for the specified usergroup, for the specified year and dimension.
 * Returns TargetAssignment[]
 */
export interface Targets_CreateDefaultTargetAssignmentForUserGroupWithYearAndDimensionRequest {
    /**
     * The id of the UserGroup
     */
    UserGroupId: number;
    /**
     * The year from which to retrieve dimension data.
     */
    Year: number;
    /**
     * The dimension id to use.
     */
    TargetDimensionId: number;
}
/**
 * Target field change
 */
export interface TargetChange extends Carrier {
    /**
     * What field was changed - target_group.period_type or target_assignment_value.month01.target_value or target_assignment_value.quarter01.target_value etc.
     */
    FieldIdentifier?: string;
    /**
     * Previous value
     */
    ValueChangeFrom?: number;
    /**
     * New value
     */
    ValueChangeTo?: number;
}
/**
 * Target Dimension carrier
 */
export interface TargetDimension extends Carrier {
    /**
     * Primary key
     */
    TargetDimensionId?: number;
    /**
     * What level this dimension can be assigned to (Company, Group, Associate)
     */
    AssignmentLevel?: enums.TargetAssignementLevel;
    /**
     * Entity type for this set of targets (Sale, Project, Selection, Appointment...)
     */
    EntityType?: enums.TargetEntityType;
    /**
     * What to measure (Amount, Count, Profit...
     */
    MeasurementUnit?: enums.TargetMeasurementUnit;
    /**
     * List that defines the dimensions for this target matrix (ex: Sale type, source, partner, business, udef or extrafield lists...)
     */
    DimensionListField?: string;
    /**
     * List name (can be used by list provider system to get list items)
     */
    DimensionListName?: string;
    /**
     * List id (can be used by list provider system to get list items)
     */
    DimensionListId?: number;
    /**
     * list label (list column name)
     */
    DimensionListLabel?: string;
    /**
     * id's of the selected/wanted dimensions (what sale types or udef list lines that should be target dimensions)
     */
    SelectedDimensions?: number[];
}
/**
 * Returns the target dimensions for the given entity type.
 * Returns TargetDimension[]
 */
export interface Targets_GetTargetDimensionsForEntityTypeRequest {
    /**
     * Targeted entity type
     */
    EntityType: enums.TargetEntityType;
}
/**
 * Returns ids of the target groups that use this dimension.
 * Returns number[]
 */
export interface Targets_GetTargetGroupIdsRequest {
    /**
     * The target dimension id
     */
    TargetDimensionId: number;
}
/**
 * Target Group carrier
 */
export interface TargetGroup extends Carrier {
    /**
     * Primary key
     */
    TargetGroupId?: number;
    /**
     * The year this set of targets are associated with (2020, 2021...)
     */
    Year?: number;
    /**
     * Entity type for this set of targets (Sale, Project, Selection, Appointment...)
     */
    EntityType?: enums.TargetEntityType;
    /**
     * Period type for editing this set of targets (Year, Quarter...)
     */
    PeriodType?: enums.TargetPeriodType;
    /**
     * Collection of target values
     */
    TargetAssignments?: TargetAssignment[];
    /**
     * Info about the target dimensions
     */
    TargetDimension?: TargetDimension;
}
/**
 * Returns the target group for the specified year and entity type.
 * Returns TargetGroup
 */
export interface Targets_GetTargetGroupForYearRequest {
    /**
     * Targeted year
     */
    TargetYear: number;
    /**
     * Targeted entity type
     */
    EntityType: enums.TargetEntityType;
}
/**
 * Renders the given targetgroup to excel, and returns the path to the temporary file.
 * Returns ExportArchiveResult
 */
export interface Targets_ExportTargetGroupToExcelRequest {
    /**
     * The id of the targetgroup to be rendered to excel.
     */
    TargetGroupId: number;
}
/**
 * Returns the target group for the specified year and dimension.
 * Returns TargetGroup
 */
export interface Targets_GetTargetGroupForYearAndDimensionRequest {
    /**
     * Targeted year
     */
    TargetYear: number;
    /**
     * Targeted dimension Id
     */
    DimensionId: number;
}
/**
 * Target revision carrier
 */
export interface TargetRevision extends Carrier {
    /**
     * Log event class (create, edit, delete, lock, unlock...
     */
    LogEvent?: enums.LogEvent;
    /**
     * Who made the change
     */
    Who?: Associate;
    /**
     * Registered when
     */
    When?: Date;
    /**
     * Collection of changes
     */
    Changes?: TargetChange[];
}
/**
 * Target revision history carrier
 */
export interface TargetRevisionHistory extends Carrier {
    /**
     * The group id - but it may not still exist
     */
    TargetGroupId?: number;
    /**
     * The year this set of targets are associated with (2020, 2021...)
     */
    Year?: number;
    /**
     * Collection of revisions (with changes)
     */
    Revisions?: TargetRevision[];
}
/**
 * Returns the revision history for a given TargetAssignmentInfo in chronological order.
 * Returns TargetRevisionHistory
 */
export interface Targets_GetTargetRevisionHistoryRequest {
    /**
     * Target assignment info id
     */
    TargetAssignmentInfoId: number;
}
/**
 * Favourite carrier.
 */
export interface Favourite extends Carrier {
    /**
     * Name of the table this favourite belongs to.
     */
    TableName?: string;
    /**
     * Id of the record this favourite belongs to.
     */
    RecordId?: number;
    /**
     * Id of the associate this favourite belongs to.
     */
    AssociateId?: number;
    /**
     * Extra information for this favourite.
     */
    ExtraInfo?: string;
    /**
     * Rank order
     */
    Rank?: number;
}
/**
 * Checks if a record in a table is a favourite for an associate
 * Returns boolean
 */
export interface Favourite_IsFavouriteRequest {
    /**
     * Table name, transformed to and from numeric table id by the service layer.
     */
    TableName: string;
    /**
     * Id of a record in your specified table (tableName)
     */
    RecordId: number;
    /**
     * Id of a current user
     */
    AssociateId: number;
}
/**
 * Add a record in a table as a favourite for an associate
 */
export interface Favourite_AddFavouriteRequest {
    /**
     * Table name, transformed to and from numeric table id by the service layer.
     */
    TableName: string;
    /**
     * Id of a record in your specified table (tableName)
     */
    RecordId: number;
    /**
     * Id of a current user
     */
    AssociateId: number;
    /**
     * Any extra information
     */
    ExtraInfo: string;
}
/**
 * Add a list of record ids as favourites for an associate
 */
export interface Favourite_AddFavouritesRequest {
    /**
     * Table name, transformed to and from numeric table id by the service layer.
     */
    TableName: string;
    /**
     * Ids of records in your specified table (tableName). Corresponding rows will be added as Favourites.
     */
    RecordIds: number[];
    /**
     * Id of a current user
     */
    AssociateId: number;
    /**
     * Any extra information
     */
    ExtraInfo: string;
}
/**
 * Add a list of tickets as favourites that are given by the ticket provider.
 */
export interface Favourite_AddTicketsToFavouritesByProviderRequest {
    /**
     * Name of a ticket provider
     */
    ProviderName: string;
    /**
     * Query restrictions to be added to provider. Fixed providers, such as LastTicketsProvider, FavouriteTicketsProvider etc. already have mandatory restrictions setup - in such case extra restrictions will be combined, however for general use case for fixed providers you can pass an empty array and provider will return default results. For selection providers generally you should pass selectionId as a restriction.
     */
    Restrictions: ArchiveRestrictionInfo[];
    /**
     * Id of a current user
     */
    AssociateId: number;
    /**
     * Any extra information
     */
    ExtraInfo: string;
}
/**
 * Remove a list of record ids from favourites for an associate
 */
export interface Favourite_RemoveFavouritesRequest {
    /**
     * Table name, transformed to and from numeric table id by the service layer.
     */
    TableName: string;
    /**
     * Ids of records in your specified table (tableName). Corresponding rows will be removed from Favourites.
     */
    RecordIds: number[];
    /**
     * Id of a current user
     */
    AssociateId: number;
}
/**
 * Remove a list of tickets from favourites that are given by the ticket provider.
 */
export interface Favourite_RemoveTicketsFromFavouritesByProviderRequest {
    /**
     * Name of a ticket provider
     */
    ProviderName: string;
    /**
     * Query restrictions to be added to provider. Fixed providers, such as LastTicketsProvider, FavouriteTicketsProvider etc. already have mandatory restrictions setup - in such case extra restrictions will be combined, however for general use case for fixed providers you can pass an empty array and provider will return default results. For selection providers generally you should pass selectionId as a restriction.
     */
    Restrictions: ArchiveRestrictionInfo[];
    /**
     * Id of a current user
     */
    AssociateId: number;
}
/**
 * Get all favourites for a table and associate
 * Returns Favourite[]
 */
export interface Favourite_GetFavouritesRequest {
    /**
     * Table name, transformed to and from numeric table id by the service layer.
     */
    TableName: string;
    /**
     * Id of a current user
     */
    AssociateId: number;
}
/**
 * Remove favourite for a table, record id and associate
 */
export interface Favourite_RemoveFavouriteRequest {
    /**
     * Table name, transformed to and from numeric table id by the service layer.
     */
    TableName: string;
    /**
     * Id of a record in your specified table (tableName)
     */
    RecordId: number;
    /**
     * Id of a current user
     */
    AssociateId: number;
}
/**
 * Remove all favourites for a table and associate
 */
export interface Favourite_RemoveAllFavouritesRequest {
    /**
     * Table name, transformed to and from numeric table id by the service layer.
     */
    TableName: string;
    /**
     * Id of a current user
     */
    AssociateId: number;
}
/**
 * Toggle a record in a table as a favourite for an associate
 * Returns boolean
 */
export interface Favourite_ToggleFavouriteRequest {
    /**
     * Table name, transformed to and from numeric table id by the service layer.
     */
    TableName: string;
    /**
     * Id of a record in your specified table (tableName)
     */
    RecordId: number;
    /**
     * Id of a current user
     */
    AssociateId: number;
    /**
     * Any extra information
     */
    ExtraInfo: string;
}
/**
 * Remove favourite using favourite id
 */
export interface Favourite_RemoveFavouritesByIdRequest {
    /**
     * Ids of favourite rows to delete
     */
    FavouriteIds: number[];
}
/**
 * Information about a dictionary step
 */
export interface DictionaryStepInformation extends Carrier {
    /**
     * The name of the dictionary step (from attribute, not class name)
     */
    Name?: string;
    /**
     * Generation number of step
     */
    StepNumber?: number;
}
/**
 * Get information about the dictionary steps that are in the currently-loggedon database
 * Returns DictionaryStepInformation[]
 */
export interface Database_GetStepsInDatabaseRequest {
}
/**
 * Get information about the dictionary steps that NetServer was generated for
 * Returns DictionaryStepInformation[]
 */
export interface Database_GetStepsFromNetServerCodeRequest {
}
/**
 * This class carries information about the definition and properties of an field used in bulk update system. The class is serializable and used on both the application and Web server sides.
 */
export interface ControlInfo extends Carrier {
    /**
     *
     */
    Type?: string;
    /**
     *
     */
    Label?: string;
    /**
     *
     */
    Dimension?: number;
    /**
     *
     */
    ListProviderName?: string;
    /**
     *
     */
    ListProviderExtraInfo?: string;
    /**
     *
     */
    ListProviderPrimaryKeyName?: string;
    /**
     *
     */
    ListLeadText?: string;
}
/**
 * This class carries information about the definition and properties of an field used in bulk update system. The class is serializable and used on both the application and Web server sides.
 */
export interface FieldValueInfo {
    /**
     * Can the field support multi use?
     */
    CanSupportMultiUse?: boolean;
    /**
     * Default show in Gui?
     */
    DefaultShowInGui?: boolean;
    /**
     * Default show in selector?
     */
    DefaultShowInSelector?: boolean;
    /**
     * True if the field and operations will be used in the bulk update
     */
    IsActive?: boolean;
    /**
     * The unique key on the field
     */
    Key?: string;
    /**
     * Describes the expected value array
     */
    ValueType?: string;
    /**
     * True if this is a mandatory field
     */
    Mandatory?: boolean;
    /**
     * The displayname of the field
     */
    EncodedDisplayName?: string;
    /**
     * The description of the field
     */
    EncodedDisplayDescription?: string;
    /**
     * The iconhint of the field
     */
    IconHint?: string;
    /**
     * Array of the controlinfos
     */
    ControlInfos?: ControlInfo[];
    /**
     *
     */
    EncodedDataCaption?: string;
    /**
     *
     */
    EncodedDataCaptionDescription?: string;
    /**
     * The selected operation to execute on this field
     */
    CurrentOperationType?: string;
    /**
     * The values to be set on this field on this bulkupdate
     */
    Values?: string[];
    /**
     * The displayvalues to be set on this field on this bulkupdate, used to resolve when values array contains ids
     */
    DisplayValues?: string[];
    /**
     * Array of the available operations for this field
     */
    OperationInfos?: OperationInfo[];
}
/**
 * Get all available fields for a given tablename/entity
 * Returns FieldValueInfo[]
 */
export interface BulkUpdate_GetAvailableFieldsRequest {
    /**
     * The name of the wanted tablename
     */
    Tablename: string;
}
/**
 * Get all stored fields for a given tablename/entity and context
 * Returns FieldValueInfo[]
 */
export interface BulkUpdate_GetStoredFieldsRequest {
    /**
     * The name of the wanted tablename
     */
    Tablename: string;
    /**
     * Where is the function called for
     */
    Context: string;
}
/**
 * Do the batchupdate on this selection
 * Returns number
 */
export interface BulkUpdate_ExecuteBySelectionIdRequest {
    /**
     * The name of the wanted tablename
     */
    FieldValueInfos: FieldValueInfo[];
    /**
     * The name of the table to bulk update
     */
    TableName: string;
    /**
     * Where is the function called for
     */
    Context: string;
    /**
     * The id of the selection
     */
    SelectionId: number;
    /**
     * Use the shadow selection
     */
    IsShadow: boolean;
}
/**
 * Do the batchupdate on selected
 * Returns number
 */
export interface BulkUpdate_ExecuteByEntityIdsRequest {
    /**
     * The name of the wanted tablename
     */
    FieldValueInfos: FieldValueInfo[];
    /**
     * The name of the table to bulk update
     */
    TableName: string;
    /**
     * Where is the function called from
     */
    Context: string;
    /**
     * Comma separated string of the ids of the entities to update
     */
    Ids: string;
}
/**
 * Get result of the batchupdate job
 * Returns string[]
 */
export interface BulkUpdate_GetJobResultsFromStorageAsJsonRequest {
}
/**
 * Remove the stored settings of the bulk update for this table from this context
 * Returns boolean
 */
export interface BulkUpdate_RemoveStoredFieldsRequest {
    /**
     * The name of the table to remove stored settings from
     */
    TableName: string;
    /**
     * Where is the function called from that we will remove the settings from
     */
    Context: string;
}
/**
 * Remove the stored settings of the bulk update for this table from this context, to get the default settings instead
 * Returns FieldValueInfo[]
 */
export interface BulkUpdate_RemoveStoredFieldsAndGetDefaultFieldsRequest {
    /**
     * The name of the table to remove stored settings from
     */
    TableName: string;
    /**
     * Where is the function called from that we will remove the settings from
     */
    Context: string;
}
/**
 * Get result of the batchupdate job
 * Returns string
 */
export interface BulkUpdate_GetJobResultAsJsonFromBinaryObjectIdRequest {
    /**
     * The name of the table that was updated to show the log from
     */
    TableName: string;
    /**
     * Which binaryobject id has stored the job result
     */
    BinaryObjectId: number;
}
/**
 * This class carries information about the definition and properties of an field used in bulk update system. The class is serializable and used on both the application and Web server sides.
 */
export interface OperationInfo extends Carrier {
    /**
     *
     */
    Key?: string;
    /**
     *
     */
    EncodedDisplayName?: string;
    /**
     *
     */
    EncodedLeadTexts?: string[];
}
/**
 * Definition and configuration of a Form
 */
export interface FormEntity extends Carrier {
    /**
     * Primary key
     */
    FormId?: number;
    /**
     * A short string used as unique id to access this form
     */
    FormKey?: string;
    /**
     * The name of this form
     */
    Name?: string;
    /**
     * Detailed description
     */
    Description?: string;
    /**
     * The JSON-formatted config of this form
     */
    Config?: string;
    /**
     * The folder which this form belongs to. -1 indicates that the shipment is on the root
     */
    FolderId?: number;
    /**
     * The CRMScript Macro which will be run when the form is submitted.
     */
    ScriptId?: number;
    /**
     * The id of the s_shipment that is used to send the response mails
     */
    ResponseShipmentId?: number;
    /**
     * Indicates if this form is active or not
     */
    Active?: boolean;
    /**
     * After this datetime, the form will become inactive
     */
    Expires?: Date;
    /**
     * After this number of submits, the form will become inactive
     */
    MaxSubmits?: number;
    /**
     * What kind of form is this? Indicates if this is a normal form or a template
     */
    Type?: enums.FormType;
    /**
     * The JSON-formatted recipe of this form
     */
    Recipe?: string;
    /**
     * The group which this form belongs to.
     */
    GroupId?: number;
    /**
     * Indicates if this form creates a ticket or not
     */
    NewTicket?: boolean;
    /**
     * What is the state of the recaptcha configuration? This is a read-only member
     */
    RecaptchaMode?: enums.FormsRecaptchaMode;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Registered by whom
     */
    RegisteredAssociateId?: number;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Last updated by whom
     */
    UpdatedAssociateId?: number;
    /**
     * Number of updates made to this record
     */
    UpdatedCount?: number;
    /**
     * The name of the folder for this form
     */
    FolderName?: string;
}
/**
 * This method will try to verify a Google recaptcha token. The token is gained from the recaptcha frontend component
 * Returns boolean
 */
export interface Marketing_VerifyGoogleRecaptchaRequest {
    /**
     * The token to be verified
     */
    Token: string;
    /**
     * Use an optional secret key instead of the system wide
     */
    OptionalSecretKey: string;
}
/**
 * Content of a Form submission
 */
export interface FormSubmissionEntity extends Carrier {
    /**
     * Primary key
     */
    FormSubmissionId?: number;
    /**
     * The id of the parent form.
     */
    FormId?: number;
    /**
     * The time of the submit.
     */
    WhenSubmitted?: Date;
    /**
     * The optional id of the contact of the person who submitted.
     */
    ContactId?: number;
    /**
     * The optional id of the person who submitted.
     */
    PersonId?: number;
    /**
     * The email address of the person who submitted
     */
    EmailAddress?: string;
    /**
     * The id of the s_shipment_addr that is the response mail
     */
    ResponseShipmentAddrId?: number;
    /**
     * The JSON-formatted response from this form
     */
    Response?: string;
    /**
     * What is the status of this submission
     */
    Status?: enums.FormSubmissionStatus;
    /**
     * A log of what happened during processing
     */
    ProcessingLog?: string;
}
/**
 * Methods for calculating mailing statistics
 */
export interface MailingStatistics extends Carrier {
}
/**
 * Calculate open and click rates for one or more mailings
 * Returns number
 */
export interface Marketing_CalculateMailingStatisticsRequest {
    /**
     * If 0, calculate rates for all dirty (are_statistics_dirty) shipments
     */
    ShipmentId: number;
}
/**
 * Get counnt of submissions for given form and status. Count for all forms is returned if negative formId is given
 * Returns number
 */
export interface Marketing_GetFormSubmissionsCountRequest {
    /**
     * If 0 or less, return count for all forms
     */
    FormId: number;
    /**
     * Which status the submissions should have. If Unknown, return count of all statuses
     */
    Status: enums.FormSubmissionStatus;
}
/**
 * A shipment message with information about the recipient it was sent to.
 */
export interface PreviewMailing extends Carrier {
    /**
     * Estimated or actual sent time (depends on status)
     */
    SendingTime?: Date;
    /**
     * Status for sending to this particular recipient
     */
    Status?: enums.ShipmentAddrStatus;
    /**
     * Primary key
     */
    ShipmentId?: number;
    /**
     * Describes the shipment
     */
    ShipmentDescription?: string;
    /**
     * Email address to put in the From header of the messages
     */
    FromAddress?: string;
    /**
     * Owning contact ID
     */
    ContactId?: number;
    /**
     * Contact name
     */
    ContactName?: string;
    /**
     * Primary key
     */
    PersonId?: number;
    /**
     * Get the persons full name (internal name used in clients for employees).
     */
    PersonFullName?: string;
    /**
     * The list item
     */
    ShipmentType?: string;
    /**
     * Primary key
     */
    MessageId?: number;
    /**
     * The mail subject field of the message
     */
    MessageSubject?: string;
    /**
     * If a document was used as the message this is the document ID.
     */
    DocumentMessageId?: number;
    /**
     * Date/time the customer read the mailing.
     */
    Opened?: Date;
    /**
     * The number of links clicked in the mailing.
     */
    LinkClicks?: number;
}
/**
 * Get a shipment message from its shipment address id
 * Returns PreviewMailing
 */
export interface Marketing_GetPreviewMailingRequest {
    /**
     * Shipment address id
     */
    ShipmentAddrId: number;
}
/**
 * A shipment with information intended for previewing it.
 */
export interface PreviewMailingHeader extends Carrier {
    /**
     * The date and time when to start this shipment
     */
    StartDate?: Date;
    /**
     * Sending/stopped/failed etc.
     */
    Status?: enums.ShipmentStatus;
    /**
     * Primary key
     */
    ShipmentId?: number;
    /**
     * Describes the shipment
     */
    ShipmentDescription?: string;
    /**
     * Email address to put in the From header of the messages
     */
    FromAddress?: string;
    /**
     * Primary key
     */
    PersonId?: number;
    /**
     * Get the persons full name (internal name used in clients for employees).
     */
    PersonFullName?: string;
    /**
     * The list item
     */
    ShipmentType?: string;
    /**
     * Primary key
     */
    MessageId?: number;
    /**
     * The mail subject field of the message
     */
    MessageSubject?: string;
    /**
     * If a document was used as the message this is the document ID.
     */
    DocumentMessageId?: number;
    /**
     * Number of emails sent at the current time.
     */
    NumSent?: number;
    /**
     * Number of recipients that opened the email.
     */
    NumOpened?: number;
    /**
     * Number of recipients that resulted in a bounce.
     */
    NumBounced?: number;
    /**
     * Number of recipients that clicked at least 1 link in the mailing.
     */
    NumClicks?: number;
}
/**
 * Get a shipment from its shipment id
 * Returns PreviewMailingHeader
 */
export interface Marketing_GetPreviewMailingHeaderRequest {
    /**
     * Shipment id
     */
    ShipmentId: number;
}
/**
 * This entity contains information about design blocks that can be used in a shipment/mailing message
 */
export interface ShipmentMessageBlockEntity extends Carrier {
    /**
     * Primary key
     */
    ShipmentMessageBlockId?: number;
    /**
     * The associate that owns this block
     */
    AssociateId?: number;
    /**
     * The block definition. Normally this will be a json structure
     */
    Block?: string;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Registered by whom
     */
    RegisteredAssociateId?: number;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Last updated by whom
     */
    UpdatedAssociateId?: number;
    /**
     * Number of updates made to this record
     */
    UpdatedCount?: number;
}
/**
 * Get the saved user blocks to be used in a shipment/mailing message
 * Returns ShipmentMessageBlockEntity[]
 */
export interface Marketing_GetUserBlocksRequest {
    /**
     * The associate id to get the user blocks. 0 will get all saved blocks
     */
    AssociateId: number;
}
/**
 * A shipment message, that contains the actual message being sent out in a mailing
 */
export interface ShipmentMessageEntity extends Carrier {
    /**
     * Primary key
     */
    ShipmentMessageId?: number;
    /**
     * Plain message text of this message
     */
    PlainMessage?: string;
    /**
     * HTML formatted text of this message
     */
    HtmlMessage?: string;
    /**
     * SMS version of this message
     */
    SmsMessage?: string;
    /**
     * Describes this message
     */
    Description?: string;
    /**
     * The mail subject field of the message
     */
    Subject?: string;
    /**
     * The folder which this message belongs to. -1 indicates that the message is on the root
     */
    FolderId?: number;
    /**
     * Extra header fields added to mail. Must be formatted correctly
     */
    HeaderField?: string;
    /**
     * Will contain the design part of a message. The format will vary based on the type of designer used to create the message
     */
    Design?: string;
    /**
     * Enum containing the type of the design
     */
    Designtype?: enums.DesignType;
    /**
     * Identifies if HTML or plain message is included in message.
     */
    Flags?: enums.ShipmentMessageType;
    /**
     * Register message views?
     */
    RegisterViews?: boolean;
    /**
     * Should images be included inline?
     */
    InlineImages?: boolean;
    /**
     * A field for a long description of this template
     */
    LongDescription?: string;
    /**
     * Key used for access verification
     */
    AccessKey?: string;
    /**
     * The SM document used as template for this mailing
     */
    DocumentMessage?: number;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Registered by whom
     */
    RegisteredAssociateId?: number;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Last updated by whom
     */
    UpdatedAssociateId?: number;
    /**
     * Number of updates made to this record
     */
    UpdatedCount?: number;
}
/**
 * The Script Service. The service implements all services working with the CRMScript object without reference to primary keys. Primarily used by VSCode integration.
 */
export interface Script extends Carrier {
    /**
     * Global unique identifier, accross customers/tenants
     */
    UniqueIdentifier?: string;
    /**
     * A description of this script
     */
    Name?: string;
    /**
     * Optional description of what this script is used for.
     */
    Description?: string;
    /**
     * A unique name used for including this script in another
     */
    IncludeId?: string;
    /**
     * The script
     */
    Source?: string;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Who created this script
     */
    RegisteredBy?: string;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Who updated this script
     */
    UpdatedBy?: string;
    /**
     * Path to script in the hierarchy.
     */
    Path?: string;
}
/**
 * Get information about a script from a unique identifier
 * Returns Script
 */
export interface CRMScript_GetCRMScriptByUniqueIdentifierRequest {
    /**
     * Global unique reference to script (independent of installation)
     */
    UniqueIdentifier: string;
}
/**
 * Create or Update the CRMScript information
 * Returns Script
 */
export interface CRMScript_SaveCRMScriptByUniqueIdentifierRequest {
    /**
     * Global unique reference to script (independent of installation)
     */
    UniqueIdentifier: string;
    /**
     * Information about the CRMScript
     */
    Crmscript: Script;
}
/**
 * Delete the CRMScript
 */
export interface CRMScript_DeleteCRMScriptByUniqueIdentifierRequest {
    /**
     * Global unique reference to script (independent of installation)
     */
    UniqueIdentifier: string;
}
/**
 * CRM Scripts - stored in the ejScript table, including source code.
 */
export interface CRMScriptEntity extends Carrier {
    /**
     * Primary key
     */
    EjscriptId?: number;
    /**
     * Global unique identifier, accross customers/tenants
     */
    UniqueIdentifier?: string;
    /**
     * A description of this script
     */
    Name?: string;
    /**
     * Optional description of what this script is used for.
     */
    Description?: string;
    /**
     * A unique name used for including this script in another
     */
    IncludeId?: string;
    /**
     * The script is inside this hierarchy folder
     */
    HierarchyId?: number;
    /**
     * The script
     */
    Source?: string;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Registered by whom
     */
    RegisteredAssociateId?: number;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Last updated by whom
     */
    UpdatedAssociateId?: number;
}
/**
 * Execute a CRMScript with parameters, returning printed output value.
 * Returns string
 */
export interface CRMScript_ExecuteScriptRequest {
    /**
     * The id of the CRMScript to execute
     */
    CRMScriptId: number;
    /**
     * Parameters passed as variables to the CRMScript
     */
    Parameters: StringDictionary;
}
/**
 * Execute a CRMScript with parameters, returning printed output value.
 * Returns string
 */
export interface CRMScript_ExecuteScriptByIncludeIdRequest {
    /**
     * The include id of the CRMScript to validate
     */
    CRMScriptIncludeId: string;
    /**
     * Parameters passed as variables to the CRMScript
     */
    Parameters: StringDictionary;
}
/**
 * Execute a CRMScript with parameters, returning printed output value.
 * Returns string
 */
export interface CRMScript_ExecuteScriptByUniqueIdRequest {
    /**
     * The unique id of the CRMScript to validate
     */
    CRMScriptUniqueId: string;
    /**
     * Parameters passed as variables to the CRMScript
     */
    Parameters: StringDictionary;
}
/**
 * Execute a CRMScript with event data as input. Returns event data with output variable values.
 * Returns EventData
 */
export interface CRMScript_ExecuteScriptAsEventRequest {
    /**
     * The id of the CRMScript to execute
     */
    CRMScriptId: number;
    /**
     * The EventData instance sent to the crmscript with input values
     */
    EventData: EventData;
}
/**
 * Execute a CRMScript with event data as input. Returns event data with output variable values.
 * Returns EventData
 */
export interface CRMScript_ExecuteScriptAsEventByUniqueIdRequest {
    /**
     * The unique id of the CRMScript to execute
     */
    CRMScriptUniqueId: string;
    /**
     * The EventData instance sent to the crmscript with input values
     */
    EventData: EventData;
}
/**
 * Validate a CRMScript. This will check that the syntax is correct
 * Returns CRMScriptResult
 */
export interface CRMScript_ValidateScriptRequest {
    /**
     * The id of the CRMScript to execute
     */
    CRMScriptId: number;
}
/**
 * Validate a CRMScript. This will check that the syntax is correct
 * Returns CRMScriptResult
 */
export interface CRMScript_ValidateScriptByIncludeIdRequest {
    /**
     * The include id of the CRMScript to validate
     */
    CRMScriptIncludeId: string;
}
/**
 * Validate a CRMScript. This will check that the syntax is correct
 * Returns CRMScriptResult
 */
export interface CRMScript_ValidateScriptByUniqueIdRequest {
    /**
     * The unique id of the CRMScript to validate
     */
    CRMScriptUniqueId: string;
}
/**
 * Object for returning information when validating a CRMScript
 */
export interface CRMScriptResult extends Carrier {
    /**
     * True if the CRMScript was successfully validated. If false, see the error message for details
     */
    Valid?: boolean;
    /**
     * Contains the error message for a non-valide CRMScript
     */
    ErrorMessage?: string;
}
/**
 * CRM Trigger Script - The script runs when a given event fires.
 */
export interface TriggerScriptEntity extends Carrier {
    /**
     * Primary key
     */
    ScreenChooserId?: number;
    /**
     * Optional description of what this script is used for.
     */
    Name?: string;
    /**
     * Event id that triggers script.  See EventHandlerType enum.
     */
    ScreenType?: enums.EventHandlerType;
    /**
     * Whether this screen chooser is enabled or not
     */
    Enabled?: boolean;
    /**
     * Global unique identifier, accross customers/tenants
     */
    UniqueIdentifier?: string;
    /**
     * The CRMscript code for this event handler
     */
    Source?: string;
    /**
     * Registered when
     */
    Registered?: Date;
    /**
     * Registered by whom
     */
    RegisteredAssociateId?: number;
    /**
     * Last updated when
     */
    Updated?: Date;
    /**
     * Last updated by whom
     */
    UpdatedAssociateId?: number;
}
/**
 * Get a trigger CRMScript.
 * Returns TriggerScriptEntity
 */
export interface CRMScript_GetTriggerScriptByUniqueIdRequest {
    /**
     * The unique id of the CRMScript to validate
     */
    TriggerScriptUniqueId: string;
}
/**
 * Validate a CRMScript. This will check that the syntax is correct
 * Returns TriggerScriptEntity
 */
export interface CRMScript_SaveTriggerScriptByUniqueIdRequest {
    /**
     * The unique id of the CRMScript to validate
     */
    TriggerScriptUniqueId: string;
    /**
     * Trigger script details and source code
     */
    Entity: TriggerScriptEntity;
}
/**
 * Delete a trigger CRMScript.
 */
export interface CRMScript_DeleteTriggerScriptByUniqueIdRequest {
    /**
     * The unique id of the CRMScript to validate
     */
    TriggerScriptUniqueId: string;
}
/**
 * Validate a Trigger CRMScript. This will check that the syntax is correct, but not execute the script.
 * Returns CRMScriptResult
 */
export interface CRMScript_ValidateTriggerScriptRequest {
    /**
     * The id of the CRMScript Trigger to validate
     */
    TriggerScriptId: number;
}
/**
 * Validate a Trigger CRMScript. This will check that the syntax is correct, but not execute the script.
 * Returns CRMScriptResult
 */
export interface CRMScript_ValidateTriggerScriptByUniqueIdRequest {
    /**
     * The unique id of the CRMScript to validate
     */
    TriggerScriptUniqueId: string;
}
/**
 * The Attachment carrier represent meta data for a Service attachment
 */
export interface AttachmentEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    AttachmentId?: number;
    /**
     * The filename for the attachment.
     */
    Name?: string;
    /**
     * The content type for the attachment (e.g. &apos;applaction/octet-stream&apos; or &apos;application/vnd.openxmlformats-officedocument.wordprocessingml.document&apos;).
     */
    ContentType?: string;
    /**
     * The size (in bytes) for the attachment.
     */
    AttSize?: number;
    /**
     * True if this attachment is inlined in the html_body.
     */
    InlineImage?: boolean;
    /**
     * The content_id of this attachment, used for inline images
     */
    ContentId?: string;
    /**
     * The key used for authenticating access to this attachment.
     */
    AuthKey?: string;
}
/**
 * Copy CRM document to an attachment
 * Returns AttachmentEntity
 */
export interface Ticket_CopyFromCRMDocumentRequest {
    /**
     * The id of the document to copy to an attachment
     */
    DocumentId: number;
}
/**
 * Copy ticket attachment to temporary file. Needed for existing document dialog compatibility
 * Returns string
 */
export interface Ticket_CopyToTempFileRequest {
    /**
     * Preferred filename
     */
    Filename: string;
    /**
     * The id of the attachment to copy
     */
    AttachmentId: number;
}
/**
 * Upload the content for an attachment
 */
export interface Ticket_UploadAttachmentRequest {
    /**
     * The id of the attachment row, for which to attach the upload data
     */
    AttachmentId: number;
    /**
     * A stream to the content to be uploaded
     */
    Content: ArrayBuffer | string;
}
/**
 * Get the content of an attachment
 * Returns Blob
 */
export interface Ticket_GetAttachmentStreamRequest {
    /**
     * The id of the attachment to retrieve
     */
    AttachmentId: number;
}
/**
 * Attachment validation info
 */
export interface AttachmentValidationResult {
    /**
     * The primary key (auto-incremented)
     */
    AttachmentId?: number;
    /**
     * Indicates if the attachment is valid
     */
    IsValid?: boolean;
    /**
     * Error message for invalid attachment
     */
    ErrorMessage?: string;
}
/**
 * The ticket carrier is used for representing a service request.
 */
export interface Ticket extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    TicketId?: number;
    /**
     * The title of the ticket.
     */
    Title?: string;
    /**
     * When the ticket was created.
     */
    CreatedAt?: Date;
    /**
     * The last time the ticket was modified.
     */
    LastChanged?: Date;
    /**
     * The datetime for when the ticket last was read by the owner.
     */
    ReadByOwner?: Date;
    /**
     * The datetime for when the ticket was read by the customer.
     */
    ReadByCustomer?: Date;
    /**
     * The datetime for when the ticket first was read by a user.
     */
    FirstReadByUser?: Date;
    /**
     * When the ticket should be activated, if it is postponed.
     */
    Activate?: Date;
    /**
     * When the ticket was closed.
     */
    ClosedAt?: Date;
    /**
     * The datetime for when the ticket was replied to. I.e. the first external message added to the ticket.
     */
    RepliedAt?: Date;
    /**
     * The datetime for when the ticket should jump to the next alert_level.
     */
    AlertTimeout?: Date;
    /**
     * Deadline for ticket.
     */
    Deadline?: Date;
    /**
     * The id of the user who created the ticket. 1 (system user) if the ticket was created externally
     */
    CreatedBy?: number;
    /**
     * Initials, also login name, possibly database user name
     */
    CreatedByName?: string;
    /**
     * A string representing the author of the ticket (same as author of first message).
     */
    Author?: string;
    /**
     * The id of the user who owns the ticket. 1 (system user) if the ticket is unassigned.
     */
    OwnedBy?: number;
    /**
     * Initials, also login name, possibly database user name
     */
    OwnedByName?: string;
    /**
     * The id of the category a ticket is in.
     */
    Category?: number;
    /**
     * The (short) name of this category. E.g. &apos;support&apos;.
     */
    CategoryName?: string;
    /**
     * The fullname (compiled from parents&apos; names) for this category. E.g. &apos;norway/product A/support&apos;.
     */
    CategoryFullname?: string;
    /**
     * The securitylevel of the ticket.
     */
    Slevel?: enums.TicketSecurityLevel;
    /**
     * The reference to the ticket_priority table.
     */
    Priority?: number;
    /**
     * The name of the priority.
     */
    PriorityName?: string;
    /**
     * The status of the ticket. I.e. active/closed/postponed/deleted
     */
    BaseStatus?: enums.TicketBaseStatus;
    /**
     * User defined ticket status
     */
    TicketStatus?: number;
    /**
     * Get the display name of the ticket status.
     */
    TicketStatusDisplayValue?: string;
    /**
     * What is the origin of this ticket
     */
    Origin?: enums.TicketOrigin;
    /**
     * The reference to the customer. NULL or -1 if ticket is not connected to customer.
     */
    CustId?: number;
    /**
     * First name
     */
    PersonFirstname?: string;
    /**
     * Middle name or 'van' etc.
     */
    PersonMiddleName?: string;
    /**
     * Last name
     */
    PersonLastname?: string;
    /**
     * Get the full name for the primary person (customer)
     */
    PersonFullname?: string;
    /**
     * The alert level for the ticket. Matches the level value of the ticket_alert table.
     */
    AlertLevel?: number;
    /**
     * If a ticket is connected to another ticket, this field is set to the id of the &apos;master&apos; ticket.
     */
    ConnectId?: number;
    /**
     * Whether the owner has read the ticket or not (red, yellow, green).
     */
    ReadStatus?: enums.TicketReadStatus;
    /**
     * The time (minutes) between when the ticket was created and when it was replied to. Calculated based on priority&apos;s timeframe.
     */
    TimeToReply?: number;
    /**
     * Same as time_to_reply, but not calculated based on priority.
     */
    RealTimeToReply?: number;
    /**
     * The time (minutes) between when the ticket was created and when it was closed. Calculated based on priority&apos;s timeframe.
     */
    TimeToClose?: number;
    /**
     * Same as time_to_close, but not calculated based on priority.
     */
    RealTimeToClose?: number;
    /**
     * The total time (seconds) within the priority's office hours the ticket has been in an open status (configurable), not including current state
     */
    TimeSpentInternally?: number;
    /**
     * The total time (seconds) within the priority's office hours the ticket has been in a external waiting status (configurable), not including current state
     */
    TimeSpentExternally?: number;
    /**
     * The total time (seconds) within the priority's office hours the ticket has been in a queue status, not including current state
     */
    TimeSpentQueue?: number;
    /**
     * The total time (seconds) within 24x7 the ticket has been in an open status (configurable), not including current state
     */
    RealTimeSpentInternally?: number;
    /**
     * The total time (seconds) within 24x7 the ticket has been in a external waiting status (configurable), not including current state
     */
    RealTimeSpentExternally?: number;
    /**
     * The total time (seconds) within 24x7 hours the ticket has been in a queue status, not including current state
     */
    RealTimeSpentQueue?: number;
    /**
     * Boolean indicating if this ticket has one or more attachments.
     */
    HasAttachment?: boolean;
    /**
     * The number of replies (messages) to the customer for this request.
     */
    NumReplies?: number;
    /**
     * The total number of messages for this request.
     */
    NumMessages?: number;
    /**
     * The from-address used when this ticket got created, e.g. by email
     */
    FromAddress?: string;
    /**
     * The company of the person in the cust_id field, if that person belongs to a company
     */
    ContactId?: number;
    /**
     * The name of the connected contact
     */
    ContactName?: string;
    /**
     * The associate id of the owner of the ticket.
     */
    OwnedByAssociateId?: number;
    /**
     * The language of the first external message
     */
    Language?: string;
    /**
     * The sentiment index of the last external message
     */
    Sentiment?: number;
    /**
     * The sentiment confidence of the last external message
     */
    SentimentConfidence?: number;
    /**
     * Reference to sale table
     */
    SaleId?: number;
    /**
     * Reference to project table
     */
    ProjectId?: number;
    /**
     * The heading of the connected sale
     */
    SaleHeading?: string;
    /**
     * The name of the connected project
     */
    ProjectName?: string;
    /**
     * If this ticket was created from a form submission, this field will point to that record
     */
    FormSubmissionId?: number;
}
/**
 * Get multiple tickets
 * Returns Ticket[]
 */
export interface Ticket_GetTicketsRequest {
    /**
     * The ids of tickets to get
     */
    TicketIds: number[];
}
/**
 * Data to add a batched ticket reply.
 */
export interface TicketBatchReplyData {
    /**
     * IDs of tickets to reply to.
     */
    TicketIds?: number[];
    /**
     * true to close the tickets after replying; otherwise, false.
     */
    CloseTickets?: boolean;
    /**
     * The IDs of attachments to connect to the reply message.
     */
    AttachmentIds?: number[];
    /**
     * The html body for the message (if any).
     */
    HtmlBody?: string;
    /**
     * The securitylevel of the message.
     */
    Slevel?: enums.TicketSecurityLevel;
    /**
     * The time spent (minutes) for this message.
     */
    TimeSpent?: number;
    /**
     * true to email the reply message to customers; otherwise, false.
     */
    SendCopyToCustomer?: boolean;
}
/**
 * The ticket entity is used for representing a service ticket
 */
export interface TicketEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    TicketId?: number;
    /**
     * The title of the ticket.
     */
    Title?: string;
    /**
     * When the ticket was created.
     */
    CreatedAt?: Date;
    /**
     * The last time the ticket was modified.
     */
    LastChanged?: Date;
    /**
     * The datetime for when the ticket last was read by the owner.
     */
    ReadByOwner?: Date;
    /**
     * The datetime for when the ticket was read by the customer.
     */
    ReadByCustomer?: Date;
    /**
     * The datetime for when the ticket first was read by the current owner.
     */
    FirstReadByOwner?: Date;
    /**
     * The datetime for when the ticket first was read by a user.
     */
    FirstReadByUser?: Date;
    /**
     * When the ticket should be activated, if it is postponed.
     */
    Activate?: Date;
    /**
     * When the ticket was closed.
     */
    ClosedAt?: Date;
    /**
     * The datetime for when the ticket was replied to. I.e. the first external message added to the ticket.
     */
    RepliedAt?: Date;
    /**
     * The datetime for when the ticket should jump to the next alert_level.
     */
    AlertTimeout?: Date;
    /**
     * Deadline for ticket.
     */
    Deadline?: Date;
    /**
     * The associate who created this ticket
     */
    CreatedBy?: Associate;
    /**
     * A string representing the author of the ticket (same as author of first message).
     */
    Author?: string;
    /**
     * The associate who owns this ticket. Setting the id to 0 will make the ticket unassigned. Setting the id to 2147483647 (MaxInt) will make it automatically assigned according to the ticket category assignment rules.
     * Use MDO List name "associate" to get list items.
     */
    OwnedBy?: Associate;
    /**
     * The ticket category entity which this ticket is connected to
     * Use MDO List name "ejcategory" to get list items.
     */
    Category?: TicketCategoryEntity;
    /**
     * The securitylevel of the ticket.
     */
    Slevel?: enums.TicketSecurityLevel;
    /**
     * The ticket priority entity which this ticket is connected to
     * Use MDO List name "ticketpriority" to get list items.
     */
    Priority?: TicketPriorityEntity;
    /**
     * The status of the ticket. I.e. active/closed/postponed/deleted
     * Use MDO List name "ticketstatus" to get list items.
     */
    BaseStatus?: enums.TicketBaseStatus;
    /**
     * The ticket status entity which this ticket is connected to
     * Use MDO List name "ticketstatus" to get list items.
     */
    Status?: TicketStatusEntity;
    /**
     * What is the origin of this ticket
     */
    Origin?: enums.TicketOrigin;
    /**
     * The primary person that this ticket is connected to
     * Use MDO List name "person_new" to get list items.
     */
    Person?: Person;
    /**
     * The secondary persons this ticket is connected to
     * Use MDO List name "person_new" to get list items.
     */
    SecondaryPersons?: Person[];
    /**
     * The alert level for the ticket. Matches the level value of the ticket_alert table.
     */
    AlertLevel?: number;
    /**
     * If a ticket is connected to another ticket, this field is set to the id of the &apos;master&apos; ticket.
     */
    ConnectId?: number;
    /**
     * Whether the owner has read the ticket or not (red, yellow, green).
     */
    ReadStatus?: enums.TicketReadStatus;
    /**
     * The time (minutes) between when the ticket was created and when it was replied to. Calculated based on priority&apos;s timeframe.
     */
    TimeToReply?: number;
    /**
     * Same as time_to_reply, but not calculated based on priority.
     */
    RealTimeToReply?: number;
    /**
     * The time (minutes) between when the ticket was created and when it was closed. Calculated based on priority&apos;s timeframe.
     */
    TimeToClose?: number;
    /**
     * Same as time_to_close, but not calculated based on priority.
     */
    RealTimeToClose?: number;
    /**
     * The total time (seconds) within the priority's office hours the ticket has been in an open status (configurable), not including current state
     */
    TimeSpentInternally?: number;
    /**
     * The total time (seconds) within the priority's office hours the ticket has been in a external waiting status (configurable), not including current state
     */
    TimeSpentExternally?: number;
    /**
     * The total time (seconds) within the priority's office hours the ticket has been in a queue status, not including current state
     */
    TimeSpentQueue?: number;
    /**
     * The total time (seconds) within 24x7 the ticket has been in an open status (configurable), not including current state
     */
    RealTimeSpentInternally?: number;
    /**
     * The total time (seconds) within 24x7 the ticket has been in a external waiting status (configurable), not including current state
     */
    RealTimeSpentExternally?: number;
    /**
     * The total time (seconds) within 24x7 hours the ticket has been in a queue status, not including current state
     */
    RealTimeSpentQueue?: number;
    /**
     * Boolean indicating if this ticket has one or more attachments.
     */
    HasAttachment?: boolean;
    /**
     * The number of replies (messages) to the customer for this request.
     */
    NumReplies?: number;
    /**
     * The total number of messages for this request.
     */
    NumMessages?: number;
    /**
     * The from-address used when this ticket got created, e.g. by email
     */
    FromAddress?: string;
    /**
     * TicketMessageId,CreatedAt,SLevel and Important for all the messages connected to this ticket. For message body see the TicketMessageEntity or the TicketMessage archive.
     */
    Messages?: TicketMessage[];
    /**
     * An array containing the tags assigned to this request
     */
    Tags?: Tag[];
    /**
     * The language of the first external message
     */
    Language?: string;
    /**
     * The sentiment index of the last external message
     */
    Sentiment?: number;
    /**
     * The sentiment confidence of the last external message
     */
    SentimentConfidence?: number;
    /**
     * Suggestion for categorization, based on the text of the message (AI)
     */
    SuggestedCategoryId?: number;
    /**
     * Suggested category from AI
     */
    SuggestedCategoryName?: string;
    /**
     * Will contain the category id selected by the user, when having the choice of using the suggested category or manually selecting a category
     */
    OrigHumanCategoryId?: number;
    /**
     * Icon representing ticket's state
     */
    IconHint?: string;
    /**
     * The sale that this ticket is connected to
     * Use MDO List name "sale" to get list items.
     */
    Sale?: Sale;
    /**
     * The project that this ticket is connected to
     * Use MDO List name "project" to get list items.
     */
    Project?: Project;
    /**
     * The form submission that this ticket is connected to
     */
    FormSubmission?: TicketFormSubmission;
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
}
/**
 * Get a ticket entity, adapted to the specific needs of the Request Management UI. WARNING: This endpoint is not guaranteed to be stable/compatible between versions
 * Returns TicketEntity
 */
export interface Ticket_GetForRmUiRequest {
    /**
     * Primary key of ticket to fetch
     */
    TicketId: number;
}
/**
 * Delete a ticket
 */
export interface Ticket_DeleteTicketEntityRequest {
    /**
     * The ticket to delete
     */
    TicketEntityId: number;
}
/**
 * Notify user agents about the creation of a new ticket
 */
export interface Ticket_NotifyNewTicketRequest {
    /**
     * The id of the ticket to notify about
     */
    TicketEntityId: number;
}
/**
 * Notify user agents about the creation of a new message on a ticket
 */
export interface Ticket_NotifyNewTicketMessageRequest {
    /**
     * The id of the ticket to notify about
     */
    TicketEntityId: number;
}
/**
 * Get attachment infos for all attachments connected to messages in specified ticket
 * Returns AttachmentEntity[]
 */
export interface Ticket_GetTicketAttachmentsRequest {
    /**
     * The id of the ticket to get attachment infos from
     */
    TicketEntityId: number;
}
/**
 * Check attachments, return validation result for each item
 * Returns AttachmentValidationResult[]
 */
export interface Ticket_ValidateAttachmentsRequest {
    /**
     * The IDs of the attachments to validate
     */
    AttachmentIds: number[];
}
/**
 * Set the ReadByOwner status for a ticket. It will only have an effect if the calling user is the same as the owner of the ticket
 * Returns TicketEntity
 */
export interface Ticket_SetTicketReadByOwnerRequest {
    /**
     * The id of the ticket to set
     */
    TicketEntityId: number;
    /**
     * The read status to set. See the enum for explanation of the different colors. Setting Unknown does nothing
     */
    ReadStatus: enums.TicketReadStatus;
    /**
     * If true, then the escalation system will be called and executed when setting the ReadByOwner
     */
    CheckEscalating: boolean;
}
/**
 * Saves a ticket and performs any user notifications
 * Returns TicketEntity
 */
export interface Ticket_SaveTicketEntityWithNotifyRequest {
    /**
     * The ticket to save
     */
    NewEntity: TicketEntity;
    /**
     * If true, then the notifications will be sent
     */
    Notify: boolean;
}
/**
 * Assign a ticket to the caller based on intelligent queue system
 * Returns TicketEntity
 */
export interface Ticket_GetNextInQueueRequest {
}
/**
 * When a user view/read a ticket, a number of action should be performed: set read status, escalation handling, remove notifications, etc. Which actions will be performed depends on owner, caller and configuration
 * Returns TicketEntity
 */
export interface Ticket_ProcessTicketWhenReadRequest {
    /**
     * The id of the ticket to mark as read
     */
    TicketEntityId: number;
}
/**
 * Save new ticket and move/copy data from existing ticket in a single request. Specified messages will be moved.
 * Returns TicketEntity
 */
export interface Ticket_SplitTicketRequest {
    /**
     * The id of the ticket to split
     */
    SourceTicketEntityId: number;
    /**
     * IDs of messages that should be transferred from the original ticket to the new one
     */
    TransferMessageIds: number[];
    /**
     * The new ticket to save. Includes new values for simple properties like title, category, status, etc., but not messages.
     */
    NewTicketEntity: TicketEntity;
}
/**
 * Create new ticket and move/copy data from existing ticket in addition update old message and save new message in a single request.
 * Returns TicketEntity
 */
export interface Ticket_SplitTicketMessageRequest {
    /**
     * The message being splitted, content can be modified as part of the split.
     */
    SourceTicketMessage: TicketMessageEntity;
    /**
     * The new ticket to save. Includes new values for simple properties like title, category, status, etc., but not messages.
     */
    NewTicketEntity: TicketEntity;
    /**
     * The new message to be saved
     */
    NewTicketMessage: TicketMessageEntity;
    /**
     * IDs of attachments that should be transferred from the original message to the new one
     */
    TransferAttachmentsIds: number[];
}
/**
 * This method changes multiple tickets' read status
 * Returns number[]
 */
export interface Ticket_UpdateTicketsReadStatusRequest {
    /**
     * Ticket ids to be updated
     */
    TicketIds: number[];
    /**
     * New read status
     */
    NewStatus: enums.TicketReadStatus;
}
/**
 * This method changes multiple tickets' read status
 * Returns number[]
 */
export interface Ticket_UpdateTicketsReadStatusByProviderRequest {
    /**
     * Name of the provider that returns ticket rows.
     */
    Provider: string;
    /**
     * Query restrictions to be added to provider. Fixed providers, such as LastTicketsProvider, FavouriteTicketsProvider etc. already have mandatory restrictions setup - in such case extra restrictions will be combined, however for general use case for fixed providers you can pass an empty array and provider will return default results. For selection providers generally you should pass selectionId as a restriction.
     */
    Restrictions: ArchiveRestrictionInfo[];
    /**
     * New read status
     */
    NewStatus: enums.TicketReadStatus;
}
/**
 * Merge one or more tickets into one primary ticket
 * Returns TicketEntity
 */
export interface Ticket_MergeTicketsRequest {
    /**
     * Merged ticket entity
     */
    MergedTicketEntity: TicketEntity;
    /**
     * Ids of secondary tickets
     */
    SecondaryTicketIds: number[];
}
/**
 * Sets tickets' status to Deleted. After a grace period these tickets will be deleted by a background job.
 * Returns number[]
 */
export interface Ticket_SetDeletedStatusByIdsRequest {
    /**
     * Ids of tickets to be set for deletion.
     */
    TicketIds: number[];
}
/**
 * Sets tickets' status to Deleted. After a grace period these tickets will be deleted by a background job.
 * Returns number[]
 */
export interface Ticket_SetDeletedStatusByProviderRequest {
    /**
     * Name of the provider that returns ticket rows.
     */
    ProviderName: string;
    /**
     * Query restrictions to be added to provider. Fixed providers, such as LastTicketsProvider, FavouriteTicketsProvider etc. already have mandatory restrictions setup - in such case extra restrictions will be combined, however for general use case for fixed providers you can pass an empty array and provider will return default results. For selection providers generally you should pass selectionId as a restriction.
     */
    Restrictions: ArchiveRestrictionInfo[];
}
/**
 * Restores deleted tickets by their ids. Status is set to a default open status defined in Registry table
 */
export interface Ticket_UndeleteByIdsRequest {
    /**
     * Ids of tickets to be restored.
     */
    TicketIds: number[];
}
/**
 * Ticket can be connected (merged) to another ticket. This method traverses through its connection(s) and returns proper ticketId
 * Returns number
 */
export interface Ticket_ResolveTicketIdRequest {
    /**
     * Potentially correct ticketId
     */
    TicketId: number;
}
/**
 * Forwards selected tickets to specified recipients. This method starts a batch task.
 * Returns number
 */
export interface Ticket_BatchForwardRequest {
    /**
     * Ids of tickets to be forwarded.
     */
    TicketIds: number[];
    /**
     * The To-recipients. Each recipient must be in correct mailbox format (john@example.com or John Doe <john@example.com>).
     */
    To: string[];
    /**
     * The Cc-recipients. Each recipient must be in correct mailbox format (john@example.com or John Doe <john@example.com>).
     */
    Cc: string[];
    /**
     * The Bcc-recipients. Each recipient must be in correct mailbox format (john@example.com or John Doe <john@example.com>).
     */
    Bcc: string[];
    /**
     * Comment will be included before ticket messages. Might be empty
     */
    Comment: string;
    /**
     * If true, ticket will be closed after forwarding
     */
    CloseTicket: boolean;
}
/**
 * Replies to the specified tickets. This method starts a batch task.
 * Returns number
 */
export interface Ticket_BatchReplyRequest {
    /**
     * All data needed to initiate a mass ticket reply sending.
     */
    BatchReplyData: TicketBatchReplyData;
}
/**
 * Clear notification status for one or more tickets.
 */
export interface Ticket_ClearNotifyRequest {
    /**
     * List of notify IDs.
     */
    Ids: number[];
}
/**
 * The TicketMessage carrier is used for representing a service ticket message
 */
export interface TicketMessage extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    TicketMessageId?: number;
    /**
     * When the message was posted.
     */
    CreatedAt?: Date;
    /**
     * The securitylevel of the message.
     */
    Slevel?: enums.TicketSecurityLevel;
    /**
     * If this message is important or not.
     */
    Important?: boolean;
    /**
     * A string representing the author of the message. Could be a user&apos;s name, or a persons email address.
     */
    Author?: string;
    /**
     * Primary key
     */
    PersonId?: number;
    /**
     * Get the persons full name (internal name used in clients for employees).
     */
    PersonFullName?: string;
    /**
     * Primary key
     */
    ContactId?: number;
    /**
     * Contact name
     */
    ContactName?: string;
    /**
     * Department
     */
    ContactDepartment?: string;
    /**
     * Number of attachments in the message
     */
    NumAttachments?: number;
    /**
     * The email header is saved in this field as raw text
     */
    EmailHeader?: string;
    /**
     * Contains the message headers, like To, Cc, Bcc information, or custom headers
     */
    MessageHeaders?: TicketMessageHeader[];
    /**
     * The language this message is in, based on some kind of analysis
     */
    Language?: string;
    /**
     * Sentiment index, 100 = completely happy; -100 = suicidally unhappy; 0 = no idea
     */
    Sentiment?: number;
    /**
     * Confidence of sentiment index, 0 = no idea, 100 = completely sure
     */
    SentimentConfidence?: number;
    /**
     * The id of the user who posted the message. The value 1 (system user) for externally posted messages.
     */
    CreatedBy?: number;
    /**
     * When the message was changed.
     */
    ChangedAt?: Date;
    /**
     * Badge to explicitly determine how a message was generated
     */
    Badge?: enums.BadgeType;
}
/**
 * The ticket messages are e-mails, SMS or other messages attached to a ticket (aka request).
 */
export interface TicketMessageEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    EjMessageId?: number;
    /**
     * The connected ticket
     */
    Ticket?: Ticket;
    /**
     * When the message was posted.
     */
    CreatedAt?: Date;
    /**
     * The associate who created this ticket message
     */
    CreatedBy?: Associate;
    /**
     * A string representing the author of the message. Could be a user&apos;s name, or a persons email address.
     */
    Author?: string;
    /**
     * The securitylevel of the message.
     */
    Slevel?: enums.TicketSecurityLevel;
    /**
     * The type of the message (plaintext/html).
     */
    Type?: enums.TicketMessageType;
    /**
     * The Message-Id header value from the email. Used for threading, i.e. connecting messages to existing tickets.
     */
    MessageId?: string;
    /**
     * The time spent (minutes) for this message.
     */
    TimeSpent?: number;
    /**
     * The textbody for the message.
     */
    Body?: string;
    /**
     * The html body for the message (if any).
     */
    HtmlBody?: string;
    /**
     * The email header is saved in this field as raw text
     */
    EmailHeader?: string;
    /**
     * The debug info for the message.
     */
    DebugInfo?: string;
    /**
     * The name of the mail sorter used when the email was imported. Note: We must use name instead of id since the id&apos;s change every time one changes the mail sorter. :-0
     */
    MailSorter?: string;
    /**
     * Defines what kind of message this is.
     */
    MessageCategory?: enums.TicketMessageCategory;
    /**
     * If this is an incoming message, this will contain the person
     * Use MDO List name "person_new" to get list items.
     */
    Person?: Person;
    /**
     * A copy of the title of the ticket, for search optimisation and simpler reporting.
     */
    SearchTitle?: string;
    /**
     * Contains the message headers, like To, Cc, Bcc information, or custom headers
     */
    MessageHeaders?: TicketMessageHeader[];
    /**
     * If this message is important or not.
     */
    Important?: boolean;
    /**
     * The language this message is in, based on some kind of analysis
     */
    Language?: string;
    /**
     * Sentiment index, 100 = completely happy; -100 = suicidally unhappy; 0 = no idea
     */
    Sentiment?: number;
    /**
     * Confidence of sentiment index, 0 = no idea, 100 = completely sure
     */
    SentimentConfidence?: number;
    /**
     * Badge to explicitly determine how a message was generated
     */
    Badge?: enums.BadgeType;
    /**
     * Message attachments information
     */
    AttachmentsInfo?: AttachmentEntity[];
    /**
     * Extra fields added to the carrier. This could be data from Plug-ins, the foreign key system, external applications, etc.
     */
    ExtraFields?: StringDictionary;
    /**
     * Extra + udef fields added to the carrier.
     */
    CustomFields?: StringDictionary;
}
/**
 * Delete a ticket message
 */
export interface Ticket_DeleteTicketMessageEntityRequest {
    /**
     * The ticket message to delete
     */
    TicketMessageEntityId: number;
}
/**
 * Remove harmful HTML tags and attributes from an email
 * Returns string
 */
export interface Ticket_SanitizeMailContentRequest {
    /**
     * The email content to sanitize
     */
    Content: string;
}
/**
 * Remove harmful HTML tags and attributes from an email
 * Returns string[]
 */
export interface Ticket_SanitizeMailContentsRequest {
    /**
     * The email contents to sanitize
     */
    Contents: string[];
}
/**
 * Create a plain text version of the html, suitable for email
 * Returns string
 */
export interface Ticket_Html2TextRequest {
    /**
     * The html version
     */
    Content: string;
}
/**
 * Get a list with meta data for all attached attachments
 * Returns AttachmentEntity[]
 */
export interface Ticket_GetAttachmentInfoRequest {
    /**
     * The id of the ticket message to get attachment infos for
     */
    TicketMessageEntityId: number;
}
/**
 * Get a list with meta data for all attached attachments, EXCEPT those marked as inline
 * Returns AttachmentEntity[]
 */
export interface Ticket_GetAttachmentInfoNonInlineRequest {
    /**
     * The id of the ticket message to get attachment infos for
     */
    TicketMessageEntityId: number;
}
/**
 * Connect existing attachments with this TicketMessage. Can connect multiple attachments
 */
export interface Ticket_AddAttachmentsRequest {
    /**
     * The id of the ticket message to connect the attachments to
     */
    TicketMessageEntityId: number;
    /**
     * An array of attachments to connect to this TicketMessage
     */
    AttachmentIds: number[];
}
/**
 * Removes attachments from the message as specified in the collection of entity ids. The ids are attachment ids (attachment primary key)
 */
export interface Ticket_RemoveMessageAttachmentsRequest {
    /**
     * The id of the ticket message to remove attachments from
     */
    TicketMessageEntityId: number;
    /**
     * Attachment primary keys
     */
    AttachmentIds: number[];
}
/**
 * Retrieve an attachment from ticket message. The returned data is intended to be used for a preview. The returned data is sanitized.
 * Returns DocumentPreview
 */
export interface Ticket_GetPreviewAttachmentStreamRequest {
    /**
     * The id of the attachment to retrieve
     */
    AttachmentId: number;
}
/**
 * Send a message to recipients by email
 */
export interface Ticket_SendTicketMessageRequest {
    /**
     * The id of the ticket message to send
     */
    TicketMessageEntityId: number;
    /**
     * The To-recipients. Each recipient must be in correct format
     */
    To: string[];
    /**
     * The Cc-recipients. Each recipient must be in correct format
     */
    Cc: string[];
    /**
     * The Bcc-recipients. Each recipient must be in correct format
     */
    Bcc: string[];
    /**
     * The subject
     */
    Subject: string;
    /**
     * Optional ID of reply template to merge message with. <= 0 to skip.
     */
    ReplyTemplateId: number;
    /**
     * Obsolete
     */
    GdprSource: string;
}
/**
 * Send a message to recipients by sms
 */
export interface Ticket_SendTicketMessageSmsRequest {
    /**
     * The id of the ticket message to send
     */
    TicketMessageEntityId: number;
    /**
     * Optional ID of reply template to merge message with. <= 0 to skip.
     */
    ReplyTemplateId: number;
    /**
     * The Sms-recipients. Each recipient must be in correct format
     */
    Sms: string[];
}
/**
 * Set the important flag on or off for a ticket message
 */
export interface Ticket_SetTicketMessageImportantRequest {
    /**
     * The id of the ticket message to set the important flag on
     */
    TicketMessageId: number;
    /**
     * Turn on or off the important flag
     */
    Important: boolean;
}
/**
 * Gets recipients for new message
 * Returns Recipient[]
 */
export interface Ticket_CalculateMessageRecipientsRequest {
    /**
     * The id of the ticket
     */
    TicketId: number;
    /**
     * Message action
     */
    ActionType: enums.MessageActionType;
    /**
     * Optional ID of message being replied. Value <= 0 ignores parameter
     */
    MessageId: number;
}
/**
 * Saves a ticket message and performs any user notifications
 * Returns TicketMessageEntity
 */
export interface Ticket_SaveTicketMessageEntityWithNotifyRequest {
    /**
     * The ticket message to save
     */
    NewEntity: TicketMessageEntity;
    /**
     * If true, then the notification will be sent along with the save
     */
    Notify: boolean;
}
/**
 * Saves a ticket message and performs additional actions
 * Returns TicketMessageEntity
 */
export interface Ticket_SaveTicketMessageEntityWithOptionsRequest {
    /**
     * The ticket message to save
     */
    Entity: TicketMessageEntity;
    /**
     * If true, then the notification will be sent along with the save
     */
    Notify: boolean;
    /**
     * An array of attachments to connect to this TicketMessage
     */
    AttachmentIds: number[];
    /**
     * Updates ticket's replied_at field if needed
     */
    UpdateRepliedAt: boolean;
}
/**
 * Generate a default message body (possibly including user signature, quoted message content) as sanitized HTML
 * Returns string
 */
export interface Ticket_GetDefaultMessageContentRequest {
    /**
     * The id of the ticket
     */
    TicketId: number;
    /**
     * Message action type: None/Reply/ReplyAll/Forward
     */
    MessageActionType: enums.MessageActionType;
    /**
     * The id of the message to quote in the returned content. 0 to skip/ignore
     */
    TicketMessageId: number;
}
/**
 * Get a ticket message entity with posibillity to change embedded images to be represented with inline data within the HTML body. If using inline data, be sure not to save this back to the database.
 * Returns TicketMessageEntity
 */
export interface Ticket_GetTicketMessageWithEmbeddedDataRequest {
    /**
     * The id of the ticket message entity
     */
    Id: number;
    /**
     * If set to Inline, then use inline base64 data to represent the images in the HTML body. Default: Link will use link to the image.
     */
    EmbedImages: enums.ImageEmbedType;
}
/**
 * Removes headers from the message as specified in the collection of entity ids. The ids are message header ids (message header primary key)
 */
export interface Ticket_DeleteMessageHeadersRequest {
    /**
     * Message header primary keys
     */
    HeaderIds: number[];
}
/**
 * Get a ticket message entity with additional options.
 * Returns TicketMessageEntity
 */
export interface Ticket_GetTicketMessageWithOptionsRequest {
    /**
     * The id of the ticket message entity
     */
    TicketMessageEntityId: number;
    /**
     * If true, then non inline attachments info will be loaded into TicketMessageEntity
     */
    IncludeNonInlineAttachmentsInfo: boolean;
}
/**
 * The ticket summary with heading, created date.
 */
export interface TicketSummaryItem {
    /**
     * The primary key (auto-incremented)
     */
    TicketId?: number;
    /**
     * User defined ticket status
     */
    TicketStatus?: number;
    /**
     * The title of the ticket.
     */
    Title?: string;
    /**
     * When the ticket was created.
     */
    Registered?: Date;
    /**
     * Icon representing ticket's state
     */
    IconHint?: string;
}
/**
 * Get an array of summaryitem for the given tickets
 * Returns TicketSummaryItem[]
 */
export interface Ticket_GetTicketSummariesRequest {
    /**
     * The tickets to fetch summaries for
     */
    TicketIds: number[];
}
/**
 * The extra table entity contains meta data for an extra table (not implemented yet)
 */
export interface TableRecord extends Carrier {
    /**
     * Values for the row, where the first string is the column name (e.g. x_number), and the second string is the value formatted as a DB-value, e.g. [I:42]
     */
    Values?: StringDictionary;
}
/**
 * Read a row from a table
 * Returns TableRecord
 */
export interface DatabaseTable_ReadRowRequest {
    /**
     * The name of the table to fetch; in the current release this must be an 'extratable'. Use the database name, on the form y_aTable
     */
    TableName: string;
    /**
     * The id of the row to fetch
     */
    Id: number;
}
/**
 * Insert a row into a table
 * Returns number
 */
export interface DatabaseTable_InsertRowRequest {
    /**
     * The name of the table to insert into; in the current release this must be an 'extratable'. Use the database name, on the form y_aTable
     */
    TableName: string;
    /**
     * A StringDictionary with the values to insert. You do not need to specify all the values in the table. The omitted ones will get default values
     */
    Values: StringDictionary;
}
/**
 * Update a row in a table
 */
export interface DatabaseTable_UpdateRowRequest {
    /**
     * The name of the table to update; in the current release this must be an 'extratable'. Use the database name, on the form y_aTable
     */
    TableName: string;
    /**
     * The id of the row to update
     */
    Id: number;
    /**
     * A StringDictionary with the values to update. You do not need to specify all the values in the table. The omitted ones will remain unchanged
     */
    Values: StringDictionary;
}
/**
 * Delete a row from a table
 */
export interface DatabaseTable_DeleteRowRequest {
    /**
     * The name of the table to delete from; in the current release this must be an 'extratable'. Use the database name, on the form y_aTable
     */
    TableName: string;
    /**
     * The id of the row to delete
     */
    Id: number;
}
/**
 * Information about a row of the results of a mass-update operation
 */
export interface UpsertRowStatus extends Carrier {
    /**
     * The primary key of the target table, that matches the keys specified in the data row
     */
    PrimaryKey?: number;
    /**
     * Actiona taken for row
     */
    Action?: enums.UpsertRowActionStatus;
    /**
     * The key values given in the incoming 'data' parameter to the Upsert call, in the order they were speicifed in the 'keys' array
     */
    RowKeys?: string[];
}
/**
 * Information about the results of a mass-update operation
 */
export interface MassOperationResult extends Carrier {
    /**
     * Did the operation succeed
     */
    Success?: boolean;
    /**
     * Any message from the method, including timing data
     */
    Message?: string;
    /**
     * Number of rows inserted
     */
    Inserts?: number;
    /**
     * Number of rows updated
     */
    Updates?: number;
    /**
     * Number of rows deleted / zeroed
     */
    Deletes?: number;
    /**
     * Array of statuses and primary keys for all rows that were specified. Populated if the 'ReturnRowStatus' parameter of 'Upsert' is set, otherwise null
     */
    RowStatus?: UpsertRowStatus[];
}
/**
 * Mass-insert rows, with or without primary keys specified. Works on physical tables with no special processing for udef etc.; traveltransactionlog and WebHooks are supported
 * Returns MassOperationResult
 */
export interface DatabaseTable_InsertRequest {
    /**
     * The name of the table where rows should be inserted
     */
    TableName: string;
    /**
     * List of column names, in the same order as in the Data parameter
     */
    Columns: string[];
    /**
     * Outer array = rows, inner = columns in specified order; use CultureDataFormatter to format values that aren't string or int
     */
    Data: string[][];
}
/**
 * Drop all rows in a table. This clearance is not individually logged in TravelTransactionlog or Webhook/script calls
 * Returns MassOperationResult
 */
export interface DatabaseTable_TruncateRequest {
    /**
     * Name of table to be truncated
     */
    TableName: string;
}
/**
 * Insert or update rows, optionally deleting/zeroing 'leftover' rows. Special support for UDEF, as well as optional extensive information return. Traveltransactionlog and WebHooks are supported
 * Returns MassOperationResult
 */
export interface DatabaseTable_UpsertRequest {
    /**
     * The name of the table where rows should be inserted or updated
     */
    TableName: string;
    /**
     * List of column names, in the same order as in the data
     */
    Columns: string[];
    /**
     * List of columns that are to be used as keys, to match any existing rows
     */
    Keys: string[];
    /**
     * Outer array = row, inner = column in specified order; use CultureDataFormatter to format values
     */
    Data: string[][];
    /**
     * Action to take on rows in the target table, that are not matched by any rows in the incoming data. Use the deletion options with care. NEVER use deletion if your Upsert is so large you need to divide it into multiple batches.
     */
    NomatchAction: enums.UpsertNomatchAction;
    /**
     * If true, then the 'RowStatus' member of the return carrier will be populated with a per-row status, for each incoming row
     */
    ReturnRowStatus: boolean;
}
/**
 * Delete rows, by primary key; traveltransactionlog and WebHooks are supported
 * Returns MassOperationResult
 */
export interface DatabaseTable_DeleteRequest {
    /**
     * The name of the table where rows should be deleted
     */
    TableName: string;
    /**
     * Primary keys of the rows to be deleted
     */
    IDs: number[];
}
/**
 * Chat Topic bot settings. Trigger script ids to run on bot events
 */
export interface ChatBotSettings {
    /**
     * Chatbot name
     */
    BotName?: string;
    /**
     * Script id to register/unregister chatbot. 0 if there is no bot
     */
    BotRegisterScriptId?: number;
    /**
     * Script id to run on new session.
     */
    BotSessionCreatedScriptId?: number;
    /**
     * Script id to run when session state changes.
     */
    BotSessionChangedScriptId?: number;
    /**
     * Script id to run when new messages received from customer.
     */
    BotMessageReceivedScriptId?: number;
}
/**
 * A message in a chat session
 */
export interface ChatMessage {
    /**
     * The primary key (auto-incremented)
     */
    ChatMessageId?: number;
    /**
     * The reference to the associated chat session.
     */
    ChatSessionId?: number;
    /**
     * The type of the message.
     */
    Type?: enums.ChatMessageType;
    /**
     * The message.
     */
    Message?: string;
    /**
     * The author of the message.
     */
    Author?: string;
    /**
     * Whether the message has been read by the customer or not.
     */
    ReadByCustomer?: number;
    /**
     * Enum indicating if it is a special message, such as an URL redirection, etc.
     */
    SpecialType?: enums.ChatMessageSpecialType;
    /**
     * Special parameter for the special_type.
     */
    SpecialParam?: string;
    /**
     * When the message was posted (UTC timestamp).
     */
    WhenPosted?: Date;
}
/**
 * Chat Topic Opening Hours
 */
export interface ChatOpeningHours {
    /**
     * Timezone used for the opening hours (start/stop times) for this topic.
     */
    TzLocation?: TimeZoneData;
    /**
     * Whether open on Mondays.
     */
    MonEnabled?: boolean;
    /**
     * When opening hours start on Mondays. Only time-part is used.
     */
    MonStart?: moment.Duration;
    /**
     * When opening hours stop on Mondays. Only time-part is used.
     */
    MonStop?: moment.Duration;
    /**
     * Whether open on Tuesdays.
     */
    TueEnabled?: boolean;
    /**
     * When opening hours start on Tuesdays. Only time-part is used.
     */
    TueStart?: moment.Duration;
    /**
     * When opening hours stop on Tuesdays. Only time-part is used.
     */
    TueStop?: moment.Duration;
    /**
     * Whether open on Wednesdays.
     */
    WedEnabled?: boolean;
    /**
     * When opening hours start on Wednesdays. Only time-part is used.
     */
    WedStart?: moment.Duration;
    /**
     * When opening hours stop on Wednesday. Only time-part is used.
     */
    WedStop?: moment.Duration;
    /**
     * Whether open on Thursdays.
     */
    ThuEnabled?: boolean;
    /**
     * When opening hours start on Thursdays. Only time-part is used.
     */
    ThuStart?: moment.Duration;
    /**
     * When opening hours stop on Thursdays. Only time-part is used.
     */
    ThuStop?: moment.Duration;
    /**
     * Whether open on Fridays.
     */
    FriEnabled?: boolean;
    /**
     * When opening hours start on Fridays. Only time-part is used.
     */
    FriStart?: moment.Duration;
    /**
     * When opening hours stop on Fridays. Only time-part is used.
     */
    FriStop?: moment.Duration;
    /**
     * Whether open on Saturdays.
     */
    SatEnabled?: boolean;
    /**
     * When opening hours start on Saturdays. Only time-part is used.
     */
    SatStart?: moment.Duration;
    /**
     * When opening hours stop on Saturdays. Only time-part is used.
     */
    SatStop?: moment.Duration;
    /**
     * Whether open on Sundays.
     */
    SunEnabled?: boolean;
    /**
     * When opening hours start on Sundays. Only time-part is used.
     */
    SunStart?: moment.Duration;
    /**
     * When opening hours stop on Sundays. Only time-part is used.
     */
    SunStop?: moment.Duration;
    /**
     * Whether to use lunch hours or not.
     */
    UseLunchHours?: boolean;
    /**
     * When opening hours starts for lunch. Only time-part is used.
     */
    LunchStart?: moment.Duration;
    /**
     * When opening hours stops for lunch. Only time-part is used.
     */
    LunchStop?: moment.Duration;
}
/**
 * Represents presence information for a chat user, bundled with some other useful information
 */
export interface ChatPresence extends Carrier {
    /**
     * The id for the chat user
     */
    UserId?: number;
    /**
     * The display name of the chat user
     */
    DisplayName?: string;
    /**
     * The number of ongoing chats this users has now
     */
    OngoingChats?: number;
    /**
     * Indicates if the user has the chat presence turned on or off
     */
    Present?: boolean;
    /**
     * An array of ids with chat topics that this user is a member of
     */
    ChatTopics?: number[];
}
/**
 * Get the chat presence status for all chat users
 * Returns ChatPresence[]
 */
export interface Chat_GetChatPresenceRequest {
}
/**
 * Save the chat presence for specified users
 */
export interface Chat_SaveChatPresenceRequest {
    /**
     * An array with ChatPresence objects. Only the UserId and Present information is used while saving
     */
    ChatPresence: ChatPresence[];
}
/**
 * Chat sessions belong to a chat topic, and contain messages to/from users
 */
export interface ChatSessionEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    ChatSessionId?: number;
    /**
     * The reference to the associated chat topic.
     */
    TopicId?: number;
    /**
     * User agent handling this session
     */
    User?: Associate;
    /**
     * Customer person in this session - could be empty if we don't know exactly.
     */
    Person?: Person;
    /**
     * The alias for the customer.
     */
    CustomerAlias?: string;
    /**
     * The hostname or IP address for the customer.
     */
    CustomerHost?: string;
    /**
     * The name of customer, if provided
     */
    CustomerName?: string;
    /**
     * The email address of the customer, if provided
     */
    CustomerEmail?: string;
    /**
     * The phone number of the customer, if provided
     */
    CustomerPhone?: string;
    /**
     * The customer consented when starting the session
     */
    CustomerConsented?: boolean;
    /**
     * The name of the customers company, if provided
     */
    CustomerCompanyName?: string;
    /**
     * Enum indicating the status for the session (pending, active, closed, etc).
     */
    Status?: enums.ChatSessionStatus;
    /**
     * A copy of the first message in the chat session
     */
    FirstMessage?: string;
    /**
     * A copy of the last message in the chat session
     */
    LastMessage?: string;
    /**
     * When the session was requested by the customer.
     */
    WhenRequested?: Date;
    /**
     * When the session was accepted by a user.
     */
    WhenStarted?: Date;
    /**
     * When the session was ended.
     */
    WhenEnded?: Date;
    /**
     * The last time anyone sent a message for this session.
     */
    WhenIdle?: Date;
    /**
     * The last time the customer&apos;s client refetched the data. Used to detect &apos;dead&apos; session.
     */
    WhenFetched?: Date;
    /**
     * Key used to authenticate the session.
     */
    SessionKey?: string;
    /**
     * The initial queue pos (i.e. the number of pending sessions + 1) when the session was requested.
     */
    InitialQueuePos?: number;
    /**
     * The alert level for this chat session.
     */
    AlertLevel?: number;
    /**
     * Lowest possible unique number for active sessions for user. User for color index. Starting at 1.
     */
    Rank?: number;
    /**
     * Various flags for the chat session
     */
    Flags?: enums.ChatSessionFlags;
    /**
     * Contact this session is connected to - could be empty if we don't know exactly.
     */
    Contact?: Contact;
    /**
     * Project the session is connectedto - could be empty if we don't know exactly.
     */
    Project?: Project;
    /**
     * Sale the session is connected to - could be empty if we don't know exactly.
     */
    Sale?: Sale;
    /**
     * Ticket the session is connected to - could be empty if we don't know exactly.
     */
    Ticket?: Ticket;
    /**
     * User agent that has a pending transfer of the chat session
     */
    TransferTo?: Associate;
    /**
     * Indicates that a chatbot is active on the session. This will cause bot triggers to fire. Set to 0 when bot hands off to user.
     */
    ChatbotIsActive?: boolean;
    /**
     * Rating of this chat conversation given by the customer
     */
    Rating?: number;
}
/**
 * Get all chat sessions which this user is a member of. Members means that you have at least one of: Can Respond, Notifications, Listen or Manager
 * Returns ChatSessionEntity[]
 */
export interface Chat_ChatSessionsForUserRequest {
}
/**
 * Request to send the session to another user. If the session does not belong to the user, nothing happens.
 * Returns ChatSessionEntity
 */
export interface Chat_TransferChatSessionRequest {
    /**
     * id of the chat session to send
     */
    ChatSessionId: number;
    /**
     * Associate username or associate id to send session to.
     */
    ToAssociate: string;
}
/**
 * Accept the transfer: assign the session to the user. If the session is not being transferred, nothing happens.
 * Returns ChatSessionEntity
 */
export interface Chat_AcceptChatSessionTransferRequest {
    /**
     * id of the chat session to send
     */
    ChatSessionId: number;
}
/**
 * Do not want. Deny the transfer to the user. If the session is not being transferred, nothing happens.
 * Returns ChatSessionEntity
 */
export interface Chat_RejectChatSessionTransferRequest {
    /**
     * id of the chat session to send back
     */
    ChatSessionId: number;
}
/**
 * 'answer' the session: assign the session to the user. The welcome message is sent to the customer. Returns NULL if session was not in queue.
 * Returns ChatSessionEntity
 */
export interface Chat_PickUpChatSessionRequest {
    /**
     * id of the chat session to answer
     */
    ChatSessionId: number;
}
/**
 * 'answer' the first available session from the queue: assign the session to the user. The welcome message is sent to the customer.
 * Returns ChatSessionEntity
 */
export interface Chat_PickUpFirstChatSessionRequest {
}
/**
 * Reset chat session, put it back on the queue for pickup. Used by bots to hand off a session to human
 * Returns ChatSessionEntity
 */
export interface Chat_ResetChatSessionRequest {
    /**
     * id of the chat session to reset
     */
    ChatSessionId: number;
}
/**
 * Get the chat transcript, formatted as plain text or html
 * Returns string
 */
export interface Chat_GetChatTranscriptRequest {
    /**
     * id of the chat session to get the transcript for
     */
    ChatSessionId: number;
    /**
     * Get transcript as HTML
     */
    Html: boolean;
}
/**
 * Get all or some of the messages in a chat session
 * Returns ChatMessage[]
 */
export interface Chat_GetChatMessagesRequest {
    /**
     * id of the chat session to reset
     */
    ChatSessionId: number;
    /**
     * Return messages after this message id
     */
    After: number;
}
/**
 * Add a new message to a chat session
 * Returns ChatMessage
 */
export interface Chat_AddChatMessageRequest {
    /**
     * id of the chat session to add message to
     */
    ChatSessionId: number;
    /**
     * Message to add
     */
    Message: ChatMessage;
}
/**
 * Chat session summary: id, title, created date
 */
export interface ChatSummaryItem {
    /**
     * The primary key (auto-incremented)
     */
    ChatSessionId?: number;
    /**
     * The name of customer, if provided
     */
    Name?: string;
    /**
     * The name of the customers company, if provided
     */
    CompanyName?: string;
    /**
     * A copy of the first message in the chat session
     */
    FirstMessage?: string;
    /**
     * A copy of the last message in the chat session
     */
    LastMessage?: string;
    /**
     * When the session was requested by the customer.
     */
    WhenRequested?: Date;
    /**
     * When the session was ended.
     */
    WhenEnded?: Date;
}
/**
 * User agents within a chat topic. Which users are assigned and what roles they have within the chat topic.
 */
export interface ChatTopicAgent {
    /**
     * The reference to the associated chat topic.
     */
    TopicId?: number;
    /**
     * The associate that is the user agent.
     */
    User?: Associate;
    /**
     * True of a user can listen in on this topic
     */
    CanListen?: boolean;
    /**
     * True if the user can respond to chats in this topic
     */
    CanRespond?: boolean;
    /**
     * True if the user is a manager for this topic
     */
    CanManage?: boolean;
    /**
     * True if the user should receive notifications for this topic
     */
    CanNotify?: boolean;
}
/**
 * Chat topics define who is assigned, when the channel is open for business, and look of the chat widget.
 */
export interface ChatTopicEntity extends Carrier {
    /**
     * The primary key (auto-incremented)
     */
    ChatTopicId?: number;
    /**
     * The name of this chat topic
     */
    Name?: string;
    /**
     * The descriptiong for this topic.
     */
    Description?: string;
    /**
     * The welcome message sent to the customer when the chat session starts.
     */
    WelcomeMessage?: string;
    /**
     * Customer language used in this topic. Optional.
     */
    Language?: CustomerLanguage;
    /**
     * The last time a session was accepted from the inside for this topic.
     */
    LastAccept?: Date;
    /**
     * The average number of seconds per accept for this topic.
     */
    SecondsPrAccept?: number;
    /**
     * The recipient(s) for the alert template
     */
    AlertRecipient?: string;
    /**
     * Template to use for alerts.
     */
    AlertTemplate?: ReplyTemplate;
    /**
     * Collect consent to store from user
     */
    CollectConsent?: boolean;
    /**
     * The badge header of the chat topic
     */
    BadgeHeader?: string;
    /**
     * Use the custom queue message text
     */
    CustomQueueTextEnabled?: boolean;
    /**
     * A text to be used in the queue message in the chat widget. Usage is controlled by the flags field, bit number 3
     */
    CustomQueueText?: string;
    /**
     * Contains the user notify time in minutes
     */
    WarnNewChatMinutes?: number;
    /**
     * Contains the manager notify time in minutes
     */
    WarnManagerNewChatMinutes?: number;
    /**
     * Enable ticket submission in offline mode
     */
    TicketEnabled?: boolean;
    /**
     * Category on ticket created from off-line request
     */
    TicketCategory?: TicketCategory;
    /**
     * Priority on ticket created from off-line request
     */
    TicketPriority?: TicketPriority;
    /**
     * Whether to use opening hours or not.
     */
    OpeningHoursEnabled?: boolean;
    /**
     * Opening hours settings
     */
    OpeningHours?: ChatOpeningHours;
    /**
     * Settings for the chat widget
     */
    Widget?: ChatWidgetSettings;
    /**
     * Enable chatbot on this topic. Run the trigger scripts on bot events.
     */
    BotEnabled?: boolean;
    /**
     * Settings for chatbot: trigger script ids to run on bot events
     */
    BotSettings?: ChatBotSettings;
    /**
     * Collect offline consent to store from user
     */
    OfflineCollectConsent?: boolean;
    /**
     * Contains the user notify time in minutes for new chat messages
     */
    WarnChatMessageMinutes?: number;
    /**
     * Contains the manager notify time in minutes for new chat messages
     */
    WarnManagerChatMessageMinutes?: number;
    /**
     * Use offline form capability from chat queue
     */
    UseQueueOfflineForm?: boolean;
    /**
     * The number of minutes in the queue before the offline form is available
     */
    OfflineFormTimeLimit?: number;
    /**
     * The number of customers in the queue before the offline form is available
     */
    OfflineFormQueueLength?: number;
    /**
     * Enable rating functionality in the chat widgte
     */
    WidgetEnableRating?: boolean;
    /**
     * The text to be displayed in the widget next to the rating stars
     */
    WidgetRatingText?: string;
}
/**
 * Check if we are right now within the opening hours of the given topic. Will use timezones to calculate if configured.
 * Returns boolean
 */
export interface Chat_IsWithinOpeningHoursRequest {
    /**
     * The id of the topic to check
     */
    ChatTopicId: number;
}
/**
 * Get all chat topics which this user is a member of. Members means that you have at least one of: Can Respond, Notifications, Listen or Manager
 * Returns ChatTopicEntity[]
 */
export interface Chat_ChatTopicsForUserRequest {
}
/**
 * Get list of users that can be assigned to chat topics. Users with Chat-CALs from the MDO list 'chatuser'
 * Returns MDOListItem[]
 */
export interface Chat_GetUserAgentListRequest {
    /**
     * Return flat list instead of grouping by usergroup.
     */
    Flat: boolean;
    /**
     * Only show users who are present
     */
    OnlyPresent: boolean;
}
/**
 * Get list of users assigned to a chat topic
 * Returns ChatTopicAgent[]
 */
export interface Chat_GetChatTopicUserAgentListRequest {
    /**
     * Id of the chat topic
     */
    ChatTopicId: number;
}
/**
 * Get a user assigned to a topic
 * Returns ChatTopicAgent
 */
export interface Chat_GetChatTopicUserAgentRequest {
    /**
     * Id of the chat topic
     */
    ChatTopicId: number;
    /**
     * Associate username or associate id to get.
     */
    Username: string;
}
/**
 * Add a user to a chat topic
 * Returns ChatTopicAgent
 */
export interface Chat_AddChatTopicUserAgentRequest {
    /**
     * Id of the chat topic
     */
    ChatTopicId: number;
    /**
     * User's role within the chat topic to add to topic.
     */
    Useragent: ChatTopicAgent;
}
/**
 * Update a user's role in a chat topic
 * Returns ChatTopicAgent
 */
export interface Chat_UpdateChatTopicUserAgentRequest {
    /**
     * Id of the chat topic
     */
    ChatTopicId: number;
    /**
     * Associate username or associate id to get.
     */
    Username: string;
    /**
     * User's updated role within the chat topic.
     */
    Useragent: ChatTopicAgent;
}
/**
 * Update users roles in a chat topic
 * Returns ChatTopicAgent[]
 */
export interface Chat_UpdateChatTopicUserAgentsRequest {
    /**
     * Id of the chat topic
     */
    ChatTopicId: number;
    /**
     * Users new/updated roles within the chat topic. Replaces existing roles
     */
    Useragents: ChatTopicAgent[];
}
/**
 * Remove a user from a topic
 */
export interface Chat_DeleteChatTopicUserAgentRequest {
    /**
     * Id of the chat topic
     */
    ChatTopicId: number;
    /**
     * Associate username or associate id to delete.
     */
    Username: string;
}
/**
 * Create a new session on a chat topic
 * Returns ChatSessionEntity
 */
export interface Chat_CreateChatSessionForTopicRequest {
    /**
     * Id of the chat topic
     */
    ChatTopicId: number;
}
/**
 * Defines the look of the chat widget.
 */
export interface ChatWidgetSettings {
    /**
     * Enable automatic FAQ suggestions
     */
    AutoFaqEnabled?: boolean;
    /**
     * Root folder for FAQ suggestions
     */
    AutoFaqCategory?: KbCategory;
    /**
     * Enable pre-chat form for anonymous users
     */
    PreFormEnabled?: boolean;
    /**
     * Message to be shown in a pre-chat
     */
    PreFormMessage?: string;
    /**
     * Fields required to start a chat
     */
    RequiredFields?: enums.WidgetRequiredFields;
    /**
     * Enable post chat form
     */
    PostFormEnabled?: boolean;
    /**
     * Header text to show in post chat form
     */
    PostFormHeader?: string;
    /**
     * Message text to show in post chat form
     */
    PostFormMessage?: string;
    /**
     * Enable transcript of chat session
     */
    PostTranscriptEnabled?: boolean;
    /**
     * The language ISO code for the widget language
     */
    LanguageIsoCode?: string;
    /**
     * Chat widget size: normal or large.
     */
    Size?: enums.ChatWidgetSize;
    /**
     * Predefined themes for the chat widget
     */
    Theme?: enums.WidgetTheme;
    /**
     * The base color of the widget
     */
    Color?: string;
    /**
     * Optional color for chat widget badge
     */
    BadgeColor?: string;
    /**
     * Optional color for chat widget badge text
     */
    BadgeTextColor?: string;
    /**
     * Optional color for chat widget customer message
     */
    CustMsgColor?: string;
    /**
     * Optional color for chat widget customer message text
     */
    CustMsgTextColor?: string;
    /**
     * Optional color for chat widget agent message
     */
    AgentMsgColor?: string;
    /**
     * Optional color for chat widget agent message text
     */
    AgentMsgTextColor?: string;
    /**
     * Optional color for chat widget button
     */
    ButtonColor?: string;
    /**
     * Optional color for chat widget button text
     */
    ButtonTextColor?: string;
    /**
     * The font used in the widget
     */
    Font?: string;
    /**
     * Optional size for chat widget font
     */
    FontSize?: string;
    /**
     * Indicates if the logo should be shown in the widget
     */
    LogoEnabled?: boolean;
    /**
     * Blob id that contains logo image
     */
    LogoBlobId?: number;
    /**
     * filename/description of logo (from blob)
     */
    LogoName?: string;
    /**
     * Use agent photo and name when chatting
     */
    ShowAgentPhoto?: boolean;
    /**
     * Short welcome message when user initiates a chat
     */
    WelcomeTitle?: string;
    /**
     * Short message displayed as long as the request is in queue or active
     */
    WelcomeMessage?: string;
    /**
     * Offline text shown in widget header
     */
    OfflineHeader?: string;
    /**
     * Offline message shown in widget
     */
    OfflineMessage?: string;
    /**
     * Required field when creating ticket in offline mode
     */
    OfflineFields?: enums.WidgetRequiredFields;
    /**
     * Whether to use the firstname of the agent in the chat widget.
     */
    UseAgentFirstname?: boolean;
}
/**
 * Details about a categorization model in HugoAI
 */
export interface CategorizationModelDetails extends Carrier {
    /**
     * Time the training finished
     */
    ModelBuiltDateTime?: Date;
    /**
     * Accuracy of the trained model
     */
    Accuracy?: number;
    /**
     * Number of tickets used to train the model
     */
    TicketCountForTraining?: number;
}
/**
 * Carrier to describe the current categorization training status for a tenant in HugoAI
 */
export interface CategorizationStatusResponse extends Carrier {
    /**
     * Contextidentifier to identify customer
     */
    ContextIdentifier?: string;
    /**
     * Determines if a training is running, finished or unavailable
     */
    Status?: string;
    /**
     * Current model information
     */
    CurrentModel?: CategorizationModelDetails;
    /**
     * Previous model information
     */
    PreviousModel?: CategorizationModelDetails;
}
/**
 * Calling the HugoAI endpoint to fetch the current training status.
 * Returns CategorizationStatusResponse
 */
export interface AI_GetTrainingStatusRequest {
}
/**
 * Category guess information
 */
export interface CategoryGuess extends Carrier {
    /**
     * This carrier is currently not used
     */
    Dummy?: string;
}
/**
 * Given a ticket's id, guess the ticket category it should be placed in. Currently this is based on the first message in the ticket
 * Returns number
 */
export interface AI_GuessCategoryRequest {
    /**
     * Id of ticket to guess category for
     */
    TicketId: number;
}
/**
 * The category guesser training API will be called with an array of CategorizationTrainingItem during the (background, Batch) execution of this call
 * Returns string
 */
export interface AI_TrainCategoryGuesserRequest {
    /**
     * Id of selection of tickets, to retrieve training data from
     */
    SelectionId: number;
    /**
     * Maximum number of tickets to retrieve data from
     */
    MaxItems: number;
    /**
     * Maximum length of PlainTextBody or any other large text, truncated to nearest word boundary
     */
    MaxTextLength: number;
}
/**
 * Sentiment information: Score (-100 to 100) and Confidence (0 to 100)
 */
export interface Sentiment extends Carrier {
    /**
     * Sentiment score, -100 = very unhappy, 100 = very happy, 0 = no idea (not recognized)
     */
    Score?: number;
    /**
     * Sentiment analysis confidence, where available. 0 = no idea, 100 = perfectly confident, -1 = no confidence score available
     */
    Confidence?: number;
}
/**
 * Given a (reasonably short) text, detect the language it is written in
 * Returns string
 */
export interface AI_DetectLanguageRequest {
    /**
     * Text to be analyzed; there may be a cost-per-character so do not send a book here
     */
    Text: string;
}
/**
 * Detect the sentiment of a (reasonably short) text. Sentiment analysis may cause a translation to be made, since sentiment analysis only supports a limited set of languages
 * Returns Sentiment
 */
export interface AI_DetectSentimentRequest {
    /**
     * Text to be analyzed
     */
    Text: string;
}
/**
 * Translate a text from one language to another. Language of the text is automatically detected.
 * Returns string
 */
export interface AI_TranslateRequest {
    /**
     * Text to be translated. Language of the text is automatically detected.
     */
    Text: string;
    /**
     * ISO Language code (such as FR) to translate the text into
     */
    TargetLanguage: string;
}
/**
 * Retrieve, format and translate text for an entity to a specified language
 * Returns string
 */
export interface AI_TranslateEntityRequest {
    /**
     * Name of entity to get the text to be translated; eg., 'ticketMessage'
     */
    EntityName: string;
    /**
     * Identifier for the entity to get text to be translated
     */
    EntityId: number;
    /**
     * ISO Language code (such as FR) to translate the text into
     */
    TargetLanguage: string;
}
/**
 * Class used to map relationship between AssociateId and the user's email.
 */
export interface DocumentMigrationAssociate {
    /**
     * Primary key
     */
    AssociateId?: number;
    /**
     * The address itself
     */
    EmailAddress?: string;
}
/**
 * Class used to summarize all document-properties relevant for migrating documents.
 */
export interface DocumentMigrationItem {
    /**
     * Primary key
     */
    DocumentId?: number;
    /**
     * Contact ID of owning contact, may be 0
     */
    ContactId?: number;
    /**
     * Person ID of person the appointment is with, may be 0
     */
    PersonId?: number;
    /**
     * Owning sale, if any (may be 0)
     */
    SaleId?: number;
    /**
     * ID of project referred to, may be 0
     */
    ProjectId?: number;
    /**
     * Primary key
     */
    DocTmplId?: number;
    /**
     * ID of associate whose diary the appointment is in, REQUIRED
     */
    AssociateId?: number;
    /**
     * Primary key
     */
    UserGroupId?: number;
    /**
     * Primary key
     */
    VisibleForId?: number;
}
/**
 *
 */
export interface DocumentMigrationItemList {
    /**
     * Total amount of documents within the selection criteria, which has been omitted from the migration.
     */
    NumDocumentsOmitted?: number;
    /**
     * Documents already migrated to the requested documentplugin.
     */
    NumDocumentsAlreadyMigrated?: number;
    /**
     * List of documents to be migrated.
     */
    Documents?: DocumentMigrationItem[];
    /**
     * List of associates whose documents will be migrated.
     */
    Associates?: DocumentMigrationAssociate[];
}
/**
 * Gets a migration summary for all documents stored in CRM. Warning: Expensive!
 * Returns DocumentMigrationItemList
 */
export interface DocumentMigration_GetForAllDocumentsRequest {
    /**
     * The ID of the document-plugin to migrate to.
     */
    DocumentPluginId: number;
    /**
     * True if documents to migrate should include emails.
     */
    IncludeEmails: boolean;
}
/**
 * Gets a migration summary for documents in the provided date-rage
 * Returns DocumentMigrationItemList
 */
export interface DocumentMigration_GetForDateRangeRequest {
    /**
     * The ID of the document-plugin to migrate to.
     */
    DocumentPluginId: number;
    /**
     * Inclusive mininmum.
     */
    MinDate: Date;
    /**
     * Inclusive maximum.
     */
    MaxDate: Date;
    /**
     * True if documents to migrate should include emails.
     */
    IncludeEmails: boolean;
}
/**
 * Gets a migration summary for documents in the provided selection
 * Returns DocumentMigrationItemList
 */
export interface DocumentMigration_GetForSelectionRequest {
    /**
     * The ID of the document-plugin to migrate to.
     */
    DocumentPluginId: number;
    /**
     * ID of the selection used to create the DocumentMigrationSummary instance.
     */
    SelectionId: number;
    /**
     * True if documents to migrate should include emails.
     */
    IncludeEmails: boolean;
}
/**
 * Migrates the document with the provided id to the specified document-plugin.
 */
export interface DocumentMigration_MigrateDocumentToNewDocPluginRequest {
    /**
     * The ID of the document to migrate.
     */
    DocumentId: number;
    /**
     * The ID of the document-plugin to migrate to.
     */
    DocumentPluginId: number;
}
/**
 * Checks if there are any documents in the current database stored using a non-default document-plugin, and which can be migrated.
 * Returns boolean
 */
export interface DocumentMigration_HasDocumentsToMigrateRequest {
}
/**
 *
 */
export interface DocumentTemplateMigrationList {
    /**
     * Total amount of templates which has been omitted from the migration.
     */
    NumTemplatesOmitted?: number;
    /**
     * Total amount of templates already migrated to the requested documentplugin.
     */
    NumTemplatesAlreadyMigrated?: number;
    /**
     * List of IDs for templates to be migrated.
     */
    TemplateIds?: number[];
}
/**
 * Gets a migration summary for all templates stored in CRM.
 * Returns DocumentTemplateMigrationList
 */
export interface DocumentMigration_GetForTemplatesRequest {
    /**
     * The ID of the document-plugin to migrate to.
     */
    TargetDocumentPluginId: number;
    /**
     * True if templates to migrate should include emails.
     */
    IncludeEmails: boolean;
}
/**
 * Migrates the template with the provided id to the specified document-plugin.
 */
export interface DocumentMigration_MigrateTemplateToNewDocPluginRequest {
    /**
     * The ID of the document-template to migrate.
     */
    DocumentTemplateId: number;
    /**
     * The ID of the document-plugin to migrate to.
     */
    TargetDocumentPluginId: number;
}
/**
 * Email flow carrier
 */
export interface EmailFlow extends Carrier {
    /**
     * Primary key
     */
    EmailFlowId?: number;
    /**
     * Name of the workflow
     */
    Name?: string;
    /**
     * Description of the workflow
     */
    Description?: string;
    /**
     * Status of the workflow definition
     */
    Status?: enums.WorkflowDefinitionStatus;
    /**
     * When a goal is reached, contact jumps directly to finished
     */
    JumpToFinish?: boolean;
    /**
     * A contact can start this flow only once
     */
    StartOnlyOnce?: boolean;
    /**
     * Override consent and subscription
     */
    OverrideConsentSubscription?: boolean;
    /**
     * Email/Mailing From field address algorithm
     */
    FromType?: enums.EmailFromType;
    /**
     * Email From name
     */
    FromName?: string;
    /**
     * Email From address: name@domain.com
     */
    FromAddr?: string;
    /**
     * Email/Mailing Reply-To field address algorithm
     */
    ReplyToType?: enums.EmailReplyToType;
    /**
     * Reply to address, if different from From-address
     */
    ReplyToAddr?: string;
    /**
     * Email Reply-To name
     */
    ReplyToName?: string;
    /**
     * SMS sender (number or name)
     */
    SmsSender?: string;
    /**
     * Use Google Analytics
     */
    UseGoogleAnalytics?: boolean;
    /**
     * GA Source
     */
    GaSource?: string;
    /**
     * GA Campaign
     */
    GaCampaign?: string;
    /**
     * Use sender timeframe settings, only send email/sms within the timeframe
     */
    UseTimeframe?: boolean;
    /**
     * Selected days (flags, so several days can be selected) for time frame
     */
    SelectedDays?: enums.Weekday;
    /**
     * Start of email/sms sending timeframe, interpreted in stored timezone or as UTC, only time part is used
     */
    TimeframeStart?: Date;
    /**
     * End of email/sms sending timeframe, interpreted in stored timezone or as UTC, only time part is used
     */
    TimeframeEnd?: Date;
    /**
     * Start the flow running with enrolled participants at the given time
     */
    UseWorkflowStart?: boolean;
    /**
     * When to start running the workflow. Until start, any enrolled members are not running through the flow, just waiting. Datetime is interpreted in stored timezone or as UTC
     */
    WorkflowStart?: Date;
    /**
     * End enrollment into the workflow at the given time
     */
    UseEnrollmentEnd?: boolean;
    /**
     * Do not enroll more participant after given time, interpreted in stored timezone or as UTC
     */
    EnrollmentEnd?: Date;
    /**
     * Workflows to remove the participants from when they are enrolled in this workflow
     */
    RemoveFromFlows?: number[];
    /**
     * The workflow timezone setting
     */
    TzLocation?: TimeZoneData;
    /**
     * The folder/hierarchy the email flow is in.
     * Use MDO List name "hierarchy" to get list items.
     */
    Folder?: HierarchyEntity;
    /**
     * The owner of the workflow.
     * Use MDO List name "associate" to get list items.
     */
    Associate?: Associate;
    /**
     * The Shipment type (mailing type)
     */
    ShipmentType?: MDOListItem;
    /**
     * The steps in the workflow, mainline steps - forking steps are indicated by its WorkflowStepType.
     */
    Steps?: WorkflowStepBase[];
    /**
     * The triggers for the workflow.
     */
    Triggers?: WorkflowTrigger[];
    /**
     * The goals for the workflow.
     */
    Goals?: WorkflowGoal[];
    /**
     * The filter for the workflow.
     */
    Filter?: WorkflowFilter;
    /**
     * Persons in the given selections are not allowed to enter this workflow
     */
    BlockLists?: number[];
    /**
     * The set of users or groups the record is visible for
     */
    VisibleFor?: VisibleFor[];
}
/**
 * Try to add a participant to the EmailFlow
 * Returns boolean[]
 */
export interface Workflow_TryAddPersonsToEmailFlowRequest {
    /**
     * Primary key of EmailFlow
     */
    EmailFlowId: number;
    /**
     * Array of Person Ids
     */
    PersonIds: number[];
}
/**
 * Create content to an email flow
 * Returns number
 */
export interface Workflow_CreateEmailFlowContentRequest {
    /**
     * The name of the content created
     */
    ContentName: string;
}
/**
 * Link any SMessage to the email flow. The SMessage (and any related SShipment etc) should probably not be used/visible elsewhere.
 */
export interface Workflow_ConnectEmailFlowContentRequest {
    /**
     * The EmailFlow to connect the message to.
     */
    EmailFlowId: number;
    /**
     * The s_message to connect to the flow. A shipment, form or flow may be connected to that s_message.
     */
    MessageId: number;
}
/**
 * Workflow filter carrier
 */
export interface WorkflowFilter extends Carrier {
    /**
     * The restrictions (can be multiple groups) that make up the Workflow filter
     */
    RestrictionGroups?: ArchiveRestrictionGroup[];
}
/**
 * Workflow goal carrier
 */
export interface WorkflowGoal extends Carrier {
    /**
     * Primary key
     */
    WorkflowGoalId?: number;
    /**
     * The flow this goal belongs to
     */
    WorkflowId?: number;
    /**
     * The workflow goal type
     */
    GoalType?: enums.WorkflowGoalType;
    /**
     * The restrictions (can be multiple groups) that make up the Workflow goal criteria
     */
    RestrictionGroups?: ArchiveRestrictionGroup[];
}
/**
 * Workflow step carrier.
 */
export interface WorkflowStepBase {
    /**
     * Primary key
     */
    WorkflowStepId?: number;
    /**
     * The flow this step belongs to
     */
    WorkflowId?: number;
    /**
     * Step type
     */
    StepType?: enums.WorkflowStepType;
    /**
     * Step order
     */
    Rank?: number;
}
/**
 * Get Workflowstep by ID
 * Returns WorkflowStepBase
 */
export interface Workflow_GetWorkflowStepRequest {
    /**
     * Primary key of WorkflowStep
     */
    WorkflowStepId: number;
}
/**
 * Add another step (and any of its substeps) after the given step id (which must exist), and move any following steps in the workflow further down the line.
 * Returns WorkflowStepBase
 */
export interface Workflow_AddAfterWorkflowStepRequest {
    /**
     * Primary key of WorkflowStep
     */
    WorkflowStepId: number;
    /**
     * The step to be inserted after given step id.
     */
    SubStep: WorkflowStepBase;
}
/**
 * Creates a new carrier from the step type given, with the right kind of properties, defaults set.
 * Returns WorkflowStepBase
 */
export interface Workflow_CreateDefaultWorkflowStepFromTypeRequest {
    /**
     * Step type to create
     */
    StepType: enums.WorkflowStepType;
}
/**
 * Step in workflow.
 */
export interface WorkflowStepAddToList extends WorkflowStepBase {
}
/**
 * Step in workflow.
 */
export interface WorkflowStepCreateFollowUp extends WorkflowStepBase {
}
/**
 * Step in workflow.
 */
export interface WorkflowStepCreateRequest extends WorkflowStepBase {
}
/**
 * Step in workflow.
 */
export interface WorkflowStepCreateSale extends WorkflowStepBase {
}
/**
 * Step in workflow.
 */
export interface WorkflowStepNotifyByEmail extends WorkflowStepBase {
}
/**
 * Step in workflow.
 */
export interface WorkflowStepNotifyBySMS extends WorkflowStepBase {
}
/**
 * Workflow step option
 */
export interface WorkflowStepOption extends Carrier {
    /**
     * Primary key
     */
    WorkflowStepOptionId?: number;
    /**
     * The workflow step this instance belongs to
     */
    WorkflowStepId?: number;
    /**
     * The flow this instance belongs to
     */
    WorkflowId?: number;
    /**
     * A key used to refer to this option
     */
    Key?: string;
    /**
     * The name of this option
     */
    Name?: string;
    /**
     * The rank of this option
     */
    Rank?: number;
    /**
     * The steps to execute if this option/path is selected
     */
    Steps?: WorkflowStepBase[];
}
/**
 * Step in workflow.
 */
export interface WorkflowStepRemoveFromList extends WorkflowStepBase {
}
/**
 * Step in workflow.
 */
export interface WorkflowStepRunScript extends WorkflowStepBase {
}
/**
 * Step in workflow that waits for time.
 */
export interface WorkflowStepSendEmail extends WorkflowStepBase {
    /**
     * Email subject
     */
    Subject?: string;
    /**
     * Info about selected CRM documents to be sent as attachments in the email
     */
    Attachments?: number[];
    /**
     * The selected mailing asset (s_message)
     */
    EmailMessageId?: number;
    /**
     * The selected mailing (s_shipment)
     */
    ShipmentId?: number;
}
/**
 * Step in workflow.
 */
export interface WorkflowStepSendSMS extends WorkflowStepBase {
}
/**
 * Step in workflow.
 */
export interface WorkflowStepSplit extends WorkflowStepBase {
    /**
     * What options are given by the split
     */
    Options?: WorkflowStepOption[];
}
/**
 * Step in workflow.
 */
export interface WorkflowStepUpdateContact extends WorkflowStepBase {
}
/**
 * Step in workflow.
 */
export interface WorkflowStepWaitForAction extends WorkflowStepBase {
}
/**
 * Step in workflow that waits for time.
 */
export interface WorkflowStepWaitForTime extends WorkflowStepBase {
    /**
     * Waiting algorithm
     */
    TimeWaitAlgorithm?: enums.WorkflowTimeWaitAlgorithm;
    /**
     * The given number of intervals to wait, if this algorithm is selected
     */
    NumIntervals?: number;
    /**
     * Interval type (Minutes, days, weeks...)
     */
    IntervalType?: enums.WorkflowTimeWaitIntervalType;
    /**
     * Wait until specific datetime, interpreted in the workflow timezone
     */
    Until?: Date;
}
/**
 * Workflow trigger carrier
 */
export interface WorkflowTrigger extends Carrier {
    /**
     * Primary key
     */
    WorkflowTriggerId?: number;
    /**
     * The flow this trigger belongs to
     */
    WorkflowId?: number;
    /**
     * The workflow trigger type
     */
    TriggerType?: enums.WorkflowTriggerType;
    /**
     * The restrictions (can be multiple groups) that make up the Workflow trigger criteria
     */
    RestrictionGroups?: ArchiveRestrictionGroup[];
}
export interface DSAParameters {
    Counter: number;
    G: any;
    J: any;
    P: any;
    Q: any;
    Seed: any;
    X: any;
    Y: any;
}
//# sourceMappingURL=Carriers.d.ts.map
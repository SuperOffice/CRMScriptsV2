"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.AIAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * AI services, such as Translation, Statistics, Sentiment analysis, backed by calls to Public Cloud providers
 */
class AIAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/AI/";
        super(options);
    }
    async _GetTrainingStatus(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTrainingStatus", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CategorizationStatusResponse_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Calling the HugoAI endpoint to fetch the current training status.
     * @returns Carrier to describe the current status of HugoAI categorization
     */
    async GetTrainingStatus(webapi_options) {
        return this._GetTrainingStatus(webapi_options);
    }
    async _GuessCategory(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GuessCategory", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GuessCategory(ticketId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketId;
        if (typeof (first) === "object" && first && (typeof (first.TicketId) != 'undefined')) {
            _request = ticketId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketId: ticketId,
            };
            _options = webapi_options;
        }
        return this._GuessCategory(_request, _options);
    }
    async _TrainCategoryGuesser(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TrainCategoryGuesser", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async TrainCategoryGuesser(selectionId, maxItems, maxTextLength, webapi_options) {
        let _request = null;
        let _options = null;
        const first = selectionId;
        if (typeof (first) === "object" && first && (typeof (first.SelectionId) != 'undefined' || typeof (first.MaxItems) != 'undefined' || typeof (first.MaxTextLength) != 'undefined')) {
            _request = selectionId;
            _options = maxItems;
        }
        else {
            _request = {
                SelectionId: selectionId,
                MaxItems: maxItems,
                MaxTextLength: maxTextLength,
            };
            _options = webapi_options;
        }
        return this._TrainCategoryGuesser(_request, _options);
    }
    async _DetectLanguage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DetectLanguage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DetectLanguage(text, webapi_options) {
        let _request = null;
        let _options = null;
        const first = text;
        if (typeof (first) === "object" && first && (typeof (first.Text) != 'undefined')) {
            _request = text;
            _options = webapi_options;
        }
        else {
            _request = {
                Text: text,
            };
            _options = webapi_options;
        }
        return this._DetectLanguage(_request, _options);
    }
    async _DetectSentiment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DetectSentiment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Sentiment_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DetectSentiment(text, webapi_options) {
        let _request = null;
        let _options = null;
        const first = text;
        if (typeof (first) === "object" && first && (typeof (first.Text) != 'undefined')) {
            _request = text;
            _options = webapi_options;
        }
        else {
            _request = {
                Text: text,
            };
            _options = webapi_options;
        }
        return this._DetectSentiment(_request, _options);
    }
    async _Translate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Translate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Translate(text, targetLanguage, webapi_options) {
        let _request = null;
        let _options = null;
        const first = text;
        if (typeof (first) === "object" && first && (typeof (first.Text) != 'undefined' || typeof (first.TargetLanguage) != 'undefined')) {
            _request = text;
            _options = targetLanguage;
        }
        else {
            _request = {
                Text: text,
                TargetLanguage: targetLanguage,
            };
            _options = webapi_options;
        }
        return this._Translate(_request, _options);
    }
    async _TranslateEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TranslateEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async TranslateEntity(entityName, entityId, targetLanguage, webapi_options) {
        let _request = null;
        let _options = null;
        const first = entityName;
        if (typeof (first) === "object" && first && (typeof (first.EntityName) != 'undefined' || typeof (first.EntityId) != 'undefined' || typeof (first.TargetLanguage) != 'undefined')) {
            _request = entityName;
            _options = entityId;
        }
        else {
            _request = {
                EntityName: entityName,
                EntityId: entityId,
                TargetLanguage: targetLanguage,
            };
            _options = webapi_options;
        }
        return this._TranslateEntity(_request, _options);
    }
} // class v1AIAgentController 
exports.AIAgent = AIAgent;
//# sourceMappingURL=AIAgent.js.map
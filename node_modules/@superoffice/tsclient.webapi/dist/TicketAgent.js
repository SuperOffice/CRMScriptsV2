"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.TicketAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
const Base64_1 = require("./Base64");
/**
 * Agent used for Ticket functions
 */
class TicketAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Ticket/";
        super(options);
    }
    /**
     * Set default values into a new AttachmentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultAttachmentEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultAttachmentEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AttachmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing AttachmentEntity or creates a new AttachmentEntity if the id parameter is empty
     * @param entity - The AttachmentEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated AttachmentEntity
     */
    async SaveAttachmentEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveAttachmentEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AttachmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TicketEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTicketEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketEntity or creates a new TicketEntity if the id parameter is empty
     * @param entity - The TicketEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketEntity
     */
    async SaveTicketEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new TicketMessageEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultTicketMessageEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultTicketMessageEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing TicketMessageEntity or creates a new TicketMessageEntity if the id parameter is empty
     * @param entity - The TicketMessageEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated TicketMessageEntity
     */
    async SaveTicketMessageEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveTicketMessageEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a AttachmentEntity object.
     * @param attachmentEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single AttachmentEntity
     */
    async GetAttachmentEntity(attachmentEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetAttachmentEntity?attachmentEntityId=" + attachmentEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AttachmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _CopyFromCRMDocument(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyFromCRMDocument", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AttachmentEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CopyFromCRMDocument(documentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = documentId;
        if (typeof (first) === "object" && first && (typeof (first.DocumentId) != 'undefined')) {
            _request = documentId;
            _options = webapi_options;
        }
        else {
            _request = {
                DocumentId: documentId,
            };
            _options = webapi_options;
        }
        return this._CopyFromCRMDocument(_request, _options);
    }
    async _CopyToTempFile(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CopyToTempFile", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CopyToTempFile(filename, attachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = filename;
        if (typeof (first) === "object" && first && (typeof (first.Filename) != 'undefined' || typeof (first.AttachmentId) != 'undefined')) {
            _request = filename;
            _options = attachmentId;
        }
        else {
            _request = {
                Filename: filename,
                AttachmentId: attachmentId,
            };
            _options = webapi_options;
        }
        return this._CopyToTempFile(_request, _options);
    }
    async _UploadAttachment(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UploadAttachment", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UploadAttachment(attachmentId, content, webapi_options) {
        let _request = null;
        let _options = null;
        const first = attachmentId;
        if (typeof (first) === "object" && first && (typeof (first.AttachmentId) != 'undefined' || typeof (first.Content) != 'undefined')) {
            _request = attachmentId;
            _options = content;
        }
        else {
            _request = {
                AttachmentId: attachmentId,
                Content: content,
            };
            _options = webapi_options;
        }
        _request.Content = (0, Base64_1.ToBase64)(_request.Content);
        return this._UploadAttachment(_request, _options);
    }
    async _GetAttachmentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options) || {};
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                if (!options || options.returnBlobAs == base.ReturnBlobType.AsArrayBuffer) {
                    config.responseType = "arraybuffer";
                    config.headers = config.headers || {};
                    config.headers["Accept"] = "application/octet-stream";
                }
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachmentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                let res = null;
                if (options && options.returnBlobAs != base.ReturnBlobType.AsArrayBuffer) {
                    res = response.data;
                    if (options.returnBlobAs == base.ReturnBlobType.AsString) {
                        res = (0, Base64_1.FromBase64ToString)(res);
                    }
                }
                else {
                    res = response.data;
                }
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAttachmentStream(attachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = attachmentId;
        if (typeof (first) === "object" && first && (typeof (first.AttachmentId) != 'undefined')) {
            _request = attachmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                AttachmentId: attachmentId,
            };
            _options = webapi_options;
        }
        return this._GetAttachmentStream(_request, _options);
    }
    /*
     * Gets a Ticket object.
     * @param ticketId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Ticket
     */
    async GetTicket(ticketId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicket?ticketId=" + ticketId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Ticket_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetTickets(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTickets", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTickets(ticketIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketIds;
        if (typeof (first) === "object" && first && (typeof (first.TicketIds) != 'undefined')) {
            _request = ticketIds;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketIds: ticketIds,
            };
            _options = webapi_options;
        }
        return this._GetTickets(_request, _options);
    }
    /*
     * Gets a TicketEntity object.
     * @param ticketEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketEntity
     */
    async GetTicketEntity(ticketEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketEntity?ticketEntityId=" + ticketEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetForRmUi(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetForRmUi", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetForRmUi(ticketId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketId;
        if (typeof (first) === "object" && first && (typeof (first.TicketId) != 'undefined')) {
            _request = ticketId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketId: ticketId,
            };
            _options = webapi_options;
        }
        return this._GetForRmUi(_request, _options);
    }
    async _DeleteTicketEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteTicketEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteTicketEntity(ticketEntityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketEntityId) != 'undefined')) {
            _request = ticketEntityId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketEntityId: ticketEntityId,
            };
            _options = webapi_options;
        }
        return this._DeleteTicketEntity(_request, _options);
    }
    async _NotifyNewTicket(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotifyNewTicket", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async NotifyNewTicket(ticketEntityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketEntityId) != 'undefined')) {
            _request = ticketEntityId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketEntityId: ticketEntityId,
            };
            _options = webapi_options;
        }
        return this._NotifyNewTicket(_request, _options);
    }
    async _NotifyNewTicketMessage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("NotifyNewTicketMessage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async NotifyNewTicketMessage(ticketEntityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketEntityId) != 'undefined')) {
            _request = ticketEntityId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketEntityId: ticketEntityId,
            };
            _options = webapi_options;
        }
        return this._NotifyNewTicketMessage(_request, _options);
    }
    async _GetTicketAttachments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketAttachments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AttachmentEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTicketAttachments(ticketEntityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketEntityId) != 'undefined')) {
            _request = ticketEntityId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketEntityId: ticketEntityId,
            };
            _options = webapi_options;
        }
        return this._GetTicketAttachments(_request, _options);
    }
    async _ValidateAttachments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateAttachments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AttachmentValidationResultArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateAttachments(attachmentIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = attachmentIds;
        if (typeof (first) === "object" && first && (typeof (first.AttachmentIds) != 'undefined')) {
            _request = attachmentIds;
            _options = webapi_options;
        }
        else {
            _request = {
                AttachmentIds: attachmentIds,
            };
            _options = webapi_options;
        }
        return this._ValidateAttachments(_request, _options);
    }
    async _SetTicketReadByOwner(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketReadByOwner", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetTicketReadByOwner(ticketEntityId, readStatus, checkEscalating, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketEntityId) != 'undefined' || typeof (first.ReadStatus) != 'undefined' || typeof (first.CheckEscalating) != 'undefined')) {
            _request = ticketEntityId;
            _options = readStatus;
        }
        else {
            _request = {
                TicketEntityId: ticketEntityId,
                ReadStatus: readStatus,
                CheckEscalating: checkEscalating,
            };
            _options = webapi_options;
        }
        return this._SetTicketReadByOwner(_request, _options);
    }
    async _SaveTicketEntityWithNotify(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTicketEntityWithNotify", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveTicketEntityWithNotify(newEntity, notify, webapi_options) {
        let _request = null;
        let _options = null;
        const first = newEntity;
        if (typeof (first) === "object" && first && (typeof (first.NewEntity) != 'undefined' || typeof (first.Notify) != 'undefined')) {
            _request = newEntity;
            _options = notify;
        }
        else {
            _request = {
                NewEntity: newEntity,
                Notify: notify,
            };
            _options = webapi_options;
        }
        return this._SaveTicketEntityWithNotify(_request, _options);
    }
    async _GetNextInQueue(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextInQueue", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Assign a ticket to the caller based on intelligent queue system
     * @returns The ticket entity after assigning it to the caller
     */
    async GetNextInQueue(webapi_options) {
        return this._GetNextInQueue(webapi_options);
    }
    async _ProcessTicketWhenRead(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ProcessTicketWhenRead", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ProcessTicketWhenRead(ticketEntityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketEntityId) != 'undefined')) {
            _request = ticketEntityId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketEntityId: ticketEntityId,
            };
            _options = webapi_options;
        }
        return this._ProcessTicketWhenRead(_request, _options);
    }
    async _SplitTicket(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SplitTicket", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SplitTicket(sourceTicketEntityId, transferMessageIds, newTicketEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourceTicketEntityId;
        if (typeof (first) === "object" && first && (typeof (first.SourceTicketEntityId) != 'undefined' || typeof (first.TransferMessageIds) != 'undefined' || typeof (first.NewTicketEntity) != 'undefined')) {
            _request = sourceTicketEntityId;
            _options = transferMessageIds;
        }
        else {
            _request = {
                SourceTicketEntityId: sourceTicketEntityId,
                TransferMessageIds: transferMessageIds,
                NewTicketEntity: newTicketEntity,
            };
            _options = webapi_options;
        }
        return this._SplitTicket(_request, _options);
    }
    async _SplitTicketMessage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SplitTicketMessage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SplitTicketMessage(sourceTicketMessage, newTicketEntity, newTicketMessage, transferAttachmentsIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = sourceTicketMessage;
        if (typeof (first) === "object" && first && (typeof (first.SourceTicketMessage) != 'undefined' || typeof (first.NewTicketEntity) != 'undefined' || typeof (first.NewTicketMessage) != 'undefined' || typeof (first.TransferAttachmentsIds) != 'undefined')) {
            _request = sourceTicketMessage;
            _options = newTicketEntity;
        }
        else {
            _request = {
                SourceTicketMessage: sourceTicketMessage,
                NewTicketEntity: newTicketEntity,
                NewTicketMessage: newTicketMessage,
                TransferAttachmentsIds: transferAttachmentsIds,
            };
            _options = webapi_options;
        }
        return this._SplitTicketMessage(_request, _options);
    }
    async _UpdateTicketsReadStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateTicketsReadStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateTicketsReadStatus(ticketIds, newStatus, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketIds;
        if (typeof (first) === "object" && first && (typeof (first.TicketIds) != 'undefined' || typeof (first.NewStatus) != 'undefined')) {
            _request = ticketIds;
            _options = newStatus;
        }
        else {
            _request = {
                TicketIds: ticketIds,
                NewStatus: newStatus,
            };
            _options = webapi_options;
        }
        return this._UpdateTicketsReadStatus(_request, _options);
    }
    async _UpdateTicketsReadStatusByProvider(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateTicketsReadStatusByProvider", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateTicketsReadStatusByProvider(provider, restrictions, newStatus, webapi_options) {
        let _request = null;
        let _options = null;
        const first = provider;
        if (typeof (first) === "object" && first && (typeof (first.Provider) != 'undefined' || typeof (first.Restrictions) != 'undefined' || typeof (first.NewStatus) != 'undefined')) {
            _request = provider;
            _options = restrictions;
        }
        else {
            _request = {
                Provider: provider,
                Restrictions: restrictions,
                NewStatus: newStatus,
            };
            _options = webapi_options;
        }
        return this._UpdateTicketsReadStatusByProvider(_request, _options);
    }
    async _MergeTickets(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MergeTickets", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MergeTickets(mergedTicketEntity, secondaryTicketIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = mergedTicketEntity;
        if (typeof (first) === "object" && first && (typeof (first.MergedTicketEntity) != 'undefined' || typeof (first.SecondaryTicketIds) != 'undefined')) {
            _request = mergedTicketEntity;
            _options = secondaryTicketIds;
        }
        else {
            _request = {
                MergedTicketEntity: mergedTicketEntity,
                SecondaryTicketIds: secondaryTicketIds,
            };
            _options = webapi_options;
        }
        return this._MergeTickets(_request, _options);
    }
    async _SetDeletedStatusByIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDeletedStatusByIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDeletedStatusByIds(ticketIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketIds;
        if (typeof (first) === "object" && first && (typeof (first.TicketIds) != 'undefined')) {
            _request = ticketIds;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketIds: ticketIds,
            };
            _options = webapi_options;
        }
        return this._SetDeletedStatusByIds(_request, _options);
    }
    async _SetDeletedStatusByProvider(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDeletedStatusByProvider", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDeletedStatusByProvider(providerName, restrictions, webapi_options) {
        let _request = null;
        let _options = null;
        const first = providerName;
        if (typeof (first) === "object" && first && (typeof (first.ProviderName) != 'undefined' || typeof (first.Restrictions) != 'undefined')) {
            _request = providerName;
            _options = restrictions;
        }
        else {
            _request = {
                ProviderName: providerName,
                Restrictions: restrictions,
            };
            _options = webapi_options;
        }
        return this._SetDeletedStatusByProvider(_request, _options);
    }
    async _UndeleteByIds(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UndeleteByIds", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UndeleteByIds(ticketIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketIds;
        if (typeof (first) === "object" && first && (typeof (first.TicketIds) != 'undefined')) {
            _request = ticketIds;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketIds: ticketIds,
            };
            _options = webapi_options;
        }
        return this._UndeleteByIds(_request, _options);
    }
    async _ResolveTicketId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResolveTicketId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ResolveTicketId(ticketId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketId;
        if (typeof (first) === "object" && first && (typeof (first.TicketId) != 'undefined')) {
            _request = ticketId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketId: ticketId,
            };
            _options = webapi_options;
        }
        return this._ResolveTicketId(_request, _options);
    }
    async _BatchForward(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("BatchForward", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async BatchForward(ticketIds, to, cc, bcc, comment, closeTicket, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketIds;
        if (typeof (first) === "object" && first && (typeof (first.TicketIds) != 'undefined' || typeof (first.To) != 'undefined' || typeof (first.Cc) != 'undefined' || typeof (first.Bcc) != 'undefined' || typeof (first.Comment) != 'undefined' || typeof (first.CloseTicket) != 'undefined')) {
            _request = ticketIds;
            _options = to;
        }
        else {
            _request = {
                TicketIds: ticketIds,
                To: to,
                Cc: cc,
                Bcc: bcc,
                Comment: comment,
                CloseTicket: closeTicket,
            };
            _options = webapi_options;
        }
        return this._BatchForward(_request, _options);
    }
    async _BatchReply(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("BatchReply", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async BatchReply(batchReplyData, webapi_options) {
        let _request = null;
        let _options = null;
        const first = batchReplyData;
        if (typeof (first) === "object" && first && (typeof (first.BatchReplyData) != 'undefined')) {
            _request = batchReplyData;
            _options = webapi_options;
        }
        else {
            _request = {
                BatchReplyData: batchReplyData,
            };
            _options = webapi_options;
        }
        return this._BatchReply(_request, _options);
    }
    async _ClearNotify(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ClearNotify", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ClearNotify(ids, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ids;
        if (typeof (first) === "object" && first && (typeof (first.Ids) != 'undefined')) {
            _request = ids;
            _options = webapi_options;
        }
        else {
            _request = {
                Ids: ids,
            };
            _options = webapi_options;
        }
        return this._ClearNotify(_request, _options);
    }
    /*
     * Gets a TicketMessage object.
     * @param ticketMessageId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketMessage
     */
    async GetTicketMessage(ticketMessageId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketMessage?ticketMessageId=" + ticketMessageId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessage_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a TicketMessageEntity object.
     * @param ticketMessageEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single TicketMessageEntity
     */
    async GetTicketMessageEntity(ticketMessageEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetTicketMessageEntity?ticketMessageEntityId=" + ticketMessageEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _DeleteTicketMessageEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteTicketMessageEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteTicketMessageEntity(ticketMessageEntityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketMessageEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketMessageEntityId) != 'undefined')) {
            _request = ticketMessageEntityId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketMessageEntityId: ticketMessageEntityId,
            };
            _options = webapi_options;
        }
        return this._DeleteTicketMessageEntity(_request, _options);
    }
    async _SanitizeMailContent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SanitizeMailContent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SanitizeMailContent(content, webapi_options) {
        let _request = null;
        let _options = null;
        const first = content;
        if (typeof (first) === "object" && first && (typeof (first.Content) != 'undefined')) {
            _request = content;
            _options = webapi_options;
        }
        else {
            _request = {
                Content: content,
            };
            _options = webapi_options;
        }
        return this._SanitizeMailContent(_request, _options);
    }
    async _SanitizeMailContents(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SanitizeMailContents", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SanitizeMailContents(contents, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contents;
        if (typeof (first) === "object" && first && (typeof (first.Contents) != 'undefined')) {
            _request = contents;
            _options = webapi_options;
        }
        else {
            _request = {
                Contents: contents,
            };
            _options = webapi_options;
        }
        return this._SanitizeMailContents(_request, _options);
    }
    async _Html2Text(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("Html2Text", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async Html2Text(content, webapi_options) {
        let _request = null;
        let _options = null;
        const first = content;
        if (typeof (first) === "object" && first && (typeof (first.Content) != 'undefined')) {
            _request = content;
            _options = webapi_options;
        }
        else {
            _request = {
                Content: content,
            };
            _options = webapi_options;
        }
        return this._Html2Text(_request, _options);
    }
    async _GetAttachmentInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachmentInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AttachmentEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAttachmentInfo(ticketMessageEntityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketMessageEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketMessageEntityId) != 'undefined')) {
            _request = ticketMessageEntityId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketMessageEntityId: ticketMessageEntityId,
            };
            _options = webapi_options;
        }
        return this._GetAttachmentInfo(_request, _options);
    }
    async _GetAttachmentInfoNonInline(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAttachmentInfoNonInline", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AttachmentEntityArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAttachmentInfoNonInline(ticketMessageEntityId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketMessageEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketMessageEntityId) != 'undefined')) {
            _request = ticketMessageEntityId;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketMessageEntityId: ticketMessageEntityId,
            };
            _options = webapi_options;
        }
        return this._GetAttachmentInfoNonInline(_request, _options);
    }
    async _AddAttachments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddAttachments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddAttachments(ticketMessageEntityId, attachmentIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketMessageEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketMessageEntityId) != 'undefined' || typeof (first.AttachmentIds) != 'undefined')) {
            _request = ticketMessageEntityId;
            _options = attachmentIds;
        }
        else {
            _request = {
                TicketMessageEntityId: ticketMessageEntityId,
                AttachmentIds: attachmentIds,
            };
            _options = webapi_options;
        }
        return this._AddAttachments(_request, _options);
    }
    async _RemoveMessageAttachments(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveMessageAttachments", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveMessageAttachments(ticketMessageEntityId, attachmentIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketMessageEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketMessageEntityId) != 'undefined' || typeof (first.AttachmentIds) != 'undefined')) {
            _request = ticketMessageEntityId;
            _options = attachmentIds;
        }
        else {
            _request = {
                TicketMessageEntityId: ticketMessageEntityId,
                AttachmentIds: attachmentIds,
            };
            _options = webapi_options;
        }
        return this._RemoveMessageAttachments(_request, _options);
    }
    async _GetPreviewAttachmentStream(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetPreviewAttachmentStream", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_DocumentPreview_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetPreviewAttachmentStream(attachmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = attachmentId;
        if (typeof (first) === "object" && first && (typeof (first.AttachmentId) != 'undefined')) {
            _request = attachmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                AttachmentId: attachmentId,
            };
            _options = webapi_options;
        }
        return this._GetPreviewAttachmentStream(_request, _options);
    }
    async _SendTicketMessage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendTicketMessage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SendTicketMessage(ticketMessageEntityId, to, cc, bcc, subject, replyTemplateId, gdprSource, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketMessageEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketMessageEntityId) != 'undefined' || typeof (first.To) != 'undefined' || typeof (first.Cc) != 'undefined' || typeof (first.Bcc) != 'undefined' || typeof (first.Subject) != 'undefined' || typeof (first.ReplyTemplateId) != 'undefined' || typeof (first.GdprSource) != 'undefined')) {
            _request = ticketMessageEntityId;
            _options = to;
        }
        else {
            _request = {
                TicketMessageEntityId: ticketMessageEntityId,
                To: to,
                Cc: cc,
                Bcc: bcc,
                Subject: subject,
                ReplyTemplateId: replyTemplateId,
                GdprSource: gdprSource,
            };
            _options = webapi_options;
        }
        return this._SendTicketMessage(_request, _options);
    }
    async _SendTicketMessageSms(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendTicketMessageSms", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SendTicketMessageSms(ticketMessageEntityId, replyTemplateId, sms, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketMessageEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketMessageEntityId) != 'undefined' || typeof (first.ReplyTemplateId) != 'undefined' || typeof (first.Sms) != 'undefined')) {
            _request = ticketMessageEntityId;
            _options = replyTemplateId;
        }
        else {
            _request = {
                TicketMessageEntityId: ticketMessageEntityId,
                ReplyTemplateId: replyTemplateId,
                Sms: sms,
            };
            _options = webapi_options;
        }
        return this._SendTicketMessageSms(_request, _options);
    }
    async _SetTicketMessageImportant(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetTicketMessageImportant", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetTicketMessageImportant(ticketMessageId, important, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketMessageId;
        if (typeof (first) === "object" && first && (typeof (first.TicketMessageId) != 'undefined' || typeof (first.Important) != 'undefined')) {
            _request = ticketMessageId;
            _options = important;
        }
        else {
            _request = {
                TicketMessageId: ticketMessageId,
                Important: important,
            };
            _options = webapi_options;
        }
        return this._SetTicketMessageImportant(_request, _options);
    }
    async _CalculateMessageRecipients(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CalculateMessageRecipients", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RecipientArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CalculateMessageRecipients(ticketId, actionType, messageId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketId;
        if (typeof (first) === "object" && first && (typeof (first.TicketId) != 'undefined' || typeof (first.ActionType) != 'undefined' || typeof (first.MessageId) != 'undefined')) {
            _request = ticketId;
            _options = actionType;
        }
        else {
            _request = {
                TicketId: ticketId,
                ActionType: actionType,
                MessageId: messageId,
            };
            _options = webapi_options;
        }
        return this._CalculateMessageRecipients(_request, _options);
    }
    async _SaveTicketMessageEntityWithNotify(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTicketMessageEntityWithNotify", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveTicketMessageEntityWithNotify(newEntity, notify, webapi_options) {
        let _request = null;
        let _options = null;
        const first = newEntity;
        if (typeof (first) === "object" && first && (typeof (first.NewEntity) != 'undefined' || typeof (first.Notify) != 'undefined')) {
            _request = newEntity;
            _options = notify;
        }
        else {
            _request = {
                NewEntity: newEntity,
                Notify: notify,
            };
            _options = webapi_options;
        }
        return this._SaveTicketMessageEntityWithNotify(_request, _options);
    }
    async _SaveTicketMessageEntityWithOptions(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveTicketMessageEntityWithOptions", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveTicketMessageEntityWithOptions(entity, notify, attachmentIds, updateRepliedAt, webapi_options) {
        let _request = null;
        let _options = null;
        const first = entity;
        if (typeof (first) === "object" && first && (typeof (first.Entity) != 'undefined' || typeof (first.Notify) != 'undefined' || typeof (first.AttachmentIds) != 'undefined' || typeof (first.UpdateRepliedAt) != 'undefined')) {
            _request = entity;
            _options = notify;
        }
        else {
            _request = {
                Entity: entity,
                Notify: notify,
                AttachmentIds: attachmentIds,
                UpdateRepliedAt: updateRepliedAt,
            };
            _options = webapi_options;
        }
        return this._SaveTicketMessageEntityWithOptions(_request, _options);
    }
    async _GetDefaultMessageContent(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultMessageContent", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDefaultMessageContent(ticketId, messageActionType, ticketMessageId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketId;
        if (typeof (first) === "object" && first && (typeof (first.TicketId) != 'undefined' || typeof (first.MessageActionType) != 'undefined' || typeof (first.TicketMessageId) != 'undefined')) {
            _request = ticketId;
            _options = messageActionType;
        }
        else {
            _request = {
                TicketId: ticketId,
                MessageActionType: messageActionType,
                TicketMessageId: ticketMessageId,
            };
            _options = webapi_options;
        }
        return this._GetDefaultMessageContent(_request, _options);
    }
    async _GetTicketMessageWithEmbeddedData(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketMessageWithEmbeddedData", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTicketMessageWithEmbeddedData(id, embedImages, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.EmbedImages) != 'undefined')) {
            _request = id;
            _options = embedImages;
        }
        else {
            _request = {
                Id: id,
                EmbedImages: embedImages,
            };
            _options = webapi_options;
        }
        return this._GetTicketMessageWithEmbeddedData(_request, _options);
    }
    async _DeleteMessageHeaders(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteMessageHeaders", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteMessageHeaders(headerIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = headerIds;
        if (typeof (first) === "object" && first && (typeof (first.HeaderIds) != 'undefined')) {
            _request = headerIds;
            _options = webapi_options;
        }
        else {
            _request = {
                HeaderIds: headerIds,
            };
            _options = webapi_options;
        }
        return this._DeleteMessageHeaders(_request, _options);
    }
    async _GetTicketMessageWithOptions(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketMessageWithOptions", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketMessageEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTicketMessageWithOptions(ticketMessageEntityId, includeNonInlineAttachmentsInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketMessageEntityId;
        if (typeof (first) === "object" && first && (typeof (first.TicketMessageEntityId) != 'undefined' || typeof (first.IncludeNonInlineAttachmentsInfo) != 'undefined')) {
            _request = ticketMessageEntityId;
            _options = includeNonInlineAttachmentsInfo;
        }
        else {
            _request = {
                TicketMessageEntityId: ticketMessageEntityId,
                IncludeNonInlineAttachmentsInfo: includeNonInlineAttachmentsInfo,
            };
            _options = webapi_options;
        }
        return this._GetTicketMessageWithOptions(_request, _options);
    }
    async _GetTicketSummaries(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetTicketSummaries", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TicketSummaryItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetTicketSummaries(ticketIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ticketIds;
        if (typeof (first) === "object" && first && (typeof (first.TicketIds) != 'undefined')) {
            _request = ticketIds;
            _options = webapi_options;
        }
        else {
            _request = {
                TicketIds: ticketIds,
            };
            _options = webapi_options;
        }
        return this._GetTicketSummaries(_request, _options);
    }
} // class v1TicketAgentController 
exports.TicketAgent = TicketAgent;
//# sourceMappingURL=TicketAgent.js.map
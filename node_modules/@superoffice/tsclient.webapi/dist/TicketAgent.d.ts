import { AxiosRequestConfig } from 'axios';
import * as enums from './Enums';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
/**
 * Agent used for Ticket functions
 */
export interface ITicketAgent {
    CreateDefaultAttachmentEntity(): Promise<carriers.AttachmentEntity>;
    SaveAttachmentEntity(entity: carriers.AttachmentEntity): Promise<carriers.AttachmentEntity>;
    CreateDefaultTicketEntity(): Promise<carriers.TicketEntity>;
    SaveTicketEntity(entity: carriers.TicketEntity): Promise<carriers.TicketEntity>;
    CreateDefaultTicketMessageEntity(): Promise<carriers.TicketMessageEntity>;
    SaveTicketMessageEntity(entity: carriers.TicketMessageEntity): Promise<carriers.TicketMessageEntity>;
    GetAttachmentEntity(attachmentEntityId: number): Promise<carriers.AttachmentEntity>;
    CopyFromCRMDocument(request: carriers.Ticket_CopyFromCRMDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity>;
    CopyFromCRMDocument(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity>;
    CopyToTempFile(request: carriers.Ticket_CopyToTempFileRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    CopyToTempFile(filename: string, attachmentId: number, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    UploadAttachment(request: carriers.Ticket_UploadAttachmentRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    UploadAttachment(attachmentId: number, content: ArrayBuffer | string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    GetAttachmentStream(request: carriers.Ticket_GetAttachmentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetAttachmentStream(attachmentId: number, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetTicket(ticketId: number): Promise<carriers.Ticket>;
    GetTickets(request: carriers.Ticket_GetTicketsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Ticket[]>;
    GetTickets(ticketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Ticket[]>;
    GetTicketEntity(ticketEntityId: number): Promise<carriers.TicketEntity>;
    GetForRmUi(request: carriers.Ticket_GetForRmUiRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    GetForRmUi(ticketId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    DeleteTicketEntity(request: carriers.Ticket_DeleteTicketEntityRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    DeleteTicketEntity(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    NotifyNewTicket(request: carriers.Ticket_NotifyNewTicketRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    NotifyNewTicket(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    NotifyNewTicketMessage(request: carriers.Ticket_NotifyNewTicketMessageRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    NotifyNewTicketMessage(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    GetTicketAttachments(request: carriers.Ticket_GetTicketAttachmentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    GetTicketAttachments(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    ValidateAttachments(request: carriers.Ticket_ValidateAttachmentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentValidationResult[]>;
    ValidateAttachments(attachmentIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentValidationResult[]>;
    SetTicketReadByOwner(request: carriers.Ticket_SetTicketReadByOwnerRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    SetTicketReadByOwner(ticketEntityId: number, readStatus: enums.TicketReadStatus, checkEscalating: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    SaveTicketEntityWithNotify(request: carriers.Ticket_SaveTicketEntityWithNotifyRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    SaveTicketEntityWithNotify(newEntity: carriers.TicketEntity, notify: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    GetNextInQueue(webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    ProcessTicketWhenRead(request: carriers.Ticket_ProcessTicketWhenReadRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    ProcessTicketWhenRead(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    SplitTicket(request: carriers.Ticket_SplitTicketRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    SplitTicket(sourceTicketEntityId: number, transferMessageIds: number[], newTicketEntity: carriers.TicketEntity, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    SplitTicketMessage(request: carriers.Ticket_SplitTicketMessageRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    SplitTicketMessage(sourceTicketMessage: carriers.TicketMessageEntity, newTicketEntity: carriers.TicketEntity, newTicketMessage: carriers.TicketMessageEntity, transferAttachmentsIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    UpdateTicketsReadStatus(request: carriers.Ticket_UpdateTicketsReadStatusRequest, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    UpdateTicketsReadStatus(ticketIds: number[], newStatus: enums.TicketReadStatus, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    UpdateTicketsReadStatusByProvider(request: carriers.Ticket_UpdateTicketsReadStatusByProviderRequest, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    UpdateTicketsReadStatusByProvider(provider: string, restrictions: carriers.ArchiveRestrictionInfo[], newStatus: enums.TicketReadStatus, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    MergeTickets(request: carriers.Ticket_MergeTicketsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    MergeTickets(mergedTicketEntity: carriers.TicketEntity, secondaryTicketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    SetDeletedStatusByIds(request: carriers.Ticket_SetDeletedStatusByIdsRequest, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    SetDeletedStatusByIds(ticketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    SetDeletedStatusByProvider(request: carriers.Ticket_SetDeletedStatusByProviderRequest, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    SetDeletedStatusByProvider(providerName: string, restrictions: carriers.ArchiveRestrictionInfo[], webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    UndeleteByIds(request: carriers.Ticket_UndeleteByIdsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    UndeleteByIds(ticketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    ResolveTicketId(request: carriers.Ticket_ResolveTicketIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    ResolveTicketId(ticketId: number, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    BatchForward(request: carriers.Ticket_BatchForwardRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    BatchForward(ticketIds: number[], to: string[], cc: string[], bcc: string[], comment: string, closeTicket: boolean, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    BatchReply(request: carriers.Ticket_BatchReplyRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    BatchReply(batchReplyData: carriers.TicketBatchReplyData, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    ClearNotify(request: carriers.Ticket_ClearNotifyRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    ClearNotify(ids: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    GetTicketMessage(ticketMessageId: number): Promise<carriers.TicketMessage>;
    GetTicketMessageEntity(ticketMessageEntityId: number): Promise<carriers.TicketMessageEntity>;
    DeleteTicketMessageEntity(request: carriers.Ticket_DeleteTicketMessageEntityRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    DeleteTicketMessageEntity(ticketMessageEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SanitizeMailContent(request: carriers.Ticket_SanitizeMailContentRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    SanitizeMailContent(content: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    SanitizeMailContents(request: carriers.Ticket_SanitizeMailContentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<string[]>;
    SanitizeMailContents(contents: string[], webapi_options?: base.WebApiRequestOptions): Promise<string[]>;
    Html2Text(request: carriers.Ticket_Html2TextRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    Html2Text(content: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetAttachmentInfo(request: carriers.Ticket_GetAttachmentInfoRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    GetAttachmentInfo(ticketMessageEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    GetAttachmentInfoNonInline(request: carriers.Ticket_GetAttachmentInfoNonInlineRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    GetAttachmentInfoNonInline(ticketMessageEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    AddAttachments(request: carriers.Ticket_AddAttachmentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    AddAttachments(ticketMessageEntityId: number, attachmentIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    RemoveMessageAttachments(request: carriers.Ticket_RemoveMessageAttachmentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    RemoveMessageAttachments(ticketMessageEntityId: number, attachmentIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    GetPreviewAttachmentStream(request: carriers.Ticket_GetPreviewAttachmentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    GetPreviewAttachmentStream(attachmentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    SendTicketMessage(request: carriers.Ticket_SendTicketMessageRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SendTicketMessage(ticketMessageEntityId: number, to: string[], cc: string[], bcc: string[], subject: string, replyTemplateId: number, gdprSource: string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SendTicketMessageSms(request: carriers.Ticket_SendTicketMessageSmsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SendTicketMessageSms(ticketMessageEntityId: number, replyTemplateId: number, sms: string[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SetTicketMessageImportant(request: carriers.Ticket_SetTicketMessageImportantRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    SetTicketMessageImportant(ticketMessageId: number, important: boolean, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    CalculateMessageRecipients(request: carriers.Ticket_CalculateMessageRecipientsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Recipient[]>;
    CalculateMessageRecipients(ticketId: number, actionType: enums.MessageActionType, messageId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Recipient[]>;
    SaveTicketMessageEntityWithNotify(request: carriers.Ticket_SaveTicketMessageEntityWithNotifyRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    SaveTicketMessageEntityWithNotify(newEntity: carriers.TicketMessageEntity, notify: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    SaveTicketMessageEntityWithOptions(request: carriers.Ticket_SaveTicketMessageEntityWithOptionsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    SaveTicketMessageEntityWithOptions(entity: carriers.TicketMessageEntity, notify: boolean, attachmentIds: number[], updateRepliedAt: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    GetDefaultMessageContent(request: carriers.Ticket_GetDefaultMessageContentRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetDefaultMessageContent(ticketId: number, messageActionType: enums.MessageActionType, ticketMessageId: number, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetTicketMessageWithEmbeddedData(request: carriers.Ticket_GetTicketMessageWithEmbeddedDataRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    GetTicketMessageWithEmbeddedData(id: number, embedImages: enums.ImageEmbedType, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    DeleteMessageHeaders(request: carriers.Ticket_DeleteMessageHeadersRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    DeleteMessageHeaders(headerIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    GetTicketMessageWithOptions(request: carriers.Ticket_GetTicketMessageWithOptionsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    GetTicketMessageWithOptions(ticketMessageEntityId: number, includeNonInlineAttachmentsInfo: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    GetTicketSummaries(request: carriers.Ticket_GetTicketSummariesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketSummaryItem[]>;
    GetTicketSummaries(ticketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketSummaryItem[]>;
}
/**
 * Agent used for Ticket functions
 */
export declare class TicketAgent extends base.WebApiBase implements ITicketAgent {
    constructor(baseUrl?: string, languageCode?: string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager: any);
    constructor(baseUrl: string, config: AxiosRequestConfig, resourceManager: any);
    constructor(baseUrl: string, config: AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config: AxiosRequestConfig, languageCode?: string, cultureCode?: string);
    constructor(options: base.WebApiOptions);
    /**
     * Set default values into a new AttachmentEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultAttachmentEntity(options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity>;
    SaveAttachmentEntity(entity: carriers.AttachmentEntity, options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity>;
    /**
     * Set default values into a new TicketEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultTicketEntity(options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    SaveTicketEntity(entity: carriers.TicketEntity, options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    /**
     * Set default values into a new TicketMessageEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    CreateDefaultTicketMessageEntity(options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    SaveTicketMessageEntity(entity: carriers.TicketMessageEntity, options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    GetAttachmentEntity(attachmentEntityId: number, options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity>;
    private _CopyFromCRMDocument;
    /**
     * Copy CRM document to an attachment
     * @param request - DocumentId
     * @returns
     */
    CopyFromCRMDocument(request: carriers.Ticket_CopyFromCRMDocumentRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity>;
    /**
     * Copy CRM document to an attachment
     * @param documentId - The id of the document to copy to an attachment
     * @returns
     */
    CopyFromCRMDocument(documentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity>;
    private _CopyToTempFile;
    /**
     * Copy ticket attachment to temporary file. Needed for existing document dialog compatibility
     * @param request - Filename, AttachmentId
     * @returns Temporary document filename
     */
    CopyToTempFile(request: carriers.Ticket_CopyToTempFileRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Copy ticket attachment to temporary file. Needed for existing document dialog compatibility
     * @param filename - Preferred filename
     * @param attachmentId - The id of the attachment to copy
     * @returns Temporary document filename
     */
    CopyToTempFile(filename: string, attachmentId: number, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _UploadAttachment;
    /**
     * Upload the content for an attachment
     * @param request - AttachmentId, Content
     * @returns This method has no return value
     */
    UploadAttachment(request: carriers.Ticket_UploadAttachmentRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Upload the content for an attachment
     * @param attachmentId - The id of the attachment row, for which to attach the upload data
     * @param content - A stream to the content to be uploaded
     * @returns This method has no return value
     */
    UploadAttachment(attachmentId: number, content: ArrayBuffer | string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _GetAttachmentStream;
    /**
     * Get the content of an attachment
     * @param request - AttachmentId
     * @returns A stream to the attachment content
     */
    GetAttachmentStream(request: carriers.Ticket_GetAttachmentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    /**
     * Get the content of an attachment
     * @param attachmentId - The id of the attachment to retrieve
     * @returns A stream to the attachment content
     */
    GetAttachmentStream(attachmentId: number, webapi_options?: base.WebApiRequestOptions): Promise<ArrayBuffer | string>;
    GetTicket(ticketId: number, options?: base.WebApiRequestOptions): Promise<carriers.Ticket>;
    private _GetTickets;
    /**
     * Get multiple tickets
     * @param request - TicketIds
     * @returns Returns array of tickets in same order as input ids
     */
    GetTickets(request: carriers.Ticket_GetTicketsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Ticket[]>;
    /**
     * Get multiple tickets
     * @param ticketIds - The ids of tickets to get
     * @returns Returns array of tickets in same order as input ids
     */
    GetTickets(ticketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.Ticket[]>;
    GetTicketEntity(ticketEntityId: number, options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    private _GetForRmUi;
    /**
     * Get a ticket entity, adapted to the specific needs of the Request Management UI. WARNING: This endpoint is not guaranteed to be stable/compatible between versions
     * @param request - TicketId
     * @returns The ticket entity. Information is filtered/adapted to the current needs of the UI
     */
    GetForRmUi(request: carriers.Ticket_GetForRmUiRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    /**
     * Get a ticket entity, adapted to the specific needs of the Request Management UI. WARNING: This endpoint is not guaranteed to be stable/compatible between versions
     * @param ticketId - Primary key of ticket to fetch
     * @returns The ticket entity. Information is filtered/adapted to the current needs of the UI
     */
    GetForRmUi(ticketId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    private _DeleteTicketEntity;
    /**
     * Delete a ticket
     * @param request - TicketEntityId
     * @returns returns void
     */
    DeleteTicketEntity(request: carriers.Ticket_DeleteTicketEntityRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Delete a ticket
     * @param ticketEntityId - The ticket to delete
     * @returns returns void
     */
    DeleteTicketEntity(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _NotifyNewTicket;
    /**
     * Notify user agents about the creation of a new ticket
     * @param request - TicketEntityId
     * @returns This method has no return value
     */
    NotifyNewTicket(request: carriers.Ticket_NotifyNewTicketRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Notify user agents about the creation of a new ticket
     * @param ticketEntityId - The id of the ticket to notify about
     * @returns This method has no return value
     */
    NotifyNewTicket(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _NotifyNewTicketMessage;
    /**
     * Notify user agents about the creation of a new message on a ticket
     * @param request - TicketEntityId
     * @returns This method has no return value
     */
    NotifyNewTicketMessage(request: carriers.Ticket_NotifyNewTicketMessageRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Notify user agents about the creation of a new message on a ticket
     * @param ticketEntityId - The id of the ticket to notify about
     * @returns This method has no return value
     */
    NotifyNewTicketMessage(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _GetTicketAttachments;
    /**
     * Get attachment infos for all attachments connected to messages in specified ticket
     * @param request - TicketEntityId
     * @returns An array containing attachment info objects for all the attachments
     */
    GetTicketAttachments(request: carriers.Ticket_GetTicketAttachmentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    /**
     * Get attachment infos for all attachments connected to messages in specified ticket
     * @param ticketEntityId - The id of the ticket to get attachment infos from
     * @returns An array containing attachment info objects for all the attachments
     */
    GetTicketAttachments(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    private _ValidateAttachments;
    /**
     * Check attachments, return validation result for each item
     * @param request - AttachmentIds
     * @returns Validation result
     */
    ValidateAttachments(request: carriers.Ticket_ValidateAttachmentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentValidationResult[]>;
    /**
     * Check attachments, return validation result for each item
     * @param attachmentIds - The IDs of the attachments to validate
     * @returns Validation result
     */
    ValidateAttachments(attachmentIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentValidationResult[]>;
    private _SetTicketReadByOwner;
    /**
     * Set the ReadByOwner status for a ticket. It will only have an effect if the calling user is the same as the owner of the ticket
     * @param request - TicketEntityId, ReadStatus, CheckEscalating
     * @returns The ticket entity after setting the ReadByOwner
     */
    SetTicketReadByOwner(request: carriers.Ticket_SetTicketReadByOwnerRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    /**
     * Set the ReadByOwner status for a ticket. It will only have an effect if the calling user is the same as the owner of the ticket
     * @param ticketEntityId - The id of the ticket to set
     * @param readStatus - The read status to set. See the enum for explanation of the different colors. Setting Unknown does nothing
     * @param checkEscalating - If true, then the escalation system will be called and executed when setting the ReadByOwner
     * @returns The ticket entity after setting the ReadByOwner
     */
    SetTicketReadByOwner(ticketEntityId: number, readStatus: enums.TicketReadStatus, checkEscalating: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    private _SaveTicketEntityWithNotify;
    /**
     * Saves a ticket and performs any user notifications
     * @param request - NewEntity, Notify
     * @returns The newly saved entity
     */
    SaveTicketEntityWithNotify(request: carriers.Ticket_SaveTicketEntityWithNotifyRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    /**
     * Saves a ticket and performs any user notifications
     * @param newEntity - The ticket to save
     * @param notify - If true, then the notifications will be sent
     * @returns The newly saved entity
     */
    SaveTicketEntityWithNotify(newEntity: carriers.TicketEntity, notify: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    private _GetNextInQueue;
    /**
     * Assign a ticket to the caller based on intelligent queue system
     * @returns The ticket entity after assigning it to the caller
     */
    GetNextInQueue(webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    private _ProcessTicketWhenRead;
    /**
     * When a user view/read a ticket, a number of action should be performed: set read status, escalation handling, remove notifications, etc. Which actions will be performed depends on owner, caller and configuration
     * @param request - TicketEntityId
     * @returns The ticket entity after marking it as read
     */
    ProcessTicketWhenRead(request: carriers.Ticket_ProcessTicketWhenReadRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    /**
     * When a user view/read a ticket, a number of action should be performed: set read status, escalation handling, remove notifications, etc. Which actions will be performed depends on owner, caller and configuration
     * @param ticketEntityId - The id of the ticket to mark as read
     * @returns The ticket entity after marking it as read
     */
    ProcessTicketWhenRead(ticketEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    private _SplitTicket;
    /**
     * Save new ticket and move/copy data from existing ticket in a single request. Specified messages will be moved.
     * @param request - SourceTicketEntityId, TransferMessageIds, NewTicketEntity
     * @returns The newly created entity
     */
    SplitTicket(request: carriers.Ticket_SplitTicketRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    /**
     * Save new ticket and move/copy data from existing ticket in a single request. Specified messages will be moved.
     * @param sourceTicketEntityId - The id of the ticket to split
     * @param transferMessageIds - IDs of messages that should be transferred from the original ticket to the new one
     * @param newTicketEntity - The new ticket to save. Includes new values for simple properties like title, category, status, etc., but not messages.
     * @returns The newly created entity
     */
    SplitTicket(sourceTicketEntityId: number, transferMessageIds: number[], newTicketEntity: carriers.TicketEntity, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    private _SplitTicketMessage;
    /**
     * Create new ticket and move/copy data from existing ticket in addition update old message and save new message in a single request.
     * @param request - SourceTicketMessage, NewTicketEntity, NewTicketMessage, TransferAttachmentsIds
     * @returns The newly created entity
     */
    SplitTicketMessage(request: carriers.Ticket_SplitTicketMessageRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    /**
     * Create new ticket and move/copy data from existing ticket in addition update old message and save new message in a single request.
     * @param sourceTicketMessage - The message being splitted, content can be modified as part of the split.
     * @param newTicketEntity - The new ticket to save. Includes new values for simple properties like title, category, status, etc., but not messages.
     * @param newTicketMessage - The new message to be saved
     * @param transferAttachmentsIds - IDs of attachments that should be transferred from the original message to the new one
     * @returns The newly created entity
     */
    SplitTicketMessage(sourceTicketMessage: carriers.TicketMessageEntity, newTicketEntity: carriers.TicketEntity, newTicketMessage: carriers.TicketMessageEntity, transferAttachmentsIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    private _UpdateTicketsReadStatus;
    /**
     * This method changes multiple tickets&apos; read status
     * @param request - TicketIds, NewStatus
     * @returns Updated ticket ids
     */
    UpdateTicketsReadStatus(request: carriers.Ticket_UpdateTicketsReadStatusRequest, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    /**
     * This method changes multiple tickets&apos; read status
     * @param ticketIds - Ticket ids to be updated
     * @param newStatus - New read status
     * @returns Updated ticket ids
     */
    UpdateTicketsReadStatus(ticketIds: number[], newStatus: enums.TicketReadStatus, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    private _UpdateTicketsReadStatusByProvider;
    /**
     * This method changes multiple tickets&apos; read status
     * @param request - Provider, Restrictions, NewStatus
     * @returns Updated ticket ids
     */
    UpdateTicketsReadStatusByProvider(request: carriers.Ticket_UpdateTicketsReadStatusByProviderRequest, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    /**
     * This method changes multiple tickets&apos; read status
     * @param provider - Name of the provider that returns ticket rows.
     * @param restrictions - Query restrictions to be added to provider. Fixed providers, such as LastTicketsProvider, FavouriteTicketsProvider etc. already have mandatory restrictions setup - in such case extra restrictions will be combined, however for general use case for fixed providers you can pass an empty array and provider will return default results. For selection providers generally you should pass selectionId as a restriction.
     * @param newStatus - New read status
     * @returns Updated ticket ids
     */
    UpdateTicketsReadStatusByProvider(provider: string, restrictions: carriers.ArchiveRestrictionInfo[], newStatus: enums.TicketReadStatus, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    private _MergeTickets;
    /**
     * Merge one or more tickets into one primary ticket
     * @param request - MergedTicketEntity, SecondaryTicketIds
     * @returns The newly merged entity
     */
    MergeTickets(request: carriers.Ticket_MergeTicketsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    /**
     * Merge one or more tickets into one primary ticket
     * @param mergedTicketEntity - Merged ticket entity
     * @param secondaryTicketIds - Ids of secondary tickets
     * @returns The newly merged entity
     */
    MergeTickets(mergedTicketEntity: carriers.TicketEntity, secondaryTicketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketEntity>;
    private _SetDeletedStatusByIds;
    /**
     * Sets tickets&apos; status to Deleted. After a grace period these tickets will be deleted by a background job.
     * @param request - TicketIds
     * @returns Ids of tickets set for deletion.
     */
    SetDeletedStatusByIds(request: carriers.Ticket_SetDeletedStatusByIdsRequest, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    /**
     * Sets tickets&apos; status to Deleted. After a grace period these tickets will be deleted by a background job.
     * @param ticketIds - Ids of tickets to be set for deletion.
     * @returns Ids of tickets set for deletion.
     */
    SetDeletedStatusByIds(ticketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    private _SetDeletedStatusByProvider;
    /**
     * Sets tickets&apos; status to Deleted. After a grace period these tickets will be deleted by a background job.
     * @param request - ProviderName, Restrictions
     * @returns Ids of tickets set for deletion.
     */
    SetDeletedStatusByProvider(request: carriers.Ticket_SetDeletedStatusByProviderRequest, webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    /**
     * Sets tickets&apos; status to Deleted. After a grace period these tickets will be deleted by a background job.
     * @param providerName - Name of the provider that returns ticket rows.
     * @param restrictions - Query restrictions to be added to provider. Fixed providers, such as LastTicketsProvider, FavouriteTicketsProvider etc. already have mandatory restrictions setup - in such case extra restrictions will be combined, however for general use case for fixed providers you can pass an empty array and provider will return default results. For selection providers generally you should pass selectionId as a restriction.
     * @returns Ids of tickets set for deletion.
     */
    SetDeletedStatusByProvider(providerName: string, restrictions: carriers.ArchiveRestrictionInfo[], webapi_options?: base.WebApiRequestOptions): Promise<number[]>;
    private _UndeleteByIds;
    /**
     * Restores deleted tickets by their ids. Status is set to a default open status defined in Registry table
     * @param request - TicketIds
     * @returns This method has no return value
     */
    UndeleteByIds(request: carriers.Ticket_UndeleteByIdsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Restores deleted tickets by their ids. Status is set to a default open status defined in Registry table
     * @param ticketIds - Ids of tickets to be restored.
     * @returns This method has no return value
     */
    UndeleteByIds(ticketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _ResolveTicketId;
    /**
     * Ticket can be connected (merged) to another ticket. This method traverses through its connection(s) and returns proper ticketId
     * @param request - TicketId
     * @returns Correct ticketId. Returns 0 in case ticket does not exists
     */
    ResolveTicketId(request: carriers.Ticket_ResolveTicketIdRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    /**
     * Ticket can be connected (merged) to another ticket. This method traverses through its connection(s) and returns proper ticketId
     * @param ticketId - Potentially correct ticketId
     * @returns Correct ticketId. Returns 0 in case ticket does not exists
     */
    ResolveTicketId(ticketId: number, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    private _BatchForward;
    /**
     * Forwards selected tickets to specified recipients. This method starts a batch task.
     * @param request - TicketIds, To, Cc, Bcc, Comment, CloseTicket
     * @returns ID of the new batch task.
     */
    BatchForward(request: carriers.Ticket_BatchForwardRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    /**
     * Forwards selected tickets to specified recipients. This method starts a batch task.
     * @param ticketIds - Ids of tickets to be forwarded.
     * @param to - The To-recipients. Each recipient must be in correct mailbox format (john@example.com or John Doe <john@example.com>).
     * @param cc - The Cc-recipients. Each recipient must be in correct mailbox format (john@example.com or John Doe <john@example.com>).
     * @param bcc - The Bcc-recipients. Each recipient must be in correct mailbox format (john@example.com or John Doe <john@example.com>).
     * @param comment - Comment will be included before ticket messages. Might be empty
     * @param closeTicket - If true, ticket will be closed after forwarding
     * @returns ID of the new batch task.
     */
    BatchForward(ticketIds: number[], to: string[], cc: string[], bcc: string[], comment: string, closeTicket: boolean, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    private _BatchReply;
    /**
     * Replies to the specified tickets. This method starts a batch task.
     * @param request - BatchReplyData
     * @returns ID of the new batch task.
     */
    BatchReply(request: carriers.Ticket_BatchReplyRequest, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    /**
     * Replies to the specified tickets. This method starts a batch task.
     * @param batchReplyData - All data needed to initiate a mass ticket reply sending.
     * @returns ID of the new batch task.
     */
    BatchReply(batchReplyData: carriers.TicketBatchReplyData, webapi_options?: base.WebApiRequestOptions): Promise<number>;
    private _ClearNotify;
    /**
     * Clear notification status for one or more tickets.
     * @param request - Ids
     * @returns This method has no return value
     */
    ClearNotify(request: carriers.Ticket_ClearNotifyRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Clear notification status for one or more tickets.
     * @param ids - List of notify IDs.
     * @returns This method has no return value
     */
    ClearNotify(ids: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    GetTicketMessage(ticketMessageId: number, options?: base.WebApiRequestOptions): Promise<carriers.TicketMessage>;
    GetTicketMessageEntity(ticketMessageEntityId: number, options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    private _DeleteTicketMessageEntity;
    /**
     * Delete a ticket message
     * @param request - TicketMessageEntityId
     * @returns returns void
     */
    DeleteTicketMessageEntity(request: carriers.Ticket_DeleteTicketMessageEntityRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Delete a ticket message
     * @param ticketMessageEntityId - The ticket message to delete
     * @returns returns void
     */
    DeleteTicketMessageEntity(ticketMessageEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _SanitizeMailContent;
    /**
     * Remove harmful HTML tags and attributes from an email
     * @param request - Content
     * @returns The sanitized email content
     */
    SanitizeMailContent(request: carriers.Ticket_SanitizeMailContentRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Remove harmful HTML tags and attributes from an email
     * @param content - The email content to sanitize
     * @returns The sanitized email content
     */
    SanitizeMailContent(content: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _SanitizeMailContents;
    /**
     * Remove harmful HTML tags and attributes from an email
     * @param request - Contents
     * @returns The sanitized email contents
     */
    SanitizeMailContents(request: carriers.Ticket_SanitizeMailContentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<string[]>;
    /**
     * Remove harmful HTML tags and attributes from an email
     * @param contents - The email contents to sanitize
     * @returns The sanitized email contents
     */
    SanitizeMailContents(contents: string[], webapi_options?: base.WebApiRequestOptions): Promise<string[]>;
    private _Html2Text;
    /**
     * Create a plain text version of the html, suitable for email
     * @param request - Content
     * @returns The plain text version
     */
    Html2Text(request: carriers.Ticket_Html2TextRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Create a plain text version of the html, suitable for email
     * @param content - The html version
     * @returns The plain text version
     */
    Html2Text(content: string, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _GetAttachmentInfo;
    /**
     * Get a list with meta data for all attached attachments
     * @param request - TicketMessageEntityId
     * @returns An array with AttachmentEntity objects, describing each attachment
     */
    GetAttachmentInfo(request: carriers.Ticket_GetAttachmentInfoRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    /**
     * Get a list with meta data for all attached attachments
     * @param ticketMessageEntityId - The id of the ticket message to get attachment infos for
     * @returns An array with AttachmentEntity objects, describing each attachment
     */
    GetAttachmentInfo(ticketMessageEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    private _GetAttachmentInfoNonInline;
    /**
     * Get a list with meta data for all attached attachments, EXCEPT those marked as inline
     * @param request - TicketMessageEntityId
     * @returns An array with AttachmentEntity objects, describing each attachment; those marked as INLINE will be skipped
     */
    GetAttachmentInfoNonInline(request: carriers.Ticket_GetAttachmentInfoNonInlineRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    /**
     * Get a list with meta data for all attached attachments, EXCEPT those marked as inline
     * @param ticketMessageEntityId - The id of the ticket message to get attachment infos for
     * @returns An array with AttachmentEntity objects, describing each attachment; those marked as INLINE will be skipped
     */
    GetAttachmentInfoNonInline(ticketMessageEntityId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.AttachmentEntity[]>;
    private _AddAttachments;
    /**
     * Connect existing attachments with this TicketMessage. Can connect multiple attachments
     * @param request - TicketMessageEntityId, AttachmentIds
     * @returns
     */
    AddAttachments(request: carriers.Ticket_AddAttachmentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Connect existing attachments with this TicketMessage. Can connect multiple attachments
     * @param ticketMessageEntityId - The id of the ticket message to connect the attachments to
     * @param attachmentIds - An array of attachments to connect to this TicketMessage
     * @returns
     */
    AddAttachments(ticketMessageEntityId: number, attachmentIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _RemoveMessageAttachments;
    /**
     * Removes attachments from the message as specified in the collection of entity ids. The ids are attachment ids (attachment primary key)
     * @param request - TicketMessageEntityId, AttachmentIds
     * @returns This method has no return value
     */
    RemoveMessageAttachments(request: carriers.Ticket_RemoveMessageAttachmentsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Removes attachments from the message as specified in the collection of entity ids. The ids are attachment ids (attachment primary key)
     * @param ticketMessageEntityId - The id of the ticket message to remove attachments from
     * @param attachmentIds - Attachment primary keys
     * @returns This method has no return value
     */
    RemoveMessageAttachments(ticketMessageEntityId: number, attachmentIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _GetPreviewAttachmentStream;
    /**
     * Retrieve an attachment from ticket message. The returned data is intended to be used for a preview. The returned data is sanitized.
     * @param request - AttachmentId
     * @returns Sanitized preview version of the attachment
     */
    GetPreviewAttachmentStream(request: carriers.Ticket_GetPreviewAttachmentStreamRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    /**
     * Retrieve an attachment from ticket message. The returned data is intended to be used for a preview. The returned data is sanitized.
     * @param attachmentId - The id of the attachment to retrieve
     * @returns Sanitized preview version of the attachment
     */
    GetPreviewAttachmentStream(attachmentId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.DocumentPreview>;
    private _SendTicketMessage;
    /**
     * Send a message to recipients by email
     * @param request - TicketMessageEntityId, To, Cc, Bcc, Subject, ReplyTemplateId, GdprSource
     * @returns This method has no return value
     */
    SendTicketMessage(request: carriers.Ticket_SendTicketMessageRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Send a message to recipients by email
     * @param ticketMessageEntityId - The id of the ticket message to send
     * @param to - The To-recipients. Each recipient must be in correct format
     * @param cc - The Cc-recipients. Each recipient must be in correct format
     * @param bcc - The Bcc-recipients. Each recipient must be in correct format
     * @param subject - The subject
     * @param replyTemplateId - Optional ID of reply template to merge message with. <= 0 to skip.
     * @param gdprSource - Obsolete
     * @returns This method has no return value
     */
    SendTicketMessage(ticketMessageEntityId: number, to: string[], cc: string[], bcc: string[], subject: string, replyTemplateId: number, gdprSource: string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _SendTicketMessageSms;
    /**
     * Send a message to recipients by sms
     * @param request - TicketMessageEntityId, ReplyTemplateId, Sms
     * @returns This method has no return value
     */
    SendTicketMessageSms(request: carriers.Ticket_SendTicketMessageSmsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Send a message to recipients by sms
     * @param ticketMessageEntityId - The id of the ticket message to send
     * @param replyTemplateId - Optional ID of reply template to merge message with. <= 0 to skip.
     * @param sms - The Sms-recipients. Each recipient must be in correct format
     * @returns This method has no return value
     */
    SendTicketMessageSms(ticketMessageEntityId: number, replyTemplateId: number, sms: string[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _SetTicketMessageImportant;
    /**
     * Set the important flag on or off for a ticket message
     * @param request - TicketMessageId, Important
     * @returns
     */
    SetTicketMessageImportant(request: carriers.Ticket_SetTicketMessageImportantRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Set the important flag on or off for a ticket message
     * @param ticketMessageId - The id of the ticket message to set the important flag on
     * @param important - Turn on or off the important flag
     * @returns
     */
    SetTicketMessageImportant(ticketMessageId: number, important: boolean, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _CalculateMessageRecipients;
    /**
     * Gets recipients for new message
     * @param request - TicketId, ActionType, MessageId
     * @returns An array with Recipient objects
     */
    CalculateMessageRecipients(request: carriers.Ticket_CalculateMessageRecipientsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Recipient[]>;
    /**
     * Gets recipients for new message
     * @param ticketId - The id of the ticket
     * @param actionType - Message action
     * @param messageId - Optional ID of message being replied. Value <= 0 ignores parameter
     * @returns An array with Recipient objects
     */
    CalculateMessageRecipients(ticketId: number, actionType: enums.MessageActionType, messageId: number, webapi_options?: base.WebApiRequestOptions): Promise<carriers.Recipient[]>;
    private _SaveTicketMessageEntityWithNotify;
    /**
     * Saves a ticket message and performs any user notifications
     * @param request - NewEntity, Notify
     * @returns The saved entity
     */
    SaveTicketMessageEntityWithNotify(request: carriers.Ticket_SaveTicketMessageEntityWithNotifyRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    /**
     * Saves a ticket message and performs any user notifications
     * @param newEntity - The ticket message to save
     * @param notify - If true, then the notification will be sent along with the save
     * @returns The saved entity
     */
    SaveTicketMessageEntityWithNotify(newEntity: carriers.TicketMessageEntity, notify: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    private _SaveTicketMessageEntityWithOptions;
    /**
     * Saves a ticket message and performs additional actions
     * @param request - Entity, Notify, AttachmentIds, UpdateRepliedAt
     * @returns The saved entity
     */
    SaveTicketMessageEntityWithOptions(request: carriers.Ticket_SaveTicketMessageEntityWithOptionsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    /**
     * Saves a ticket message and performs additional actions
     * @param entity - The ticket message to save
     * @param notify - If true, then the notification will be sent along with the save
     * @param attachmentIds - An array of attachments to connect to this TicketMessage
     * @param updateRepliedAt - Updates ticket's replied_at field if needed
     * @returns The saved entity
     */
    SaveTicketMessageEntityWithOptions(entity: carriers.TicketMessageEntity, notify: boolean, attachmentIds: number[], updateRepliedAt: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    private _GetDefaultMessageContent;
    /**
     * Generate a default message body (possibly including user signature, quoted message content) as sanitized HTML
     * @param request - TicketId, MessageActionType, TicketMessageId
     * @returns Sanitized HTML content including possibly user signature and quoted message
     */
    GetDefaultMessageContent(request: carriers.Ticket_GetDefaultMessageContentRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Generate a default message body (possibly including user signature, quoted message content) as sanitized HTML
     * @param ticketId - The id of the ticket
     * @param messageActionType - Message action type: None/Reply/ReplyAll/Forward
     * @param ticketMessageId - The id of the message to quote in the returned content. 0 to skip/ignore
     * @returns Sanitized HTML content including possibly user signature and quoted message
     */
    GetDefaultMessageContent(ticketId: number, messageActionType: enums.MessageActionType, ticketMessageId: number, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _GetTicketMessageWithEmbeddedData;
    /**
     * Get a ticket message entity with posibillity to change embedded images to be represented with inline data within the HTML body. If using inline data, be sure not to save this back to the database.
     * @param request - Id, EmbedImages
     * @returns The entity to get
     */
    GetTicketMessageWithEmbeddedData(request: carriers.Ticket_GetTicketMessageWithEmbeddedDataRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    /**
     * Get a ticket message entity with posibillity to change embedded images to be represented with inline data within the HTML body. If using inline data, be sure not to save this back to the database.
     * @param id - The id of the ticket message entity
     * @param embedImages - If set to Inline, then use inline base64 data to represent the images in the HTML body. Default: Link will use link to the image.
     * @returns The entity to get
     */
    GetTicketMessageWithEmbeddedData(id: number, embedImages: enums.ImageEmbedType, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    private _DeleteMessageHeaders;
    /**
     * Removes headers from the message as specified in the collection of entity ids. The ids are message header ids (message header primary key)
     * @param request - HeaderIds
     * @returns This method has no return value
     */
    DeleteMessageHeaders(request: carriers.Ticket_DeleteMessageHeadersRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Removes headers from the message as specified in the collection of entity ids. The ids are message header ids (message header primary key)
     * @param headerIds - Message header primary keys
     * @returns This method has no return value
     */
    DeleteMessageHeaders(headerIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _GetTicketMessageWithOptions;
    /**
     * Get a ticket message entity with additional options.
     * @param request - TicketMessageEntityId, IncludeNonInlineAttachmentsInfo
     * @returns The entity to get
     */
    GetTicketMessageWithOptions(request: carriers.Ticket_GetTicketMessageWithOptionsRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    /**
     * Get a ticket message entity with additional options.
     * @param ticketMessageEntityId - The id of the ticket message entity
     * @param includeNonInlineAttachmentsInfo - If true, then non inline attachments info will be loaded into TicketMessageEntity
     * @returns The entity to get
     */
    GetTicketMessageWithOptions(ticketMessageEntityId: number, includeNonInlineAttachmentsInfo: boolean, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketMessageEntity>;
    private _GetTicketSummaries;
    /**
     * Get an array of summaryitem for the given tickets
     * @param request - TicketIds
     * @returns Summary items for the given id's, in no particular order
     */
    GetTicketSummaries(request: carriers.Ticket_GetTicketSummariesRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketSummaryItem[]>;
    /**
     * Get an array of summaryitem for the given tickets
     * @param ticketIds - The tickets to fetch summaries for
     * @returns Summary items for the given id's, in no particular order
     */
    GetTicketSummaries(ticketIds: number[], webapi_options?: base.WebApiRequestOptions): Promise<carriers.TicketSummaryItem[]>;
}
//# sourceMappingURL=TicketAgent.d.ts.map
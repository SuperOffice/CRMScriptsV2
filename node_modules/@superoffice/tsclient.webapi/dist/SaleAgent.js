"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.SaleAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * Sale data services
 */
class SaleAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/Sale/";
        super(options);
    }
    /**
     * Set default values into a new SaleEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSaleEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SaleEntity or creates a new SaleEntity if the id parameter is empty
     * @param entity - The SaleEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SaleEntity
     */
    async SaveSaleEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSaleEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the SaleEntity
     * @param SaleEntityId - The id of the SaleEntity to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteSaleEntity(SaleEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteSaleEntity?SaleEntityId=" + SaleEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new SaleStakeholder.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSaleStakeholder(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleStakeholder", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStakeholder_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing SaleStakeholder or creates a new SaleStakeholder if the id parameter is empty
     * @param entity - The SaleStakeholder to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated SaleStakeholder
     */
    async SaveSaleStakeholder(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveSaleStakeholder", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStakeholder_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the SaleStakeholder
     * @param SaleStakeholderId - The id of the SaleStakeholder to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteSaleStakeholder(SaleStakeholderId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteSaleStakeholder?SaleStakeholderId=" + SaleStakeholderId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new SaleSummary.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultSaleSummary(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultSaleSummary", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleSummary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a Sale object.
     * @param saleId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Sale
     */
    async GetSale(saleId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSale?saleId=" + saleId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Sale_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a SaleEntity object.
     * @param saleEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleEntity
     */
    async GetSaleEntity(saleEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleEntity?saleEntityId=" + saleEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _HasGuide(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasGuide", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async HasGuide(saleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined')) {
            _request = saleId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleId: saleId,
            };
            _options = webapi_options;
        }
        return this._HasGuide(_request, _options);
    }
    async _GetNextDueDate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextDueDate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetNextDueDate(saleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined')) {
            _request = saleId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleId: saleId,
            };
            _options = webapi_options;
        }
        return this._GetNextDueDate(_request, _options);
    }
    async _BatchUpdateNextDueDate(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("BatchUpdateNextDueDate", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Re-calculate all the next due dates
     * @returns
     */
    async BatchUpdateNextDueDate(webapi_options) {
        return this._BatchUpdateNextDueDate(webapi_options);
    }
    async _GetNextSaleStage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetNextSaleStage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetNextSaleStage(saleId, includeCurrentStage, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined' || typeof (first.IncludeCurrentStage) != 'undefined')) {
            _request = saleId;
            _options = includeCurrentStage;
        }
        else {
            _request = {
                SaleId: saleId,
                IncludeCurrentStage: includeCurrentStage,
            };
            _options = webapi_options;
        }
        return this._GetNextSaleStage(_request, _options);
    }
    async _HasGuideActivities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasGuideActivities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async HasGuideActivities(saleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined')) {
            _request = saleId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleId: saleId,
            };
            _options = webapi_options;
        }
        return this._HasGuideActivities(_request, _options);
    }
    async _OfferAutoNextStageOnApppointmentCompleted(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("OfferAutoNextStageOnApppointmentCompleted", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async OfferAutoNextStageOnApppointmentCompleted(appointmentId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appointmentId;
        if (typeof (first) === "object" && first && (typeof (first.AppointmentId) != 'undefined')) {
            _request = appointmentId;
            _options = webapi_options;
        }
        else {
            _request = {
                AppointmentId: appointmentId,
            };
            _options = webapi_options;
        }
        return this._OfferAutoNextStageOnApppointmentCompleted(_request, _options);
    }
    async _GetProbabilityFromStage(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetProbabilityFromStage", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetProbabilityFromStage(stageId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = stageId;
        if (typeof (first) === "object" && first && (typeof (first.StageId) != 'undefined')) {
            _request = stageId;
            _options = webapi_options;
        }
        else {
            _request = {
                StageId: stageId,
            };
            _options = webapi_options;
        }
        return this._GetProbabilityFromStage(_request, _options);
    }
    async _IsNumberValid(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNumberValid", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsNumberValid(contactId, number, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.Number) != 'undefined')) {
            _request = contactId;
            _options = number;
        }
        else {
            _request = {
                ContactId: contactId,
                Number: number,
            };
            _options = webapi_options;
        }
        return this._IsNumberValid(_request, _options);
    }
    async _AddSaleStakeholders(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddSaleStakeholders", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddSaleStakeholders(saleId, saleStakeholders, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined' || typeof (first.SaleStakeholders) != 'undefined')) {
            _request = saleId;
            _options = saleStakeholders;
        }
        else {
            _request = {
                SaleId: saleId,
                SaleStakeholders: saleStakeholders,
            };
            _options = webapi_options;
        }
        return this._AddSaleStakeholders(_request, _options);
    }
    async _DeleteSaleStakeholders(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteSaleStakeholders", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteSaleStakeholders(saleStakeholderIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleStakeholderIds;
        if (typeof (first) === "object" && first && (typeof (first.SaleStakeholderIds) != 'undefined')) {
            _request = saleStakeholderIds;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleStakeholderIds: saleStakeholderIds,
            };
            _options = webapi_options;
        }
        return this._DeleteSaleStakeholders(_request, _options);
    }
    async _HasStakeholderSetting(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("HasStakeholderSetting", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async HasStakeholderSetting(saleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined')) {
            _request = saleId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleId: saleId,
            };
            _options = webapi_options;
        }
        return this._HasStakeholderSetting(_request, _options);
    }
    async _ValidateSaleEntity(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateSaleEntity", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateSaleEntity(saleEntity, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleEntity;
        if (typeof (first) === "object" && first && (typeof (first.SaleEntity) != 'undefined')) {
            _request = saleEntity;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleEntity: saleEntity,
            };
            _options = webapi_options;
        }
        return this._ValidateSaleEntity(_request, _options);
    }
    /*
     * Gets an array of Sale objects.
     * @param saleIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of Sale
     */
    async GetSaleList(saleIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleList", saleIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetMyOpportunities(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetMyOpportunities", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetMyOpportunities(count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = count;
        if (typeof (first) === "object" && first && (typeof (first.Count) != 'undefined')) {
            _request = count;
            _options = webapi_options;
        }
        else {
            _request = {
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetMyOpportunities(_request, _options);
    }
    async _GetRecentSales(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetRecentSales", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetRecentSales(amountLimit, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = amountLimit;
        if (typeof (first) === "object" && first && (typeof (first.AmountLimit) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = amountLimit;
            _options = count;
        }
        else {
            _request = {
                AmountLimit: amountLimit,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetRecentSales(_request, _options);
    }
    async _GetUpcomingSales(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUpcomingSales", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUpcomingSales(weightedAmountLimit, count, webapi_options) {
        let _request = null;
        let _options = null;
        const first = weightedAmountLimit;
        if (typeof (first) === "object" && first && (typeof (first.WeightedAmountLimit) != 'undefined' || typeof (first.Count) != 'undefined')) {
            _request = weightedAmountLimit;
            _options = count;
        }
        else {
            _request = {
                WeightedAmountLimit: weightedAmountLimit,
                Count: count,
            };
            _options = webapi_options;
        }
        return this._GetUpcomingSales(_request, _options);
    }
    async _GetSalesByDate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSalesByDate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSalesByDate(fromDate, toDate, amountLimit, status, webapi_options) {
        let _request = null;
        let _options = null;
        const first = fromDate;
        if (typeof (first) === "object" && first && (typeof (first.FromDate) != 'undefined' || typeof (first.ToDate) != 'undefined' || typeof (first.AmountLimit) != 'undefined' || typeof (first.Status) != 'undefined')) {
            _request = fromDate;
            _options = toDate;
        }
        else {
            _request = {
                FromDate: fromDate,
                ToDate: toDate,
                AmountLimit: amountLimit,
                Status: status,
            };
            _options = webapi_options;
        }
        return this._GetSalesByDate(_request, _options);
    }
    async _GetOpenSalesForContact(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOpenSalesForContact", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetOpenSalesForContact(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._GetOpenSalesForContact(_request, _options);
    }
    async _SetAsSold(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetAsSold", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetAsSold(saleIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleIds;
        if (typeof (first) === "object" && first && (typeof (first.SaleIds) != 'undefined')) {
            _request = saleIds;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleIds: saleIds,
            };
            _options = webapi_options;
        }
        return this._SetAsSold(_request, _options);
    }
    async _SetAsLost(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetAsLost", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetAsLost(saleIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleIds;
        if (typeof (first) === "object" && first && (typeof (first.SaleIds) != 'undefined')) {
            _request = saleIds;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleIds: saleIds,
            };
            _options = webapi_options;
        }
        return this._SetAsLost(_request, _options);
    }
    async _GetSalesFromContact(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSalesFromContact", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSalesFromContact(contactId, onlyOpenSales, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.OnlyOpenSales) != 'undefined')) {
            _request = contactId;
            _options = onlyOpenSales;
        }
        else {
            _request = {
                ContactId: contactId,
                OnlyOpenSales: onlyOpenSales,
            };
            _options = webapi_options;
        }
        return this._GetSalesFromContact(_request, _options);
    }
    async _GetSalesFromPerson(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSalesFromPerson", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSalesFromPerson(personId, onlyOpenSales, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.OnlyOpenSales) != 'undefined')) {
            _request = personId;
            _options = onlyOpenSales;
        }
        else {
            _request = {
                PersonId: personId,
                OnlyOpenSales: onlyOpenSales,
            };
            _options = webapi_options;
        }
        return this._GetSalesFromPerson(_request, _options);
    }
    /*
     * Gets a SaleStakeholder object.
     * @param saleStakeholderId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single SaleStakeholder
     */
    async GetSaleStakeholder(saleStakeholderId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleStakeholder?saleStakeholderId=" + saleStakeholderId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStakeholder_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of SaleStakeholder objects.
     * @param saleStakeholderIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of SaleStakeholder
     */
    async GetSaleStakeholderList(saleStakeholderIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetSaleStakeholderList", saleStakeholderIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStakeholderArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetSaleStakeholders(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSaleStakeholders", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStakeholderArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSaleStakeholders(saleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleId;
        if (typeof (first) === "object" && first && (typeof (first.SaleId) != 'undefined')) {
            _request = saleId;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleId: saleId,
            };
            _options = webapi_options;
        }
        return this._GetSaleStakeholders(_request, _options);
    }
    async _UpdateSaleStakeholders(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateSaleStakeholders", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStakeholderArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async UpdateSaleStakeholders(stakeholders, webapi_options) {
        let _request = null;
        let _options = null;
        const first = stakeholders;
        if (typeof (first) === "object" && first && (typeof (first.Stakeholders) != 'undefined')) {
            _request = stakeholders;
            _options = webapi_options;
        }
        else {
            _request = {
                Stakeholders: stakeholders,
            };
            _options = webapi_options;
        }
        return this._UpdateSaleStakeholders(_request, _options);
    }
    async _GetSaleStakeholderById(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSaleStakeholderById", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleStakeholderArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSaleStakeholderById(saleStakeholderIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = saleStakeholderIds;
        if (typeof (first) === "object" && first && (typeof (first.SaleStakeholderIds) != 'undefined')) {
            _request = saleStakeholderIds;
            _options = webapi_options;
        }
        else {
            _request = {
                SaleStakeholderIds: saleStakeholderIds,
            };
            _options = webapi_options;
        }
        return this._GetSaleStakeholderById(_request, _options);
    }
    async _GetSummaryByAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSummaryByAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleSummary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSummaryByAssociate(associateId, fromDate, toDate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.FromDate) != 'undefined' || typeof (first.ToDate) != 'undefined')) {
            _request = associateId;
            _options = fromDate;
        }
        else {
            _request = {
                AssociateId: associateId,
                FromDate: fromDate,
                ToDate: toDate,
            };
            _options = webapi_options;
        }
        return this._GetSummaryByAssociate(_request, _options);
    }
    async _GetSummaryByGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSummaryByGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleSummary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSummaryByGroup(groupId, fromDate, toDate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = groupId;
        if (typeof (first) === "object" && first && (typeof (first.GroupId) != 'undefined' || typeof (first.FromDate) != 'undefined' || typeof (first.ToDate) != 'undefined')) {
            _request = groupId;
            _options = fromDate;
        }
        else {
            _request = {
                GroupId: groupId,
                FromDate: fromDate,
                ToDate: toDate,
            };
            _options = webapi_options;
        }
        return this._GetSummaryByGroup(_request, _options);
    }
    async _GetSummaryByContact(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSummaryByContact", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SaleSummary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSummaryByContact(contactId, fromDate, toDate, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.FromDate) != 'undefined' || typeof (first.ToDate) != 'undefined')) {
            _request = contactId;
            _options = fromDate;
        }
        else {
            _request = {
                ContactId: contactId,
                FromDate: fromDate,
                ToDate: toDate,
            };
            _options = webapi_options;
        }
        return this._GetSummaryByContact(_request, _options);
    }
} // class v1SaleAgentController 
exports.SaleAgent = SaleAgent;
//# sourceMappingURL=SaleAgent.js.map
"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeZoneAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * TimeZone maintenance
 */
class TimeZoneAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/TimeZone/";
        super(options);
    }
    async _GetDefaultTimeZoneInformation(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultTimeZoneInformation", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_PreferredTimeZone_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get information about the current, preferred timezone for the current user. If no such preference has been set, returns the correct fallback (and UserPreferenceId is 0)
     * @returns Get information about the current, preferred timezone for the current user.
     */
    async GetDefaultTimeZoneInformation(webapi_options) {
        return this._GetDefaultTimeZoneInformation(webapi_options);
    }
    async _InitializeTimeZoneData(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("InitializeTimeZoneData", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TimeZoneDataArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Initalizes the TimeZoneData
     * @returns
     */
    async InitializeTimeZoneData(webapi_options) {
        return this._InitializeTimeZoneData(webapi_options);
    }
    async _GetBaseTimeZoneId(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetBaseTimeZoneId", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the base timezone id.
     * @returns Returns the base timezone id. Returns 0 if not set.
     */
    async GetBaseTimeZoneId(webapi_options) {
        return this._GetBaseTimeZoneId(webapi_options);
    }
    async _UpdateTimeZoneData(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("UpdateTimeZoneData", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Retrieve time zone data from the SuperOffice server and update TimeZone data in the database
     * @returns Returns true if the operation succeeded
     */
    async UpdateTimeZoneData(webapi_options) {
        return this._UpdateTimeZoneData(webapi_options);
    }
    async _CheckNewTimeZoneDataAvailable(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckNewTimeZoneDataAvailable", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Check to see if new timezone data is available
     * @returns Returns true if new timezone info is found available, false otherwise
     */
    async CheckNewTimeZoneDataAvailable(webapi_options) {
        return this._CheckNewTimeZoneDataAvailable(webapi_options);
    }
    async _ToggleActiveTimeZoneRow(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ToggleActiveTimeZoneRow", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ToggleActiveTimeZoneRow(id, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined')) {
            _request = id;
            _options = webapi_options;
        }
        else {
            _request = {
                Id: id,
            };
            _options = webapi_options;
        }
        return this._ToggleActiveTimeZoneRow(_request, _options);
    }
    async _SetActiveTimeZonesByFilter(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetActiveTimeZonesByFilter", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetActiveTimeZonesByFilter(filter, active, webapi_options) {
        let _request = null;
        let _options = null;
        const first = filter;
        if (typeof (first) === "object" && first && (typeof (first.Filter) != 'undefined' || typeof (first.Active) != 'undefined')) {
            _request = filter;
            _options = active;
        }
        else {
            _request = {
                Filter: filter,
                Active: active,
            };
            _options = webapi_options;
        }
        return this._SetActiveTimeZonesByFilter(_request, _options);
    }
    async _TimeOfLastTimeZoneUpdate(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("TimeOfLastTimeZoneUpdate", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get the time time zone data was last updated
     * @returns Time of last update
     */
    async TimeOfLastTimeZoneUpdate(webapi_options) {
        return this._TimeOfLastTimeZoneUpdate(webapi_options);
    }
    async _SetBaseTimeZoneId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetBaseTimeZoneId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetBaseTimeZoneId(timezoneId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = timezoneId;
        if (typeof (first) === "object" && first && (typeof (first.TimezoneId) != 'undefined')) {
            _request = timezoneId;
            _options = webapi_options;
        }
        else {
            _request = {
                TimezoneId: timezoneId,
            };
            _options = webapi_options;
        }
        return this._SetBaseTimeZoneId(_request, _options);
    }
    async _GetDefaultTimeZonePreference(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultTimeZonePreference", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns the id of the default timezone preference with deflevel system wide
     * @returns The id of the system wide default timezone preference
     */
    async GetDefaultTimeZonePreference(webapi_options) {
        return this._GetDefaultTimeZonePreference(webapi_options);
    }
    async _DeleteTimeZones(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteTimeZones", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Deletes all time zone data (locations and rules) from the database
     * @returns
     */
    async DeleteTimeZones(webapi_options) {
        return this._DeleteTimeZones(webapi_options);
    }
    async _SetActiveTimeZoneRow(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetActiveTimeZoneRow", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetActiveTimeZoneRow(id, active, webapi_options) {
        let _request = null;
        let _options = null;
        const first = id;
        if (typeof (first) === "object" && first && (typeof (first.Id) != 'undefined' || typeof (first.Active) != 'undefined')) {
            _request = id;
            _options = active;
        }
        else {
            _request = {
                Id: id,
                Active: active,
            };
            _options = webapi_options;
        }
        return this._SetActiveTimeZoneRow(_request, _options);
    }
} // class v1TimeZoneAgentController 
exports.TimeZoneAgent = TimeZoneAgent;
//# sourceMappingURL=TimeZoneAgent.js.map
"use strict";
// <auto-generated>
//      SuperOffice Code Generator
//      modelling\templates\servicesnew\tsagents.tt
// </auto-generated>
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserAgent = void 0;
const tslib_1 = require("tslib");
const base = tslib_1.__importStar(require("./WebApiBase"));
const converters = tslib_1.__importStar(require("./Converters"));
/**
 * User administration
 */
class UserAgent extends base.WebApiBase {
    constructor(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode) {
        const options = base.WebApiBase.FigureOutOptions(baseUrlOrOptions, langOrconfigOrRM, langOrResourceOrRM, cultureCode);
        options.basePath = "v1/Agents/User/";
        super(options);
    }
    /**
     * Set default values into a new RoleEntity.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultRoleEntity(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultRoleEntity", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RoleEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing RoleEntity or creates a new RoleEntity if the id parameter is empty
     * @param entity - The RoleEntity to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated RoleEntity
     */
    async SaveRoleEntity(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveRoleEntity", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RoleEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new ServiceAuth.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultServiceAuth(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultServiceAuth", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ServiceAuth_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing ServiceAuth or creates a new ServiceAuth if the id parameter is empty
     * @param entity - The ServiceAuth to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated ServiceAuth
     */
    async SaveServiceAuth(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveServiceAuth", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ServiceAuth_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the ServiceAuth
     * @param ServiceAuthId - The id of the ServiceAuth to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteServiceAuth(ServiceAuthId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteServiceAuth?ServiceAuthId=" + ServiceAuthId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new UntrustedCredentials.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultUntrustedCredentials(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultUntrustedCredentials", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UntrustedCredentials_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Set default values into a new User.
     * NetServer calculates default values on the entity, which is required when creating/storing a new instance
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A blank entity.
     */
    async CreateDefaultUser(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("CreateDefaultUser", null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Updates the existing User or creates a new User if the id parameter is empty
     * @param entity - The User to be saved.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns New or updated User
     */
    async SaveUser(entity, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("SaveUser", entity, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Get registered custom commands for User
     * @param request - The User entity to get commands for.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns Custom commands for the requested User.
     */
    async GetUserCommands(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserCommands", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CustomCommandArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Executes the custom command for User
     * @param request - The name of the command to execute. The User to execute commands on.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns Result of the executed command: Success + Message + CommandActionResult
     */
    async ExecuteUserCommand(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("ExecuteUserCommand", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CommandResult_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Deletes the User
     * @param UserId - The id of the User to be deleted.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     */
    async DeleteUser(UserId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("DeleteUser?UserId=" + UserId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetAccessGatewayInfo(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAccessGatewayInfo", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AccessGatewayInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Returns accessgateway registration info
     * @returns
     */
    async GetAccessGatewayInfo(webapi_options) {
        return this._GetAccessGatewayInfo(webapi_options);
    }
    async _GetOrRegisterAccessGatewayInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetOrRegisterAccessGatewayInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AccessGatewayInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetOrRegisterAccessGatewayInfo(redirectUri, webapi_options) {
        let _request = null;
        let _options = null;
        const first = redirectUri;
        if (typeof (first) === "object" && first && (typeof (first.RedirectUri) != 'undefined')) {
            _request = redirectUri;
            _options = webapi_options;
        }
        else {
            _request = {
                RedirectUri: redirectUri,
            };
            _options = webapi_options;
        }
        return this._GetOrRegisterAccessGatewayInfo(_request, _options);
    }
    async _RegisterWithAccessGateway(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RegisterWithAccessGateway", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_AccessGatewayInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RegisterWithAccessGateway(redirectUri, webapi_options) {
        let _request = null;
        let _options = null;
        const first = redirectUri;
        if (typeof (first) === "object" && first && (typeof (first.RedirectUri) != 'undefined')) {
            _request = redirectUri;
            _options = webapi_options;
        }
        else {
            _request = {
                RedirectUri: redirectUri,
            };
            _options = webapi_options;
        }
        return this._RegisterWithAccessGateway(_request, _options);
    }
    async _CheckAccessGatewayRegistration(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CheckAccessGatewayRegistration", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Checks if AccessGatewayRegistration is valid
     * @returns True if the registration is usable
     */
    async CheckAccessGatewayRegistration(webapi_options) {
        return this._CheckAccessGatewayRegistration(webapi_options);
    }
    async _SaveCredential(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveCredential", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveCredential(userId, credential, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userId;
        if (typeof (first) === "object" && first && (typeof (first.UserId) != 'undefined' || typeof (first.Credential) != 'undefined')) {
            _request = userId;
            _options = credential;
        }
        else {
            _request = {
                UserId: userId,
                Credential: credential,
            };
            _options = webapi_options;
        }
        return this._SaveCredential(_request, _options);
    }
    async _DeleteCredential(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteCredential", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteCredential(userId, credentialType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userId;
        if (typeof (first) === "object" && first && (typeof (first.UserId) != 'undefined' || typeof (first.CredentialType) != 'undefined')) {
            _request = userId;
            _options = credentialType;
        }
        else {
            _request = {
                UserId: userId,
                CredentialType: credentialType,
            };
            _options = webapi_options;
        }
        return this._DeleteCredential(_request, _options);
    }
    async _FindCredentialsGroups(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindCredentialsGroups", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CredentialsGroupArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindCredentialsGroups(type, searchString, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined' || typeof (first.SearchString) != 'undefined')) {
            _request = type;
            _options = searchString;
        }
        else {
            _request = {
                Type: type,
                SearchString: searchString,
            };
            _options = webapi_options;
        }
        return this._FindCredentialsGroups(_request, _options);
    }
    async _FindCredentialUsers(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindCredentialUsers", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CredentialsGroupUsers_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindCredentialUsers(type, searchString, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined' || typeof (first.SearchString) != 'undefined')) {
            _request = type;
            _options = searchString;
        }
        else {
            _request = {
                Type: type,
                SearchString: searchString,
            };
            _options = webapi_options;
        }
        return this._FindCredentialUsers(_request, _options);
    }
    async _GetCredentialUsersInGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCredentialUsersInGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CredentialsGroupUsers_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCredentialUsersInGroup(type, groupName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined' || typeof (first.GroupName) != 'undefined')) {
            _request = type;
            _options = groupName;
        }
        else {
            _request = {
                Type: type,
                GroupName: groupName,
            };
            _options = webapi_options;
        }
        return this._GetCredentialUsersInGroup(_request, _options);
    }
    /*
     * Gets a Role object.
     * @param roleId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single Role
     */
    async GetRole(roleId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRole?roleId=" + roleId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_Role_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a RoleEntity object.
     * @param roleEntityId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single RoleEntity
     */
    async GetRoleEntity(roleEntityId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetRoleEntity?roleEntityId=" + roleEntityId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RoleEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _DeleteRole(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteRole", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteRole(roleIdToDelete, replacingRoleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = roleIdToDelete;
        if (typeof (first) === "object" && first && (typeof (first.RoleIdToDelete) != 'undefined' || typeof (first.ReplacingRoleId) != 'undefined')) {
            _request = roleIdToDelete;
            _options = replacingRoleId;
        }
        else {
            _request = {
                RoleIdToDelete: roleIdToDelete,
                ReplacingRoleId: replacingRoleId,
            };
            _options = webapi_options;
        }
        return this._DeleteRole(_request, _options);
    }
    async _GetAllRoles(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllRoles", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllRoles(roleType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = roleType;
        if (typeof (first) === "object" && first && (typeof (first.RoleType) != 'undefined')) {
            _request = roleType;
            _options = webapi_options;
        }
        else {
            _request = {
                RoleType: roleType,
            };
            _options = webapi_options;
        }
        return this._GetAllRoles(_request, _options);
    }
    async _GetAllFunctionalRights(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllFunctionalRights", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllFunctionalRights(roleType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = roleType;
        if (typeof (first) === "object" && first && (typeof (first.RoleType) != 'undefined')) {
            _request = roleType;
            _options = webapi_options;
        }
        else {
            _request = {
                RoleType: roleType,
            };
            _options = webapi_options;
        }
        return this._GetAllFunctionalRights(_request, _options);
    }
    async _GetFunctionalRights(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetFunctionalRights", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_SelectableMDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetFunctionalRights(roleId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = roleId;
        if (typeof (first) === "object" && first && (typeof (first.RoleId) != 'undefined')) {
            _request = roleId;
            _options = webapi_options;
        }
        else {
            _request = {
                RoleId: roleId,
            };
            _options = webapi_options;
        }
        return this._GetFunctionalRights(_request, _options);
    }
    async _SetFunctionalRights(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetFunctionalRights", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetFunctionalRights(roleId, functionalRightIds, webapi_options) {
        let _request = null;
        let _options = null;
        const first = roleId;
        if (typeof (first) === "object" && first && (typeof (first.RoleId) != 'undefined' || typeof (first.FunctionalRightIds) != 'undefined')) {
            _request = roleId;
            _options = functionalRightIds;
        }
        else {
            _request = {
                RoleId: roleId,
                FunctionalRightIds: functionalRightIds,
            };
            _options = webapi_options;
        }
        return this._SetFunctionalRights(_request, _options);
    }
    async _SetDataRight(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetDataRight", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetDataRight(roleId, tableName, relationToOwner, dataRightValue, webapi_options) {
        let _request = null;
        let _options = null;
        const first = roleId;
        if (typeof (first) === "object" && first && (typeof (first.RoleId) != 'undefined' || typeof (first.TableName) != 'undefined' || typeof (first.RelationToOwner) != 'undefined' || typeof (first.DataRightValue) != 'undefined')) {
            _request = roleId;
            _options = tableName;
        }
        else {
            _request = {
                RoleId: roleId,
                TableName: tableName,
                RelationToOwner: relationToOwner,
                DataRightValue: dataRightValue,
            };
            _options = webapi_options;
        }
        return this._SetDataRight(_request, _options);
    }
    async _GetDataRight(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDataRight", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDataRight(roleId, tableName, relationToOwner, webapi_options) {
        let _request = null;
        let _options = null;
        const first = roleId;
        if (typeof (first) === "object" && first && (typeof (first.RoleId) != 'undefined' || typeof (first.TableName) != 'undefined' || typeof (first.RelationToOwner) != 'undefined')) {
            _request = roleId;
            _options = tableName;
        }
        else {
            _request = {
                RoleId: roleId,
                TableName: tableName,
                RelationToOwner: relationToOwner,
            };
            _options = webapi_options;
        }
        return this._GetDataRight(_request, _options);
    }
    async _GetDataRights(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDataRights", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDataRights(roleId, tableName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = roleId;
        if (typeof (first) === "object" && first && (typeof (first.RoleId) != 'undefined' || typeof (first.TableName) != 'undefined')) {
            _request = roleId;
            _options = tableName;
        }
        else {
            _request = {
                RoleId: roleId,
                TableName: tableName,
            };
            _options = webapi_options;
        }
        return this._GetDataRights(_request, _options);
    }
    async _CreateDefaultRoleEntityFromType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultRoleEntityFromType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_RoleEntity_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultRoleEntityFromType(type, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined')) {
            _request = type;
            _options = webapi_options;
        }
        else {
            _request = {
                Type: type,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultRoleEntityFromType(_request, _options);
    }
    async _FindRolesWithFunctionalRight(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindRolesWithFunctionalRight", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_MDOListItemArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindRolesWithFunctionalRight(functionalRightName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = functionalRightName;
        if (typeof (first) === "object" && first && (typeof (first.FunctionalRightName) != 'undefined')) {
            _request = functionalRightName;
            _options = webapi_options;
        }
        else {
            _request = {
                FunctionalRightName: functionalRightName,
            };
            _options = webapi_options;
        }
        return this._FindRolesWithFunctionalRight(_request, _options);
    }
    async _FindRolesWithFunctionalRights(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindRolesWithFunctionalRights", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindRolesWithFunctionalRights(functionalRightNames, webapi_options) {
        let _request = null;
        let _options = null;
        const first = functionalRightNames;
        if (typeof (first) === "object" && first && (typeof (first.FunctionalRightNames) != 'undefined')) {
            _request = functionalRightNames;
            _options = webapi_options;
        }
        else {
            _request = {
                FunctionalRightNames: functionalRightNames,
            };
            _options = webapi_options;
        }
        return this._FindRolesWithFunctionalRights(_request, _options);
    }
    async _FindRolesWithoutFunctionalRights(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("FindRolesWithoutFunctionalRights", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async FindRolesWithoutFunctionalRights(functionalRightNames, webapi_options) {
        let _request = null;
        let _options = null;
        const first = functionalRightNames;
        if (typeof (first) === "object" && first && (typeof (first.FunctionalRightNames) != 'undefined')) {
            _request = functionalRightNames;
            _options = webapi_options;
        }
        else {
            _request = {
                FunctionalRightNames: functionalRightNames,
            };
            _options = webapi_options;
        }
        return this._FindRolesWithoutFunctionalRights(_request, _options);
    }
    /*
     * Gets a ServiceAuth object.
     * @param serviceAuthId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single ServiceAuth
     */
    async GetServiceAuth(serviceAuthId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetServiceAuth?serviceAuthId=" + serviceAuthId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ServiceAuth_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SaveExternalTokens(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveExternalTokens", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveExternalTokens(tokenManagementInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = tokenManagementInfo;
        if (typeof (first) === "object" && first && (typeof (first.TokenManagementInfo) != 'undefined')) {
            _request = tokenManagementInfo;
            _options = webapi_options;
        }
        else {
            _request = {
                TokenManagementInfo: tokenManagementInfo,
            };
            _options = webapi_options;
        }
        return this._SaveExternalTokens(_request, _options);
    }
    async _DecryptAndSaveExternalTokens(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DecryptAndSaveExternalTokens", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DecryptAndSaveExternalTokens(tokenManagementInfo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = tokenManagementInfo;
        if (typeof (first) === "object" && first && (typeof (first.TokenManagementInfo) != 'undefined')) {
            _request = tokenManagementInfo;
            _options = webapi_options;
        }
        else {
            _request = {
                TokenManagementInfo: tokenManagementInfo,
            };
            _options = webapi_options;
        }
        return this._DecryptAndSaveExternalTokens(_request, _options);
    }
    async _GetExternalTokens(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetExternalTokens", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_TokenManagementInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetExternalTokens(key, webapi_options) {
        let _request = null;
        let _options = null;
        const first = key;
        if (typeof (first) === "object" && first && (typeof (first.Key) != 'undefined')) {
            _request = key;
            _options = webapi_options;
        }
        else {
            _request = {
                Key: key,
            };
            _options = webapi_options;
        }
        return this._GetExternalTokens(_request, _options);
    }
    /*
     * Gets a User object.
     * @param userId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single User
     */
    async GetUser(userId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUser?userId=" + userId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _GetUserFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUserFromName(userName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userName;
        if (typeof (first) === "object" && first && (typeof (first.UserName) != 'undefined')) {
            _request = userName;
            _options = webapi_options;
        }
        else {
            _request = {
                UserName: userName,
            };
            _options = webapi_options;
        }
        return this._GetUserFromName(_request, _options);
    }
    async _SaveUserFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveUserFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveUserFromName(userName, user, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userName;
        if (typeof (first) === "object" && first && (typeof (first.UserName) != 'undefined' || typeof (first.User) != 'undefined')) {
            _request = userName;
            _options = user;
        }
        else {
            _request = {
                UserName: userName,
                User: user,
            };
            _options = webapi_options;
        }
        return this._SaveUserFromName(_request, _options);
    }
    async _DeleteUserFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteUserFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteUserFromName(userName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userName;
        if (typeof (first) === "object" && first && (typeof (first.UserName) != 'undefined')) {
            _request = userName;
            _options = webapi_options;
        }
        else {
            _request = {
                UserName: userName,
            };
            _options = webapi_options;
        }
        return this._DeleteUserFromName(_request, _options);
    }
    async _GetCredentialTypes(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCredentialTypes", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CredentialTypeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Get available credential types that can be used for authentication
     * @returns Credential types that can be used for authentication
     */
    async GetCredentialTypes(webapi_options) {
        return this._GetCredentialTypes(webapi_options);
    }
    async _GetCredentialTypesForUserType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetCredentialTypesForUserType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_CredentialTypeArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetCredentialTypesForUserType(userType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userType;
        if (typeof (first) === "object" && first && (typeof (first.UserType) != 'undefined')) {
            _request = userType;
            _options = webapi_options;
        }
        else {
            _request = {
                UserType: userType,
            };
            _options = webapi_options;
        }
        return this._GetCredentialTypesForUserType(_request, _options);
    }
    async _SaveUntrustedCredentials(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveUntrustedCredentials", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveUntrustedCredentials(type, credentials, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined' || typeof (first.Credentials) != 'undefined')) {
            _request = type;
            _options = credentials;
        }
        else {
            _request = {
                Type: type,
                Credentials: credentials,
            };
            _options = webapi_options;
        }
        return this._SaveUntrustedCredentials(_request, _options);
    }
    async _GetUntrustedCredentials(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUntrustedCredentials", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UntrustedCredentialsArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUntrustedCredentials(type, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined')) {
            _request = type;
            _options = webapi_options;
        }
        else {
            _request = {
                Type: type,
            };
            _options = webapi_options;
        }
        return this._GetUntrustedCredentials(_request, _options);
    }
    async _GetUntrustedCredentialsForAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUntrustedCredentialsForAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UntrustedCredentialsArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUntrustedCredentialsForAssociate(associateId, type, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Type) != 'undefined')) {
            _request = associateId;
            _options = type;
        }
        else {
            _request = {
                AssociateId: associateId,
                Type: type,
            };
            _options = webapi_options;
        }
        return this._GetUntrustedCredentialsForAssociate(_request, _options);
    }
    async _SaveUntrustedCredentialsForAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveUntrustedCredentialsForAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveUntrustedCredentialsForAssociate(associateId, type, credentials, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Type) != 'undefined' || typeof (first.Credentials) != 'undefined')) {
            _request = associateId;
            _options = type;
        }
        else {
            _request = {
                AssociateId: associateId,
                Type: type,
                Credentials: credentials,
            };
            _options = webapi_options;
        }
        return this._SaveUntrustedCredentialsForAssociate(_request, _options);
    }
    async _RemoveUntrustedCredentials(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveUntrustedCredentials", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveUntrustedCredentials(type, publicValue, webapi_options) {
        let _request = null;
        let _options = null;
        const first = type;
        if (typeof (first) === "object" && first && (typeof (first.Type) != 'undefined' || typeof (first.PublicValue) != 'undefined')) {
            _request = type;
            _options = publicValue;
        }
        else {
            _request = {
                Type: type,
                PublicValue: publicValue,
            };
            _options = webapi_options;
        }
        return this._RemoveUntrustedCredentials(_request, _options);
    }
    async _RemoveUntrustedCredentialsForAssociate(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveUntrustedCredentialsForAssociate", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveUntrustedCredentialsForAssociate(associateId, type, publicValue, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Type) != 'undefined' || typeof (first.PublicValue) != 'undefined')) {
            _request = associateId;
            _options = type;
        }
        else {
            _request = {
                AssociateId: associateId,
                Type: type,
                PublicValue: publicValue,
            };
            _options = webapi_options;
        }
        return this._RemoveUntrustedCredentialsForAssociate(_request, _options);
    }
    async _CreateExternalUser(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateExternalUser", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateExternalUser(personId, userName, password, roleId, isActive, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined' || typeof (first.UserName) != 'undefined' || typeof (first.Password) != 'undefined' || typeof (first.RoleId) != 'undefined' || typeof (first.IsActive) != 'undefined')) {
            _request = personId;
            _options = userName;
        }
        else {
            _request = {
                PersonId: personId,
                UserName: userName,
                Password: password,
                RoleId: roleId,
                IsActive: isActive,
            };
            _options = webapi_options;
        }
        return this._CreateExternalUser(_request, _options);
    }
    async _DeleteExternalUser(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteExternalUser", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteExternalUser(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._DeleteExternalUser(_request, _options);
    }
    async _SetExternalUserInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetExternalUserInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetExternalUserInfo(associateId, userName, password, isActive, roleId, externalUserInfoModification, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.UserName) != 'undefined' || typeof (first.Password) != 'undefined' || typeof (first.IsActive) != 'undefined' || typeof (first.RoleId) != 'undefined' || typeof (first.ExternalUserInfoModification) != 'undefined')) {
            _request = associateId;
            _options = userName;
        }
        else {
            _request = {
                AssociateId: associateId,
                UserName: userName,
                Password: password,
                IsActive: isActive,
                RoleId: roleId,
                ExternalUserInfoModification: externalUserInfoModification,
            };
            _options = webapi_options;
        }
        return this._SetExternalUserInfo(_request, _options);
    }
    async _GenerateNewPasswordForExternalUser(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GenerateNewPasswordForExternalUser", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GenerateNewPasswordForExternalUser(associateName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateName;
        if (typeof (first) === "object" && first && (typeof (first.AssociateName) != 'undefined')) {
            _request = associateName;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateName: associateName,
            };
            _options = webapi_options;
        }
        return this._GenerateNewPasswordForExternalUser(_request, _options);
    }
    async _CanChangePassword(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CanChangePassword", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CanChangePassword(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._CanChangePassword(_request, _options);
    }
    async _GetSupportedChangePasswordTypes(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetSupportedChangePasswordTypes", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetSupportedChangePasswordTypes(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._GetSupportedChangePasswordTypes(_request, _options);
    }
    async _ChangePassword(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangePassword", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangePassword(associateId, oldPassword, newPassword, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.OldPassword) != 'undefined' || typeof (first.NewPassword) != 'undefined')) {
            _request = associateId;
            _options = oldPassword;
        }
        else {
            _request = {
                AssociateId: associateId,
                OldPassword: oldPassword,
                NewPassword: newPassword,
            };
            _options = webapi_options;
        }
        return this._ChangePassword(_request, _options);
    }
    async _SendChangePasswordEMail(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SendChangePasswordEMail", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_OperationResult_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SendChangePasswordEMail(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._SendChangePasswordEMail(_request, _options);
    }
    async _GetUserFromPersonId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserFromPersonId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUserFromPersonId(personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = personId;
        if (typeof (first) === "object" && first && (typeof (first.PersonId) != 'undefined')) {
            _request = personId;
            _options = webapi_options;
        }
        else {
            _request = {
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._GetUserFromPersonId(_request, _options);
    }
    async _CreateDefaultUserFromUserTypeAndPersonId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultUserFromUserTypeAndPersonId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultUserFromUserTypeAndPersonId(userType, personId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userType;
        if (typeof (first) === "object" && first && (typeof (first.UserType) != 'undefined' || typeof (first.PersonId) != 'undefined')) {
            _request = userType;
            _options = personId;
        }
        else {
            _request = {
                UserType: userType,
                PersonId: personId,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultUserFromUserTypeAndPersonId(_request, _options);
    }
    async _CreateDefaultUserFromUserType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultUserFromUserType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultUserFromUserType(userType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userType;
        if (typeof (first) === "object" && first && (typeof (first.UserType) != 'undefined')) {
            _request = userType;
            _options = webapi_options;
        }
        else {
            _request = {
                UserType: userType,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultUserFromUserType(_request, _options);
    }
    async _GetUserFromEjUserId(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserFromEjUserId", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUserFromEjUserId(ejUserId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = ejUserId;
        if (typeof (first) === "object" && first && (typeof (first.EjUserId) != 'undefined')) {
            _request = ejUserId;
            _options = webapi_options;
        }
        else {
            _request = {
                EjUserId: ejUserId,
            };
            _options = webapi_options;
        }
        return this._GetUserFromEjUserId(_request, _options);
    }
    async _SetPasswordFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPasswordFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetPasswordFromName(associateName, password, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateName;
        if (typeof (first) === "object" && first && (typeof (first.AssociateName) != 'undefined' || typeof (first.Password) != 'undefined')) {
            _request = associateName;
            _options = password;
        }
        else {
            _request = {
                AssociateName: associateName,
                Password: password,
            };
            _options = webapi_options;
        }
        return this._SetPasswordFromName(_request, _options);
    }
    async _SetPassword(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetPassword", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetPassword(associateId, password, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Password) != 'undefined')) {
            _request = associateId;
            _options = password;
        }
        else {
            _request = {
                AssociateId: associateId,
                Password: password,
            };
            _options = webapi_options;
        }
        return this._SetPassword(_request, _options);
    }
    async _ChangeOwnPassword(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeOwnPassword", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeOwnPassword(oldPassword, newPassword, webapi_options) {
        let _request = null;
        let _options = null;
        const first = oldPassword;
        if (typeof (first) === "object" && first && (typeof (first.OldPassword) != 'undefined' || typeof (first.NewPassword) != 'undefined')) {
            _request = oldPassword;
            _options = newPassword;
        }
        else {
            _request = {
                OldPassword: oldPassword,
                NewPassword: newPassword,
            };
            _options = webapi_options;
        }
        return this._ChangeOwnPassword(_request, _options);
    }
    async _ChangePasswordFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangePasswordFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangePasswordFromName(associateName, oldPassword, newPassword, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateName;
        if (typeof (first) === "object" && first && (typeof (first.AssociateName) != 'undefined' || typeof (first.OldPassword) != 'undefined' || typeof (first.NewPassword) != 'undefined')) {
            _request = associateName;
            _options = oldPassword;
        }
        else {
            _request = {
                AssociateName: associateName,
                OldPassword: oldPassword,
                NewPassword: newPassword,
            };
            _options = webapi_options;
        }
        return this._ChangePasswordFromName(_request, _options);
    }
    async _IsUserNameValid(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsUserNameValid", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsUserNameValid(associateId, type, personId, userName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Type) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.UserName) != 'undefined')) {
            _request = associateId;
            _options = type;
        }
        else {
            _request = {
                AssociateId: associateId,
                Type: type,
                PersonId: personId,
                UserName: userName,
            };
            _options = webapi_options;
        }
        return this._IsUserNameValid(_request, _options);
    }
    async _IsPasswordValid(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsPasswordValid", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsPasswordValid(associateId, type, personId, password, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Type) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.Password) != 'undefined')) {
            _request = associateId;
            _options = type;
        }
        else {
            _request = {
                AssociateId: associateId,
                Type: type,
                PersonId: personId,
                Password: password,
            };
            _options = webapi_options;
        }
        return this._IsPasswordValid(_request, _options);
    }
    async _SetGeneratedPassword(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetGeneratedPassword", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetGeneratedPassword(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._SetGeneratedPassword(_request, _options);
    }
    async _SetGeneratedPasswordFromName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetGeneratedPasswordFromName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetGeneratedPasswordFromName(associateName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateName;
        if (typeof (first) === "object" && first && (typeof (first.AssociateName) != 'undefined')) {
            _request = associateName;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateName: associateName,
            };
            _options = webapi_options;
        }
        return this._SetGeneratedPasswordFromName(_request, _options);
    }
    async _IsPasswordValidWithReason(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsPasswordValidWithReason", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserValidationResult_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsPasswordValidWithReason(associateId, type, personId, password, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Type) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.Password) != 'undefined')) {
            _request = associateId;
            _options = type;
        }
        else {
            _request = {
                AssociateId: associateId,
                Type: type,
                PersonId: personId,
                Password: password,
            };
            _options = webapi_options;
        }
        return this._IsPasswordValidWithReason(_request, _options);
    }
    async _IsUserNameValidWithReason(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsUserNameValidWithReason", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserValidationResult_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsUserNameValidWithReason(associateId, type, personId, userName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Type) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.UserName) != 'undefined')) {
            _request = associateId;
            _options = type;
        }
        else {
            _request = {
                AssociateId: associateId,
                Type: type,
                PersonId: personId,
                UserName: userName,
            };
            _options = webapi_options;
        }
        return this._IsUserNameValidWithReason(_request, _options);
    }
    async _ChangeUserType(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ChangeUserType", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ChangeUserType(user, userType, webapi_options) {
        let _request = null;
        let _options = null;
        const first = user;
        if (typeof (first) === "object" && first && (typeof (first.User) != 'undefined' || typeof (first.UserType) != 'undefined')) {
            _request = user;
            _options = userType;
        }
        else {
            _request = {
                User: user,
                UserType: userType,
            };
            _options = webapi_options;
        }
        return this._ChangeUserType(_request, _options);
    }
    async _CreateDefaultUserFromUserTypeAndCredential(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateDefaultUserFromUserTypeAndCredential", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_User_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async CreateDefaultUserFromUserTypeAndCredential(userType, contactId, credentialType, credentialValue, credentialDisplayValue, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userType;
        if (typeof (first) === "object" && first && (typeof (first.UserType) != 'undefined' || typeof (first.ContactId) != 'undefined' || typeof (first.CredentialType) != 'undefined' || typeof (first.CredentialValue) != 'undefined' || typeof (first.CredentialDisplayValue) != 'undefined')) {
            _request = userType;
            _options = contactId;
        }
        else {
            _request = {
                UserType: userType,
                ContactId: contactId,
                CredentialType: credentialType,
                CredentialValue: credentialValue,
                CredentialDisplayValue: credentialDisplayValue,
            };
            _options = webapi_options;
        }
        return this._CreateDefaultUserFromUserTypeAndCredential(_request, _options);
    }
    async _GetValidUserName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetValidUserName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetValidUserName(associateId, type, personId, userName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Type) != 'undefined' || typeof (first.PersonId) != 'undefined' || typeof (first.UserName) != 'undefined')) {
            _request = associateId;
            _options = type;
        }
        else {
            _request = {
                AssociateId: associateId,
                Type: type,
                PersonId: personId,
                UserName: userName,
            };
            _options = webapi_options;
        }
        return this._GetValidUserName(_request, _options);
    }
    async _RemoveLicenses(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveLicenses", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveLicenses(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._RemoveLicenses(_request, _options);
    }
    async _MakeRetired(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("MakeRetired", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async MakeRetired(associateId, retired, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.Retired) != 'undefined')) {
            _request = associateId;
            _options = retired;
        }
        else {
            _request = {
                AssociateId: associateId,
                Retired: retired,
            };
            _options = webapi_options;
        }
        return this._MakeRetired(_request, _options);
    }
    async _AddOwnerContact(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("AddOwnerContact", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async AddOwnerContact(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._AddOwnerContact(_request, _options);
    }
    async _RemoveOwnerContact(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("RemoveOwnerContact", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async RemoveOwnerContact(contactId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined')) {
            _request = contactId;
            _options = webapi_options;
        }
        else {
            _request = {
                ContactId: contactId,
            };
            _options = webapi_options;
        }
        return this._RemoveOwnerContact(_request, _options);
    }
    async _ResolveUserFromInfo(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ResolveUserFromInfo", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_ResolvedUser_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ResolveUserFromInfo(contactId, personName, phoneNumbers, emails, userType, credential, webapi_options) {
        let _request = null;
        let _options = null;
        const first = contactId;
        if (typeof (first) === "object" && first && (typeof (first.ContactId) != 'undefined' || typeof (first.PersonName) != 'undefined' || typeof (first.PhoneNumbers) != 'undefined' || typeof (first.Emails) != 'undefined' || typeof (first.UserType) != 'undefined' || typeof (first.Credential) != 'undefined')) {
            _request = contactId;
            _options = personName;
        }
        else {
            _request = {
                ContactId: contactId,
                PersonName: personName,
                PhoneNumbers: phoneNumbers,
                Emails: emails,
                UserType: userType,
                Credential: credential,
            };
            _options = webapi_options;
        }
        return this._ResolveUserFromInfo(_request, _options);
    }
    async _GetAccessToken(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAccessToken", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAccessToken(appToken, includeCsSession, webapi_options) {
        let _request = null;
        let _options = null;
        const first = appToken;
        if (typeof (first) === "object" && first && (typeof (first.AppToken) != 'undefined' || typeof (first.IncludeCsSession) != 'undefined')) {
            _request = appToken;
            _options = includeCsSession;
        }
        else {
            _request = {
                AppToken: appToken,
                IncludeCsSession: includeCsSession,
            };
            _options = webapi_options;
        }
        return this._GetAccessToken(_request, _options);
    }
    async _GetValidUserNameForNewUser(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetValidUserNameForNewUser", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetValidUserNameForNewUser(user, webapi_options) {
        let _request = null;
        let _options = null;
        const first = user;
        if (typeof (first) === "object" && first && (typeof (first.User) != 'undefined')) {
            _request = user;
            _options = webapi_options;
        }
        else {
            _request = {
                User: user,
            };
            _options = webapi_options;
        }
        return this._GetValidUserNameForNewUser(_request, _options);
    }
    async _GetDefaultAssociateUserName(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetDefaultAssociateUserName", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetDefaultAssociateUserName(user, webapi_options) {
        let _request = null;
        let _options = null;
        const first = user;
        if (typeof (first) === "object" && first && (typeof (first.User) != 'undefined')) {
            _request = user;
            _options = webapi_options;
        }
        else {
            _request = {
                User: user,
            };
            _options = webapi_options;
        }
        return this._GetDefaultAssociateUserName(_request, _options);
    }
    async _IsNickNameUnique(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("IsNickNameUnique", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async IsNickNameUnique(associateId, nickName, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.NickName) != 'undefined')) {
            _request = associateId;
            _options = nickName;
        }
        else {
            _request = {
                AssociateId: associateId,
                NickName: nickName,
            };
            _options = webapi_options;
        }
        return this._IsNickNameUnique(_request, _options);
    }
    async _ValidateUser(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("ValidateUser", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_StringDictionary_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async ValidateUser(user, webapi_options) {
        let _request = null;
        let _options = null;
        const first = user;
        if (typeof (first) === "object" && first && (typeof (first.User) != 'undefined')) {
            _request = user;
            _options = webapi_options;
        }
        else {
            _request = {
                User: user,
            };
            _options = webapi_options;
        }
        return this._ValidateUser(_request, _options);
    }
    async _GetUserPresenceStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetUserPresenceStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserPresenceStatus_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetUserPresenceStatus(associateId, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined')) {
            _request = associateId;
            _options = webapi_options;
        }
        else {
            _request = {
                AssociateId: associateId,
            };
            _options = webapi_options;
        }
        return this._GetUserPresenceStatus(_request, _options);
    }
    async _SetUserPresenceStatus(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SetUserPresenceStatus", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserPresenceStatus_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SetUserPresenceStatus(associateId, userPresenceStatus, webapi_options) {
        let _request = null;
        let _options = null;
        const first = associateId;
        if (typeof (first) === "object" && first && (typeof (first.AssociateId) != 'undefined' || typeof (first.UserPresenceStatus) != 'undefined')) {
            _request = associateId;
            _options = userPresenceStatus;
        }
        else {
            _request = {
                AssociateId: associateId,
                UserPresenceStatus: userPresenceStatus,
            };
            _options = webapi_options;
        }
        return this._SetUserPresenceStatus(_request, _options);
    }
    /*
     * Gets a UserGroup object.
     * @param userGroupId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single UserGroup
     */
    async GetUserGroup(userGroupId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserGroup?userGroupId=" + userGroupId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async _SaveUserGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("SaveUserGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async SaveUserGroup(userGroup, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userGroup;
        if (typeof (first) === "object" && first && (typeof (first.UserGroup) != 'undefined')) {
            _request = userGroup;
            _options = webapi_options;
        }
        else {
            _request = {
                UserGroup: userGroup,
            };
            _options = webapi_options;
        }
        return this._SaveUserGroup(_request, _options);
    }
    async _GetAllUserGroups(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("GetAllUserGroups", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserGroupArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async GetAllUserGroups(includeDeleted, webapi_options) {
        let _request = null;
        let _options = null;
        const first = includeDeleted;
        if (typeof (first) === "object" && first && (typeof (first.IncludeDeleted) != 'undefined')) {
            _request = includeDeleted;
            _options = webapi_options;
        }
        else {
            _request = {
                IncludeDeleted: includeDeleted,
            };
            _options = webapi_options;
        }
        return this._GetAllUserGroups(_request, _options);
    }
    async _CreateUserGroup(options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("CreateUserGroup", undefined, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserGroup_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /**
     * Create UserGroup (Rank is assigned to the highest rank)
     * @returns
     */
    async CreateUserGroup(webapi_options) {
        return this._CreateUserGroup(webapi_options);
    }
    async _DeleteUserGroup(request, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                config.baseURL = this._options.baseUrl;
                const response = await this._axios.post("DeleteUserGroup", request, config);
                base.WebApiBase.SetCompleted(options);
                const res = response.data;
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    async DeleteUserGroup(userGroupToDelete, userGroupToMoveTo, webapi_options) {
        let _request = null;
        let _options = null;
        const first = userGroupToDelete;
        if (typeof (first) === "object" && first && (typeof (first.UserGroupToDelete) != 'undefined' || typeof (first.UserGroupToMoveTo) != 'undefined')) {
            _request = userGroupToDelete;
            _options = userGroupToMoveTo;
        }
        else {
            _request = {
                UserGroupToDelete: userGroupToDelete,
                UserGroupToMoveTo: userGroupToMoveTo,
            };
            _options = webapi_options;
        }
        return this._DeleteUserGroup(_request, _options);
    }
    /*
     * Gets an array of UserGroup objects.
     * @param userGroupIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of UserGroup
     */
    async GetUserGroupList(userGroupIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserGroupList", userGroupIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserGroupArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets a UserInfo object.
     * @param userInfoId - The primary key.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns A single UserInfo
     */
    async GetUserInfo(userInfoId, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserInfo?userInfoId=" + userInfoId, null, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserInfo_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
    /*
     * Gets an array of UserInfo objects.
     * @param userInfoIds - The primary keys.
     * @param options - Override language/culture codes on this request. Provide cancellation and request status values.
     * @returns An array of UserInfo
     */
    async GetUserInfoList(userInfoIds, options) {
        const config = base.WebApiBase.GetAxiosRequestConfig(options, this._options);
        base.WebApiBase.SetPending(options);
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._axios.post("GetUserInfoList", userInfoIds, config);
                base.WebApiBase.SetCompleted(options);
                const res = converters.Create_UserInfoArray_From(response.data);
                resolve(res);
            }
            catch (err) {
                base.WebApiBase.HandleError(options, config, err);
                reject(err);
            }
        });
    }
} // class v1UserAgentController 
exports.UserAgent = UserAgent;
//# sourceMappingURL=UserAgent.js.map
import { AxiosRequestConfig } from 'axios';
import * as base from './WebApiBase';
import * as carriers from './Carriers';
/**
 * Diagnostics, usage data collection, caches and flushing
 */
export interface IDiagnosticsAgent {
    FlushCaches(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    GetCacheNames(webapi_options?: base.WebApiRequestOptions): Promise<string[]>;
    FlushCachesByName(request: carriers.Diagnostics_FlushCachesByNameRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    FlushCachesByName(cacheNames: string[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    GetCacheState(request: carriers.Diagnostics_GetCacheStateRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetCacheState(cacheNames: string[], webapi_options?: base.WebApiRequestOptions): Promise<string>;
    GetEntityCountsForCurrentUser(webapi_options?: base.WebApiRequestOptions): Promise<carriers.EntityCounts[]>;
    LogViewState(request: carriers.Diagnostics_LogViewStateRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    LogViewState(viewState: string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    ChangeLogSettings(request: carriers.Diagnostics_ChangeLogSettingsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    ChangeLogSettings(logWarning: boolean, logInformation: boolean, logSuccessAudit: boolean, logFailureAudit: boolean, logToEventLog: boolean, logToSuperOffice: boolean, logToFile: boolean, logToTrace: boolean, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    CollectDataAdditions(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    CollectWinUsage(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    CollectWebUsage(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    CollectTableSizes(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    ResyncUsers(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    PerformTasksAfterUpgrade(webapi_options?: base.WebApiRequestOptions): Promise<string>;
    AddWebAppUsage(request: carriers.Diagnostics_AddWebAppUsageRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    AddWebAppUsage(webAppUsages: carriers.WebAppUsage[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    WebAppUsageExistsInPeriod(request: carriers.Diagnostics_WebAppUsageExistsInPeriodRequest, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    WebAppUsageExistsInPeriod(associateId: number, viewState: string, fromDate: Date, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    GetWebAppUsagesForPeriod(request: carriers.Diagnostics_GetWebAppUsagesForPeriodRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.WebAppUsage[]>;
    GetWebAppUsagesForPeriod(fromDate: Date, toDate: Date, searchTerm: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.WebAppUsage[]>;
}
/**
 * Diagnostics, usage data collection, caches and flushing
 */
export declare class DiagnosticsAgent extends base.WebApiBase implements IDiagnosticsAgent {
    constructor(baseUrl?: string, languageCode?: string, cultureCode?: string);
    constructor(baseUrl?: string, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, resourceManager: any);
    constructor(baseUrl: string, config: AxiosRequestConfig, resourceManager: any);
    constructor(baseUrl: string, config: AxiosRequestConfig, resourceParsing?: base.ResourceParsing);
    constructor(baseUrl: string, config: AxiosRequestConfig, languageCode?: string, cultureCode?: string);
    constructor(options: base.WebApiOptions);
    private _FlushCaches;
    /**
     * Flushes all NetServer caches
     * @returns
     */
    FlushCaches(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _GetCacheNames;
    /**
     * Get the name of the caches that can be flushed
     * @returns Name of the caches that can be flusehd
     */
    GetCacheNames(webapi_options?: base.WebApiRequestOptions): Promise<string[]>;
    private _FlushCachesByName;
    /**
     * Flushes all NetServer caches named
     * @param request - CacheNames
     * @returns This method has no return value
     */
    FlushCachesByName(request: carriers.Diagnostics_FlushCachesByNameRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Flushes all NetServer caches named
     * @param cacheNames - Name of the cachnes to flush
     * @returns This method has no return value
     */
    FlushCachesByName(cacheNames: string[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _GetCacheState;
    /**
     * Get the current generation value of the named caches. State is opaque.
     * @param request - CacheNames
     * @returns Current state of the caches named. If not the same as previous value, then it is time to flush
     */
    GetCacheState(request: carriers.Diagnostics_GetCacheStateRequest, webapi_options?: base.WebApiRequestOptions): Promise<string>;
    /**
     * Get the current generation value of the named caches. State is opaque.
     * @param cacheNames - Names of the caches to check
     * @returns Current state of the caches named. If not the same as previous value, then it is time to flush
     */
    GetCacheState(cacheNames: string[], webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _GetEntityCountsForCurrentUser;
    /**
     * Get an array of entities and number of entities created for the current associate
     * @returns Array of EntityCounts[] for the current associate
     */
    GetEntityCountsForCurrentUser(webapi_options?: base.WebApiRequestOptions): Promise<carriers.EntityCounts[]>;
    private _LogViewState;
    /**
     * Log a change in view state. The granularity of the logging depends on the current configuration. This call returns asynchronously, leaving the server to finish processing later on.
     * @param request - ViewState
     * @returns
     */
    LogViewState(request: carriers.Diagnostics_LogViewStateRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Log a change in view state. The granularity of the logging depends on the current configuration. This call returns asynchronously, leaving the server to finish processing later on.
     * @param viewState - Current view state to be logged
     * @returns
     */
    LogViewState(viewState: string, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _ChangeLogSettings;
    /**
     * Change NetServer log settings.
     * @param request - LogWarning, LogInformation, LogSuccessAudit, LogFailureAudit, LogToEventLog, LogToSuperOffice, LogToFile, LogToTrace
     * @returns
     */
    ChangeLogSettings(request: carriers.Diagnostics_ChangeLogSettingsRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Change NetServer log settings.
     * @param logWarning - Turn on warning log
     * @param logInformation - Turn on information log
     * @param logSuccessAudit - Turn on success audit log
     * @param logFailureAudit - Turn on failure audit log
     * @param logToEventLog - Log to event log
     * @param logToSuperOffice - Log to SuperOffice
     * @param logToFile - Log to file
     * @param logToTrace - Log to trace
     * @returns
     */
    ChangeLogSettings(logWarning: boolean, logInformation: boolean, logSuccessAudit: boolean, logFailureAudit: boolean, logToEventLog: boolean, logToSuperOffice: boolean, logToFile: boolean, logToTrace: boolean, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _CollectDataAdditions;
    /**
     * Collect and transmit usage statistics: Database Additions. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    CollectDataAdditions(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _CollectWinUsage;
    /**
     * Collect and transmit usage statistics: Windows CRM Client Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    CollectWinUsage(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _CollectWebUsage;
    /**
     * Collect and transmit usage statistics: Web-based clients Usage. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    CollectWebUsage(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _CollectTableSizes;
    /**
     * Collect and transmit usage statistics: Table Sizes. If opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    CollectTableSizes(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _ResyncUsers;
    /**
     * Resynchronize user information with SuperOffice Community, if opted-out then this call does nothing. The call returns immediately (starting a background thread), and updates CS scheduler table to set the next run time.
     * @returns This method has no return value
     */
    ResyncUsers(webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _PerformTasksAfterUpgrade;
    /**
     * After upgrading to a new fileset, there may be tasks that need to be done. Examples - import new TypicalSearches, if present. Tasks performed here need to be idempotent and independent of the actual upgrade jump (what was the previous version). They should complete in a reasonable time, not more than a few minutes maximum.
     * @returns Message that can be shown to the user, summarizing what has been done, if anything.
     */
    PerformTasksAfterUpgrade(webapi_options?: base.WebApiRequestOptions): Promise<string>;
    private _AddWebAppUsage;
    /**
     * Adds WebApp usage to existing log
     * @param request - WebAppUsages
     * @returns
     */
    AddWebAppUsage(request: carriers.Diagnostics_AddWebAppUsageRequest, webapi_options?: base.WebApiRequestOptions): Promise<void>;
    /**
     * Adds WebApp usage to existing log
     * @param webAppUsages - Web app usage.
     * @returns
     */
    AddWebAppUsage(webAppUsages: carriers.WebAppUsage[], webapi_options?: base.WebApiRequestOptions): Promise<void>;
    private _WebAppUsageExistsInPeriod;
    /**
     * Returns true if viewState has been clicked at least once since FromDate, if asscoiateId &lt; 0 or FromDate is DateTime.MinValue no restriction given for those parameters
     * @param request - AssociateId, ViewState, FromDate
     * @returns Returns true if viewState has been clicked at least once since FromDate
     */
    WebAppUsageExistsInPeriod(request: carriers.Diagnostics_WebAppUsageExistsInPeriodRequest, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    /**
     * Returns true if viewState has been clicked at least once since FromDate, if asscoiateId &lt; 0 or FromDate is DateTime.MinValue no restriction given for those parameters
     * @param associateId - The asscoiate id to look for webapp usage
     * @param viewState - The viewState to search for
     * @param fromDate - The datetime to restrict webapp usage on
     * @returns Returns true if viewState has been clicked at least once since FromDate
     */
    WebAppUsageExistsInPeriod(associateId: number, viewState: string, fromDate: Date, webapi_options?: base.WebApiRequestOptions): Promise<boolean>;
    private _GetWebAppUsagesForPeriod;
    /**
     * Get all WebAppUsages for a given period, that match an optional search term
     * @param request - FromDate, ToDate, SearchTerm
     * @returns
     */
    GetWebAppUsagesForPeriod(request: carriers.Diagnostics_GetWebAppUsagesForPeriodRequest, webapi_options?: base.WebApiRequestOptions): Promise<carriers.WebAppUsage[]>;
    /**
     * Get all WebAppUsages for a given period, that match an optional search term
     * @param fromDate -
     * @param toDate -
     * @param searchTerm - ViewState search term. '%' is the wildcard character, for example 'Pocket%' will match all viewstates starting with 'Pocket'. If empty, all viewstates will be matched
     * @returns
     */
    GetWebAppUsagesForPeriod(fromDate: Date, toDate: Date, searchTerm: string, webapi_options?: base.WebApiRequestOptions): Promise<carriers.WebAppUsage[]>;
}
//# sourceMappingURL=DiagnosticsAgent.d.ts.map